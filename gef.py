#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
#######################################################################################
# GEF - Multi-Architecture GDB Enhanced Features for Exploiters & Reverse-Engineers
#
# original: by @_hugsy_
# improvement: by @bata_24
#
#######################################################################################
#
# GEF is a kick-ass set of commands for X86, ARM, MIPS, PowerPC and SPARC to
# make GDB cool again for exploit dev. It is aimed to be used mostly by exploit
# devs and reversers, to provides additional features to GDB using the Python
# API to assist during the process of dynamic analysis.
#
# GEF fully relies on GDB API and other Linux-specific sources of information
# (such as /proc/<pid>). As a consequence, some of the features might not work
# on custom or hardened systems such as GrSec.
#
# Since January 2020, GEF solely support GDB compiled with Python3 and was tested on
#   * x86-32 & x86-64
#   * arm v5,v6,v7
#   * aarch64 (armv8)
#   * mips & mips64
#   * powerpc & powerpc64
#   * sparc & sparc64(v9)
#
# For GEF with Python2 (only) support was moved to the GEF-Legacy
# (https://github.com/hugsy/gef-legacy)
#
# To start: in gdb, type `source /path/to/gef.py`
#
#######################################################################################
#
# gef is distributed under the MIT License (MIT)
# Copyright (c) 2013-2022 crazy rabbidz
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
#######################################################################################
# Use this command when check by flake8
# flake8 gef.py --ignore E203,E221,E241,E261,E265,E401,E402,E501,E731
# E203: whitespace before ':'
# E221: multiple spaces before operator
# E241: multiple spaces after ','
# E261: at least two spaces before inline comment
# E265: block comment should start with '# '
# E401: multiple imports on one line
# E402: module level import not at top of file
# E501: line too long (> 79 characters)
# E731: do not assign a lambda expression, use a def
#

from __future__ import print_function, division, absolute_import
print("Loading GEF...")

import abc
import binascii
import codecs
import collections
import configparser
import ctypes
import functools
import getopt
import hashlib
import inspect
import io
import itertools
import json
import math
import os
import platform
import psutil
import re
import site
import socket
import string
import struct
import subprocess
import sys
import tempfile
import time
import timeout
import traceback
import urllib.request

LEFT_ARROW = " <- "
RIGHT_ARROW = " -> "
DOWN_ARROW = "v"
HORIZONTAL_LINE = "-"
VERTICAL_LINE = "|"
BP_GLYPH = "*"
GEF_PROMPT = "gef> "
GEF_PROMPT_ON = "\001\033[1;32m\002{0:s}\001\033[0m\002".format(GEF_PROMPT)
GEF_PROMPT_OFF = "\001\033[1;31m\002{0:s}\001\033[0m\002".format(GEF_PROMPT)


def http_get(url):
    """Basic HTTP wrapper for GET request. Return the body of the page if HTTP code is OK,
    otherwise return None."""
    try:
        req = urllib.request.Request(url)
        req.add_header('Cache-Control', 'no-cache, no-store')
        http = urllib.request.urlopen(req)
        if http.getcode() != 200:
            return None
        return http.read()
    except Exception:
        return None


def update_gef(argv):
    """Try to update `gef` to the latest version pushed on GitHub master branch.
    Return 0 on success, 1 on failure. """
    gef_local = os.path.realpath(argv[0])
    hash_gef_local = hashlib.sha512(open(gef_local, "rb").read()).digest()
    gef_remote = "https://raw.githubusercontent.com/bata24/gef/dev/gef.py"
    gef_remote_data = http_get(gef_remote)
    if gef_remote_data is None:
        print("[-] Failed to get remote gef")
        return 1

    hash_gef_remote = hashlib.sha512(gef_remote_data).digest()
    if hash_gef_local == hash_gef_remote:
        print("[-] No update")
    else:
        with open(gef_local, "wb") as f:
            f.write(gef_remote_data)
        print("[+] Updated")
    return 0


try:
    import gdb
except ImportError:
    # if out of gdb, the only action allowed is to update gef.py
    if len(sys.argv) == 2 and sys.argv[1].lower() in ("--update", "--upgrade", "-u"):
        sys.exit(update_gef(sys.argv))
    print("[-] gef cannot run as standalone")
    sys.exit(0)

__gef__                                = None
__commands__                           = []
__functions__                          = []
__aliases__                            = []
__config__                             = {}
__watches__                            = {}
__gef_convenience_vars_index__         = 0
__context_messages__                   = []
__heap_allocated_list__                = []
__heap_freed_list__                    = []
__heap_uaf_watchpoints__               = []
__pie_breakpoints__                    = {}
__pie_counter__                        = 1
__gef_qemu_mode__                      = False
__gef_default_main_arena__             = "main_arena"
__gef_int_stream_buffer__              = None
__gef_redirect_output_fd__             = None

DEFAULT_PAGE_ALIGN_SHIFT               = 12
DEFAULT_PAGE_SIZE                      = 1 << DEFAULT_PAGE_ALIGN_SHIFT
DEFAULT_PAGE_SIZE_MASK                 = ~ (DEFAULT_PAGE_SIZE - 1)
GEF_RC                                 = os.getenv("GEF_RC") or os.path.join(os.getenv("HOME") or "~", ".gef.rc")
GEF_TEMP_DIR                           = os.path.join(tempfile.gettempdir(), "gef")
GEF_MAX_STRING_LENGTH                  = 0x50

GDB_MIN_VERSION                        = (7, 7)
GDB_VERSION                            = tuple(map(int, re.search(r"(\d+)[^\d]+(\d+)", gdb.VERSION).groups()))

current_elf  = None
current_arch = None

libc_args_definitions = {}

highlight_table = {}
ANSI_SPLIT_RE = r"(\033\[[\d;]*m)"


def perf_enable(f):
    """Decorator wrapper to perf."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        import cProfile, pstats, io
        pr = cProfile.Profile()
        pr.enable()
        ret = f(*args, **kwargs)
        pr.disable()
        s = io.StringIO()
        #sortby = pstats.SortKey.CUMULATIVE
        sortby = pstats.SortKey.TIME
        ps = pstats.Stats(pr, stream=s).sort_stats(sortby)
        ps.print_stats(20)
        print(s.getvalue())
        return ret

    return wrapper


def perf_by_line_enable(f):
    """Decorator wrapper to perf."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        import line_profiler, io
        pr = line_profiler.LineProfiler()
        pr.add_function(f)
        pr.enable()
        ret = f(*args, **kwargs)
        pr.disable()
        s = io.StringIO()
        pr.print_stats(stream=s)
        print(s.getvalue())
        return ret

    return wrapper


def reset_all_caches():
    """Free all caches. If an object is cached, it will have a callable attribute `cache_clear`
    which will be invoked to purge the function cache."""
    global __gef_default_main_arena__

    for mod in dir(sys.modules["__main__"]):
        obj = getattr(sys.modules["__main__"], mod)
        if hasattr(obj, "cache_clear"):
            obj.cache_clear()

    __gef_default_main_arena__ = "main_arena"
    return


def highlight_text(text):
    """Highlight text using highlight_table { match -> color } settings.

    If RegEx is enabled it will create a match group around all items in the
    highlight_table and wrap the specified color in the highlight_table
    around those matches.

    If RegEx is disabled, split by ANSI codes and 'colorify' each match found
    within the specified string."""
    if not highlight_table:
        return text

    if get_gef_setting("highlight.regex"):
        for match, color in highlight_table.items():
            text = re.sub("(" + match + ")", Color.colorify("\\1", color), text)
        return text

    ansiSplit = re.split(ANSI_SPLIT_RE, text)

    for match, color in highlight_table.items():
        for index, val in enumerate(ansiSplit):
            found = val.find(match)
            if found > -1:
                ansiSplit[index] = val.replace(match, Color.colorify(match, color))
                break
        text = "".join(ansiSplit)
        ansiSplit = re.split(ANSI_SPLIT_RE, text)

    return "".join(ansiSplit)


def gef_print(x="", *args, **kwargs):
    """Wrapper around print(), using string buffering feature."""
    x = highlight_text(x)
    if __gef_int_stream_buffer__ and not is_debug():
        return __gef_int_stream_buffer__.write(x + kwargs.get("end", "\n"))
    return print(x, *args, **kwargs)


def bufferize(f):
    """Store the content to be printed for a function in memory, and flush it on function exit."""
    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        global __gef_int_stream_buffer__, __gef_redirect_output_fd__

        if __gef_int_stream_buffer__:
            return f(*args, **kwargs)

        __gef_int_stream_buffer__ = io.StringIO()
        try:
            rv = f(*args, **kwargs)
        finally:
            redirect = get_gef_setting("context.redirect")
            if redirect.startswith("/dev/pts/"):
                if not __gef_redirect_output_fd__:
                    # if the FD has never been open, open it
                    fd = open(redirect, "wt")
                    __gef_redirect_output_fd__ = fd
                elif redirect != __gef_redirect_output_fd__.name:
                    # if the user has changed the redirect setting during runtime, update the state
                    __gef_redirect_output_fd__.close()
                    fd = open(redirect, "wt")
                    __gef_redirect_output_fd__ = fd
                else:
                    # otherwise, keep using it
                    fd = __gef_redirect_output_fd__
            else:
                fd = sys.stdout
                __gef_redirect_output_fd__ = None

            if __gef_redirect_output_fd__ and fd.closed:
                # if the tty was closed, revert back to stdout
                fd = sys.stdout
                __gef_redirect_output_fd__ = None
                set_gef_setting("context.redirect", "")

            fd.write(__gef_int_stream_buffer__.getvalue())
            fd.flush()
            __gef_int_stream_buffer__ = None
        return rv

    return wrapper


class Color:
    """Used to colorify terminal output."""
    colors = {
        "normal"         : "\033[0m",
        "gray"           : "\033[1;38;5;240m",
        "light_gray"     : "\033[0;37m",
        "red"            : "\033[31m",
        "green"          : "\033[32m",
        "yellow"         : "\033[33m",
        "blue"           : "\033[34m",
        "pink"           : "\033[35m",
        "cyan"           : "\033[36m",
        "bold"           : "\033[1m",
        "underline"      : "\033[4m",
        "underline_off"  : "\033[24m",
        "highlight"      : "\033[3m",
        "highlight_off"  : "\033[23m",
        "blink"          : "\033[5m",
        "blink_off"      : "\033[25m",
    }

    @staticmethod
    def redify(msg):
        return Color.colorify(msg, "red")

    @staticmethod
    def greenify(msg):
        return Color.colorify(msg, "green")

    @staticmethod
    def blueify(msg):
        return Color.colorify(msg, "blue")

    @staticmethod
    def yellowify(msg):
        return Color.colorify(msg, "yellow")

    @staticmethod
    def grayify(msg):
        return Color.colorify(msg, "gray")

    @staticmethod
    def light_grayify(msg):
        return Color.colorify(msg, "light_gray")

    @staticmethod
    def pinkify(msg):
        return Color.colorify(msg, "pink")

    @staticmethod
    def cyanify(msg):
        return Color.colorify(msg, "cyan")

    @staticmethod
    def boldify(msg):
        return Color.colorify(msg, "bold")

    @staticmethod
    def underlinify(msg):
        return Color.colorify(msg, "underline")

    @staticmethod
    def highlightify(msg):
        return Color.colorify(msg, "highlight")

    @staticmethod
    def blinkify(msg):
        return Color.colorify(msg, "blink")

    @staticmethod
    def colorify(text, attrs):
        """Color text according to the given attributes."""
        if get_gef_setting("gef.disable_color") is True:
            return text

        colors = Color.colors
        msg = [colors[attr] for attr in attrs.split() if attr in colors]
        msg.append(str(text))
        if colors["highlight"] in msg:
            msg.append(colors["highlight_off"])
        if colors["underline"] in msg:
            msg.append(colors["underline_off"])
        if colors["blink"] in msg:
            msg.append(colors["blink_off"])
        msg.append(colors["normal"])
        return "".join(msg)


class Address:
    """GEF representation of memory addresses."""
    def __init__(self, *args, **kwargs):
        self.value = kwargs.get("value", 0)
        self.section = kwargs.get("section", None)
        self.info = kwargs.get("info", None)
        self.valid = kwargs.get("valid", True)
        return

    def __str__(self):
        value = format_address(self.value)
        if self.is_in_text_segment():
            code_color = get_gef_setting("theme.address_code")
            return Color.colorify(value, code_color)
        if self.is_in_heap_segment():
            heap_color = get_gef_setting("theme.address_heap")
            return Color.colorify(value, heap_color)
        if self.is_in_stack_segment():
            stack_color = get_gef_setting("theme.address_stack")
            return Color.colorify(value, stack_color)
        return value

    def is_in_text_segment(self):
        return (hasattr(self.info, "name") and ".text" in self.info.name) or \
            (hasattr(self.section, "path") and get_filepath(for_vmmap=True) == self.section.path and self.section.is_executable())

    def is_in_stack_segment(self):
        return hasattr(self.section, "path") and "[stack]" == self.section.path

    def is_in_heap_segment(self):
        return hasattr(self.section, "path") and "[heap]" == self.section.path

    def dereference(self):
        addr = align_address(int(self.value))
        derefed = dereference(addr)
        return None if derefed is None else int(derefed)


class Permission:
    """GEF representation of Linux permission."""
    NONE    = 0
    READ    = 1
    WRITE   = 2
    EXECUTE = 4
    ALL     = READ | WRITE | EXECUTE

    def __init__(self, **kwargs):
        self.value = kwargs.get("value", 0)
        return

    def __or__(self, value):
        return self.value | value

    def __and__(self, value):
        return self.value & value

    def __xor__(self, value):
        return self.value ^ value

    def __eq__(self, value):
        return self.value == value

    def __ne__(self, value):
        return self.value != value

    def __str__(self):
        perm_str = ""
        perm_str += "r" if self & Permission.READ else "-"
        perm_str += "w" if self & Permission.WRITE else "-"
        perm_str += "x" if self & Permission.EXECUTE else "-"
        return perm_str

    @staticmethod
    def from_info_sections(*args):
        perm = Permission()
        for arg in args:
            if "READONLY" in arg:
                perm.value += Permission.READ
            if "DATA" in arg:
                perm.value += Permission.WRITE
            if "CODE" in arg:
                perm.value += Permission.EXECUTE
        return perm

    @staticmethod
    def from_process_maps(perm_str):
        perm = Permission()
        if perm_str[0] == "r":
            perm.value += Permission.READ
        if perm_str[1] == "w":
            perm.value += Permission.WRITE
        if perm_str[2] == "x":
            perm.value += Permission.EXECUTE
        return perm


class Section:
    """GEF representation of process memory sections."""
    def __init__(self, *args, **kwargs):
        self.page_start = kwargs.get("page_start")
        self.page_end = kwargs.get("page_end")
        self.offset = kwargs.get("offset")
        self.permission = kwargs.get("permission")
        self.inode = kwargs.get("inode")
        self.path = kwargs.get("path")
        return

    def is_readable(self):
        return self.permission.value and self.permission.value & Permission.READ

    def is_writable(self):
        return self.permission.value and self.permission.value & Permission.WRITE

    def is_executable(self):
        return self.permission.value and self.permission.value & Permission.EXECUTE

    @property
    def size(self):
        if self.page_end is None or self.page_start is None:
            return -1
        return self.page_end - self.page_start

    @property
    def realpath(self):
        return self.path


Zone = collections.namedtuple("Zone", ["name", "zone_start", "zone_end", "filename"])


class Elf:
    """Basic ELF parsing.
    Ref:
    - http://www.skyfree.org/linux/references/ELF_Format.pdf
    - http://refspecs.freestandards.org/elf/elfspec_ppc.pdf
    - http://refspecs.linuxfoundation.org/ELF/ppc64/PPC-elf64abi.html"""
    LITTLE_ENDIAN     = 1
    BIG_ENDIAN        = 2

    ELF_32_BITS       = 0x01
    ELF_64_BITS       = 0x02
    ELF_MAGIC         = 0x7f454c46

    X86_64            = 0x3e
    X86_32            = 0x03
    ARM               = 0x28
    MIPS              = 0x08
    POWERPC           = 0x14
    POWERPC64         = 0x15
    SPARC             = 0x02
    SPARC64           = 0x2b
    AARCH64           = 0xb7
    RISCV             = 0xf3
    IA64              = 0x32

    ET_RELOC          = 1
    ET_EXEC           = 2
    ET_DYN            = 3
    ET_CORE           = 4

    OSABI_SYSTEMV     = 0x00
    OSABI_HPUX        = 0x01
    OSABI_NETBSD      = 0x02
    OSABI_LINUX       = 0x03
    OSABI_SOLARIS     = 0x06
    OSABI_AIX         = 0x07
    OSABI_IRIX        = 0x08
    OSABI_FREEBSD     = 0x09
    OSABI_OPENBSD     = 0x0C

    e_magic           = ELF_MAGIC
    e_class           = ELF_32_BITS
    e_endianness      = LITTLE_ENDIAN
    e_eiversion       = None
    e_osabi           = None
    e_abiversion      = None
    e_pad             = None
    e_type            = ET_EXEC
    e_machine         = X86_32
    e_version         = None
    e_entry           = 0x00
    e_phoff           = None
    e_shoff           = None
    e_flags           = None
    e_ehsize          = None
    e_phentsize       = None
    e_phnum           = None
    e_shentsize       = None
    e_shnum           = None
    e_shstrndx        = None

    def __init__(self, elf="", minimalist=False):
        """Instantiate an ELF object. The default behavior is to create the object by parsing the ELF file.
        But in some cases (QEMU-stub), we may just want a simple minimal object with default values."""
        if minimalist:
            return

        if isinstance(elf, str):
            if not os.access(elf, os.R_OK):
                err("'{0}' not found/readable".format(elf))
                err("Failed to get file debug information, most of gef features will not work")
                self.e_magic = None
                return
            self.fd = open(elf, "rb")
            self.addr = None
            self.pos = 0
            self.filename = elf
        elif isinstance(elf, int):
            self.fd = None
            self.addr = elf
            self.pos = 0
            self.filename = None
        else:
            raise

        # off 0x0
        self.e_magic, self.e_class, self.e_endianness, self.e_eiversion = struct.unpack(">IBBB", self.read(7))
        # adjust endianness in bin reading
        endian = "<" if self.e_endianness == Elf.LITTLE_ENDIAN else ">"
        # off 0x7
        self.e_osabi, self.e_abiversion = struct.unpack("{}BB".format(endian), self.read(2))
        # off 0x9
        self.e_pad = self.read(7)
        # off 0x10
        self.e_type, self.e_machine, self.e_version = struct.unpack("{}HHI".format(endian), self.read(8))
        # off 0x18
        if self.e_class == Elf.ELF_64_BITS:
            # if arch 64bits
            self.e_entry, self.e_phoff, self.e_shoff = struct.unpack("{}QQQ".format(endian), self.read(24))
        else:
            # else arch 32bits
            self.e_entry, self.e_phoff, self.e_shoff = struct.unpack("{}III".format(endian), self.read(12))
        self.e_flags, self.e_ehsize, self.e_phentsize, self.e_phnum = struct.unpack("{}IHHH".format(endian), self.read(10))
        self.e_shentsize, self.e_shnum, self.e_shstrndx = struct.unpack("{}HHH".format(endian), self.read(6))
        # phdr
        self.phdrs = []
        for i in range(self.e_phnum):
            self.phdrs.append(Phdr(self, self.e_phoff + self.e_phentsize * i))
        # shdr
        self.shdrs = []
        for i in range(self.e_shnum):
            try:
                self.shdrs.append(Shdr(self, self.e_shoff + self.e_shentsize * i))
            except Exception:
                # Perspective failure. Probably it occurs when parsing ELF loaded into memory.
                # Even if the ELF is loaded, the section header is not loaded. Therefore, it is ignored.
                self.shdrs = []
                break
        else:
            # The existence of multiple SHT_NULLs is assumed to be abnormal, and an error is raised.
            if sum([x.sh_type == Shdr.SHT_NULL for x in self.shdrs]) > 1:
                self.shdrs = []

        if self.fd is not None:
            self.fd.close()
            self.fd = None
        return

    def read(self, size):
        if self.fd is not None:
            v = self.fd.read(size)
        elif self.addr is not None:
            v = read_memory(self.addr + self.pos, size)
        else:
            raise
        self.pos += size
        return v

    def seek(self, off):
        if self.fd is not None:
            self.fd.seek(off, 0)
        elif self.addr is not None:
            self.pos = off
        else:
            raise
        return

    def is_valid(self):
        return self.e_magic == Elf.ELF_MAGIC


class Phdr:
    PT_NULL          = 0
    PT_LOAD          = 1
    PT_DYNAMIC       = 2
    PT_INTERP        = 3
    PT_NOTE          = 4
    PT_SHLIB         = 5
    PT_PHDR          = 6
    PT_TLS           = 7
    #PT_LOOS          = 0x60000000
    PT_GNU_EH_FRAME  = 0x6474e550
    PT_GNU_STACK     = 0x6474e551
    PT_GNU_RELRO     = 0x6474e552
    #PT_LOSUNW        = 0x6ffffffa
    PT_SUNWBSS       = 0x6ffffffa
    PT_SUNWSTACK     = 0x6ffffffb
    #PT_HISUNW        = 0x6fffffff
    #PT_HIOS          = 0x6fffffff
    #PT_LOPROC        = 0x70000000
    #PT_HIPROC        = 0x7fffffff
    PT_MIPS_REGINFO  = 0x70000000
    PT_MIPS_RTPROC   = 0x70000001
    PT_MIPS_OPTIONS  = 0x70000002
    PT_MIPS_ABIFLAGS = 0x70000003

    PF_X             = 1
    PF_W             = 2
    PF_R             = 4

    p_type           = None
    p_flags          = None
    p_offset         = None
    p_vaddr          = None
    p_paddr          = None
    p_filesz         = None
    p_memsz          = None
    p_align          = None

    def __init__(self, elf, off):
        if elf is None:
            return None
        elf.seek(off)
        endian = "<" if elf.e_endianness == Elf.LITTLE_ENDIAN else ">"
        if elf.e_class == Elf.ELF_64_BITS:
            self.p_type, self.p_flags, self.p_offset = struct.unpack("{}IIQ".format(endian), elf.read(16))
            self.p_vaddr, self.p_paddr = struct.unpack("{}QQ".format(endian), elf.read(16))
            self.p_filesz, self.p_memsz, self.p_align = struct.unpack("{}QQQ".format(endian), elf.read(24))
        else:
            self.p_type, self.p_offset = struct.unpack("{}II".format(endian), elf.read(8))
            self.p_vaddr, self.p_paddr = struct.unpack("{}II".format(endian), elf.read(8))
            self.p_filesz, self.p_memsz, self.p_flags, self.p_align = struct.unpack("{}IIII".format(endian), elf.read(16))


class Shdr:
    SHT_NULL             = 0
    SHT_PROGBITS         = 1
    SHT_SYMTAB           = 2
    SHT_STRTAB           = 3
    SHT_RELA             = 4
    SHT_HASH             = 5
    SHT_DYNAMIC          = 6
    SHT_NOTE             = 7
    SHT_NOBITS           = 8
    SHT_REL              = 9
    SHT_SHLIB            = 10
    SHT_DYNSYM           = 11
    SHT_NUM              = 12
    SHT_INIT_ARRAY       = 14
    SHT_FINI_ARRAY       = 15
    SHT_PREINIT_ARRAY    = 16
    SHT_GROUP            = 17
    SHT_SYMTAB_SHNDX     = 18
    SHT_NUM              = 19
    #SHT_LOOS             = 0x60000000
    SHT_GNU_ATTRIBUTES   = 0x6ffffff5
    SHT_GNU_HASH         = 0x6ffffff6
    SHT_GNU_LIBLIST      = 0x6ffffff7
    SHT_CHECKSUM         = 0x6ffffff8
    #SHT_LOSUNW           = 0x6ffffffa
    SHT_SUNW_move        = 0x6ffffffa
    SHT_SUNW_COMDAT      = 0x6ffffffb
    SHT_SUNW_syminfo     = 0x6ffffffc
    SHT_GNU_verdef       = 0x6ffffffd
    SHT_GNU_verneed      = 0x6ffffffe
    SHT_GNU_versym       = 0x6fffffff
    #SHT_HISUNW           = 0x6fffffff
    #SHT_HIOS             = 0x6fffffff
    #SHT_LOPROC           = 0x70000000
    #SHT_HIPROC           = 0x7fffffff
    #SHT_LOUSER           = 0x80000000
    #SHT_HIUSER           = 0x8fffffff

    SHF_WRITE            = 1
    SHF_ALLOC            = 2
    SHF_EXECINSTR        = 4
    SHF_MERGE            = 0x10
    SHF_STRINGS          = 0x20
    SHF_INFO_LINK        = 0x40
    SHF_LINK_ORDER       = 0x80
    SHF_OS_NONCONFORMING = 0x100
    SHF_GROUP            = 0x200
    SHF_TLS              = 0x400
    SHF_COMPRESSED       = 0x800
    SHF_RELA_LIVEPATCH   = 0x00100000
    SHF_RO_AFTER_INIT    = 0x00200000
    SHF_ORDERED          = 0x40000000
    SHF_EXCLUDE          = 0x80000000

    sh_name              = None
    sh_type              = None
    sh_flags             = None
    sh_addr              = None
    sh_offset            = None
    sh_size              = None
    sh_link              = None
    sh_info              = None
    sh_addralign         = None
    sh_entsize           = None

    def __init__(self, elf, off):
        if elf is None:
            return None
        elf.seek(off)
        endian = "<" if elf.e_endianness == Elf.LITTLE_ENDIAN else ">"
        if elf.e_class == Elf.ELF_64_BITS:
            self.sh_name, self.sh_type, self.sh_flags = struct.unpack("{}IIQ".format(endian), elf.read(16))
            self.sh_addr, self.sh_offset = struct.unpack("{}QQ".format(endian), elf.read(16))
            self.sh_size, self.sh_link, self.sh_info = struct.unpack("{}QII".format(endian), elf.read(16))
            self.sh_addralign, self.sh_entsize = struct.unpack("{}QQ".format(endian), elf.read(16))
        else:
            self.sh_name, self.sh_type, self.sh_flags = struct.unpack("{}III".format(endian), elf.read(12))
            self.sh_addr, self.sh_offset = struct.unpack("{}II".format(endian), elf.read(8))
            self.sh_size, self.sh_link, self.sh_info = struct.unpack("{}III".format(endian), elf.read(12))
            self.sh_addralign, self.sh_entsize = struct.unpack("{}II".format(endian), elf.read(8))

        stroff = elf.e_shoff + elf.e_shentsize * elf.e_shstrndx

        if elf.e_class == Elf.ELF_64_BITS:
            elf.seek(stroff + 16 + 8)
            offset = struct.unpack("{}Q".format(endian), elf.read(8))[0]
        else:
            elf.seek(stroff + 12 + 4)
            offset = struct.unpack("{}I".format(endian), elf.read(4))[0]
        elf.seek(offset + self.sh_name)
        self.sh_name = ""
        while True:
            c = ord(elf.read(1))
            if c == 0:
                break
            self.sh_name += chr(c)
        return


class Instruction:
    """GEF representation of a CPU instruction."""
    def __init__(self, address, location, mnemo, operands, opcodes):
        # example:
        #   address: 0x55555555a7d0
        #   location: "" or "<main+0>"
        #   mnemo: "lea"
        #   operands: ['rcx', '[rip+0x11ee5]        # 0x55555556c69a']
        #   opcodes: b'H\x8d\r\xe5\x1e\x01\x00'
        self.address, self.location, self.mnemonic, self.operands, self.opcodes = address, location, mnemo, operands, opcodes
        return

    # Allow formatting an instruction with {:o} to show opcodes.
    # The number of bytes to display can be configured, e.g. {:4o} to only show 4 bytes of the opcodes
    def __format__(self, format_spec):
        if len(format_spec) == 0 or format_spec[-1] != "o":  # format_spec example: "4o"
            return str(self)

        # format opcode
        if format_spec == "o": # no specifed length
            opcodes_len = len(self.opcodes)
        else:
            opcodes_len = int(format_spec[:-1])
        opcodes_text = "".join("{:02x}".format(b) for b in self.opcodes) # ex:"488d0de51e0100"
        # ex1: spec:"4o", opcodes:01020304   -> 01020304
        # ex2: spec:"4o", opcodes:0102030405 -> 010203..
        if opcodes_len < len(self.opcodes):
            opcodes_text = opcodes_text[:opcodes_len * 2 - 2] + ".."

        # format location
        location = self.smartify_text(self.location)
        if not location:
            location = "<NO_SYMBOL>"
        else:
            r = re.search(r"<(.+)\+(\d+)>", location)
            if r:
                location = "<{}+{:#x}>".format(r.group(1), int(r.group(2)))

        # format operands
        operands = self.smartify_text(", ".join(self.operands))
        r = re.search(r"(.*?)<(.+)\+(\d+)>(.*?)", operands)
        if r:
            operands = "{}<{}+{:#x}>{}".format(r.group(1), r.group(2), int(r.group(3)), r.group(4))

        # resolve symbol
        sym = ""

        # ex: call 0xXXXX
        if sym == "" and (is_x86_32() or is_x86_64() or is_arm64()) and len(self.operands) > 0:
            try:
                reference_addr = self.operands[-1].replace("#", "")
                ret = gdb_get_location_from_symbol(int(reference_addr, 0))
                if ret is None:
                    sym = ""
                elif ret[1] == 0:
                    sym = "<{}>".format(ret[0])
                else:
                    sym = "<{}+{:#x}>".format(ret[0], ret[1])
            except Exception:
                pass

        # ex: lea rax, [rip + 0xXXXX]
        if sym == "" and is_x86_64() and len(self.operands) > 0:
            try:
                m = re.match(r"\[rip \+ (0x\w+)\]", self.operands[-1])
                reference_addr = self.address + len(self.opcodes) + int(m.group(1), 0)
                ret = gdb_get_location_from_symbol(reference_addr)
                if ret is None:
                    sym = ""
                elif ret[1] == 0:
                    sym = "# {:#x} <{}>".format(reference_addr, ret[0])
                else:
                    sym = "# {:#x} <{}+{:#x}>".format(reference_addr, ret[0], ret[1])
            except Exception:
                pass

        # ex: b #0xXXXX
        if sym == "" and is_arm32() and len(self.operands) > 0:
            try:
                m = re.match(r"#(\w+)", self.operands[-1])
                ret = gdb_get_location_from_symbol(int(m.group(1), 0))
                if ret is None:
                    sym = ""
                elif ret[1] == 0:
                    sym = "<{}>".format(ret[0])
                else:
                    sym = "<{}+{:#x}>".format(ret[0], ret[1])
            except Exception:
                pass

        # ex: ldr r0, [pc, #0xXXXX]
        if sym == "" and is_arm32() and len(self.operands) > 1:
            try:
                m = re.match(r"\[pc,#(\w+)\]", ','.join(self.operands[-2:]))
                reference_addr = self.address + len(self.opcodes) + int(m.group(1), 0)
                ret = gdb_get_location_from_symbol(reference_addr)
                if ret is None:
                    sym = ""
                elif ret[1] == 0:
                    sym = "; {:#x} <{}>".format(reference_addr, ret[0])
                else:
                    sym = "; {:#x} <{}+{:#x}>".format(reference_addr, ret[0], ret[1])
            except Exception:
                pass

        # formatting
        fmt = "{:#10x} {:{:d}}   {:20}   {:6} {:s} {:s}"
        return fmt.format(self.address, opcodes_text, opcodes_len * 2, location, self.mnemonic, operands, sym)

    def __str__(self):
        location = self.smartify_text(self.location)
        if not location:
            location = "<NO_SYMBOL>"
        operands = self.smartify_text(", ".join(self.operands))
        fmt = "{:#10x} {:20} {:6} {:s}"
        return fmt.format(self.address, location, self.mnemonic, operands)

    def is_valid(self):
        return "(bad)" not in self.mnemonic

    @staticmethod
    def smartify_text(text):
        smart_cpp_function_name = get_gef_setting("context.smart_cpp_function_name")
        if not smart_cpp_function_name:
            return text

        if text is None:
            return text

        if len(text) == 0:
            return text

        text = re.sub(r"\bstd::__1::", "", text)

        old_text = text[::]
        while True:
            text = re.sub(r"\([^(]+?\)", "__MARKER_GEF__", text)
            if text == old_text:
                break
            old_text = text[::]
        text = re.sub("__MARKER_GEF__", "(...)", text)

        if text[0] == "<":
            text_0, text = text[0], text[1:]
        else:
            text_0 = ""
        if text[-1] == ">":
            text_end, text = text[-1], text[:-1]
        else:
            text_end = ""

        while True:
            text = re.sub(r"\<[^<]+?\>", "__MARKER_GEF__", text)
            if text == old_text:
                break
            old_text = text[::]
        text = re.sub("__MARKER_GEF__", "<...>", text)
        if text_0:
            text = text_0 + text
        if text_end:
            text = text + text_end
        return text


@functools.lru_cache()
def search_for_main_arena():
    global __gef_default_main_arena__
    malloc_hook_addr = parse_address("(void *)&__malloc_hook")

    if is_x86():
        addr = align_address_to_size(malloc_hook_addr + current_arch.ptrsize, 0x20)
    elif is_arch(Elf.AARCH64) or is_arch(Elf.ARM):
        addr = malloc_hook_addr - current_arch.ptrsize * 2 - MallocStateStruct("*0").struct_size
    else:
        raise OSError("Cannot find main_arena for {}".format(current_arch.arch))

    __gef_default_main_arena__ = "*{:#x}".format(addr)
    return addr


class MallocStateStruct:
    """GEF representation of malloc_state from https://github.com/bminor/glibc/blob/glibc-2.28/malloc/malloc.c#L1658"""
    def __init__(self, addr):
        try:
            self.__addr = parse_address("&{}".format(addr))
        except gdb.error:
            self.__addr = search_for_main_arena()

        self.num_fastbins = 10
        self.num_bins = 254

        self.int_size = cached_lookup_type("int").sizeof
        self.size_t = cached_lookup_type("size_t")
        if not self.size_t:
            ptr_type = "unsigned long" if current_arch.ptrsize == 8 else "unsigned int"
            self.size_t = cached_lookup_type(ptr_type)

        # Account for separation of have_fastchunks flag into its own field
        # within the malloc_state struct in GLIBC >= 2.27
        # https://sourceware.org/git/?p=glibc.git;a=commit;h=e956075a5a2044d05ce48b905b10270ed4a63e87
        # Be aware you could see this change backported into GLIBC release
        # branches.
        if get_libc_version() >= (2, 27):
            self.fastbin_offset = align_address_to_size(self.int_size * 3, 8)
        else:
            self.fastbin_offset = self.int_size * 2
        return

    # struct offsets
    @property
    def addr(self):
        return self.__addr

    @property
    def fastbins_addr(self):
        return self.__addr + self.fastbin_offset

    @property
    def top_addr(self):
        return self.fastbins_addr + self.num_fastbins * current_arch.ptrsize

    @property
    def last_remainder_addr(self):
        return self.top_addr + current_arch.ptrsize

    @property
    def bins_addr(self):
        return self.last_remainder_addr + current_arch.ptrsize

    @property
    def next_addr(self):
        return self.bins_addr + self.num_bins * current_arch.ptrsize + self.int_size * 4

    @property
    def next_free_addr(self):
        return self.next_addr + current_arch.ptrsize

    @property
    def system_mem_addr(self):
        return self.next_free_addr + current_arch.ptrsize * 2

    @property
    def struct_size(self):
        return self.system_mem_addr + current_arch.ptrsize * 2 - self.__addr

    # struct members
    @property
    def fastbinsY(self):
        return self.get_size_t_array(self.fastbins_addr, self.num_fastbins)

    @property
    def top(self):
        return self.get_size_t_pointer(self.top_addr)

    @property
    def last_remainder(self):
        return self.get_size_t_pointer(self.last_remainder_addr)

    @property
    def bins(self):
        return self.get_size_t_array(self.bins_addr, self.num_bins)

    @property
    def next(self):
        return self.get_size_t_pointer(self.next_addr)

    @property
    def next_free(self):
        return self.get_size_t_pointer(self.next_free_addr)

    @property
    def system_mem(self):
        return self.get_size_t(self.system_mem_addr)

    # helper methods
    def get_size_t(self, addr):
        return dereference(addr).cast(self.size_t)

    def get_size_t_pointer(self, addr):
        size_t_pointer = self.size_t.pointer()
        return dereference(addr).cast(size_t_pointer)

    def get_size_t_array(self, addr, length):
        size_t_array = self.size_t.array(length)
        return dereference(addr).cast(size_t_array)

    def __getitem__(self, item):
        return getattr(self, item)


class GlibcArena:
    """Glibc arena class
    Ref: https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1671"""
    TCACHE_MAX_BINS = 0x40

    def __init__(self, addr, name=None):
        self.__name = name or __gef_default_main_arena__
        try:
            arena = gdb.parse_and_eval(addr)
            malloc_state_t = cached_lookup_type("struct malloc_state")
            self.__arena = arena.cast(malloc_state_t)
            self.__addr = int(arena.address)
            self.__size = malloc_state_t.sizeof
        except Exception:
            self.__arena = MallocStateStruct(addr)
            self.__addr = self.__arena.addr
            self.__size = self.__arena.struct_size
        try:
            self.top = int(self.top)
            self.last_remainder = int(self.last_remainder)
            self.n = int(self.next)
            self.nfree = int(self.next_free)
            self.sysmem = int(self.system_mem)
        except gdb.error as e:
            err("Glibc arena: {}".format(e))
        return

    def __getitem__(self, item):
        return self.__arena[item]

    def __getattr__(self, item):
        return self.__arena[item]

    def __int__(self):
        return self.__addr

    def is_main_arena(self):
        try:
            return self.__name == "main_arena" or self.__addr == parse_address("&main_arena")
        except Exception:
            pass
        try:
            return self.__addr == search_for_main_arena()
        except Exception:
            return None

    @property
    def addr(self):
        return self.__addr

    # arena aligned_size
    @property
    def size(self):
        if current_arch.ptrsize == 4:
            aligned_size = (self.__size + 7) & ~0b111
        else:
            aligned_size = (self.__size + 15) & ~0b1111
        return aligned_size

    @property
    def heap_base(self):
        if self.is_main_arena():
            return HeapBaseFunction.heap_base()
        else:
            return self.addr + self.size

    def tcachebin(self, i):
        """Return head chunk in tcache[i]."""
        if self.heap_base is None:
            return None
        if get_libc_version() < (2, 30):
            addr = dereference(self.heap_base + 0x10 + self.TCACHE_MAX_BINS + i * current_arch.ptrsize)
        else:
            addr = dereference(self.heap_base + 0x10 + 2 * self.TCACHE_MAX_BINS + i * current_arch.ptrsize)
        if not addr:
            return None
        return GlibcChunk(int(addr))

    def fastbin(self, i):
        """Return head chunk in fastbinsY[i]."""
        addr = int(self.fastbinsY[i])
        if addr == 0:
            return None
        return GlibcChunk(addr + 2 * current_arch.ptrsize)

    def bin(self, i):
        idx = i * 2
        fd = int(self.bins[idx])
        bw = int(self.bins[idx + 1])
        return fd, bw

    def get_next(self):
        addr_next = int(self.next)
        arena_main = GlibcArena(self.__name)
        if addr_next == arena_main.__addr:
            return None
        return GlibcArena("*{:#x} ".format(addr_next))

    def __str__(self):
        fmt = "Arena (base={:#x}, top={:#x}, last_remainder={:#x}, next={:#x}, next_free={:#x}, system_mem={:#x})"
        return fmt.format(self.__addr, self.top, self.last_remainder, self.n, self.nfree, self.sysmem)

    def tcache_list(self):
        if get_libc_version() < (2, 26):
            info("No Tcache in this version of libc")
            return {}
        if self.heap_base is None:
            return {}

        chunks_all = {}
        for i in range(self.TCACHE_MAX_BINS):
            chunk = self.tcachebin(i)
            chunks = set()
            while True:
                if chunk is None:
                    break
                try:
                    if chunk.address in chunks:
                        break # loop detected
                    chunks.add(chunk.address)
                    next_chunk = chunk.get_fwd_ptr(True)
                    if next_chunk == 0:
                        break
                    chunk = GlibcChunk(next_chunk)
                except gdb.MemoryError:
                    break
            chunks_all[i] = chunks
        return chunks_all

    def fastbin_list(self):
        def fastbin_index(sz):
            return (sz >> 4) - 2 if SIZE_SZ == 8 else (sz >> 3) - 2

        SIZE_SZ = current_arch.ptrsize
        MAX_FAST_SIZE = (80 * SIZE_SZ // 4)
        NFASTBINS = fastbin_index(MAX_FAST_SIZE) - 1
        chunks_all = {}
        for i in range(NFASTBINS):
            chunk = self.fastbin(i)
            chunks = set()
            while True:
                if chunk is None:
                    break
                try:
                    if chunk.address in chunks:
                        break # loop detected
                    chunks.add(chunk.address)
                    next_chunk = chunk.get_fwd_ptr(True)
                    if next_chunk == 0:
                        break
                    chunk = GlibcChunk(next_chunk, from_base=True)
                except gdb.MemoryError:
                    break
            chunks_all[i] = chunks
        return chunks_all

    def bin_list(self, index):
        fw, bk = self.bin(index)
        if bk == 0x00 and fw == 0x00:
            return set() # invalid
        head = GlibcChunk(bk, from_base=True).fwd
        if fw == head:
            return set() # no entry
        chunks = set()
        while fw != head:
            chunk = GlibcChunk(fw, from_base=True)
            chunks.add(chunk.address)
            fw = chunk.fwd
        return chunks

    def unsortedbin_list(self):
        chunks_all = {}
        chunks_all[0] = self.bin_list(0)
        return chunks_all

    def smallbin_list(self):
        chunks_all = {}
        for i in range(1, 63):
            chunks_all[i] = self.bin_list(i)
        return chunks_all

    def largebin_list(self):
        chunks_all = {}
        for i in range(63, 126):
            chunks_all[i] = self.bin_list(i)
        return chunks_all


class GlibcChunk:
    """Glibc chunk class.
    Ref: https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/."""
    def __init__(self, addr, from_base=False):
        self.ptrsize = current_arch.ptrsize
        if from_base:
            self.chunk_base_address = addr
            self.address = addr + 2 * self.ptrsize
        else:
            self.chunk_base_address = int(addr - 2 * self.ptrsize)
            self.address = addr

        self.size_addr = int(self.address - self.ptrsize)
        self.prev_size_addr = self.chunk_base_address
        return

    def get_chunk_size(self):
        return read_int_from_memory(self.size_addr) & (~0x07)

    @property
    def size(self):
        return self.get_chunk_size()

    def get_usable_size(self):
        # https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L4537
        cursz = self.get_chunk_size()
        if cursz == 0:
            return cursz
        if self.has_m_bit():
            return cursz - 2 * self.ptrsize
        return cursz - self.ptrsize

    @property
    def usable_size(self):
        return self.get_usable_size()

    def get_prev_chunk_size(self):
        return read_int_from_memory(self.prev_size_addr)

    def get_next_chunk(self):
        addr = self.address + self.get_chunk_size()
        return GlibcChunk(addr)

    # if free-ed functions
    def get_fwd_ptr(self, sll):
        # Not a single-linked-list (sll) or no Safe-Linking support yet
        if not sll or get_libc_version() < (2, 32):
            return read_int_from_memory(self.address)
        # Unmask ("reveal") the Safe-Linking pointer
        else:
            return read_int_from_memory(self.address) ^ (self.address >> 12)

    @property
    def fwd(self):
        return self.get_fwd_ptr(False)

    fd = fwd # for compat

    def get_bkw_ptr(self):
        return read_int_from_memory(self.address + self.ptrsize)

    @property
    def bck(self):
        return self.get_bkw_ptr()

    bk = bck # for compat

    def get_fd_nextsize_ptr(self):
        return read_int_from_memory(self.address + self.ptrsize * 2)

    @property
    def fd_nextsize(self):
        return self.get_fd_nextsize_ptr()

    def get_bk_nextsize_ptr(self):
        return read_int_from_memory(self.address + self.ptrsize * 3)

    @property
    def bk_nextsize(self):
        return self.get_bk_nextsize_ptr()
    # endif free-ed functions

    def has_p_bit(self):
        return read_int_from_memory(self.size_addr) & 0x01

    def has_m_bit(self):
        return read_int_from_memory(self.size_addr) & 0x02

    def has_n_bit(self):
        return read_int_from_memory(self.size_addr) & 0x04

    def is_used(self):
        """Check if the current block is used by:
        - checking the M bit is true
        - or checking that next chunk PREV_INUSE flag is true"""
        if self.has_m_bit():
            return True

        next_chunk = self.get_next_chunk()
        return True if next_chunk.has_p_bit() else False

    def str_chunk_size_flag(self):
        msg = []
        msg.append("PREV_INUSE flag: {}".format(Color.greenify("On") if self.has_p_bit() else Color.redify("Off")))
        msg.append("IS_MMAPPED flag: {}".format(Color.greenify("On") if self.has_m_bit() else Color.redify("Off")))
        msg.append("NON_MAIN_ARENA flag: {}".format(Color.greenify("On") if self.has_n_bit() else Color.redify("Off")))
        return "\n".join(msg)

    def _str_sizes(self):
        msg = []
        failed = False

        try:
            msg.append("Chunk size: {0:d} ({0:#x})".format(self.get_chunk_size()))
            msg.append("Usable size: {0:d} ({0:#x})".format(self.get_usable_size()))
            failed = True
        except gdb.MemoryError:
            msg.append("Chunk size: Cannot read at {:#x} (corrupted?)".format(self.size_addr))

        try:
            msg.append("Previous chunk size: {0:d} ({0:#x})".format(self.get_prev_chunk_size()))
            failed = True
        except gdb.MemoryError:
            msg.append("Previous chunk size: Cannot read at {:#x} (corrupted?)".format(self.chunk_base_address))

        if failed:
            msg.append(self.str_chunk_size_flag())

        return "\n".join(msg)

    def _str_pointers(self):
        fwd = self.address
        bkw = self.address + self.ptrsize

        msg = []
        try:
            msg.append("Forward pointer: {0:#x}".format(self.get_fwd_ptr(False)))
        except gdb.MemoryError:
            msg.append("Forward pointer: {0:#x} (corrupted?)".format(fwd))

        try:
            msg.append("Backward pointer: {0:#x}".format(self.get_bkw_ptr()))
        except gdb.MemoryError:
            msg.append("Backward pointer: {0:#x} (corrupted?)".format(bkw))

        return "\n".join(msg)

    def str_as_alloced(self):
        return self._str_sizes()

    def str_as_freed(self):
        return "{}\n\n{}".format(self._str_sizes(), self._str_pointers())

    def flags_as_string(self):
        flags = []
        if self.has_p_bit():
            flags.append(Color.colorify("PREV_INUSE", "red bold"))
        if self.has_m_bit():
            flags.append(Color.colorify("IS_MMAPPED", "blue bold"))
        if self.has_n_bit():
            flags.append(Color.colorify("NON_MAIN_ARENA", "yellow bold"))
        return "|".join(flags)

    def __str__(self):
        chunk_c = Color.colorify("Chunk", "yellow bold underline")
        size_c = Color.colorify("{:#x}".format(self.get_chunk_size()), "bold pink")
        msg = "{:s}(addr={:#x}, size={:s}, flags={:s})".format(chunk_c, int(self.address), size_c, self.flags_as_string())
        return msg

    def str_large(self):
        chunk_c = Color.colorify("Chunk", "yellow bold underline")
        fmt = "{:s}(addr={:#x}, size={:#x}, flags={:s}, fd_nextsize={:#x}, bk_nextsize={:#x})"
        msg = fmt.format(chunk_c, int(self.address), self.get_chunk_size(), self.flags_as_string(), self.fd_nextsize, self.bk_nextsize)
        return msg

    def psprint(self):
        msg = []
        msg.append(str(self))
        if self.is_used():
            msg.append(self.str_as_alloced())
        else:
            msg.append(self.str_as_freed())
        return "\n".join(msg) + "\n"


pattern_libc_ver = re.compile(rb"glibc (\d+)\.(\d+)")


@functools.lru_cache()
def get_libc_version():
    sections = get_process_maps()
    for section in sections:
        match = re.search(r"libc6?[-_](\d+)\.(\d+)\.so", section.path)
        if match:
            return tuple(int(_) for _ in match.groups())
        if "libc" in section.path:
            try:
                with open(section.path, "rb") as f:
                    data = f.read()
            except OSError:
                continue
            match = re.search(pattern_libc_ver, data)
            if match:
                return tuple(int(_) for _ in match.groups())
    return 0, 0


def get_main_arena():
    try:
        return GlibcArena(__gef_default_main_arena__)
    except Exception as e:
        err("Failed to get the main arena, heap commands may not work properly: {}".format(e))
        return None


def titlify(text, color=None, msg_color=None):
    """Print a centered title."""
    cols = get_terminal_size()[1]
    nb = (cols - len(text) - 2) // 2
    if color is None:
        color = __config__.get("theme.default_title_line")[0]
    if msg_color is None:
        msg_color = __config__.get("theme.default_title_message")[0]

    msg = []
    msg.append(Color.colorify("{} ".format(HORIZONTAL_LINE * nb), color))
    msg.append(Color.colorify(text, msg_color))
    msg.append(Color.colorify(" {}".format(HORIZONTAL_LINE * nb), color))
    return "".join(msg)


def err(msg):
    gef_print("{} {}".format(Color.colorify("[!]", "bold red"), msg))
    return


def warn(msg):
    gef_print("{} {}".format(Color.colorify("[*]", "bold yellow"), msg))
    return


def ok(msg):
    gef_print("{} {}".format(Color.colorify("[+]", "bold green"), msg))
    return


def info(msg):
    gef_print("{} {}".format(Color.colorify("[+]", "bold blue"), msg))
    return


def push_context_message(level, message):
    """Push the message to be displayed the next time the context is invoked."""
    global __context_messages__
    if level not in ("error", "warn", "ok", "info"):
        err("Invalid level '{}', discarding message".format(level))
        return
    __context_messages__.append((level, message))
    return


def show_last_exception():
    """Display the last Python exception."""
    def _show_code_line(fname, idx):
        fname = os.path.expanduser(os.path.expandvars(fname))
        __data = open(fname, "r").read().splitlines()
        return __data[idx - 1] if idx < len(__data) else ""

    gef_print("")
    exc_type, exc_value, exc_traceback = sys.exc_info()

    gef_print(" Exception raised ".center(80, HORIZONTAL_LINE))
    gef_print("{}: {}".format(Color.colorify(exc_type.__name__, "bold underline red"), exc_value))
    gef_print(" Detailed stacktrace ".center(80, HORIZONTAL_LINE))

    for fs in traceback.extract_tb(exc_traceback)[::-1]:
        filename, lineno, method, code = fs

        if not code or not code.strip():
            code = _show_code_line(filename, lineno)

        gef_print("""{} File "{}", line {:d}, in {}()""".format(DOWN_ARROW, Color.yellowify(filename),
                                                                lineno, Color.greenify(method)))
        gef_print("   {}    {}".format(RIGHT_ARROW, code))

    gef_print(" Last 10 GDB commands ".center(80, HORIZONTAL_LINE))
    gdb.execute("show commands")
    gef_print(" Runtime environment ".center(80, HORIZONTAL_LINE))
    gef_print("* GDB: {}".format(gdb.VERSION))
    gef_print("* Python: {:d}.{:d}.{:d} - {:s}".format(sys.version_info.major, sys.version_info.minor,
                                                       sys.version_info.micro, sys.version_info.releaselevel))
    gef_print("* OS: {:s} - {:s} ({:s})".format(platform.system(), platform.release(), platform.machine()))

    gef_print(" lsb_release -a ".center(80, HORIZONTAL_LINE))
    try:
        lsb_release = which("lsb_release")
        gdb.execute("!{} -a".format(lsb_release,))
    except FileNotFoundError as e:
        gef_print("Cannot collect additional debug information: {}".format(e))

    gef_print(HORIZONTAL_LINE * 80)
    gef_print("")
    return


def gef_pystring(x):
    """Returns a sanitized version as string of the bytes list given in input."""
    res = str(x, encoding="utf-8")
    substs = [("\n", "\\n"), ("\r", "\\r"), ("\t", "\\t"), ("\v", "\\v"), ("\b", "\\b"), ]
    for x, y in substs:
        res = res.replace(x, y)
    return res


def gef_pybytes(x):
    """Returns an immutable bytes list from the string given as input."""
    return bytes(str(x), encoding="utf-8")


def slicer(data, n):
    return [data[i:i + n] for i in range(0, len(data), n)]


def slice_unpack(data, n):
    if n == 8:
        return [u64(data[i:i + 8]) for i in range(0, len(data), 8)]
    elif n == 4:
        return [u32(data[i:i + 4]) for i in range(0, len(data), 4)]
    else:
        raise


@functools.lru_cache()
def which(program):
    """Locate a command on the filesystem."""
    def is_exe(fpath):
        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)

    fpath = os.path.split(program)[0]
    if fpath:
        if is_exe(program):
            return program
    else:
        env_path = os.getenv("PATH")
        if env_path is None:
            env_path = "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
        for path in env_path.split(os.pathsep):
            path = path.strip('"')
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return exe_file
    raise FileNotFoundError("Missing file `{:s}`".format(program))


def style_byte(b, color=True):
    style = {
        "nonprintable": "yellow",
        "printable": "white",
        "00": "gray",
        "0a": "blue",
        "ff": "green",
    }
    sbyte = "{:02x}".format(b)
    if not color or get_gef_setting("highlight.regex"):
        return sbyte

    if sbyte in style:
        st = style[sbyte]
    elif chr(b) in (string.ascii_letters + string.digits + string.punctuation + " "):
        st = style.get("printable")
    else:
        st = style.get("nonprintable")
    if st:
        sbyte = Color.colorify(sbyte, st)
    return sbyte


def hexdump(source, length=0x10, separator=".", show_raw=False, show_symbol=True, base=0x00):
    """Return the hexdump of `src` argument.
    @param source *MUST* be of type bytes or bytearray
    @param length is the length of items per line
    @param separator is the default character to use if one byte is not printable
    @param show_raw if True, do not add the line nor the text translation
    @param base is the start address of the block being hexdump
    @return a string with the hexdump"""
    result = []
    align = get_memory_alignment() * 2 + 2 if is_alive() else 18

    for i in range(0, len(source), length):
        chunk = bytearray(source[i : i + length])
        padlen = (0x10 - len(chunk)) * 3
        hexa = " ".join([style_byte(b, color=not show_raw) for b in chunk])

        if show_raw:
            result.append(hexa)
            continue

        text = "".join([chr(b) if 0x20 <= b < 0x7F else separator for b in chunk])
        if show_symbol:
            sym = gdb_get_location_from_symbol(base + i)
            sym = "<{:s}+{:04x}>".format(*sym) if sym else ""
        else:
            sym = ""

        fmt = "{addr:#0{aw}x}{sym}   {data}{pad}   {text}"
        result.append(fmt.format(aw=align, addr=base + i, sym=" " + sym, pad=" " * padlen, data=hexa, text=text))
    return "\n".join(result)


@functools.lru_cache()
def is_debug():
    """Check if debug mode is enabled."""
    return get_gef_setting("gef.debug") is True


context_hidden = False


def hide_context():
    global context_hidden
    context_hidden = True
    return


def unhide_context():
    global context_hidden
    context_hidden = False
    return


def enable_redirect_output(to_file="/dev/null"):
    """Redirect all GDB output to `to_file` parameter. By default, `to_file` redirects to `/dev/null`."""
    gdb.execute("set logging overwrite")
    gdb.execute("set logging file {:s}".format(to_file))
    gdb.execute("set logging redirect on")
    gdb.execute("set logging on")
    return


def disable_redirect_output():
    """Disable the output redirection, if any."""
    gdb.execute("set logging off")
    gdb.execute("set logging redirect off")
    return


@functools.lru_cache()
def get_gef_setting(name):
    """Read global gef settings.
    Return None if not found. A valid config setting can never return None,
    but False, 0 or ""."""
    global __config__
    setting = __config__.get(name, None)
    if not setting:
        return None
    return setting[0]


def set_gef_setting(name, value, _type=None, _desc=None):
    """Set global gef settings.
    Raise ValueError if `name` doesn't exist and `type` and `desc`
    are not provided."""
    global __config__

    if name not in __config__:
        # create new setting
        if _type is None or _desc is None:
            raise ValueError("Setting '{}' is undefined, need to provide type and description".format(name))
        __config__[name] = [_type(value), _type, _desc]
        return

    # set existing setting
    func = __config__[name][1]
    __config__[name][0] = func(value)
    get_gef_setting.cache_clear()
    return


def gef_makedirs(path, mode=0o755):
    """Recursive mkdir() creation. If successful, return the absolute path of the directory created."""
    abspath = os.path.expanduser(path)
    abspath = os.path.realpath(abspath)

    if os.path.isdir(abspath):
        return abspath

    os.makedirs(abspath, mode=mode, exist_ok=True)
    return abspath


@functools.lru_cache(maxsize=512)
def gdb_get_location_from_symbol(address):
    """Retrieve the location of the `address` argument from the symbol table.
    Return a tuple with the name and offset if found, None otherwise."""
    # this is horrible, ugly hack and shitty perf...
    # find a *clean* way to get gdb.Location from an address
    name = None
    sym = gdb.execute("info symbol {:#x}".format(address), to_string=True)
    if sym.startswith("No symbol matches"):
        return None

    i = sym.find(" in section ")
    sym = sym[:i].split()
    if len(sym) >= 3 and sym[-1].isdigit():
        name = ' '.join(sym[:-2])
        offset = int(sym[-1])
    else:
        name = ' '.join(sym)
        offset = 0
    return name, offset


def get_symbol_string(addr, nosymbol_string=""):
    try:
        if isinstance(addr, str):
            addr = re.sub(r"\x1B\[([0-9]{1,2}(;[0-9]{1,2})*)?m", "", addr) # remove color
            addr = int(addr, 16)
        ret = gdb_get_location_from_symbol(addr)
    except Exception:
        return nosymbol_string
    if ret is None:
        return nosymbol_string
    sym_name, sym_offset = ret[0], ret[1]
    sym_name = Instruction.smartify_text(sym_name)
    if sym_offset == 0:
        return " <{}>".format(sym_name)
    else:
        return " <{}+{:#x}>".format(sym_name, sym_offset)


def load_capstone(f):
    """Decorator wrapper to load capstone."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        try:
            __import__("capstone")
            return f(*args, **kwargs)
        except ImportError:
            msg = "Missing `capstone` package for Python. Install with `pip install capstone`."
            raise ImportWarning(msg)

    return wrapper


def load_unicorn(f):
    """Decorator wrapper to load unicorn."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        try:
            __import__("unicorn")
            __import__("unicorn.ppc_const")
            return f(*args, **kwargs)
        except ImportError:
            msg = "Missing `unicorn` package for Python. Install with `pip install unicorn`."
            raise ImportWarning(msg)

    return wrapper


def load_keystone(f):
    """Decorator wrapper to load keystone."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        try:
            __import__("keystone")
            return f(*args, **kwargs)
        except ImportError:
            msg = "Missing `keystone-engine` package, install with: `pip install keystone-engine`."
            raise ImportWarning(msg)

    return wrapper


__prev_arch = None


def gdb_disassemble(start_pc, **kwargs):
    """Disassemble instructions from `start_pc` (Integer). Accepts the following named parameters:
    - `end_pc` (Integer) only instructions whose start address fall in the interval from start_pc to end_pc are returned.
    - `count` (Integer) list at most this many disassembled instructions
    If `end_pc` and `count` are not provided, the function will behave as if `count=1`.
    Return an iterator of Instruction objects"""

    try:
        arch = gdb.selected_frame().architecture()
        global __prev_arch
        __prev_arch = arch
    except Exception:
        # For unknown reasons, gdb.selected_frame() may cause an error (often occurs during kernel startup).
        # At this time arch cannot be resolved, but if it was successful before, it will be used.
        arch = __prev_arch
        if __prev_arch is None:
            raise

    for insn in arch.disassemble(start_pc, **kwargs):
        address = insn["addr"]
        asm = insn["asm"].rstrip().split(None, 1)
        if len(asm) > 1:
            mnemo, operands = asm
            operands = operands.split(",")
        else:
            mnemo, operands = asm[0], []

        loc = gdb_get_location_from_symbol(address)
        location = "<{}+{}>".format(*loc) if loc else ""

        if is_arm32() and insn["addr"] & 1:
            opcodes = read_memory(insn["addr"] - 1, insn["length"])
        else:
            opcodes = read_memory(insn["addr"], insn["length"])

        yield Instruction(address, location, mnemo, operands, opcodes)


def gdb_get_nth_previous_instruction_address(addr, n):
    """Return the address (Integer) of the `n`-th instruction before `addr`."""
    # fixed-length ABI
    if current_arch.instruction_length:
        return max(0, addr - n * current_arch.instruction_length)

    # variable-length ABI
    cur_insn_addr = gef_current_instruction(addr).address

    # we try to find a good set of previous instructions by "guessing" disassembling backwards
    # the 15 comes from the longest instruction valid size
    for i in range(15 * n, 0, -1):
        try:
            insns = list(gdb_disassemble(addr - i, end_pc=cur_insn_addr))
        except gdb.MemoryError:
            # this is because we can hit an unmapped page trying to read backward
            break

        # 1. check that the disassembled instructions list size can satisfy
        if len(insns) < n + 1: # we expect the current instruction plus the n before it
            continue

        # If the list of instructions is longer than what we need, then we
        # could get lucky and already have more than what we need, so slice down
        insns = insns[-n - 1 :]

        # 2. check that the sequence ends with the current address
        if insns[-1].address != cur_insn_addr:
            continue

        # 3. check all instructions are valid
        if all(insn.is_valid() for insn in insns):
            return insns[0].address

    return None


def gdb_get_nth_next_instruction_address(addr, n):
    """Return the address (Integer) of the `n`-th instruction after `addr`."""
    # fixed-length ABI
    if current_arch.instruction_length:
        return addr + n * current_arch.instruction_length

    # variable-length ABI
    insn = list(gdb_disassemble(addr, count=n))[-1]
    return insn.address


def gef_instruction_n(addr, n):
    """Return the `n`-th instruction after `addr` as an Instruction object."""
    return list(gdb_disassemble(addr, count=n + 1))[n]


def gef_get_instruction_at(addr):
    """Return the full Instruction found at the specified address."""
    insn = next(gef_disassemble(addr, 1))
    return insn


def gef_current_instruction(addr):
    """Return the current instruction as an Instruction object."""
    return gef_instruction_n(addr, 0)


def gef_next_instruction(addr):
    """Return the next instruction as an Instruction object."""
    return gef_instruction_n(addr, 1)


def gef_disassemble(addr, nb_insn, nb_prev=0):
    """Disassemble `nb_insn` instructions after `addr` and `nb_prev` before `addr`.
    Return an iterator of Instruction objects."""
    nb_insn = max(1, nb_insn)

    if nb_prev:
        done = False
        for i in range(nb_prev):
            if done:
                break
            start_addr = gdb_get_nth_previous_instruction_address(addr, nb_prev - i)
            if not start_addr:
                continue
            try:
                for insn in gdb_disassemble(start_addr, count=nb_prev):
                    if insn.address == addr:
                        done = True
                        break
                    yield insn
                done = True
                break
            except Exception:
                pass

    for insn in gdb_disassemble(addr, count=nb_insn):
        yield insn


@load_capstone
def capstone_disassemble(location, nb_insn, **kwargs):
    """Disassemble `nb_insn` instructions after `addr` and `nb_prev` before
    `addr` using the Capstone-Engine disassembler, if available.
    Return an iterator of Instruction objects."""
    def cs_insn_to_gef_insn(cs_insn):
        sym_info = gdb_get_location_from_symbol(cs_insn.address)
        loc = "<{}+{}>".format(*sym_info) if sym_info else ""
        ops = [] + cs_insn.op_str.split(", ")
        return Instruction(cs_insn.address, loc, cs_insn.mnemonic, ops, cs_insn.bytes)

    capstone = sys.modules["capstone"]
    arch, mode = get_capstone_arch(arch=kwargs.get("arch", None), mode=kwargs.get("mode", None), endian=kwargs.get("endian", None))
    cs = capstone.Cs(arch, mode)
    cs.detail = True
    skip = int(kwargs.get("skip", 0))

    if "code" in kwargs:
        code = kwargs["code"].replace(" ", "")
        code = binascii.unhexlify(code)
        for insn in cs.disasm(code, location):
            if skip:
                skip -= 1
                continue
            nb_insn -= 1
            yield Instruction(insn.address, "", insn.mnemonic, [] + insn.op_str.split(", "), insn.bytes)
            if nb_insn == 0:
                break
        return
    else:
        pc = current_arch.pc
        nb_prev = int(kwargs.get("nb_prev", 0))
        if nb_prev > 0:
            location = gdb_get_nth_previous_instruction_address(pc, nb_prev)
            nb_insn += nb_prev

        # split raeding by page_size
        used_bytes = 0
        code = b""
        page_start = align_address_to_page(location)
        offset = location - page_start
        read_addr = location
        if is_arm32() and read_addr & 1:
            read_addr -= 1
            offset -= 1
        read_size = gef_getpagesize() - offset
        while True:
            try:
                read_data = read_memory(read_addr, read_size)
            except gdb.MemoryError:
                err("Memory read error at {:#x}-{:#x}".format(read_addr, read_addr + read_size))
                return
            code += bytes(read_data)
            for insn in cs.disasm(code, location):
                if skip:
                    skip -= 1
                    continue
                nb_insn -= 1
                used_bytes += len(insn.bytes)
                yield cs_insn_to_gef_insn(insn)
                if nb_insn == 0:
                    return
            code = code[used_bytes:] # There may be instructions placed across page boundaries.
            location += used_bytes
            used_bytes = 0
            read_addr += read_size # 1st loop is the offset size. 2nd~ loops are the page size.
            read_size = gef_getpagesize()
    return


def gef_execute_external(command, as_list=False, *args, **kwargs):
    """Execute an external command and return the result."""
    res = subprocess.check_output(command, stderr=subprocess.STDOUT, shell=kwargs.get("shell", False))
    return [gef_pystring(_) for _ in res.splitlines()] if as_list else gef_pystring(res)


def gef_execute_gdb_script(commands):
    """Execute the parameter `source` as GDB command. This is done by writing `commands` to
    a temporary file, which is then executed via GDB `source` command. The tempfile is then deleted."""
    fd, fname = tempfile.mkstemp(suffix=".gdb", prefix="gef_")
    with os.fdopen(fd, "w") as f:
        f.write(commands)
        f.flush()
    if os.access(fname, os.R_OK):
        gdb.execute("source {:s}".format(fname))
        os.unlink(fname)
    return


@functools.lru_cache()
def checksec(filename):
    """Check the security property of the ELF binary. The following properties are:
    - Static
    - Stripped
    - Canary
    - NX
    - PIE
    - RELRO
    - Fortify
    - Intel CET
    - RPATH/RUNPATH
    - Clang CFI/SafeStack
    Return a dict() with the different keys mentioned above, and the boolean
    associated whether the protection was found."""

    try:
        readelf = which("readelf")
        objdump = which("objdump")
    except FileNotFoundError as e:
        err("{}".format(e))
        return False

    if not os.path.exists(filename):
        return False

    cache = {}

    def __check_security_property(opt, filename, pattern):
        if (opt, filename) in cache:
            lines = cache[(opt, filename)]
        else:
            cmd = [readelf]
            cmd += opt.split()
            cmd += [filename]
            lines = gef_execute_external(cmd, as_list=True)
            cache[(opt, filename)] = lines
        for line in lines:
            if re.search(pattern, line):
                return True
        return False

    results = collections.OrderedDict()
    # Static
    results["Static"] = is_static(filename)
    # Stripped
    results["Stripped"] = is_stripped(filename)
    # Canary
    if not is_stripped(filename):
        results["Canary"] = __check_security_property("-rs", filename, r"__stack_chk_fail") is True
        if not results["Canary"]:
            results["Canary"] = __check_security_property("-rs", filename, r"__stack_chk_guard") is True # for non-x86
        if not results["Canary"]:
            results["Canary"] = __check_security_property("-rs", filename, r"__intel_security_cookie") is True # for intel compiler
    else:
        results["Canary"] = None # it means unknown
        if is_x86_64():
            proc = subprocess.Popen([objdump, "-d", filename], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            for i in range(0x10000):
                if b"%fs:0x28" in proc.stdout.readline():
                    results["Canary"] = True
                    break
            proc.kill()
        elif is_x86_32():
            proc = subprocess.Popen([objdump, "-d", filename], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            for i in range(0x10000):
                if b"%gs:0x14" in proc.stdout.readline():
                    results["Canary"] = True
                    break
            proc.kill()
    # NX
    has_gnu_stack = __check_security_property("-W -l", filename, r"GNU_STACK") is True
    if has_gnu_stack:
        results["NX"] = __check_security_property("-W -l", filename, r"GNU_STACK.*RWE") is False
    else:
        results["NX"] = False
    # PIE
    results["PIE"] = __check_security_property("-h", filename, r":.*EXEC") is False
    # RELRO
    results["Partial RELRO"] = __check_security_property("-l", filename, r"GNU_RELRO") is True
    results["Full RELRO"] = results["Partial RELRO"] and __check_security_property("-d", filename, r"BIND_NOW") is True
    # Fortify
    if is_stripped(filename):
        results["Fortify"] = None # it means unknown
    elif is_static(filename):
        results["Fortify"] = __check_security_property("-rs", filename, r"__mem(cpy|move)_chk") is True
    else:
        results["Fortify"] = __check_security_property("-rs", filename, r"_chk@GLIBC") is True
    # CET
    if not is_x86():
        results["Intel CET"] = False
    elif not is_stripped(filename) and not is_static(filename):
        results["Intel CET"] = __check_security_property("-S", filename, r"\.plt\.sec") is True
    else: # static or stripped
        cmd = [objdump, "-d", "-j", ".plt", filename] # check only .plt section for speed up
        out = gef_execute_external(cmd, as_list=True)
        results["Intel CET"] = False
        for line in out:
            line = line.strip()
            if not line:
                continue
            if is_x86_64() and line.endswith("endbr64"):
                results["Intel CET"] = True
                break
            elif is_x86_32() and line.endswith("endbr32"):
                results["Intel CET"] = True
                break
    # RPATH
    results["RPATH"] = __check_security_property("-d", filename, r"\(RPATH\)") is True
    # RUNPATH
    results["RUNPATH"] = __check_security_property("-d", filename, r"\(RUNPATH\)") is True
    # Clang CFI (detected only when `-fno-sanitize-trap=all`)
    results["Clang CFI"] = __check_security_property("-s", filename, r"__ubsan_handle_cfi_") is True
    # Clang SafeStack
    results["Clang SafeStack"] = __check_security_property("-s", filename, r"__safestack_init") is True
    return results


@functools.lru_cache()
def get_arch():
    """Return the binary's architecture."""
    if is_alive():
        try:
            arch = gdb.selected_frame().architecture()
            return arch.name()
        except Exception:
            # For unknown reasons, gdb.selected_frame() may cause an error (often occurs during kernel startup).
            # Resolve by moving to the slow path.
            pass

    # slow path
    arch_str = gdb.execute("show architecture", to_string=True).strip()
    if "The target architecture is set automatically (currently " in arch_str:
        arch_str = arch_str.split("(currently ", 1)[1]
        arch_str = arch_str.split(")", 1)[0]
    elif "The target architecture is set to \"auto\" (currently \"" in arch_str:
        # GDB version >= 12.x
        arch_str = arch_str.split("(currently \"", 1)[1]
        arch_str = arch_str.split("\")", 1)[0]
    elif "The target architecture is assumed to be " in arch_str:
        arch_str = arch_str.replace("The target architecture is assumed to be ", "")
    elif "The target architecture is set to " in arch_str:
        # GDB version >= 10.1
        arch_str = re.findall(r"\"(.+)\"", arch_str)[0]
    else:
        # Unknown, we throw an exception to be safe
        raise RuntimeError("Unknown architecture: {}".format(arch_str))
    return arch_str


@functools.lru_cache()
def get_endian():
    """Return the binary endianness."""
    endian = gdb.execute("show endian", to_string=True).strip().lower()
    if "little endian" in endian:
        return Elf.LITTLE_ENDIAN
    if "big endian" in endian:
        return Elf.BIG_ENDIAN
    raise EnvironmentError("Invalid endianness")


@functools.lru_cache()
def get_entry_point():
    """Return the binary entry point."""
    for line in gdb.execute("info target", to_string=True).split("\n"):
        if "Entry point:" in line:
            return int(line.strip().split(" ")[-1], 16)
    for line in gdb.execute("elf-info", to_string=True).split("\n"):
        if "Entry point" in line:
            return int(line.strip().split(" ")[-1], 16)
    return None


def is_pie(fpath):
    return checksec(fpath).get("PIE", False)


def is_big_endian():
    return get_endian() == Elf.BIG_ENDIAN


def is_little_endian():
    return not is_big_endian()


def flags_to_human(reg_value, value_table):
    """Return a human readable string showing the flag states."""
    flags = []
    for i in value_table:
        if reg_value & (1 << i):
            flag_str = Color.boldify(value_table[i].upper())
        else:
            flag_str = value_table[i].lower()
        flags.append(flag_str)
    return "{:#x} [{}]".format(reg_value, " ".join(flags))


class Architecture:
    """Generic metaclass for the architecture supported by GEF."""
    __metaclass__ = abc.ABCMeta

    @abc.abstractproperty
    def all_registers(self):
        pass

    @abc.abstractproperty
    def instruction_length(self):
        pass

    @abc.abstractproperty
    def nop_insn(self):
        pass

    @abc.abstractproperty
    def infloop_insn(self):
        pass

    @abc.abstractproperty
    def trap_insn(self):
        pass

    @abc.abstractproperty
    def ret_insn(self):
        pass

    @abc.abstractproperty
    def return_register(self):
        pass

    @abc.abstractproperty
    def flag_register(self):
        pass

    @abc.abstractproperty
    def flags_table(self):
        pass

    @abc.abstractproperty
    def function_parameters(self):
        pass

    @abc.abstractmethod
    def flag_register_to_human(self, val=None):
        pass

    @abc.abstractmethod
    def is_syscall(self, insn):
        pass

    @abc.abstractmethod
    def is_call(self, insn):
        pass

    @abc.abstractmethod
    def is_jump(self, insn):
        pass

    @abc.abstractmethod
    def is_ret(self, insn):
        pass

    @abc.abstractmethod
    def is_conditional_branch(self, insn):
        pass

    @abc.abstractmethod
    def is_branch_taken(self, insn):
        pass

    @abc.abstractmethod
    def get_ra(self, insn, frame):
        pass

    special_registers = []

    @property
    def pc(self):
        return get_register("$pc")

    @property
    def sp(self):
        return get_register("$sp")

    @property
    def fp(self):
        return get_register("$fp")

    @property
    def ptrsize(self):
        return get_memory_alignment()

    def get_ith_parameter(self, i, in_func=True):
        if i < len(self.function_parameters):
            reg = self.function_parameters[i]
            val = get_register(reg)
            key = reg
            return key, val
        else:
            i -= len(self.function_parameters)
            if in_func and is_x86():
                i += 1 # Account for RA being at the top of the stack
            sp = current_arch.sp
            sz = current_arch.ptrsize
            loc = sp + (i * sz)
            val = read_int_from_memory(loc)
            key = "[sp + {:#x}]".format(i * sz)
            return key, val

    __aliased_registers = None

    # {"$zero":"$zero/$x0", ...}
    def get_aliased_registers(self):
        if self.__aliased_registers is not None:
            return self.__aliased_registers
        self.__aliased_registers = {}
        for reg in self.all_registers:
            if reg in self.alias_registers:
                reg_str = "{:s}/{:s}".format(reg, self.alias_registers[reg])
            else:
                reg_str = reg
            self.__aliased_registers[reg] = reg_str
        return self.__aliased_registers

    __aliased_registers_max_len = None

    # max(len("$zero/$x0"), ...)
    def get_aliased_registers_name_max(self):
        if self.__aliased_registers_max_len is not None:
            return self.__aliased_regsiters_max_len
        maxlen = max([len(v) for k, v in self.get_aliased_registers().items()])
        self.__aliased_regsiters_max_len = maxlen
        return self.__aliased_regsiters_max_len


class RISCV(Architecture):
    arch = "RISCV"
    mode = "RISCV"

    all_registers = [
        "$zero", "$ra", "$sp", "$gp", "$tp", "$t0", "$t1", "$t2",
        "$fp", "$s1", "$a0", "$a1", "$a2", "$a3", "$a4", "$a5",
        "$a6", "$a7", "$s2", "$s3", "$s4", "$s5", "$s6", "$s7",
        "$s8", "$s9", "$s10", "$s11", "$t3", "$t4", "$t5", "$t6",
    ]
    alias_registers = {
        "$zero": "$x0", "$ra": "$x1", "$sp": "$x2", "$gp": "$x3", "$tp": "$x4", "$t0": "$x5", "$t1": "$x6", "$t2": "$x7",
        "$fp": "$x8", "$s1": "$x9", "$a0": "$x10", "$a1": "$x11", "$a2": "$x12", "$a3": "$x13", "$a4": "$x14", "$a5": "$x15",
        "$a6": "$x16", "$a7": "$x17", "$s2": "$x18", "$s3": "$x19", "$s4": "$x20", "$s5": "$x21", "$s6": "$x22", "$s7": "$x23",
        "$s8": "$x24", "$s9": "$x25", "$s10": "$x26", "$s11": "$x27", "$t3": "$x28", "$t4": "$x29", "$t5": "$x30", "$t6": "$x31",
    }
    return_register = "$a0"
    function_parameters = ["$a0", "$a1", "$a2", "$a3", "$a4", "$a5", "$a6", "$a7"]
    syscall_register = "$a7"
    syscall_instructions = ["ecall"]

    nop_insn = b"\x01\x00" # c.nop
    infloop_insn = b"\x01\xa0" # c.j self
    trap_insn = b"\x02\x90" # c.ebreak
    ret_insn = b"\x82\x80" # c.ret

    # RISC-V has no flags registers
    flag_register = None
    flags_table = None

    def flag_register_to_human(self, val=None):
        return Color.colorify("No flag register", "yellow underline")

    @property
    def instruction_length(self):
        return None

    def is_syscall(self, insn):
        return insn.mnemonic == "ecall"

    def is_call(self, insn):
        return not self.is_ret(insn) and insn.mnemonic in ["jal", "jalr"]

    def is_jump(self, insn):
        return self.is_conditional_branch(self) or (not self.is_ret(insn) and insn.mnemonic in ["jal", "jalr"])

    def is_ret(self, insn):
        mnemo = insn.mnemonic
        if mnemo == "ret":
            return True
        elif (mnemo == "jalr" and insn.operands[0] == "zero" and insn.operands[1] == "ra" and insn.operands[2] == 0):
            return True
        elif (mnemo == "c.jalr" and insn.operands[0] == "ra"):
            return True
        return False

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        raise OSError("Architecture {:s} not supported yet".format(cls.arch))

    def is_conditional_branch(self, insn):
        return insn.mnemonic.startswith("b")

    def is_branch_taken(self, insn):
        def long_to_twos_complement(v):
            """Convert a python long value to its two's complement."""
            if is_32bit():
                if v & 0x80000000:
                    return v - 0x100000000
            elif is_64bit():
                if v & 0x8000000000000000:
                    return v - 0x10000000000000000
            else:
                raise OSError("RISC-V: ELF file is not ELF32 or ELF64. This is not currently supported")
            return v

        mnemo = insn.mnemonic
        condition = mnemo[1:]

        if condition.endswith("z"):
            # r2 is the zero register if we are comparing to 0
            rs1 = get_register(insn.operands[0])
            rs2 = get_register("$zero")
            condition = condition[:-1]
        elif len(insn.operands) > 2:
            # r2 is populated with the second operand
            rs1 = get_register(insn.operands[0])
            rs2 = get_register(insn.operands[1])
        else:
            raise OSError("RISC-V: Failed to get rs1 and rs2 for instruction: `{}`".format(insn))

        # If the conditional operation is not unsigned, convert the python long into
        # its two's complement
        if not condition.endswith("u"):
            rs2 = long_to_twos_complement(rs2)
            rs1 = long_to_twos_complement(rs1)
        else:
            condition = condition[:-1]

        if condition == "eq":
            if rs1 == rs2:
                taken, reason = True, "{}={}".format(rs1, rs2)
            else:
                taken, reason = False, "{}!={}".format(rs1, rs2)
        elif condition == "ne":
            if rs1 != rs2:
                taken, reason = True, "{}!={}".format(rs1, rs2)
            else:
                taken, reason = False, "{}={}".format(rs1, rs2)
        elif condition == "lt":
            if rs1 < rs2:
                taken, reason = True, "{}<{}".format(rs1, rs2)
            else:
                taken, reason = False, "{}>={}".format(rs1, rs2)
        elif condition == "ge":
            if rs1 < rs2:
                taken, reason = True, "{}>={}".format(rs1, rs2)
            else:
                taken, reason = False, "{}<{}".format(rs1, rs2)
        else:
            raise OSError("RISC-V: Conditional instruction `{:s}` not supported yet".format(insn))

        return taken, reason

    def get_ra(self, insn, frame):
        ra = None
        try:
            if self.is_ret(insn):
                ra = get_register("$ra")
            elif frame.older():
                ra = frame.older().pc()
        except Exception:
            pass
        return ra


class ARM(Architecture):
    arch = "ARM"

    try:
        gdb.execute("info registers xpsr", to_string=True)
        _mode = "cortex-m"
    except Exception:
        _mode = "normal"

    if _mode == "normal":
        all_registers = [
            "$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6", "$r7",
            "$r8", "$r9", "$r10", "$r11", "$r12", "$sp", "$lr", "$pc",
            "$cpsr",
        ]
        alias_registers = {
            "$sp": "$r13", "$lr": "$r14", "$pc": "$r15",
        }
        flag_register = "$cpsr"
        thumb_bit = 5
    elif _mode == "cortex-m":
        all_registers = [
            "$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6", "$r7",
            "$r8", "$r9", "$r10", "$r11", "$r12", "$sp", "$lr", "$pc",
            "$xpsr",
            "$msp", "$psp", "$primask", "$basepri", "$faultmask", "$control",
        ]
        alias_registers = {
            "$sp": "$r13", "$lr": "$r14", "$pc": "$r15",
        }
        flag_register = "$xpsr"
        thumb_bit = 24
    else:
        raise

    # http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0041c/Caccegih.html
    # return b"\x00\x00\xa0\xe1" # mov r0, r0
    @property
    def nop_insn(self):
        if self.is_thumb():
            return b"\x00\xbf" # nop
        else:
            return b"\x01\x10\xa0\xe1" # mov r1, r1

    @property
    def infloop_insn(self):
        if self.is_thumb():
            return b"\xfe\xe7" # b #0
        else:
            return b"\xfe\xff\xff\xea" # b #0

    @property
    def trap_insn(self):
        if self.is_thumb():
            return b"\x00\xbe" # bkpt #0
        else:
            return b"\x70\x00\x20\xe1" # bkpt #0

    @property
    def ret_insn(self):
        if self.is_thumb():
            return b"\xf7\x46" # mov pc, lr
        else:
            return b"\x0e\xf0\xa0\xe1" # mov pc, lr

    return_register = "$r0"
    flags_table = {
        31: "negative",
        30: "zero",
        29: "carry",
        28: "overflow",
        7: "interrupt",
        6: "fast",
        thumb_bit: "thumb",
    }
    function_parameters = ["$r0", "$r1", "$r2", "$r3"]
    syscall_register = "$r7"
    syscall_instructions = ["svc 0x0", "swi 0x0", "swi NR"]

    def is_thumb(self):
        """Determine if the machine is currently in THUMB mode."""
        return is_alive() and get_register(self.flag_register) & (1 << self.thumb_bit)

    @property
    def pc(self):
        pc = get_register("$pc")
        if self.is_thumb():
            pc += 1
        return pc

    @property
    def mode(self):
        return "THUMB" if self.is_thumb() else "ARM"

    @property
    def instruction_length(self):
        # Thumb instructions have variable-length (2 or 4-byte)
        return None if self.is_thumb() else 4

    def is_syscall(self, insn):
        return insn.mnemonic in ["svc", "swi"]

    def is_call(self, insn):
        for c in ["bl", "blx"]:
            for cc in ["", "eq", "ne", "lt", "le", "gt", "ge", "vs", "vc", "mi", "pl", "hi", "ls", "cs", "cc", "hs", "lo", "al"]:
                if insn.mnemonic == c + cc:
                    return True
        return False

    def is_jump(self, insn):
        if insn.mnemonic in ["b", "bx"] and insn.operands[-1] == "lr":
            return False
        for c in ["b", "bx"]:
            for cc in ["", "eq", "ne", "lt", "le", "gt", "ge", "vs", "vc", "mi", "pl", "hi", "ls", "cs", "cc", "hs", "lo", "al"]:
                for suffix in ["", ".n", ".w"]:
                    if insn.mnemonic == c + cc + suffix:
                        return True
        return insn.mnemonic in ["mov", "ldr", "add"] and insn.operands[0] == "pc"

    def is_ret(self, insn):
        load_mnemos = [
            "pop", "ldm", "ldmea", "ldmed", "ldmfa", "ldmfd", "ldmia", "ldmib", "ldmda", "ldmdb",
            "ldm.w", "ldmea.w", "ldmed.w", "ldmfa.w", "ldmfd.w", "ldmia.w", "ldmib.w", "ldmda.w", "ldmdb.w"
        ]
        if insn.mnemonic in load_mnemos:
            return insn.operands[-1].strip() == "pc}"
        if insn.mnemonic in ["bl", "blx", "b", "bx"]:
            return insn.operands[-1] == "lr"
        if insn.mnemonic in ["ldr", "add"]:
            return insn.operands[0] == "pc"
        if insn.mnemonic == "rfe":
            return True
        return False

    __SCR_available = None
    __mode_dic = {
        # encoding: [mode, PL]
        0b10000: ["User", 0],
        0b10001: ["FIQ", 1],
        0b10010: ["IRQ", 1],
        0b10011: ["Supervisor", 1],
        0b10110: ["Monitor", 1],
        0b10111: ["Abort", 1],
        0b11010: ["Hypervisor", 2],
        0b11011: ["Undefined", 1],
        0b11111: ["System", 1],
    }

    def flag_register_to_human(self, val=None):
        # http://www.botskool.com/user-pages/tutorials/electronics/arm-7-tutorial-part-1
        if val is None:
            reg = self.flag_register
            val = get_register(reg) & 0xffffffff

        key = val & 0b11111
        CurrentMode, CurrentPL = self.__mode_dic[key]

        if self.__SCR_available is False: # for speed up
            mode = " [Mode={:s}({:#07b},PL{:d})]".format(CurrentMode, key, CurrentPL)
        else:
            scr = get_register("$SCR")
            if scr is not None:
                self.__SCR_available = True
                secure_state = ["Secure", "Non-Secure"][scr & 1]
                mode = " [Mode={:s}({:#07b},PL{:d}),{:s}]".format(CurrentMode, key, CurrentPL, secure_state)
            else:
                self.__SCR_available = False
                mode = " [Mode={:s}({:#07b},PL{:d})]".format(CurrentMode, key, CurrentPL)
        return flags_to_human(val, self.flags_table) + mode

    def is_conditional_branch(self, insn):
        conditions = ["eq", "ne", "lt", "le", "gt", "ge", "vs", "vc", "mi", "pl", "hi", "ls", "cs", "cc", "hs", "lo"]
        return (not insn.mnemonic == "svc") and (insn.mnemonic[-2:] in conditions)

    def is_branch_taken(self, insn):
        mnemo = insn.mnemonic
        # ref: http://www.davespace.co.uk/arm/introduction-to-arm/conditional.html
        flags = dict((self.flags_table[k], k) for k in self.flags_table)
        val = get_register(self.flag_register)
        taken, reason = False, ""

        zero = bool(val & (1 << flags["zero"]))
        negative = bool(val & (1 << flags["negative"]))
        overflow = bool(val & (1 << flags["overflow"]))
        carry = bool(val & (1 << flags["carry"]))

        if mnemo.endswith("eq"):
            taken, reason = zero, "Z"
        elif mnemo.endswith("ne"):
            taken, reason = not zero, "!Z"
        elif mnemo.endswith("lt"):
            taken, reason = negative != overflow, "N!=V"
        elif mnemo.endswith("le"):
            taken, reason = zero or negative != overflow, "Z || N!=V"
        elif mnemo.endswith("gt"):
            taken, reason = not zero and negative == overflow, "!Z && N==V"
        elif mnemo.endswith("ge"):
            taken, reason = negative == overflow, "N==V"
        elif mnemo.endswith("vs"):
            taken, reason = overflow, "V"
        elif mnemo.endswith("vc"):
            taken, reason = not overflow, "!V"
        elif mnemo.endswith("mi"):
            taken, reason = negative, "N"
        elif mnemo.endswith("pl"):
            taken, reason = not negative, "N==0"
        elif mnemo.endswith("hi"):
            taken, reason = carry and not zero, "C && !Z"
        elif mnemo.endswith("ls"):
            taken, reason = not carry or zero, "!C || Z"
        elif mnemo.endswith("cs") or mnemo.endswith("hs"):
            taken, reason = carry, "C"
        elif mnemo.endswith("cc") or mnemo.endswith("lo"):
            taken, reason = not carry, "!C"
        return taken, reason

    def get_ra(self, insn, frame):
        ra = None
        try:
            if self.is_ret(insn):
                # If it's a pop, we have to peek into the stack, otherwise use lr
                if insn.mnemonic == "pop":
                    ra_addr = current_arch.sp + (len(insn.operands) - 1) * get_memory_alignment()
                    ra = to_unsigned_long(dereference(ra_addr))
                elif insn.mnemonic == "ldr":
                    return to_unsigned_long(dereference(current_arch.sp))
                else: # 'bx lr' or 'add pc, lr, #0'
                    return get_register("$lr")
            elif frame.older():
                ra = frame.older().pc()
        except Exception:
            pass
        return ra

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        _NR_mprotect = 125
        insns = [
            "mov r7, {:d}".format(_NR_mprotect),
            "movw r0, #{:#x}".format((addr >> 16) & 0xffff),
            "lsl r0, r0, 16",
            "orr r0, #{:#x}".format((addr >> 0) & 0xffff),
            "movw r1, #{:#x}".format((size >> 16) & 0xffff),
            "lsl r1, r1, 16",
            "orr r1, #{:#x}".format((size >> 0) & 0xffff),
            "mov r2, {:d}".format(perm),
            "svc 0",
        ]
        return "; ".join(insns)


class AARCH64(ARM):
    arch = "ARM64"
    mode = "ARM"

    all_registers = [
        "$x0", "$x1", "$x2", "$x3", "$x4", "$x5", "$x6", "$x7",
        "$x8", "$x9", "$x10", "$x11", "$x12", "$x13", "$x14", "$x15",
        "$x16", "$x17", "$x18", "$x19", "$x20", "$x21", "$x22", "$x23",
        "$x24", "$x25", "$x26", "$x27", "$x28", "$x29", "$x30", "$sp",
        "$pc", "$cpsr", "$fpsr", "$fpcr",
    ]
    alias_registers = {
        "$x30": "$lr",
    }
    return_register = "$x0"
    flag_register = "$cpsr"
    flags_table = {
        31: "negative",
        30: "zero",
        29: "carry",
        28: "overflow",
        7: "interrupt",
        6: "fast",
    }
    function_parameters = ["$x0", "$x1", "$x2", "$x3", "$x4", "$x5", "$x6", "$x7"]
    syscall_register = "$x8"
    syscall_instructions = ["svc #0x0"]

    nop_insn = b"\x1f\x20\x03\xd5" # nop
    infloop_insn = b"\x00\x00\x00\x14" # b #0
    trap_insn = b"\x00\x00\x20\xd4" # bkr #0
    ret_insn = b"\xc0\x03\x5f\xd6" # ret

    def is_syscall(self, insn):
        return insn.mnemonic == "svc"

    def is_call(self, insn):
        return insn.mnemonic in ["bl", "blr"]

    def is_jump(self, insn):
        return insn.mnemonic in ["b", "br"] or self.is_conditional_branch(insn)

    def is_ret(self, insn):
        return (insn.mnemonic in ["ret", "eret"]) or (insn.mnemonic == "ldp" and "pc" in insn.operands)

    __SCR_EL3_available = None

    def flag_register_to_human(self, val=None):
        # http://events.linuxfoundation.org/sites/events/files/slides/KoreaLinuxForum-2014.pdf
        if val is None:
            reg = self.flag_register
            val = get_register(reg) & 0xffffffff

        if self.__SCR_EL3_available is False: # for speed up
            mode = " [EL={:d},SP={:d}]".format((val >> 2) & 0b11, val & 0b11)
        else:
            scr = get_register("$SCR_EL3")
            if scr is not None:
                self.__SCR_EL3_available = True
                secure_state = ["Secure", "Non-Secure"][scr & 1]
                mode = " [EL={:d},SP={:d},{:s}]".format((val >> 2) & 0b11, val & 0b11, secure_state)
            else:
                self.__SCR_EL3_available = False
                mode = " [EL={:d},SP={:d}]".format((val >> 2) & 0b11, val & 0b11)

        return flags_to_human(val, self.flags_table) + mode

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        _NR_mprotect = 226
        insns = [
            "mov x8, {:d}".format(_NR_mprotect),
            "movz x0, {:#x}".format(addr & 0xffff),
            "movk x0, {:#x}, lsl 16".format((addr >> 16) & 0xffff),
            "movk x0, {:#x}, lsl 32".format((addr >> 32) & 0xffff),
            "movk x0, {:#x}, lsl 48".format((addr >> 48) & 0xffff),
            "movz x1, {:#x}".format(size & 0xffff),
            "movk x1, {:#x}, lsl 16".format((size >> 16) & 0xffff),
            "movk x1, {:#x}, lsl 32".format((size >> 32) & 0xffff),
            "movk x1, {:#x}, lsl 48".format((size >> 48) & 0xffff),
            "mov x2, {:d}".format(perm),
            "svc 0",
        ]
        return "; ".join(insns)

    def is_conditional_branch(self, insn):
        # https://www.element14.com/community/servlet/JiveServlet/previewBody/41836-102-1-229511/ARM.Reference_Manual.pdf
        # sect. 5.1.1
        mnemo = insn.mnemonic
        branch_mnemos = ["cbnz", "cbz", "tbnz", "tbz"]
        return mnemo.startswith("b.") or mnemo in branch_mnemos

    def is_branch_taken(self, insn):
        mnemo, operands = insn.mnemonic, insn.operands
        taken, reason = False, ""

        if mnemo in ["cbnz", "cbz", "tbnz", "tbz"]:
            reg = operands[0]
            op = get_register(reg)
            if mnemo == "cbnz":
                if op != 0:
                    taken, reason = True, "{}!=0".format(reg)
                else:
                    taken, reason = False, "{}==0".format(reg)
            elif mnemo == "cbz":
                if op == 0:
                    taken, reason = True, "{}==0".format(reg)
                else:
                    taken, reason = False, "{}!=0".format(reg)
            elif mnemo == "tbnz":
                # operands[1] has one or more white spaces in front, then a #, then the number
                # so we need to eliminate them
                i = int(operands[1].strip().lstrip("#"))
                if (op & (1 << i)) != 0:
                    taken, reason = True, "{}&1<<{}!=0".format(reg, i)
                else:
                    taken, reason = False, "{}&1<<{}==0".format(reg, i)
            elif mnemo == "tbz":
                # operands[1] has one or more white spaces in front, then a #, then the number
                # so we need to eliminate them
                i = int(operands[1].strip().lstrip("#"))
                if (op & (1 << i)) == 0:
                    taken, reason = True, "{}&1<<{}==0".format(reg, i)
                else:
                    taken, reason = False, "{}&1<<{}!=0".format(reg, i)

        if not reason:
            taken, reason = super().is_branch_taken(insn)
        return taken, reason


class X86(Architecture):
    arch = "X86"
    mode = "32"

    nop_insn = b"\x90" # nop
    infloop_insn = b"\xeb\xfe" # jmp 0
    trap_insn = b"\xcc" # int3
    ret_insn = b"\xc3" # ret

    flag_register = "$eflags"
    special_registers = ["$cs", "$ss", "$ds", "$es", "$fs", "$gs"]
    gpr_registers = ["$eax", "$ebx", "$ecx", "$edx", "$esp", "$ebp", "$esi", "$edi", "$eip"]
    all_registers = gpr_registers + [flag_register] + special_registers
    alias_registers = {}
    instruction_length = None
    return_register = "$eax"
    function_parameters = ["$esp"] # but unused because x86 uses stack
    flags_table = {
        21: "identification",
        #20: "virtual_interrupt_pending",
        #19: "virtual_interrupt",
        18: "align",
        17: "virtualx86",
        16: "resume",
        #15: N/A
        14: "nested",
        #12-13: "iopl",
        11: "overflow",
        10: "direction",
        9: "interrupt",
        8: "trap",
        7: "sign",
        6: "zero",
        #5: N/A
        4: "adjust",
        #3: N/A
        2: "parity",
        #1: N/A
        0: "carry",
    }
    syscall_register = "$eax"
    syscall_instructions = ["sysenter", "syscall", "int 0x80"]

    def flag_register_to_human(self, val=None):
        if val is None:
            reg = self.flag_register
            val = get_register(reg) & 0xffffffff
        mode = " [Ring={:d}]".format(get_register("$cs") & 0b11)
        return flags_to_human(val, self.flags_table) + mode

    def is_syscall(self, insn):
        insn_str = insn.mnemonic + " " + ", ".join(insn.operands)
        return insn_str.strip() in self.syscall_instructions

    def is_call(self, insn):
        return insn.mnemonic in ["call", "callq"]

    def is_jump(self, insn):
        return insn.mnemonic == "jmp" or self.is_conditional_branch(insn)

    def is_ret(self, insn):
        return insn.mnemonic in ["ret", "retf", "sysret", "iret"]

    def is_conditional_branch(self, insn):
        branch_mnemos = [
            "ja", "jnbe", "jae", "jnb", "jnc", "jb", "jc", "jnae", "jbe", "jna",
            "jcxz", "jecxz", "jrcxz", "je", "jz", "jg", "jnle", "jge", "jnl",
            "jl", "jnge", "jle", "jng", "jne", "jnz", "jno", "jnp", "jpo", "jns",
            "jo", "jp", "jpe", "js",
        ]
        return insn.mnemonic in branch_mnemos

    def is_branch_taken(self, insn):
        mnemo = insn.mnemonic
        # all kudos to fG! (https://github.com/gdbinit/Gdbinit/blob/master/gdbinit#L1654)
        flags = dict((self.flags_table[k], k) for k in self.flags_table)
        val = get_register(self.flag_register)
        taken, reason = False, ""

        zero = bool(val & (1 << flags["zero"]))
        sign = bool(val & (1 << flags["sign"]))
        overflow = bool(val & (1 << flags["overflow"]))
        carry = bool(val & (1 << flags["carry"]))
        parity = bool(val & (1 << flags["parity"]))

        if mnemo in ["ja", "jnbe"]:
            taken, reason = not carry and not zero, "!C && !Z"
        elif mnemo in ["jae", "jnb", "jnc"]:
            taken, reason = not carry, "!C"
        elif mnemo in ["jb", "jc", "jnae"]:
            taken, reason = carry, "C"
        elif mnemo in ["jbe", "jna"]:
            taken, reason = carry or zero, "C || Z"
        elif mnemo in ["jcxz", "jecxz", "jrcxz"]:
            cx = get_register("$rcx") if self.mode == "64" else get_register("$ecx")
            taken, reason = cx == 0, "!$CX"
        elif mnemo in ["je", "jz"]:
            taken, reason = zero, "Z"
        elif mnemo in ["jne", "jnz"]:
            taken, reason = not zero, "!Z"
        elif mnemo in ["jg", "jnle"]:
            taken, reason = not zero and sign == overflow, "!Z && S==O"
        elif mnemo in ["jge", "jnl"]:
            taken, reason = sign == overflow, "S==O"
        elif mnemo in ["jl", "jnge"]:
            taken, reason = sign != overflow, "S!=O"
        elif mnemo in ["jle", "jng"]:
            taken, reason = zero or sign != overflow, "Z || S!=O"
        elif mnemo in ["jo"]:
            taken, reason = overflow, "O"
        elif mnemo in ["jno"]:
            taken, reason = not overflow, "!O"
        elif mnemo in ["jpe", "jp"]:
            taken, reason = parity, "P"
        elif mnemo in ["jnp", "jpo"]:
            taken, reason = not parity, "!P"
        elif mnemo in ["js"]:
            taken, reason = sign, "S"
        elif mnemo in ["jns"]:
            taken, reason = not sign, "!S"
        return taken, reason

    def get_ra(self, insn, frame):
        ra = None
        try:
            if self.is_ret(insn):
                ra = to_unsigned_long(dereference(current_arch.sp))
            if frame.older():
                ra = frame.older().pc()
        except Exception:
            pass
        return ra

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        _NR_mprotect = 125
        insns = [
            "mov eax, {:d}".format(_NR_mprotect),
            "mov ebx, {:d}".format(addr),
            "mov ecx, {:d}".format(size),
            "mov edx, {:d}".format(perm),
            "int 0x80",
        ]
        return "; ".join(insns)

    def get_ith_parameter(self, i, in_func=True):
        if in_func:
            i += 1 # Account for RA being at the top of the stack
        sp = current_arch.sp
        sz = current_arch.ptrsize
        loc = sp + (i * sz)
        val = read_int_from_memory(loc)
        key = "[sp + {:#x}]".format(i * sz)
        return key, val


class X86_64(X86):
    arch = "X86"
    mode = "64"

    gpr_registers = [
        "$rax", "$rbx", "$rcx", "$rdx", "$rsp", "$rbp", "$rsi", "$rdi", "$rip",
        "$r8", "$r9", "$r10", "$r11", "$r12", "$r13", "$r14", "$r15",
    ]
    all_registers = gpr_registers + [X86.flag_register] + X86.special_registers
    alias_registers = {}
    return_register = "$rax"
    function_parameters = ["$rdi", "$rsi", "$rdx", "$rcx", "$r8", "$r9"]
    syscall_register = "$rax"
    syscall_instructions = ["syscall", "sysenter"]
    # We don't want to inherit x86's stack based param getter
    get_ith_parameter = Architecture.get_ith_parameter

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        _NR_mprotect = 10
        insns = [
            "mov rax, {:d}".format(_NR_mprotect),
            "mov rdi, {:d}".format(addr),
            "mov rsi, {:d}".format(size),
            "mov rdx, {:d}".format(perm),
            "syscall",
        ]
        return "; ".join(insns)


class PowerPC(Architecture):
    arch = "PPC"
    mode = "PPC32"

    all_registers = [
        "$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6", "$r7",
        "$r8", "$r9", "$r10", "$r11", "$r12", "$r13", "$r14", "$r15",
        "$r16", "$r17", "$r18", "$r19", "$r20", "$r21", "$r22", "$r23",
        "$r24", "$r25", "$r26", "$r27", "$r28", "$r29", "$r30", "$r31",
        "$pc", "$msr", "$cr", "$lr", "$ctr", "$xer", "$fpscr",
    ]
    alias_registers = {"$r1": "$sp"}
    instruction_length = 4

    nop_insn = b"\x00\x00\x00\x60" # nop # http://www.ibm.com/developerworks/library/l-ppc/index.html
    infloop_insn = b"\x00\x00\x00\x48" # b #0
    trap_insn = b"\x08\x00\xe0\x7f" # trap
    ret_insn = b"\x20\x00\x80\x4e" # blr

    return_register = "$r0"
    flag_register = "$cr"
    flags_table = {
        3: "negative[0]",
        2: "positive[0]",
        1: "equal[0]",
        0: "overflow[0]",
        # cr7
        31: "less[7]",
        30: "greater[7]",
        29: "equal[7]",
        28: "overflow[7]",
    }
    function_parameters = ["$r0", "$r1", "$r2", "$r3", "$r4", "$r5"]
    syscall_register = "$r0"
    syscall_instructions = ["sc"]

    def flag_register_to_human(self, val=None):
        # http://www.cebix.net/downloads/bebox/pem32b.pdf (% 2.1.3)
        if not val:
            reg = self.flag_register
            val = get_register(reg)
        return flags_to_human(val, self.flags_table)

    def is_syscall(self, insn):
        return insn.mnemonic == "sc"

    def is_call(self, insn):
        condition = ["", "lt", "le", "eq", "ge", "gt", "nl", "ne", "ng", "so", "ns", "un", "nu"]
        for c in condition:
            if insn.mnemonic == "b" + c + "l":
                return True
            if insn.mnemonic == "b" + c + "la":
                return True
            if insn.mnemonic == "b" + c + "ctrl":
                return True
            if insn.mnemonic == "b" + c + "lrl":
                return True
        mode = ["dz", "dnzf", "dzt", "dzf", "dnzt", "dnz"]
        for m in mode:
            if insn.mnemonic == "b" + m + "l":
                return True
            if insn.mnemonic == "b" + m + "la":
                return True
            if insn.mnemonic == "b" + m + "lrl":
                return True
        return False

    def is_jump(self, insn):
        condition = ["", "lt", "le", "eq", "ge", "gt", "nl", "ne", "ng", "so", "ns", "un", "nu"]
        for c in condition:
            if insn.mnemonic == "b" + c:
                return True
            if insn.mnemonic == "b" + c + "a":
                return True
            if insn.mnemonic == "b" + c + "ctr":
                return True
        mode = ["dz", "dnzf", "dzt", "dzf", "dnzt", "dnz"]
        for m in mode:
            if insn.mnemonic == "b" + m:
                return True
            if insn.mnemonic == "b" + m + "a":
                return True
        return False

    def is_ret(self, insn):
        condition = ["", "lt", "le", "eq", "ge", "gt", "nl", "ne", "ng", "so", "ns", "un", "nu"]
        for c in condition:
            if insn.mnemonic == "b" + c + "lr":
                return True
            if insn.mnemonic == "b" + c + "lrl":
                return True
        mode = ["dz", "dnzf", "dzt", "dzf", "dnzt", "dnz"]
        for m in mode:
            if insn.mnemonic == "b" + m + "lr":
                return True
            if insn.mnemonic == "b" + m + "lrl":
                return True
        return False

    def is_conditional_branch(self, insn):
        branch_mnemos = ["beq", "bne", "ble", "blt", "bgt", "bge", "bdz", "bdnz", "bdzt", "bdnzt", "bdzf", "bdnzf"]
        return insn.mnemonic in branch_mnemos

    def is_branch_taken(self, insn):
        mnemo = insn.mnemonic
        flags = dict((self.flags_table[k], k) for k in self.flags_table)
        val = get_register(self.flag_register)
        taken, reason = False, ""

        equal = bool(val & (1 << flags["equal[7]"]))
        less = bool(val & (1 << flags["less[7]"]))
        greater = bool(val & (1 << flags["greater[7]"]))

        if mnemo == "beq":
            taken, reason = equal, "E"
        elif mnemo == "bne":
            taken, reason = not equal, "!E"
        elif mnemo == "ble":
            taken, reason = equal or less, "E || L"
        elif mnemo == "blt":
            taken, reason = less, "L"
        elif mnemo == "bge":
            taken, reason = equal or greater, "E || G"
        elif mnemo == "bgt":
            taken, reason = greater, "G"
        # todo: bdn?z[tf]? are unsupported
        return taken, reason

    def get_ra(self, insn, frame):
        ra = None
        try:
            if self.is_ret(insn):
                ra = get_register("$lr")
            elif frame.older():
                ra = frame.older().pc()
        except Exception:
            pass
        return ra

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        # Ref: http://www.ibm.com/developerworks/library/l-ppc/index.html
        _NR_mprotect = 125
        insns = [
            "li 3, 0",
            "ori 3, 3, {:d}".format((addr >> 16) & 0xffff),
            "slwi 3, 3, 16",
            "ori 3, 3, {:d}".format((addr >> 0) & 0xffff),
            "li 4, 0",
            "ori 4, 4, {:d}".format((size >> 16) & 0xffff),
            "slwi 4, 4, 16",
            "ori 4, 4, {:d}".format((size >> 0) & 0xffff),
            "li 5, {:d}".format(perm),
            "li 0, {:d}".format(_NR_mprotect),
            "sc",
        ]
        return ";".join(insns)


class PowerPC64(PowerPC):
    arch = "PPC"
    mode = "PPC64"

    all_registers = [
        "$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6", "$r7",
        "$r8", "$r9", "$r10", "$r11", "$r12", "$r13", "$r14", "$r15",
        "$r16", "$r17", "$r18", "$r19", "$r20", "$r21", "$r22", "$r23",
        "$r24", "$r25", "$r26", "$r27", "$r28", "$r29", "$r30", "$r31",
        "$pc", "$msr", "$cr", "$lr", "$ctr", "$xer", "$fpscr", "$vscr", "$vrsave",
    ]

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        _NR_mprotect = 125
        insns = [
            "li 3, 0",
            "ori 3, 3, {:d}".format((addr >> 48) & 0xffff),
            "sldi 3, 3, 16",
            "ori 3, 3, {:d}".format((addr >> 32) & 0xffff),
            "sldi 3, 3, 16",
            "ori 3, 3, {:d}".format((addr >> 16) & 0xffff),
            "sldi 3, 3, 16",
            "ori 3, 3, {:d}".format((addr >> 0) & 0xffff),
            "li 4, 0",
            "ori 4, 4, {:d}".format((size >> 48) & 0xffff),
            "sldi 4, 4, 16",
            "ori 4, 4, {:d}".format((size >> 32) & 0xffff),
            "sldi 4, 4, 16",
            "ori 4, 4, {:d}".format((size >> 16) & 0xffff),
            "sldi 4, 4, 16",
            "ori 4, 4, {:d}".format((size >> 48) & 0xffff),
            "li 5, {:d}".format(perm),
            "li 0, {:d}".format(_NR_mprotect),
            "sc",
        ]
        return ";".join(insns)


class SPARC(Architecture):
    """ Refs:
    - http://www.cse.scu.edu/~atkinson/teaching/sp05/259/sparc.pdf"""
    arch = "SPARC"
    mode = "SPARC32"

    all_registers = [
        "$g0", "$g1", "$g2", "$g3", "$g4", "$g5", "$g6", "$g7",
        "$o0", "$o1", "$o2", "$o3", "$o4", "$o5", "$sp", "$o7",
        "$l0", "$l1", "$l2", "$l3", "$l4", "$l5", "$l6", "$l7",
        "$i0", "$i1", "$i2", "$i3", "$i4", "$i5", "$fp", "$i7",
        "$y", "$psr", "$wim", "$tbr", "$pc", "$npc", "$fsr", "$csr",
    ]
    alias_registers = {
        "$sp": "$o6", "$fp": "$i6",
    }
    instruction_length = 4

    nop_insn = b"\x00\x00\x00\x01" # nop
    infloop_insn = b"\x00\x00\x80\x10" + nop_insn # b #0 (+ delay slot)
    ret_insn = b"\x08\xe0\xc7\x81" + nop_insn # ret (+ delay slot)

    return_register = "$i0"
    flag_register = "$psr"
    flags_table = {
        23: "negative",
        22: "zero",
        21: "overflow",
        20: "carry",
        7: "supervisor",
        5: "trap",
    }
    function_parameters = ["$o0", "$o1", "$o2", "$o3", "$o4", "$o5", "$o7"]
    syscall_register = "$g1"
    syscall_instructions = ["ta 0x10"]

    def flag_register_to_human(self, val=None):
        # http://www.gaisler.com/doc/sparcv8.pdf
        reg = self.flag_register
        if not val:
            val = get_register(reg)
        return flags_to_human(val, self.flags_table)

    def is_syscall(self, insn):
        return insn.mnemonic == "ta"

    def is_call(self, insn):
        return insn.mnemonic in ["jmpl", "call"]

    def is_jump(self, insn):
        mnemo = insn.mnemonic
        return mnemo.startswith("b") or mnemo.startswith("fb") or mnemo == "jmpl"

    def is_ret(self, insn):
        return insn.mnemonic in ["ret", "retl"]

    def is_conditional_branch(self, insn):
        branch_mnemos = [
            # http://moss.csc.ncsu.edu/~mueller/codeopt/codeopt00/notes/condbranch.html
            "be", "bne", "bg", "bge", "bgeu", "bgu", "bl", "ble", "blu", "bleu",
            "bneg", "bpos", "bvs", "bvc", "bcs", "bcc"
            # https://www.gaisler.com/doc/sparcv8.pdf
            "fbu", "fbg", "fbug", "fbl", "fbul", "fblg", "fbne", "fbe", "fbue", "fbge",
            "fbuge", "fble", "fbule", "fbo",
            # https://docs.oracle.com/cd/E18752_01/html/816-1681/sparcv9-30990.html
            "bpne", "bpe", "bpg", "bple", "bpge", "bpl", "bpgu", "bpleu", "bpcc", "bpcs",
            "bppos", "bpneg", "bpvc", "bpvs", "brz", "brlez", "brlz", "brnz", "brgz", "brgez",
            "fbpu", "fbpg", "fbpug", "fbpl", "fbpul", "fbplg", "fbpne", "fbpe", "fbpue", "fbpge",
            "fbpuge", "fbple", "fbpule", "fbpo",
        ]
        return insn.mnemonic in branch_mnemos

    def is_branch_taken(self, insn):
        mnemo = insn.mnemonic
        flags = dict((self.flags_table[k], k) for k in self.flags_table)
        val = get_register(self.flag_register)
        taken, reason = False, ""

        zero = bool(val & (1 << flags["zero"]))
        negative = bool(val & (1 << flags["negative"]))
        overflow = bool(val & (1 << flags["overflow"]))
        carry = bool(val & (1 << flags["carry"]))

        if mnemo in ["be", "bpe"]:
            taken, reason = zero, "Z"
        elif mnemo in ["bne", "bpne"]:
            taken, reason = not zero, "!Z"
        elif mnemo in ["bg", "bpg"]:
            taken, reason = not zero and (not negative or not overflow), "!Z && (!N || !O)"
        elif mnemo in ["bge", "bpge"]:
            taken, reason = not negative or not overflow, "!N || !O"
        elif mnemo in ["bgu", "bpgu"]:
            taken, reason = not carry and not zero, "!C && !Z"
        elif mnemo in ["bgeu"]:
            taken, reason = not carry, "!C"
        elif mnemo in ["bl", "bpl"]:
            taken, reason = negative and overflow, "N && O"
        elif mnemo in ["blu"]:
            taken, reason = carry, "C"
        elif mnemo in ["ble", "bple"]:
            taken, reason = zero or (negative or overflow), "Z || (N || O)"
        elif mnemo in ["bleu", "bpleu"]:
            taken, reason = carry or zero, "C || Z"
        elif mnemo in ["bneg", "bpneg"]:
            taken, reason = negative, "N"
        elif mnemo in ["bpos", "bppos"]:
            taken, reason = not negative, "!N"
        elif mnemo in ["bvs", "bpvs"]:
            taken, reason = overflow, "O"
        elif mnemo in ["bvc", "bpvc"]:
            taken, reason = not overflow, "!O"
        elif mnemo in ["bcs", "bpcs"]:
            taken, reason = carry, "C"
        elif mnemo in ["bcc", "bpcc"]:
            taken, reason = not carry, "!C"
        # todo: f* opcode, brn?z/br[lg]e?z are unsupported
        return taken, reason

    def get_ra(self, insn, frame):
        ra = None
        try:
            if self.is_ret(insn):
                ra = get_register("$o7")
            elif frame.older():
                ra = frame.older().pc()
        except Exception:
            pass
        return ra

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        _NR_mprotect = 74
        insns = [
            "sethi %hi({}), %o0".format(addr & 0xfffffc00),
            "or %o0, {}, %o0".format(addr & 0x000003ff),
            "sethi %hi({}), %o1".format(size & 0xfffffc00),
            "or %o1, {}, %o1".format(size & 0x000003ff),
            "mov {}, %o2".format(perm),
            "mov {}, %g1".format(_NR_mprotect),
            "t 0x10",
            "nop", # keystone does not give nop for delay slot, needs this nop
        ]
        return "; ".join(insns)


class SPARC64(SPARC):
    """Refs:
    - http://math-atlas.sourceforge.net/devel/assembly/abi_sysV_sparc.pdf
    - https://cr.yp.to/2005-590/sparcv9.pdf"""
    arch = "SPARC"
    mode = "SPARC64"

    all_registers = [
        "$g0", "$g1", "$g2", "$g3", "$g4", "$g5", "$g6", "$g7",
        "$o0", "$o1", "$o2", "$o3", "$o4", "$o5", "$sp", "$o7",
        "$l0", "$l1", "$l2", "$l3", "$l4", "$l5", "$l6", "$l7",
        "$i0", "$i1", "$i2", "$i3", "$i4", "$i5", "$fp", "$i7",
        "$pc", "$npc", "$state", "$fsr", "$fprs", "$y", "$cwp",
        "$pstate", "$asi", "$ccr",
    ]
    alias_registers = {
        "$sp": "$o6", "$fp": "$i6",
    }
    flag_register = "$state" # sparcv9.pdf, 5.1.5.1 (ccr)
    flags_table = {
        35: "negative",
        34: "zero",
        33: "overflow",
        32: "carry",
    }

    nop_insn = b"\x00\x00\x00\x01" # nop
    infloop_insn = b"\x00\x00\x80\x10" + nop_insn # b #0 (+ delay slot)
    ret_insn = b"\x08\xe0\xc7\x81" + nop_insn # ret (+ delay slot)

    syscall_instructions = ["ta 0x6d"]

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        _NR_mprotect = 74
        insns = [
            "sethi %hi({}), %o0".format(addr & 0xfffffc00),
            "or %o0, {}, %o0".format(addr & 0x000003ff),
            "sethi %hi({}), %o1".format((addr >> 32) & 0xfffffc00),
            "or %o1, {}, %o1".format((addr >> 32) & 0x000003ff),
            "sllx %o1, 32, %o1",
            "or %o0, %o1, %o0",
            "sethi %hi({}), %o1".format(size & 0xfffffc00),
            "or %o1, {}, %o1".format(size & 0x000003ff),
            "sethi %hi({}), %o2".format((size >> 32) & 0xfffffc00),
            "or %o2, {}, %o2".format((size >> 32) & 0x000003ff),
            "sllx %o2, 32, %o2",
            "or %o1, %o2, %o1",
            "mov {}, %o2".format(perm),
            "mov {}, %g1".format(_NR_mprotect),
            "t 0x6d",
            "nop", # keystone does not give nop for delay slot, needs this nop
        ]
        return "; ".join(insns)


class MIPS(Architecture):
    arch = "MIPS"
    mode = "MIPS32"

    # http://vhouten.home.xs4all.nl/mipsel/r3000-isa.html
    all_registers = [
        "$zero", "$at", "$v0", "$v1", "$a0", "$a1", "$a2", "$a3",
        "$t0", "$t1", "$t2", "$t3", "$t4", "$t5", "$t6", "$t7",
        "$s0", "$s1", "$s2", "$s3", "$s4", "$s5", "$s6", "$s7",
        "$t8", "$t9", "$k0", "$k1", "$gp", "$sp", "$fp", "$ra",
        "$sr", "$lo", "$hi", "$bad", "$cause", "$fsr", "$fir", "$pc",
    ]
    alias_registers = {
        "$zero": "$r0", "$at": "$r1", "$v0": "$r2", "$v1": "$r3", "$a0": "$r4", "$a1": "$r5", "$a2": "$r6", "$a3": "$r7",
        "$t0": "$r8", "$t1": "$r9", "$t2": "$r10", "$t3": "$r11", "$t4": "$r12", "$t5": "$r13", "$t6": "$r14", "$t7": "$r15",
        "$s0": "$r16", "$s1": "$r17", "$s2": "$r18", "$s3": "$r19", "$s4": "$r20", "$s5": "$r21", "$s6": "$r22", "$s7": "$r23",
        "$t8": "$r24", "$t9": "$r25", "$k0": "$r26", "$k1": "$r27", "$gp": "$r28", "$sp": "$r29", "$fp": "$s8/$r30", "$ra": "$r31",
    }
    instruction_length = 4

    nop_insn = b"\x00\x00\x00\x00" # nop
    infloop_insn = b"\xff\xff\x00\x10" + nop_insn # b 0 (+ delay slot)
    trap_insn = b"\x0d\x00\x00\x00" + nop_insn # break (+ delay slot)
    ret_insn = b"\x08\x00\xe0\x03" + nop_insn # jr $ra (+ delay slot)

    return_register = "$v0"
    flag_register = "$fcsr"
    flags_table = {}
    function_parameters = ["$a0", "$a1", "$a2", "$a3"]
    syscall_register = "$v0"
    syscall_instructions = ["syscall"]

    def flag_register_to_human(self, val=None):
        return Color.colorify("No flag register", "yellow underline")

    def is_syscall(self, insn):
        return insn.mnemonic == "syscall"

    def is_call(self, insn):
        return insn.mnemonic in ["bal", "balc", "jal", "jalr", "jalrc", "jalrc.hb", "bgezal", "bgezall", "bltzal", "bltzall"]

    def is_jump(self, insn):
        if self.is_ret(insn):
            return False
        if insn.mnemonic in ["b", "bc", "j", "jr", "jrc", "balrsc", "brsc"]:
            return True
        if self.is_conditional_branch(insn):
            return True
        return False

    def is_ret(self, insn):
        if insn.mnemonic in ["jr", "jrc"] and insn.operands[0] == "ra":
            return True
        if insn.mnemonic in ["deret", "eret", "eretnc"]:
            return True
        if insn.mnemonic in ["restore", "restore.jrc"]:
            return True
        return False

    def is_conditional_branch(self, insn):
        branch_mnemos = [
            "beq", "bne", "bgtz", "bgez", "bltz", "blez", "beqz", "bnez",
            "beql", "bnel", "bgtzl", "bgezl", "bltzl", "blezl",
            "bgezal", "bgezall", "bltzal", "bltzall",
            "bc1f", "bc1fl", "bc1t", "bc1tl", "bc2f", "bc2fl", "bc2t", "bc2tl",
            "beqc", "beqic", "beqzc",
            "bnec", "bneic", "bnezc",
            "bgec", "bgeic", "bgeiuc", "bgeuc",
            "bltc", "bltic", "bltiuc", "bltuc",
            "bbeqzc", "bbnezc",
        ]
        return insn.mnemonic in branch_mnemos

    def is_branch_taken(self, insn):
        mnemo, ops = insn.mnemonic, insn.operands
        taken, reason = False, ""

        p = lambda a: struct.pack("<I", a & 0xffffffff)
        ui = lambda a: struct.unpack("<i", a)[0]
        u2i = lambda a: ui(p(a))

        if mnemo in ["beq", "beql", "beqc"]:
            taken, reason = get_register(ops[0]) == get_register(ops[1]), "{0[0]} == {0[1]}".format(ops)
        elif mnemo in ["beqic"]:
            taken, reason = get_register(ops[0]) == int(ops[1], 0), "{0[0]} == {0[1]}".format(ops)
        elif mnemo in ["bne", "bnel", "bnec"]:
            taken, reason = get_register(ops[0]) != get_register(ops[1]), "{0[0]} != {0[1]}".format(ops)
        elif mnemo in ["bneic"]:
            taken, reason = get_register(ops[0]) != int(ops[1], 0), "{0[0]} != {0[1]}".format(ops)
        elif mnemo in ["beqz", "beqzc"]:
            taken, reason = get_register(ops[0]) == 0, "{0[0]} == 0".format(ops)
        elif mnemo in ["bnez", "bnezc"]:
            taken, reason = get_register(ops[0]) != 0, "{0[0]} != 0".format(ops)
        elif mnemo in ["bgtz", "bgtzl"]:
            taken, reason = get_register(ops[0]) > 0, "{0[0]} > 0".format(ops)
        elif mnemo in ["bgez", "bgezl"]:
            taken, reason = get_register(ops[0]) >= 0, "{0[0]} >= 0".format(ops)
        elif mnemo in ["bltz", "bltzl"]:
            taken, reason = get_register(ops[0]) < 0, "{0[0]} < 0".format(ops)
        elif mnemo in ["blez", "blezl"]:
            taken, reason = get_register(ops[0]) <= 0, "{0[0]} <= 0".format(ops)
        elif mnemo in ["bbeqzc"]:
            taken, reason = (get_register(ops[0]) >> int(ops[1], 0) & 1) == 0, "(({0[0]} >> {0[1]}) & 1) == 0".format(ops)
        elif mnemo in ["bbnezc"]:
            taken, reason = (get_register(ops[0]) >> int(ops[1], 0) & 1) == 0, "(({0[0]} >> {0[1]}) & 1) != 0".format(ops)
        elif mnemo in ["bgec"]:
            taken, reason = get_register(ops[0]) >= u2i(get_register(ops[1])), "{0[0]} >= {0[1]}".format(ops)
        elif mnemo in ["bgeic"]:
            taken, reason = get_register(ops[0]) >= u2i(int(ops[1], 0)), "{0[0]} >= {0[1]}".format(ops)
        elif mnemo in ["bgeuc"]:
            taken, reason = get_register(ops[0]) >= get_register(ops[1]), "{0[0]} >= {0[1]}".format(ops)
        elif mnemo in ["bgeiuc"]:
            taken, reason = get_register(ops[0]) >= int(ops[1], 0), "{0[0]} >= {0[1]}".format(ops)
        elif mnemo in ["bltc"]:
            taken, reason = get_register(ops[0]) < u2i(get_register(ops[1])), "{0[0]} < {0[1]}".format(ops)
        elif mnemo in ["bltic"]:
            taken, reason = get_register(ops[0]) < u2i(int(ops[1], 0)), "{0[0]} < {0[1]}".format(ops)
        elif mnemo in ["bltuc"]:
            taken, reason = get_register(ops[0]) < get_register(ops[1]), "{0[0]} < {0[1]}".format(ops)
        elif mnemo in ["bltiuc"]:
            taken, reason = get_register(ops[0]) < int(ops[1], 0), "{0[0]} < {0[1]}".format(ops)
        return taken, reason

    def get_ra(self, insn, frame):
        ra = None
        try:
            if self.is_ret(insn):
                ra = get_register("$ra")
            elif frame.older():
                ra = frame.older().pc()
        except Exception:
            pass
        return ra

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        _NR_mprotect = 4125
        insns = [
            "li $v0, {:d}".format(_NR_mprotect),
            "li $a0, {:d}".format(addr),
            "li $a1, {:d}".format(size),
            "li $a2, {:d}".format(perm),
            "syscall", # keystone gives nop for delay slot, need not nop
        ]
        return "; ".join(insns)


class MIPS64(MIPS):
    arch = "MIPS"
    mode = "MIPS64"

    all_registers = [
        "$zero", "$at", "$v0", "$v1", "$a0", "$a1", "$a2", "$a3",
        "$a4", "$a5", "$a6", "$a7", "$t0", "$t1", "$t2", "$t3",
        "$s0", "$s1", "$s2", "$s3", "$s4", "$s5", "$s6", "$s7",
        "$t8", "$t9", "$k0", "$k1", "$gp", "$sp", "$fp", "$ra",
        "$sr", "$lo", "$hi", "$bad", "$cause", "$fsr", "$fir", "$pc",
    ]
    alias_registers = {
        "$zero": "$r0", "$at": "$r1", "$v0": "$r2", "$v1": "$r3", "$a0": "$r4", "$a1": "$r5", "$a2": "$r6", "$a3": "$r7",
        "$a4": "$r8", "$a5": "$r9", "$a6": "$r10", "$a7": "$r11", "$t0": "$r12", "$t1": "$r13", "$t2": "$r14", "$t3": "$r15",
        "$s0": "$r16", "$s1": "$r17", "$s2": "$r18", "$s3": "$r19", "$s4": "$r20", "$s5": "$r21", "$s6": "$r22", "$s7": "$r23",
        "$t8": "$r24", "$t9": "$r25", "$k0": "$r26", "$k1": "$r27", "$gp": "$r28", "$sp": "$r29", "$fp": "$s8/$r30", "$ra": "$r31",
    }

    @classmethod
    def mprotect_asm(cls, addr, size, perm):
        _NR_mprotect = 5010
        insns = [
            "ori $a0, $zero, {:#x}".format((addr >> 48) & 0xffff),
            "dsll $a0, $a0, 16",
            "ori $a0, $a0, {:#x}".format((addr >> 32) & 0xffff),
            "dsll $a0, $a0, 16",
            "ori $a0, $a0, {:#x}".format((addr >> 16) & 0xffff),
            "dsll $a0, $a0, 16",
            "ori $a0, $a0, {:#x}".format((addr >> 0) & 0xffff),
            "ori $a1, $zero, {:#x}".format((size >> 48) & 0xffff),
            "dsll $a1, $a1, 16",
            "ori $a1, $a1, {:#x}".format((size >> 32) & 0xffff),
            "dsll $a1, $a1, 16",
            "ori $a1, $a1, {:#x}".format((size >> 16) & 0xffff),
            "dsll $a1, $a1, 16",
            "ori $a1, $a1, {:#x}".format((size >> 0) & 0xffff),
            "li $a2, {:d}".format(perm),
            "li $v0, {:d}".format(_NR_mprotect),
            "syscall", # keystone gives nop for delay slot, need not nop
        ]
        return "; ".join(insns)


def write_memory(address, buffer, length=0x10):
    """Write `buffer` at address `address`."""
    try:
        gdb.selected_inferior().write_memory(address, buffer, length)
        ret = length
        return ret
    except gdb.MemoryError:
        pass

    pid = get_pid()
    if is_qemu_usermode() and pid:
        # Under qemu-user you may not be able to patch code areas, so we patch via /proc/pid/mem
        info("Detected memory write error, attempt patch via /proc/pid/mem (offset +0x0)")

        def write_memory_by_pid(pid, address, buffer, length):
            with open("/proc/{:d}/mem".format(pid), "wb") as fd:
                try:
                    fd.seek(address)
                    ret = fd.write(buffer[:length])
                    fd.flush()
                    gdb.execute("maintenance flush dcache", to_string=True)
                    return ret
                except Exception:
                    return None

        def write_with_check(pid, address, buffer, length, offset=0):
            before = read_memory(address, length)
            ret = write_memory_by_pid(pid, address + offset, buffer, length)
            after = read_memory(address, length)

            if ret:
                if after == buffer[:length]:
                    return ret
                else:
                    # fail, revert
                    write_memory_by_pid(pid, address + offset, before, length)
                    return None
            return None

        ret = write_with_check(pid, address, buffer, length)
        if ret:
            return ret

        # some qemu-user maps the memory at +0x10000
        info("Detected memory write error, attempt patch via /proc/pid/mem (offset +0x10000)")
        ret = write_with_check(pid, address, buffer, length, offset=0x10000)
        if ret:
            return ret
        else:
            raise Exception("Unsupported before qemu 5.1")

    raise Exception("Write memory error")


def read_memory(addr, length=0x10):
    """Return a `length` long byte array with the copy of the process memory at `addr`."""
    return gdb.selected_inferior().read_memory(addr, length).tobytes()


def read_int_from_memory(addr):
    """Return an integer read from memory."""
    sz = current_arch.ptrsize
    mem = read_memory(addr, sz)
    unpack = u32 if sz == 4 else u64
    return unpack(mem)


def read_cstring_from_memory(address, max_length=GEF_MAX_STRING_LENGTH):
    """Return a C-string read from memory."""
    # original GEF uses gdb.Value().cast("char"), but this is too slow if string is too large.
    # for example 0xcccccccccccccccc....(too long), this is in kernel or firmware commonly.
    # to avoid this, gdb.Value().cast() is removed.

    # first, read to page boundary
    length = gef_getpagesize() - (address % gef_getpagesize())
    try:
        res = read_memory(address, length)
    except gdb.MemoryError:
        return None

    # if too short, more read
    while len(res) < max_length:
        if b"\x00" in res:
            break
        try:
            read_length = min(max_length - len(res), gef_getpagesize())
            res += read_memory(address + len(res), read_length)
        except gdb.MemoryError:
            break

    # treat as utf-8
    res = res.split(b"\x00")[0]
    ustr = res.decode("utf-8")
    if len(ustr) > max_length:
        ustr = "{}[...]".format(ustr[:max_length])
    return ustr


def read_ascii_string(address):
    """Read an ASCII string from memory"""
    cstr = read_cstring_from_memory(address)
    if isinstance(cstr, str) and cstr and all([x in string.printable for x in cstr]):
        return cstr
    return None


def read_physmem_secure(paddr, size):
    sm_base, sm_size = XSecureMemAddrCommand.get_secure_memory_base_and_size()
    if sm_base is None or sm_size is None:
        return None
    if not (sm_base <= paddr < sm_base + sm_size):
        return None
    sm = XSecureMemAddrCommand.get_secure_memory_qemu_map(sm_base, sm_size)
    if sm is None:
        return None
    out = XSecureMemAddrCommand.read_secure_memory(sm, paddr - sm_base, size)
    return out


def read_physmem(paddr, size):
    def fast_path(paddr, size):
        out = read_memory(paddr, size)
        return out

    def slow_path(paddr, size): # < qemu 4.1.0-rc0
        res = gdb.execute("monitor xp/{:d}xb {:#x}".format(size, paddr), to_string=True)
        out = b""
        for line in res.splitlines():
            data = line.split()[1:]
            out += bytes([int(x, 16) for x in data])
        return out

    if is_arm32() or is_arm64():
        out = read_physmem_secure(paddr, size)
        if out:
            return out

    if not is_supported_physmode():
        return slow_path(paddr, size)

    try:
        orig_mode = get_current_mmu_mode()
        if orig_mode == "virt":
            enable_phys()
        out = fast_path(paddr, size)
        if orig_mode == "virt":
            disable_phys()
    except gdb.MemoryError:
        if orig_mode == "virt":
            disable_phys()
        # fall through to slow path
        out = slow_path(paddr, size)
    return out


def write_physmem_secure(paddr, buffer):
    sm_base, sm_size = XSecureMemAddrCommand.get_secure_memory_base_and_size()
    if sm_base is None or sm_size is None:
        return None
    if not (sm_base <= paddr < sm_base + sm_size):
        return None
    sm = XSecureMemAddrCommand.get_secure_memory_qemu_map(sm_base, sm_size)
    if sm is None:
        return None
    out = WSecureMemAddrCommand.write_secure_memory(sm, paddr - sm_base, buffer)
    return out


def write_physmem(paddr, buffer):
    if is_arm32() or is_arm64():
        ret = write_physmem_secure(paddr, buffer)
        if ret:
            return ret

    if not is_supported_physmode():
        return None

    try:
        orig_mode = get_current_mmu_mode()
        if orig_mode == "virt":
            enable_phys()
        ret = write_memory(paddr, buffer, len(buffer))
        if orig_mode == "virt":
            disable_phys()
    except Exception:
        if orig_mode == "virt":
            disable_phys()
    return ret


def get_current_mmu_mode():
    try:
        response = gdb.execute('maintenance packet qqemu.PhyMemMode', to_string=True, from_tty=False)
        if 'received: "0"' in response:
            return "virt"
        elif 'received: "1"' in response:
            return "phys"
        else:
            return False
    except Exception:
        return False


def is_supported_physmode():
    return get_current_mmu_mode() in ["virt", "phys"]


def enable_phys():
    response = gdb.execute('maintenance packet Qqemu.PhyMemMode:1', to_string=True, from_tty=False)
    response = gdb.execute('maintenance packet qqemu.PhyMemMode', to_string=True, from_tty=False)
    return 'received: "1"' in response


def disable_phys():
    response = gdb.execute('maintenance packet Qqemu.PhyMemMode:0', to_string=True, from_tty=False)
    response = gdb.execute('maintenance packet qqemu.PhyMemMode', to_string=True, from_tty=False)
    return 'received: "0"' in response


@functools.lru_cache()
def p8(x: int, s: bool = False) -> bytes:
    """Pack one byte respecting the current architecture endianness."""
    return struct.pack("{}B".format(endian_str()), x) if not s else struct.pack("{}b".format(endian_str()), x)


@functools.lru_cache()
def p16(x: int, s: bool = False) -> bytes:
    """Pack one word respecting the current architecture endianness."""
    return struct.pack("{}H".format(endian_str()), x) if not s else struct.pack("{}h".format(endian_str()), x)


@functools.lru_cache()
def p32(x: int, s: bool = False) -> bytes:
    """Pack one dword respecting the current architecture endianness."""
    return struct.pack("{}I".format(endian_str()), x) if not s else struct.pack("{}i".format(endian_str()), x)


@functools.lru_cache()
def p64(x: int, s: bool = False) -> bytes:
    """Pack one qword respecting the current architecture endianness."""
    return struct.pack("{}Q".format(endian_str()), x) if not s else struct.pack("{}q".format(endian_str()), x)


@functools.lru_cache()
def u8(x: bytes, s: bool = False) -> int:
    """Unpack one byte respecting the current architecture endianness."""
    return struct.unpack("{}B".format(endian_str()), x)[0] if not s else struct.unpack("{}b".format(endian_str()), x)[0]


@functools.lru_cache()
def u16(x: bytes, s: bool = False) -> int:
    """Unpack one word respecting the current architecture endianness."""
    return struct.unpack("{}H".format(endian_str()), x)[0] if not s else struct.unpack("{}h".format(endian_str()), x)[0]


@functools.lru_cache()
def u32(x: bytes, s: bool = False) -> int:
    """Unpack one dword respecting the current architecture endianness."""
    return struct.unpack("{}I".format(endian_str()), x)[0] if not s else struct.unpack("{}i".format(endian_str()), x)[0]


@functools.lru_cache()
def u64(x: bytes, s: bool = False) -> int:
    """Unpack one qword respecting the current architecture endianness."""
    return struct.unpack("{}Q".format(endian_str()), x)[0] if not s else struct.unpack("{}q".format(endian_str()), x)[0]


def is_ascii_string(address):
    """Helper function to determine if the buffer pointed by `address` is an ASCII string (in GDB)"""
    try:
        return read_ascii_string(address) is not None
    except Exception:
        return False


def is_alive():
    """Check if GDB is running."""
    try:
        return gdb.selected_inferior().pid > 0
    except Exception:
        return False
    return False


def only_if_gdb_running(f):
    """Decorator wrapper to check if GDB is running."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        if is_alive():
            return f(*args, **kwargs)
        else:
            warn("No debugging session active")
            return

    return wrapper


def only_if_gdb_target_local(f):
    """Decorator wrapper to check if GDB is running locally (target not remote)."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        if not is_remote_debug() or is_remote_but_same_host():
            return f(*args, **kwargs)
        else:
            warn("This command cannot work for remote sessions.")
            return

    return wrapper


def only_if_qemu_system(f):
    """Decorator wrapper to check if GDB is connected to qemu-system."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        if is_qemu_system():
            return f(*args, **kwargs)
        else:
            warn("This command can work under qemu-system only.")
            return

    return wrapper


def only_if_not_qemu_system(f):
    """Decorator wrapper to check if GDB is connected to qemu-system."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        if not is_qemu_system():
            return f(*args, **kwargs)
        else:
            warn("This command cannot work under qemu-system.")
            return

    return wrapper


def experimental_feature(f):
    """Decorator to add a warning when a feature is experimental."""

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        warn("This feature is under development, expect bugs and unstability...")
        return f(*args, **kwargs)

    return wrapper


def only_if_specific_arch(arch=[]):
    """Decorator wrapper to check if the archtecture is specific."""

    def wrapper(f):
        @functools.wraps(f)
        def inner_f(*args, **kwargs):
            for a in arch:
                if a == "x86_32" and is_x86_32():
                    return f(*args, **kwargs)
                elif a == "x86_64" and is_x86_64():
                    return f(*args, **kwargs)
                elif a == "ARM64" and is_arm64():
                    return f(*args, **kwargs)
                elif a == "ARM32" and is_arm32():
                    return f(*args, **kwargs)
                elif a == "MIPS32" and is_mips32():
                    return f(*args, **kwargs)
                elif a == "MIPS64" and is_mips64():
                    return f(*args, **kwargs)
                elif a == "PPC32" and is_ppc32():
                    return f(*args, **kwargs)
                elif a == "PPC64" and is_ppc64():
                    return f(*args, **kwargs)
                elif a == "SPARC32" and is_sparc32():
                    return f(*args, **kwargs)
                elif a == "SPARC64" and is_sparc64():
                    return f(*args, **kwargs)
            else:
                warn("This command cannot work under this architecture.")
                return

        return inner_f

    return wrapper


def exclude_specific_arch(arch=[]):
    """Decorator wrapper to check if the archtecture is specific."""

    def wrapper(f):
        @functools.wraps(f)
        def inner_f(*args, **kwargs):
            for a in arch:
                if a == "x86_32" and is_x86_32():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "x86_64" and is_x86_64():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "ARM64" and is_arm64():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "ARM32" and is_arm32():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "MIPS32" and is_mips32():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "MIPS64" and is_mips64():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "PPC32" and is_ppc32():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "PPC64" and is_ppc64():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "SPARC32" and is_sparc32():
                    warn("This command cannot work under this architecture.")
                    return
                elif a == "SPARC64" and is_sparc64():
                    warn("This command cannot work under this architecture.")
                    return
            else:
                return f(*args, **kwargs)

        return inner_f

    return wrapper


def only_if_gdb_version_higher_than(required_gdb_version):
    """Decorator to check whether current GDB version requirements."""

    def wrapper(f):
        def inner_f(*args, **kwargs):
            if GDB_VERSION >= required_gdb_version:
                return f(*args, **kwargs)
            else:
                reason = "GDB >= {} for this command".format(required_gdb_version)
                raise EnvironmentError(reason)

        return inner_f

    return wrapper


def use_stdtype():
    if is_32bit():
        return "uint32_t"
    elif is_64bit():
        return "uint64_t"
    return "uint16_t"


def use_default_type():
    if is_32bit():
        return "unsigned int"
    elif is_64bit():
        return "unsigned long"
    return "unsigned short"


def use_golang_type():
    if is_32bit():
        return "uint32"
    elif is_64bit():
        return "uint64"
    return "uint16"


def use_rust_type():
    if is_32bit():
        return "u32"
    elif is_64bit():
        return "u64"
    return "u16"


def to_unsigned_long(v):
    """Cast a gdb.Value to unsigned long."""
    if is_32bit():
        mask = (1 << 32) - 1
    else:
        mask = (1 << 64) - 1
    return int(v.cast(gdb.Value(mask).type)) & mask


def get_register(regname):
    """Return a register's value."""
    if regname[0] != '$':
        regname = "$" + regname

    try:
        value = gdb.parse_and_eval(regname)
        if value.type.code == gdb.TYPE_CODE_INT:
            return to_unsigned_long(value)
        else:
            return int(value)
    except gdb.error:
        try:
            value = gdb.selected_frame().read_register(regname)
            return int(value)
        except ValueError:
            return None
        except gdb.error:
            return None


def get_path_from_info_proc():
    try:
        response = gdb.execute("info proc", to_string=True)
    except Exception:
        return None
    for x in response.splitlines():
        if x.startswith("exe = "):
            return x.split(" = ")[1].replace("'", "")
    return None


@functools.lru_cache()
def get_os():
    """Return the current OS."""
    return platform.system().lower()


@functools.lru_cache()
def is_pin():
    if not is_remote_debug():
        return False
    response = gdb.execute('maintenance packet qSupported', to_string=True, from_tty=False)
    return 'intel.name=' in response


@functools.lru_cache()
def is_qemu():
    if not is_remote_debug():
        return False
    response = gdb.execute('maintenance packet Qqemu.sstepbits', to_string=True, from_tty=False)
    return 'ENABLE=' in response


@functools.lru_cache()
def is_qemu_usermode():
    if is_qemu() is False:
        return False
    response = gdb.execute('maintenance packet qOffsets', to_string=True, from_tty=False)
    return 'Text=' in response


@functools.lru_cache()
def is_qemu_system():
    if is_qemu() is False:
        return False
    response = gdb.execute('maintenance packet qOffsets', to_string=True, from_tty=False)
    return 'received: ""' in response


@functools.lru_cache()
def get_pid():
    """Return the PID of the debuggee process."""
    def get_filepath_from_info_files():
        response = gdb.execute('info files', to_string=True)
        for line in response.splitlines():
            if line.startswith("Symbols from"):
                return line.split('"')[1]
        return None

    def get_pid_from_tcp_session(filepath, match_prefix_only=False):
        gdb_tcp_sess = list(c.raddr for c in psutil.Process().connections())
        if not gdb_tcp_sess:
            err("gdb has no tcp session")
            return None
        for process in psutil.process_iter():
            if match_prefix_only is True and not process.name().startswith(filepath):
                continue
            if match_prefix_only is False and process.name() != os.path.basename(filepath):
                continue
            try:
                connections = process.connections()
            except Exception:
                continue
            for c in connections:
                if c.laddr in gdb_tcp_sess:
                    return process.pid
        return None

    if is_pin():
        filepath = get_filepath_from_info_files()
        if filepath is None:
            err("Missing info about architecture. Please set: `file /path/to/target_binary`")
            return None
        return get_pid_from_tcp_session(filepath)

    elif is_qemu_usermode() or is_qemu_system():
        return get_pid_from_tcp_session("qemu", match_prefix_only=True)

    return gdb.selected_inferior().pid


@functools.lru_cache()
def get_filepath(for_vmmap=False):
    """Return the local absolute path of the file currently debugged."""
    filepath = gdb.current_progspace().filename

    def append_proc_root(filepath):
        if filepath is None:
            return None
        prefix = "/proc/{}/root".format(get_pid())
        relative_path = filepath.lstrip("/")
        return os.path.join(prefix, relative_path)

    if is_remote_debug():
        if filepath is None:
            return None
        elif filepath.startswith("target:"):
            return None
        elif filepath.startswith(".gnu_debugdata for target:"):
            return None
        else:
            return filepath
    else:
        # inferior probably did not have name, extract cmdline from info proc
        if filepath is None:
            filepath = get_path_from_info_proc()
            if not for_vmmap:
                # maybe different mnt namespace, so use /proc/<PID>/root
                filepath = append_proc_root(filepath)
        # not remote, but different PID namespace and attaching by pid. it shows with `target:`
        elif filepath.startswith("target:"):
            # /proc/PID/root is not given when used for purposes such as comparing with entry in vmmap
            filepath = filepath[len("target:"):]
            if not for_vmmap:
                # maybe different mnt namespace, so use /proc/<PID>/root
                filepath = append_proc_root(filepath)
        # normal path
        return filepath


@functools.lru_cache()
def get_filename():
    """Return the full filename of the file currently debugged."""
    filename = get_filepath()
    if filename is None:
        return None
    return os.path.basename(filename)


def get_process_maps_linux(pid):
    """Parse the Linux process `/proc/pid/maps` file."""
    proc_map_file = "/proc/{:d}/maps".format(pid)
    maps = []
    for line in open(proc_map_file, "r"):
        line = line.strip()
        addr, perm, off, _, rest = line.split(" ", 4)
        rest = rest.split(" ", 1)
        inode = rest[0]
        if len(rest) == 1:
            pathname = ""
        else:
            pathname = rest[1].lstrip()
        addr_start, addr_end = [int(x, 16) for x in addr.split("-")]
        off = int(off, 16)
        perm = Permission.from_process_maps(perm)
        sect = Section(page_start=addr_start, page_end=addr_end, offset=off, permission=perm, inode=inode, path=pathname)
        maps.append(sect)
    return maps


# get_explored_regions (used at qemu-user mode) is too slow,
# Because it repeats read_memory many times to find the upper and lower bounds of the page.
# functools.lru_cache() is not effective because it is cleared every time you stepi.
# Fortunately, memory maps rarely change.
# I decided to make it a cache mechanism independent of functools.lru_cache and introduce a mechanism to forcibly clear it with vmmap.
explored_regions = None


def clear_explored_regions():
    global explored_regions
    explored_regions = None
    reset_all_caches()
    return


def get_explored_regions():
    """Return sections from auxv exploring"""

    # return if it is cached
    global explored_regions
    if explored_regions:
        return explored_regions

    regions = []

    @functools.lru_cache()
    def is_exist_page(addr):
        try:
            read_memory(addr, 1)
            return True
        except gdb.MemoryError:
            return False

    @functools.lru_cache()
    def get_region_start_end(addr):
        addr &= gef_getpagesize_mask()
        if not is_exist_page(addr):
            return None, None
        region_start = addr
        region_end = addr + gef_getpagesize()

        end_addrs = [r.page_end for r in regions]
        start_addrs = [r.page_start for r in regions]

        # up search
        while True:
            if region_start - gef_getpagesize() < 0:
                break
            if not is_exist_page(region_start - gef_getpagesize()):
                break
            if region_start in end_addrs:
                break
            region_start -= gef_getpagesize()

        bound = (1 << 32) if is_32bit() else (1 << 64)
        # down search
        while True:
            if region_end > bound:
                break
            if not is_exist_page(region_end):
                break
            if region_end in start_addrs:
                break
            region_end += gef_getpagesize()
        return region_start, region_end

    def make_regions(addr, label, perm="rwx"):
        # check if already in region
        for rg in regions:
            if rg.page_start <= addr < rg.page_end:
                return []
        # make region
        start, end = get_region_start_end(addr)
        if start is None:
            return []
        perm = Permission.from_process_maps(perm)
        sect = Section(page_start=start, page_end=end, offset=0, permission=perm, inode=None, path=label)
        return [sect]

    @functools.lru_cache()
    def get_ehdr(addr):
        bound = (1 << 32) if is_32bit() else (1 << 64)
        for i in range(128):
            if addr < 0 or addr > bound:
                return None
            try:
                if read_memory(addr, 4) == b'\x7FELF':
                    return Elf(addr)
            except gdb.MemoryError:
                return None
            addr -= gef_getpagesize()
        return None

    def parse_region_from_ehdr(addr, label):
        elf = get_ehdr(addr & gef_getpagesize_mask())
        if elf is None:
            return []

        pages = []
        for phdr in elf.phdrs:
            if not phdr.p_memsz:
                continue

            vaddr = phdr.p_vaddr
            if elf.e_type == Elf.ET_DYN: # PIE
                vaddr += elf.addr
            vaddr_end = vaddr + phdr.p_memsz

            offset = phdr.p_offset
            flags = phdr.p_flags

            # align
            vaddr &= gef_getpagesize_mask()
            offset &= gef_getpagesize_mask()
            vaddr_end = (vaddr_end + (gef_getpagesize() - 1)) & gef_getpagesize_mask()

            # add per pages
            for page_addr in range(vaddr, vaddr_end, gef_getpagesize()):
                # check already exist
                for i, page in enumerate(pages):
                    if page['vaddr'] == page_addr:
                        # found, so fix flags
                        if page['flags'] & 1: # already has PF_X
                            flags |= 1
                        pages[i]['flags'] = flags # overwrite, because RELRO
                        break
                else:
                    # not found, so add new page
                    page = {'vaddr': page_addr, 'memsize': gef_getpagesize(), 'flags': flags, 'offset': offset + (page_addr - vaddr)}
                    pages.append(page)

        pages = sorted(pages, key=lambda x: x['vaddr'])

        # merge contiguous
        prev = pages[0]
        for page in pages[1:]:
            prev_vend = prev['vaddr'] + prev['memsize']
            if prev['flags'] == page['flags'] and prev_vend == page['vaddr']:
                prev['memsize'] += page['memsize']
                pages.remove(page)
            else:
                prev = page

        # page -> section
        sects = []
        for page in pages:
            perm = ""
            perm += "r" if page['flags'] & 4 else "-"
            perm += "w" if page['flags'] & 2 else "-"
            perm += "x" if page['flags'] & 1 else "-"
            perm = Permission.from_process_maps(perm)
            page_start = page['vaddr']
            page_end = page['vaddr'] + page['memsize']
            off = page['offset']
            sect = Section(page_start=page_start, page_end=page_end, offset=off, permission=perm, inode=None, path=label)
            sects.append(sect)
        return sects

    # auxv parse
    auxv = gef_get_auxiliary_values()
    if auxv:
        if "AT_PHDR" in auxv:
            regions += parse_region_from_ehdr(auxv["AT_PHDR"], "[code]")
        elif "AT_ENTRY" in auxv:
            regions += parse_region_from_ehdr(auxv["AT_ENTRY"], "[code]")
        if "AT_BASE" in auxv:
            regions += parse_region_from_ehdr(auxv["AT_BASE"], "[linker]")
        if "AT_SYSINFO_EHDR" in auxv:
            regions += parse_region_from_ehdr(auxv["AT_SYSINFO_EHDR"], "[vdso]")
        elif "AT_SYSINFO" in auxv:
            regions += parse_region_from_ehdr(auxv["AT_SYSINFO"], "[vdso]")

    # stack registers
    stack_permission = "rw-"
    if auxv and "AT_PHDR" in auxv:
        elf = get_ehdr(auxv["AT_PHDR"] & gef_getpagesize_mask())
        for phdr in elf.phdrs:
            if phdr.p_type != Phdr.PT_GNU_STACK:
                continue
            pflags = {
                0                                 : "---",
                Phdr.PF_X                         : "--x",
                Phdr.PF_W                         : "-w-",
                Phdr.PF_R                         : "r--",
                Phdr.PF_W | Phdr.PF_X             : "-wx",
                Phdr.PF_R | Phdr.PF_X             : "r-x",
                Phdr.PF_R | Phdr.PF_W             : "rw-",
                Phdr.PF_R | Phdr.PF_W | Phdr.PF_X : "rwx",
            }
            stack_permission = pflags[phdr.p_flags]
            break
        else:
            stack_permission = "rwx" # no GNU_STACK phdr means no-NX
    regions += make_regions(get_register("$sp"), "[stack]", stack_permission)

    # registers
    for regname in current_arch.all_registers:
        try:
            regions += make_regions(get_register(regname), "<explored>")
        except TypeError:
            pass

    # walk from stack top
    sp = get_register("$sp")
    data = None
    try:
        data = read_memory(sp & gef_getpagesize_mask(), gef_getpagesize())
    except gdb.MemoryError:
        pass
    if data:
        data = slice_unpack(data, current_arch.ptrsize)
        data = list(set(data))
        for d in data:
            regions += make_regions(d, "<explored>")

    # walk from known map, because qemu may maps extra regions (?)
    for r in regions.copy():
        regions += make_regions(r.page_start - 1, "<explored>", str(r.permission))
        regions += make_regions(r.page_end + 1, "<explored>", str(r.permission))

    # ok
    regions = sorted(regions, key=lambda x: x.page_start)

    # cache globally
    explored_regions = regions.copy()
    return regions


@functools.lru_cache()
def get_process_maps(outer=False):
    """Return the mapped memory sections"""
    if is_qemu_usermode() and not outer:
        return get_explored_regions()

    pid = get_pid() # get_pid() returns pid of qemu-user if outer
    if pid is not None:
        try:
            return get_process_maps_linux(pid)
        except FileNotFoundError as e:
            warn("Failed to read /proc/<PID>/maps, using GDB sections info: {}".format(e))

    @functools.lru_cache()
    def get_info_sections():
        """Retrieve the debuggee sections."""
        lines = gdb.execute("maintenance info sections", to_string=True).splitlines()
        maps = []
        for line in lines:
            if not line:
                break
            try:
                parts = [x.strip() for x in line.split()]
                addr_start, addr_end = [int(x, 16) for x in parts[1].split("->")]
                off = int(parts[3][:-1], 16)
                path = parts[4]
                perm = Permission.from_info_sections(parts[5:])
                sect = Section(page_start=addr_start, page_end=addr_end, offset=off, permission=perm, inode=None, path=path)
                maps.append(sect)
            except IndexError:
                continue
            except ValueError:
                continue
        return maps

    return get_info_sections()


@functools.lru_cache()
def get_info_files():
    """Retrieve all the files loaded by debuggee."""
    lines = gdb.execute("info files", to_string=True).splitlines()
    info_files = []
    for line in lines:
        line = line.strip()
        if not line:
            break
        if not line.startswith("0x"):
            continue
        blobs = [x.strip() for x in line.split(" ")]
        addr_start = int(blobs[0], 16)
        addr_end = int(blobs[2], 16)
        section_name = blobs[4]
        if "system-supplied DSO" in line:
            filepath = "[vdso]"
        elif len(blobs) == 7:
            filepath = blobs[6]
        else:
            filepath = get_filepath(for_vmmap=True)
        info = Zone(section_name, addr_start, addr_end, filepath)
        info_files.append(info)
    return info_files


@functools.lru_cache()
def process_lookup_address(address):
    """Look up for an address in memory.
    Return an Address object if found, None otherwise."""
    if not is_alive():
        err("Process is not running")
        return None
    if is_x86():
        if is_in_x86_kernel(address):
            return None
    for sect in get_process_maps():
        if sect.page_start <= address < sect.page_end:
            return sect
    return None


@functools.lru_cache()
def process_lookup_path(names, perm=Permission.ALL):
    """Look up for paths in the process memory mapping.
    Return a Section object of load base if found, None otherwise."""
    if not is_alive():
        err("Process is not running")
        return None

    @functools.lru_cache()
    def lookup(name, perm):
        for sect in get_process_maps():
            if name in sect.path and sect.permission.value & perm:
                return sect

    if isinstance(names, str):
        return lookup(names, perm)
    elif isinstance(names, tuple):
        for name in names:
            sect = lookup(name, perm)
            if sect is not None:
                return sect
    return None


@functools.lru_cache()
def file_lookup_name_path(name, path):
    """Look up a file by name and path.
    Return a Zone object if found, None otherwise."""
    for xfile in get_info_files():
        if path == xfile.filename and name == xfile.name:
            return xfile
    return None


@functools.lru_cache()
def file_lookup_address(address):
    """Look up for a file by its address.
    Return a Zone object if found, None otherwise."""
    for info in get_info_files():
        if info.zone_start <= address < info.zone_end:
            return info
    return None


@functools.lru_cache()
def lookup_address(address):
    """Try to find the address in the process address space.
    Return an Address object, with validity flag set based on success."""
    sect = process_lookup_address(address)
    info = file_lookup_address(address)
    if sect is None and info is None:
        # i.e. there is no info on this address
        return Address(value=address, valid=False)
    return Address(value=address, section=sect, info=info)


def xor(data, key):
    """Return `data` xor-ed with `key`."""
    key = key.removeprefix("0x")
    key = binascii.unhexlify(key)
    return bytearray([x ^ y for x, y in zip(data, itertools.cycle(key))])


def is_hex(pattern):
    """Return whether provided string is a hexadecimal value."""
    if not pattern.startswith("0x") and not pattern.startswith("0X"):
        return False
    return len(pattern) % 2 == 0 and all(c in string.hexdigits for c in pattern[2:])


def continue_handler(event):
    """GDB event handler for new object continue cases."""
    return


check_info_file = True


def hook_stop_handler(event):
    """GDB event handler for stop cases."""
    reset_all_caches()
    if current_arch is None:
        set_arch(get_arch())
    gdb.execute("context")

    global check_info_file
    if check_info_file:
        response = gdb.execute('info files', to_string=True)
        if "Symbols from" not in response:
            err("Missing info about architecture. Please set: `file /path/to/target_binary`")
            err("Some architectures may not be automatically recognized. Set it manually with `set architecture YOUR_ARCH`.")
        check_info_file = False
    return


def new_objfile_handler(event):
    """GDB event handler for new object file cases."""
    reset_all_caches()
    set_arch()
    load_libc_args()
    return


def exit_handler(event):
    """GDB event handler for exit cases."""
    global __gef_qemu_mode__
    reset_all_caches()
    __gef_qemu_mode__ = False
    return


def memchanged_handler(event):
    """GDB event handler for mem changes cases."""
    reset_all_caches()
    return


def regchanged_handler(event):
    """GDB event handler for reg changes cases."""
    reset_all_caches()
    return


def load_libc_args():
    # load libc function arguments' definitions
    if not get_gef_setting("context.libc_args"):
        return

    path = get_gef_setting("context.libc_args_path")
    if path is None:
        warn("Config `context.libc_args_path` not set but `context.libc_args` is True. Make sure you have `gef-extras` installed")
        return

    path = os.path.realpath(os.path.expanduser(path))

    if not os.path.isdir(path):
        warn("Config `context.libc_args_path` set but it's not a directory")
        return

    _arch_mode = "{}_{}".format(current_arch.arch.lower(), current_arch.mode)
    _libc_args_file = "{}/{}.json".format(path, _arch_mode)

    global libc_args_definitions

    # current arch and mode already loaded
    if _arch_mode in libc_args_definitions:
        return

    libc_args_definitions[_arch_mode] = {}
    try:
        with open(_libc_args_file) as _libc_args:
            libc_args_definitions[_arch_mode] = json.load(_libc_args)
    except FileNotFoundError:
        del libc_args_definitions[_arch_mode]
        warn("Config context.libc_args is set but definition cannot be loaded: file {} not found".format(_libc_args_file))
    except json.decoder.JSONDecodeError as e:
        del libc_args_definitions[_arch_mode]
        warn("Config context.libc_args is set but definition cannot be loaded from file {}: {}".format(_libc_args_file, e))
    return


def get_terminal_size():
    """Return the current terminal size."""
    if platform.system() == "Windows":
        hStdErr = -12
        herr = ctypes.windll.kernel32.GetStdHandle(hStdErr)
        csbi = ctypes.create_string_buffer(22)
        res = ctypes.windll.kernel32.GetConsoleScreenBufferInfo(herr, csbi)
        if res:
            _, _, _, _, _, left, top, right, bottom, _, _ = struct.unpack("hhhhHhhhhhh", csbi.raw)
            tty_columns = right - left + 1
            tty_rows = bottom - top + 1
            return tty_rows, tty_columns
        else:
            return 600, 100
    else:
        import fcntl
        import termios
        try:
            tty_rows, tty_columns = struct.unpack("hh", fcntl.ioctl(1, termios.TIOCGWINSZ, "1234"))
            return tty_rows, tty_columns
        except OSError:
            return 600, 100


def get_generic_arch(module, prefix, arch, mode, big_endian, to_string=False):
    """Retrieves architecture and mode from the arguments for use for the holy
    {cap,key}stone/unicorn trinity."""
    if to_string:
        arch = "{:s}.{:s}_ARCH_{:s}".format(module.__name__, prefix, arch)
        if mode:
            mode = "{:s}.{:s}_MODE_{:s}".format(module.__name__, prefix, str(mode))
        else:
            mode = "0"
        if big_endian:
            mode += " + {:s}.{:s}_MODE_BIG_ENDIAN".format(module.__name__, prefix)
        else:
            mode += " + {:s}.{:s}_MODE_LITTLE_ENDIAN".format(module.__name__, prefix)
    else:
        arch = getattr(module, "{:s}_ARCH_{:s}".format(prefix, arch))
        if mode:
            mode = getattr(module, "{:s}_MODE_{:s}".format(prefix, mode))
        else:
            mode = 0
        if big_endian:
            mode |= getattr(module, "{:s}_MODE_BIG_ENDIAN".format(prefix))
        else:
            mode |= getattr(module, "{:s}_MODE_LITTLE_ENDIAN".format(prefix))
    return arch, mode


@load_unicorn
def get_unicorn_arch(arch=None, mode=None, endian=None, to_string=False):
    unicorn = sys.modules["unicorn"]
    if (arch, mode, endian) == (None, None, None):
        arch = current_arch.arch
        mode = current_arch.mode
        endian = is_big_endian()
    return get_generic_arch(unicorn, "UC", arch, mode, endian, to_string)


@load_capstone
def get_capstone_arch(arch=None, mode=None, endian=None, to_string=False):
    capstone = sys.modules["capstone"]
    if (arch, mode, endian) == (None, None, None):
        arch = current_arch.arch
        mode = current_arch.mode
        endian = is_big_endian()
    # hacky patch for applying to capstone's mode
    if arch == "PPC" and mode == "PPC32":
        mode = "32"
    if arch == "PPC" and mode == "PPC64":
        mode = "64"
    if arch == "SPARC" and mode == "SPARC32":
        mode = ""
    if arch == "SPARC" and mode == "SPARC64":
        mode = "V9"
    return get_generic_arch(capstone, "CS", arch, mode, endian, to_string)


@load_keystone
def get_keystone_arch(arch=None, mode=None, endian=None, to_string=False):
    keystone = sys.modules["keystone"]
    if (arch, mode, endian) == (None, None, None):
        arch = current_arch.arch
        mode = current_arch.mode
        endian = is_big_endian()
    # hacky patch for applying to capstone's mode
    if arch == "ARM64" and mode == "ARM":
        mode = 0
    return get_generic_arch(keystone, "KS", arch, mode, endian, to_string)


@load_unicorn
def get_unicorn_registers(to_string=False):
    "Return a dict matching the Unicorn identifier for a specific register."
    unicorn = sys.modules["unicorn"]
    regs = {}

    if current_arch is not None:
        arch = current_arch.arch.lower()
    else:
        raise OSError("Oops")

    const = getattr(unicorn, "{}_const".format(arch))
    for reg in current_arch.all_registers:
        if arch == "ppc" and reg.startswith("$r"):
            regname = "UC_{:s}_REG_{:s}".format(arch.upper(), reg.lstrip("$r").upper())
        else:
            regname = "UC_{:s}_REG_{:s}".format(arch.upper(), reg.lstrip("$").upper())
        try:
            getattr(const, regname)
        except AttributeError:
            continue
        if to_string:
            regs[reg] = "{:s}.{:s}".format(const.__name__, regname)
        else:
            regs[reg] = getattr(const, regname)
    return regs


@load_keystone
def keystone_assemble(code, arch, mode, *args, **kwargs):
    """Assembly encoding function based on keystone."""
    keystone = sys.modules["keystone"]
    code = gef_pybytes(code)
    addr = kwargs.get("addr", 0x1000)

    @timeout.timeout(duration=1)
    def ks_asm(code, addr):
        return ks.asm(code, addr)

    try:
        ks = keystone.Ks(arch, mode)
        enc, cnt = ks_asm(code, addr)
    except keystone.KsError as e:
        err("Keystone assembler error: {:s}".format(str(e)))
        return None
    except timeout.TimeoutException:
        err("Keystone assembler timeout error")
        return None

    if cnt == 0:
        return ""

    enc = bytearray(enc)
    if "raw" not in kwargs:
        s = binascii.hexlify(enc)
        enc = b"\\x" + b"\\x".join([s[i : i + 2] for i in range(0, len(s), 2)])
        enc = enc.decode("utf-8")

    return enc


@functools.lru_cache()
def get_elf_headers(filepath=None):
    """Return an Elf object with info from `filename`. If not provided, will return
    the currently debugged file."""
    if filepath is None:
        filepath = get_filepath()
        if filepath is None:
            return None
    return Elf(filepath)


def _ptr_width():
    void = cached_lookup_type("void")
    if void is None:
        uintptr_t = cached_lookup_type("uintptr_t")
        return uintptr_t.sizeof
    else:
        return void.pointer().sizeof


@functools.lru_cache()
def is_64bit():
    """Checks if current target is 64bit."""
    return _ptr_width() == 8


@functools.lru_cache()
def is_32bit():
    """Checks if current target is 32bit."""
    return _ptr_width() == 4


@functools.lru_cache()
def is_x86_64():
    """Checks if current target is x86-64"""
    return get_arch() == "i386:x86-64"


@functools.lru_cache()
def is_x86_32():
    """Checks if current target is an x86-32"""
    return get_arch() == "i386"


@functools.lru_cache()
def is_x86():
    return is_x86_32() or is_x86_64()


@functools.lru_cache()
def is_arm32():
    """Checks if current target is an arm-32"""
    try:
        return current_arch.arch == "ARM"
    except Exception:
        return False


@functools.lru_cache()
def is_arm64():
    """Checks if current target is an aarch64"""
    try:
        return current_arch.arch == "ARM64"
    except Exception:
        return False


@functools.lru_cache()
def is_mips32():
    """Checks if current target is an mips-32"""
    try:
        return current_arch.arch == "MIPS" and current_arch.mode == "MIPS32"
    except Exception:
        return False


@functools.lru_cache()
def is_mips64():
    """Checks if current target is an mips-64"""
    try:
        return current_arch.arch == "MIPS" and current_arch.mode == "MIPS64"
    except Exception:
        return False


@functools.lru_cache()
def is_ppc32():
    """Checks if current target is an powerpc-32"""
    try:
        return current_arch.arch == "PPC" and current_arch.mode == "PPC32"
    except Exception:
        return False


@functools.lru_cache()
def is_ppc64():
    """Checks if current target is an powerpc-64"""
    try:
        return current_arch.arch == "PPC" and current_arch.mode == "PPC64"
    except Exception:
        return False


@functools.lru_cache()
def is_sparc32():
    """Checks if current target is an sparc-32"""
    try:
        return current_arch.arch == "SPARC" and current_arch.mode == "SPARC32"
    except Exception:
        return False


@functools.lru_cache()
def is_sparc64():
    """Checks if current target is an powerpc-64"""
    try:
        return current_arch.arch == "SPARC" and current_arch.mode == "SPARC64"
    except Exception:
        return False


@functools.lru_cache()
def is_arch(arch):
    """Checks if current target is specific architecture"""
    elf = current_elf or get_elf_headers()
    return elf and elf.e_machine == arch


@functools.lru_cache()
def is_static(filename=None):
    if filename is None:
        filename = get_filepath()
    file_bin = which("file")
    cmd = [file_bin, filename]
    out = gef_execute_external(cmd)
    return "statically linked" in out


@functools.lru_cache()
def is_stripped(filename=None):
    if filename is None:
        filename = get_filepath()
    file_bin = which("file")
    cmd = [file_bin, filename]
    out = gef_execute_external(cmd)
    return not ("not stripped" in out)


def set_arch(arch=None, default=None):
    """Sets the current architecture.
    If an arch is explicitly specified, use that one, otherwise try to parse it out of the current target.
    If that fails, and default is specified, select and set that arch.
    Return the selected arch, or raise an OSError."""
    arches = {
        Elf.ARM: ARM, "ARM": ARM, "ARM_ANY": ARM, "ARMV2": ARM, "ARMV2A": ARM, "ARMV3": ARM,
        "ARMV4": ARM, "ARMV4T": ARM, "ARMV5": ARM, "ARMV5T": ARM, "ARMV5TE": ARM, "ARMV5TEJ": ARM,
        "ARMV6": ARM, "ARMV6K": ARM, "ARMV6KZ": ARM, "ARMV6T2": ARM, "ARMV7": ARM,
        Elf.AARCH64: AARCH64, "AARCH64": AARCH64, "ARM64": AARCH64, "ARMV8": AARCH64, "ARMV8-A": AARCH64,
        "ARMV9": AARCH64, "ARMV9-A": AARCH64,
        Elf.X86_32: X86, "X86": X86, "I386": X86, "I386:INTEL": X86, "I8086": X86,
        Elf.X86_64: X86_64, "X64": X86_64, "AMD64": X86_64, "X86_64": X86_64, "X86-64": X86_64,
        "I386:X86-64": X86_64, "I386:X86-64:INTEL": X86_64,
        Elf.POWERPC: PowerPC, "POWERPC": PowerPC, "PPC": PowerPC, "PPC32": PowerPC, "POWERPC:COMMON": PowerPC,
        Elf.POWERPC64: PowerPC64, "POWERPC64": PowerPC64, "PPC64": PowerPC64, "POWERPC:COMMON64": PowerPC64,
        Elf.RISCV: RISCV, "RISCV": RISCV, "RISCV:RV32": RISCV, "RISCV:RV64": RISCV,
        Elf.SPARC: SPARC, "SPARC": SPARC, "SPARC32": SPARC, "SPARC:V8": SPARC, "SPARC:V8PLUS": SPARC,
        Elf.SPARC64: SPARC64, "SPARC64": SPARC64, "SPARC:V9": SPARC64,
        Elf.MIPS: MIPS, "MIPS": MIPS, "MIPS:ISA32": MIPS, "MIPS:ISA32R2": MIPS, "MIPS:ISA32R3": MIPS,
        "MIPS:ISA32R5": MIPS, "MIPS:ISA32R6": MIPS,
        "MIPS64": MIPS64, "MIPS:ISA64": MIPS64, "MIPS:ISA64R2": MIPS64, "MIPS:ISA64R3": MIPS64,
        "MIPS:ISA64R5": MIPS64, "MIPS:ISA64R6": MIPS64,
    }
    global current_arch, current_elf

    if arch:
        try:
            if isinstance(arch, str):
                current_arch = arches[arch.upper()]()
            else:
                current_arch = arches[arch]()
            return
        except KeyError:
            if isinstance(arch, str):
                raise OSError("Specified arch {:s} is not supported".format(arch.upper()))
            else:
                raise OSError("Specified arch {:d} is not supported".format(arch))
    else:
        if not current_elf:
            elf = get_elf_headers()
            if elf and elf.is_valid():
                current_elf = elf
            else:
                current_elf = None

        try:
            if current_elf and current_elf.e_machine != Elf.MIPS:
                current_arch = arches[current_elf.e_machine]()
            else:
                # MIPS64 and MIPS32 are indistinguishable because e_machine of the ELF header has the same value
                # so we use the detection result of gdb
                current_arch = arches[get_arch().upper()]()
        except KeyError:
            if default:
                try:
                    current_arch = arches[default.upper()]()
                except KeyError:
                    raise OSError("CPU not supported, neither is default {:s}".format(default.upper()))
            else:
                raise OSError("CPU type is currently not supported: {:s}".format(get_arch().upper()))
        return


@functools.lru_cache()
def cached_lookup_type(_type):
    try:
        return gdb.lookup_type(_type).strip_typedefs()
    except RuntimeError:
        return None


@functools.lru_cache()
def get_memory_alignment(in_bits=False):
    """Try to determine the size of a pointer on this system.
    First, try to parse it out of the ELF header.
    Next, use the size of `size_t`.
    Finally, try the size of $pc.
    If `in_bits` is set to True, the result is returned in bits, otherwise in bytes."""
    if is_32bit():
        return 4 if not in_bits else 32
    elif is_64bit():
        return 8 if not in_bits else 64

    res = cached_lookup_type("size_t")
    if res is not None:
        return res.sizeof if not in_bits else res.sizeof * 8

    try:
        return gdb.parse_and_eval("$pc").type.sizeof
    except Exception:
        pass
    raise EnvironmentError("GEF is running under an unsupported mode")


def clear_screen(tty=""):
    """Clear the screen."""
    if not tty:
        # this is more faster than executing "shell clear -x"
        print("\x1b[H\x1b[2J", end="")
        return

    # Since the tty can be closed at any time, a PermissionError exception can
    # occur when `clear_screen` is called. We handle this scenario properly
    try:
        with open(tty, "wt") as f:
            f.write("\x1b[H\x1b[2J")
    except PermissionError:
        global __gef_redirect_output_fd__
        __gef_redirect_output_fd__ = None
        set_gef_setting("context.redirect", "")
    return


def format_address(addr, memalign_size=None):
    """Format the address according to its size."""
    # if qemu-xxx(32bit arch) runs on x86-64 machine, memalign_size does not match get_memory_alignment()
    # so use the value forcibly if memalign_size is not None
    if memalign_size is None:
        memalign_size = get_memory_alignment()

    if isinstance(addr, str):
        if addr.startswith("0x"):
            return addr
        else:
            return "0x" + addr

    addr = align_address(addr, memalign_size)

    if memalign_size == 4:
        return "{:#010x}".format(addr)

    return "{:#018x}".format(addr)


def format_address_spaces(addr, left=True):
    """Format the address according to its size, but with spaces instead of zeroes."""
    width = get_memory_alignment() * 2 + 2
    addr = align_address(addr)

    if not left:
        return "{:#x}".format(addr).rjust(width)

    return "{:#x}".format(addr).ljust(width)


def align_address(address, memalign_size=None):
    """Align the provided address to the process's native length."""
    # if qemu-xxx(32bit arch) runs on x86-64 machine, memalign_size does not match get_memory_alignment()
    # so use the value forcibly if memalign_size is not None
    if memalign_size is None and get_memory_alignment() == 4:
        return address & 0xFFFFFFFF
    return address & 0xFFFFFFFFFFFFFFFF


def align_address_to_size(address, align):
    """Align the address to the given size."""
    return address + ((align - (address % align)) % align)


def align_address_to_page(address):
    """Align the address to a page."""
    a = align_address(address) >> DEFAULT_PAGE_ALIGN_SHIFT
    return a << DEFAULT_PAGE_ALIGN_SHIFT


def parse_address(address):
    """Parse an address and return it as an Integer."""
    if is_hex(address):
        return int(address, 16)
    return to_unsigned_long(gdb.parse_and_eval(address))


def get_ksymaddr(sym):
    # use available symbol
    try:
        return parse_address('&' + sym)
    except Exception:
        pass
    # use ksymaddr-remote
    try:
        res = gdb.execute("ksymaddr-remote --silent --exact {:s}".format(sym), to_string=True)
        return int(res.split()[0], 16)
    except Exception:
        return None


def is_in_x86_kernel(address):
    address = align_address(address)
    memalign = get_memory_alignment(in_bits=True) - 1
    return (address >> memalign) == 0xF


@functools.lru_cache()
def endian_str():
    return "<" if is_little_endian() else ">"


@functools.lru_cache()
def is_remote_debug():
    """"Return True is the current debugging session is running through GDB remote session."""
    res = gdb.execute("maintenance print target-stack", to_string=True)
    return "remote" in res


@functools.lru_cache()
def is_remote_but_same_host():
    connections = psutil.Process().connections()
    for ip, port in list(c.raddr for c in connections):
        if ip == "127.0.0.1":
            return True
    return False


def de_bruijn(alphabet, n):
    """De Bruijn sequence for alphabet and subsequences of length n (for compat. w/ pwnlib)."""
    k = len(alphabet)
    a = [0] * k * n

    def db(t, p):
        if t > n:
            if n % p == 0:
                for j in range(1, p + 1):
                    yield alphabet[a[j]]
        else:
            a[t] = a[t - p]
            for c in db(t + 1, p):
                yield c

            for j in range(a[t - p] + 1, k):
                a[t] = j
                for c in db(t + 1, t):
                    yield c

    return db(1, 1)


def generate_cyclic_pattern(length):
    """Create a `length` byte bytearray of a de Bruijn cyclic pattern."""
    charset = bytearray(b"abcdefghijklmnopqrstuvwxyz")
    cycle = get_memory_alignment()
    return bytearray(itertools.islice(de_bruijn(charset, cycle), length))


def safe_parse_and_eval(value):
    """GEF wrapper for gdb.parse_and_eval(): this function returns None instead of raising
    gdb.error if the eval failed."""
    try:
        return gdb.parse_and_eval(value)
    except gdb.error:
        return None


@functools.lru_cache()
def dereference(addr):
    """GEF wrapper for gdb dereference function."""
    try:
        ulong_t = cached_lookup_type(use_stdtype())
        if not ulong_t:
            ulong_t = cached_lookup_type(use_default_type())
            if not ulong_t:
                ulong_t = cached_lookup_type(use_golang_type())
                if not ulong_t:
                    ulong_t = cached_lookup_type(use_rust_type())
        unsigned_long_type = ulong_t.pointer()
        res = gdb.Value(addr).cast(unsigned_long_type).dereference()
        # GDB does lazy fetch by default so we need to force access to the value
        res.fetch_lazy()
        return res
    except gdb.MemoryError:
        pass
    return None


def gef_convenience(value):
    """Defines a new convenience value."""
    global __gef_convenience_vars_index__
    var_name = "$_gef{:d}".format(__gef_convenience_vars_index__)
    __gef_convenience_vars_index__ += 1
    gdb.execute("""set {:s} = "{:s}" """.format(var_name, value))
    return var_name


def parse_string_range(s):
    """Parses an address range (e.g. 0x400000-0x401000)"""
    addrs = s.split("-")
    return [int(x, 16) for x in addrs]


AT_CONSTANTS = {
    0  : 'AT_NULL',           # /* End of vector */
    1  : 'AT_IGNORE',         # /* Entry should be ignored */
    2  : 'AT_EXECFD',         # /* File descriptor of program */
    3  : 'AT_PHDR',           # /* Program headers for program */
    4  : 'AT_PHENT',          # /* Size of program header entry */
    5  : 'AT_PHNUM',          # /* Number of program headers */
    6  : 'AT_PAGESZ',         # /* System page size */
    7  : 'AT_BASE',           # /* Base address of interpreter */
    8  : 'AT_FLAGS',          # /* Flags */
    9  : 'AT_ENTRY',          # /* Entry point of program */
    10 : 'AT_NOTELF',         # /* Program is not ELF */
    11 : 'AT_UID',            # /* Real uid */
    12 : 'AT_EUID',           # /* Effective uid */
    13 : 'AT_GID',            # /* Real gid */
    14 : 'AT_EGID',           # /* Effective gid */
    15 : 'AT_PLATFORM',       # /* String identifying platform */
    16 : 'AT_HWCAP',          # /* Machine dependent hints about processor capabilities */
    17 : 'AT_CLKTCK',         # /* Frequency of times() */
    18 : 'AT_FPUCW',          #
    19 : 'AT_DCACHEBSIZE',    #
    20 : 'AT_ICACHEBSIZE',    #
    21 : 'AT_UCACHEBSIZE',    #
    22 : 'AT_IGNOREPPC',      #
    23 : 'AT_SECURE',         #
    24 : 'AT_BASE_PLATFORM',  # String identifying real platforms
    25 : 'AT_RANDOM',         # Address of 16 random bytes
    26 : 'AT_HWCAP2',         # extension of AT_HWCAP
    31 : 'AT_EXECFN',         # Filename of executable
    32 : 'AT_SYSINFO',        #
    33 : 'AT_SYSINFO_EHDR',   #
    34 : 'AT_L1I_CACHESHAPE', #
    35 : 'AT_L1D_CACHESHAPE', #
    36 : 'AT_L2_CACHESHAPE',  #
    37 : 'AT_L3_CACHESHAPE',  #
}


# get_auxiliary_walk (used qemu-user mode) is too slower,
# Because it repeats read_memory many times to find the auxv value.
# functools.lru_cache() is not effective because it is cleared every time you stepi.
# Fortunately, memory maps rarely change.
# I decided to make it a cache mechanism independent of functools.lru_cache and introduce a mechanism to forcibly clear it with vmmap.
explored_auxv = {}


def clear_explored_auxv():
    global explored_auxv
    explored_auxv = {}
    reset_all_caches()
    return


def get_auxiliary_walk(offset=0):
    """Find AUXV by walking stack"""

    # return if it is cached
    global explored_auxv
    if offset in explored_auxv:
        return explored_auxv[offset]

    addr = get_register("$sp") & ~(DEFAULT_PAGE_SIZE - 1)

    # check readable or not
    try:
        read_memory(addr, 1)
    except gdb.MemoryError:
        return None

    # find stack bottom
    try:
        while True:
            if b"\x7fELF" == read_memory(addr, 4):
                break
            addr += DEFAULT_PAGE_SIZE
    except gdb.MemoryError: # if read error, that is stack bottom
        pass
    current = addr - current_arch.ptrsize * 2 - offset

    # check readable or not again
    try:
        read_memory(current, 1)
    except gdb.MemoryError: # something is wrong, maybe stack is pivoted
        return None

    # find auxv end
    while True:
        a = read_int_from_memory(current)
        b = read_int_from_memory(current + current_arch.ptrsize)
        if a == b == 0:
            break
        current -= current_arch.ptrsize * 2

    # skip dummy null if exist
    for i in range(1024):
        a = read_int_from_memory(current)
        if a == 7: # AT_BASE
            break
        current -= current_arch.ptrsize * 2
    else:
        return None

    # find auxv start
    while read_int_from_memory(current) <= 37: # AT_L3_CACHESHAPE
        current -= current_arch.ptrsize * 2
    current += current_arch.ptrsize * 2

    # parse auxv
    res = {}
    while True:
        key = read_int_from_memory(current)
        val = read_int_from_memory(current + current_arch.ptrsize)
        if key not in AT_CONSTANTS:
            break
        res[AT_CONSTANTS[key]] = val
        if key == 0:
            break
        current += current_arch.ptrsize * 2

    # test
    if "AT_ENTRY" not in res:
        return None
    if "AT_PHDR" not in res:
        return None
    if "AT_RANDOM" not in res:
        return None
    if "AT_BASE" not in res:
        return None
    if "AT_NULL" not in res:
        return None

    # cache_globally
    explored_auxv[offset] = res.copy()
    return res


@functools.lru_cache()
def gef_get_auxiliary_values():
    """Retrieves the auxiliary values of the current execution.
    Returns None if not running, or a dict() of values."""
    if not is_alive():
        return None

    if is_qemu_usermode():
        if is_arm32():
            # sometimes AUXV under qemu-arm is not aligned.
            # for fast search, switch order
            for offset in [current_arch.ptrsize, 0]:
                result = get_auxiliary_walk(offset)
                if result:
                    return result
        else:
            for offset in [0, current_arch.ptrsize]:
                result = get_auxiliary_walk(offset)
                if result:
                    return result
        return None

    try:
        result = gdb.execute("info auxv", to_string=True)
    except Exception:
        return None

    res = {}
    for line in result.splitlines():
        tmp = line.split()
        _type = tmp[1]
        if _type in ("AT_PLATFORM", "AT_EXECFN"):
            m = re.match("^.+?(0x[0-9a-f]+)", line)
            res[_type] = int(m.group(1), base=0)
        else:
            res[_type] = int(tmp[-1], base=0)
    return res


@functools.lru_cache()
def gef_read_canary():
    """Read the canary of a running process using Auxiliary Vector.
    Return a tuple of (canary, location) if found, None otherwise."""
    auxval = gef_get_auxiliary_values()
    if not auxval:
        return None

    try:
        canary_location = auxval["AT_RANDOM"]
        canary = read_int_from_memory(canary_location)
        canary &= ~0xFF
        return canary, canary_location
    except Exception:
        return None


def gef_get_pie_breakpoint(num):
    global __pie_breakpoints__
    return __pie_breakpoints__[num]


@functools.lru_cache()
def gef_getpagesize():
    """Get the page size from auxiliary values."""
    auxval = gef_get_auxiliary_values()
    if not auxval:
        return DEFAULT_PAGE_SIZE
    return auxval["AT_PAGESZ"]


@functools.lru_cache()
def gef_getpagesize_mask():
    """Get the page size mask from auxiliary values."""
    auxval = gef_get_auxiliary_values()
    if not auxval:
        return DEFAULT_PAGE_SIZE_MASK
    return ~(auxval["AT_PAGESZ"] - 1)


def only_if_events_supported(event_type):
    """Checks if GDB supports events without crashing."""

    def wrap(f):
        def wrapped_f(*args, **kwargs):
            if getattr(gdb, "events") and getattr(gdb.events, event_type):
                return f(*args, **kwargs)
            warn("GDB events cannot be set")
        return wrapped_f

    return wrap


#
# Event hooking
#

@only_if_events_supported("cont")
def gef_on_continue_hook(func):
    return gdb.events.cont.connect(func)


@only_if_events_supported("cont")
def gef_on_continue_unhook(func):
    return gdb.events.cont.disconnect(func)


@only_if_events_supported("stop")
def gef_on_stop_hook(func):
    return gdb.events.stop.connect(func)


@only_if_events_supported("stop")
def gef_on_stop_unhook(func):
    return gdb.events.stop.disconnect(func)


@only_if_events_supported("exited")
def gef_on_exit_hook(func):
    return gdb.events.exited.connect(func)


@only_if_events_supported("exited")
def gef_on_exit_unhook(func):
    return gdb.events.exited.disconnect(func)


@only_if_events_supported("new_objfile")
def gef_on_new_hook(func):
    return gdb.events.new_objfile.connect(func)


@only_if_events_supported("new_objfile")
def gef_on_new_unhook(func):
    return gdb.events.new_objfile.disconnect(func)


@only_if_events_supported("memory_changed")
def gef_on_memchanged_hook(func):
    return gdb.events.memory_changed.connect(func)


@only_if_events_supported("memory_changed")
def gef_on_memchanged_unhook(func):
    return gdb.events.memory_changed.disconnect(func)


@only_if_events_supported("register_changed")
def gef_on_regchanged_hook(func):
    return gdb.events.register_changed.connect(func)


@only_if_events_supported("register_changed")
def gef_on_regchanged_unhook(func):
    return gdb.events.register_changed.disconnect(func)

#
# Virtual breakpoints
#


class PieVirtualBreakpoint:
    """PIE virtual breakpoint (not real breakpoint)."""
    def __init__(self, set_func, vbp_num, addr):
        # set_func(base): given a base address return a
        # "set breakpoint" gdb command string
        self.set_func = set_func
        self.vbp_num = vbp_num
        # breakpoint num, 0 represents not instantiated yet
        self.bp_num = 0
        self.bp_addr = 0
        # this address might be a symbol, just to know where to break
        if isinstance(addr, int):
            self.addr = hex(addr)
        else:
            self.addr = addr
        return

    def instantiate(self, base):
        if self.bp_num:
            self.destroy()

        try:
            res = gdb.execute(self.set_func(base), to_string=True)
        except gdb.error as e:
            err(e)
            return

        if "Breakpoint" not in res:
            err(res)
            return
        res_list = res.split()
        self.bp_num = res_list[1]
        self.bp_addr = res_list[3]
        return

    def destroy(self):
        if not self.bp_num:
            err("Destroy PIE breakpoint not even set")
            return
        gdb.execute("delete {}".format(self.bp_num))
        self.bp_num = 0
        return

#
# Breakpoints
#


class FormatStringBreakpoint(gdb.Breakpoint):
    """Inspect stack for format string."""
    def __init__(self, spec, num_args):
        super().__init__(spec, type=gdb.BP_BREAKPOINT, internal=False)
        self.num_args = num_args
        self.enabled = True
        return

    def stop(self):
        reset_all_caches()
        msg = []
        ptr, addr = current_arch.get_ith_parameter(self.num_args)
        addr = lookup_address(addr)

        if not addr.valid:
            return False

        if addr.section.permission.value & Permission.WRITE:
            content = read_cstring_from_memory(addr.value)
            name = addr.info.name if addr.info else addr.section.path
            msg.append(Color.colorify("Format string helper", "yellow bold"))
            m = "Possible insecure format string: {:s}('{:s}' {:s} {:#x}: '{:s}')"
            msg.append(m.format(self.location, ptr, RIGHT_ARROW, addr.value, content))
            m = "Reason: Call to '{:s}()' with format string argument in position "
            m += "#{:d} is in page {:#x} ({:s}) that has write permission"
            msg.append(m.format(self.location, self.num_args, addr.section.page_start, name))
            push_context_message("warn", "\n".join(msg))
            return True
        return False


class StubBreakpoint(gdb.Breakpoint):
    """Create a breakpoint to permanently disable a call (fork/alarm/signal/etc.)."""
    def __init__(self, func, retval):
        super().__init__(func, gdb.BP_BREAKPOINT, internal=False)
        self.func = func
        self.retval = retval

        m = "All calls to '{:s}' will be skipped".format(self.func)
        if self.retval is not None:
            m += " (with return value set to {:#x})".format(self.retval)
        info(m)
        return

    def stop(self):
        m = "Ignoring call to '{:s}' ".format(self.func)
        m += "(setting return value to {:#x})".format(self.retval)
        gdb.execute("return (unsigned int){:#x}".format(self.retval))
        ok(m)
        return False


class ChangePermissionBreakpoint(gdb.Breakpoint):
    """When hit, this temporary breakpoint will restore the original code, and position
    $pc correctly."""
    def __init__(self, loc, code, pc, regs):
        super().__init__(loc, gdb.BP_BREAKPOINT, internal=True, temporary=True)
        self.original_code = code
        self.original_pc = pc
        self.original_regs = regs
        return

    def stop(self):
        info("Restoring original context")
        write_memory(self.original_pc, self.original_code, len(self.original_code))
        info("Restoring registers")
        for k, v in self.original_regs.items():
            try:
                gdb.execute("set {:s} = {:#x}".format(k, v))
            except gdb.error:
                pass
        return True


class TraceMallocBreakpoint(gdb.Breakpoint):
    """Track allocations done with malloc() or calloc()."""
    def __init__(self, name):
        super().__init__(name, gdb.BP_BREAKPOINT, internal=True)
        self.silent = True
        self.name = name
        return

    def stop(self):
        # The first call to malloc calls malloc twice internally, like malloc-> malloc_hook_ini-> malloc.
        # You need to prevent the breakpoint from being set twice.
        if hasattr(self, "retbp") and self.retbp.enabled:
            return False
        reset_all_caches()
        _, size = current_arch.get_ith_parameter(0)
        self.retbp = TraceMallocRetBreakpoint(size, self.name)
        return False


class TraceMallocRetBreakpoint(gdb.FinishBreakpoint):
    """Internal temporary breakpoint to retrieve the return value of malloc()."""
    def __init__(self, size, name):
        super().__init__(gdb.newest_frame(), internal=True)
        self.size = size
        self.name = name
        self.silent = True
        return

    def stop(self):
        global __heap_uaf_watchpoints__, __heap_freed_list__, __heap_allocated_list__

        if self.return_value:
            loc = int(self.return_value)
        else:
            loc = parse_address(current_arch.return_register)

        size = self.size
        ok("{} - {}({})={:#x}".format(Color.colorify("Heap-Analysis", "yellow bold"), self.name, size, loc))
        check_heap_overlap = get_gef_setting("heap-analysis-helper.check_heap_overlap")

        # pop from free-ed list if it was in it
        if __heap_freed_list__:
            idx = 0
            for item in __heap_freed_list__:
                addr = item[0]
                if addr == loc:
                    __heap_freed_list__.remove(item)
                    continue
                idx += 1

        # pop from uaf watchlist
        if __heap_uaf_watchpoints__:
            idx = 0
            for wp in __heap_uaf_watchpoints__:
                wp_addr = wp.address
                if loc <= wp_addr < loc + size:
                    __heap_uaf_watchpoints__.remove(wp)
                    wp.enabled = False
                    continue
                idx += 1

        item = (loc, size)

        if check_heap_overlap:
            # seek all the currently allocated chunks, read their effective size and check for overlap
            msg = []
            align = get_memory_alignment()
            for chunk_addr, _ in __heap_allocated_list__:
                current_chunk = GlibcChunk(chunk_addr)
                current_chunk_size = current_chunk.get_chunk_size()

                if not (chunk_addr <= loc < chunk_addr + current_chunk_size):
                    continue
                offset = loc - chunk_addr - 2 * align
                if offset < 0:
                    continue # false positive, discard

                msg.append(Color.colorify("Heap-Analysis", "yellow bold"))
                msg.append("Possible heap overlap detected")
                fmt = "Reason {} new allocated chunk {:#x} (of size {:d}) overlaps in-used chunk {:#x} (of size {:#x})"
                msg.append(fmt.format(RIGHT_ARROW, loc, size, chunk_addr, current_chunk_size))
                msg.append("Writing {0:d} bytes from {1:#x} will reach chunk {2:#x}".format(offset, chunk_addr, loc))
                msg.append("Payload example for chunk {1:#x} (to overwrite {0:#x} headers):".format(loc, chunk_addr))
                msg.append("  data = 'A'*{0:d} + 'B'*{1:d} + 'C'*{1:d}".format(offset, align))
                push_context_message("warn", "\n".join(msg))
                return True

        # add it to alloc-ed list
        __heap_allocated_list__.append(item)
        return False


class TraceReallocBreakpoint(gdb.Breakpoint):
    """Track re-allocations done with realloc()."""
    def __init__(self):
        super().__init__("__libc_realloc", gdb.BP_BREAKPOINT, internal=True)
        self.silent = True
        return

    def stop(self):
        _, ptr = current_arch.get_ith_parameter(0)
        _, size = current_arch.get_ith_parameter(1)
        self.retbp = TraceReallocRetBreakpoint(ptr, size)
        return False


class TraceReallocRetBreakpoint(gdb.FinishBreakpoint):
    """Internal temporary breakpoint to retrieve the return value of realloc()."""
    def __init__(self, ptr, size):
        super().__init__(gdb.newest_frame(), internal=True)
        self.ptr = ptr
        self.size = size
        self.silent = True
        return

    def stop(self):
        global __heap_uaf_watchpoints__, __heap_freed_list__, __heap_allocated_list__

        if self.return_value:
            newloc = int(self.return_value)
        else:
            newloc = parse_address(current_arch.return_register)

        if newloc != self:
            ok("{} - realloc({:#x}, {})={}".format(Color.colorify("Heap-Analysis", "yellow bold"),
                                                   self.ptr, self.size,
                                                   Color.colorify("{:#x}".format(newloc), "green"),))
        else:
            ok("{} - realloc({:#x}, {})={}".format(Color.colorify("Heap-Analysis", "yellow bold"),
                                                   self.ptr, self.size,
                                                   Color.colorify("{:#x}".format(newloc), "red"),))

        item = (newloc, self.size)

        try:
            # check if item was in alloc-ed list
            idx = [x for x, y in __heap_allocated_list__].index(self.ptr)
            # if so pop it out
            item = __heap_allocated_list__.pop(idx)
        except ValueError:
            if is_debug():
                warn("Chunk {:#x} was not in tracking list".format(self.ptr))
        finally:
            # add new item to alloc-ed list
            __heap_allocated_list__.append(item)

        return False


class TraceFreeBreakpoint(gdb.Breakpoint):
    """Track calls to free() and attempts to detect inconsistencies."""
    def __init__(self):
        super().__init__("__libc_free", gdb.BP_BREAKPOINT, internal=True)
        self.silent = True
        return

    def stop(self):
        reset_all_caches()
        _, addr = current_arch.get_ith_parameter(0)
        msg = []
        check_free_null = get_gef_setting("heap-analysis-helper.check_free_null")
        check_double_free = get_gef_setting("heap-analysis-helper.check_double_free")
        check_weird_free = get_gef_setting("heap-analysis-helper.check_weird_free")
        check_uaf = get_gef_setting("heap-analysis-helper.check_uaf")

        ok("{} - free({:#x})".format(Color.colorify("Heap-Analysis", "yellow bold"), addr))
        if addr == 0:
            if check_free_null:
                msg.append(Color.colorify("Heap-Analysis", "yellow bold"))
                msg.append("Attempting to free(NULL) at {:#x}".format(current_arch.pc))
                msg.append("Reason: if NULL page is allocatable, this can lead to code execution.")
                push_context_message("warn", "\n".join(msg))
                return True
            return False

        if addr in [x for (x, y) in __heap_freed_list__]:
            if check_double_free:
                msg.append(Color.colorify("Heap-Analysis", "yellow bold"))
                fmt = "Double-free detected {} free({:#x}) is called at {:#x} but is already in the free-ed list"
                msg.append(fmt.format(RIGHT_ARROW, addr, current_arch.pc))
                msg.append("Execution will likely crash...")
                push_context_message("warn", "\n".join(msg))
                return True
            return False

        # if here, no error
        # 1. move alloc-ed item to free list
        try:
            # pop from alloc-ed list
            idx = [x for x, y in __heap_allocated_list__].index(addr)
            item = __heap_allocated_list__.pop(idx)

        except ValueError:
            if check_weird_free:
                msg.append(Color.colorify("Heap-Analysis", "yellow bold"))
                msg.append("Heap inconsistency detected:")
                msg.append("Attempting to free an unknown value: {:#x}".format(addr))
                push_context_message("warn", "\n".join(msg))
                return True
            return False

        # 2. add it to free-ed list
        __heap_freed_list__.append(item)

        self.retbp = None
        if check_uaf:
            # 3. (opt.) add a watchpoint on pointer
            self.retbp = TraceFreeRetBreakpoint(addr)
        return False


class TraceFreeRetBreakpoint(gdb.FinishBreakpoint):
    """Internal temporary breakpoint to track free()d values."""
    def __init__(self, addr):
        super().__init__(gdb.newest_frame(), internal=True)
        self.silent = True
        self.addr = addr
        return

    def stop(self):
        reset_all_caches()
        wp = UafWatchpoint(self.addr)
        __heap_uaf_watchpoints__.append(wp)
        return False


class UafWatchpoint(gdb.Breakpoint):
    """Custom watchpoints set TraceFreeBreakpoint() to monitor free()d pointers being used."""
    def __init__(self, addr):
        super().__init__("*{:#x}".format(addr), gdb.BP_WATCHPOINT, internal=True)
        self.address = addr
        self.silent = True
        self.enabled = True
        return

    def stop(self):
        """If this method is triggered, we likely have a UaF. Break the execution and report it."""
        reset_all_caches()
        try:
            frame = gdb.selected_frame()
        except Exception:
            return False
        if frame.name() in ("_int_malloc", "malloc_consolidate", "__libc_calloc", ):
            return False

        # software watchpoints stop after the next statement (see
        # https://sourceware.org/gdb/onlinedocs/gdb/Set-Watchpoints.html)
        pc = gdb_get_nth_previous_instruction_address(current_arch.pc, 2)
        insn = gef_current_instruction(pc)
        msg = []
        msg.append(Color.colorify("Heap-Analysis", "yellow bold"))
        msg.append("Possible Use-after-Free in '{:s}': pointer {:#x} was freed, but is attempted to be used at {:#x}"
                   .format(get_filepath(), self.address, pc))
        msg.append("{:#x}   {:s} {:s}".format(insn.address, insn.mnemonic, Color.yellowify(", ".join(insn.operands))))
        push_context_message("warn", "\n".join(msg))
        return True


class EntryBreakBreakpoint(gdb.Breakpoint):
    """Breakpoint used internally to stop execution at the most convenient entry point."""
    def __init__(self, location):
        super().__init__(location, gdb.BP_BREAKPOINT, internal=True, temporary=True)
        self.silent = True
        return

    def stop(self):
        reset_all_caches()
        return True


class NamedBreakpoint(gdb.Breakpoint):
    """Breakpoint which shows a specified name, when hit."""
    def __init__(self, location, name):
        super().__init__(spec=location, type=gdb.BP_BREAKPOINT, internal=False, temporary=False)
        self.name = name
        self.loc = location

        return

    def stop(self):
        reset_all_caches()
        push_context_message("info", "Hit breakpoint {} ({})".format(self.loc, Color.colorify(self.name, "red bold")))
        return True


#
# Commands
#

def register_external_command(obj):
    """Registering function for new GEF (sub-)command to GDB."""
    global __commands__, __gef__
    cls = obj.__class__
    __commands__.append(cls)
    __gef__.load(initial=False)
    __gef__.doc.add_command_to_doc((cls._cmdline_, cls, None))
    __gef__.doc.refresh()
    return cls


def register_command(cls):
    """Decorator for registering new GEF (sub-)command to GDB."""
    global __commands__
    __commands__.append(cls)
    return cls


def register_priority_command(cls):
    """Decorator for registering new command with priority, meaning that it must
    loaded before the other generic commands."""
    global __commands__
    __commands__.insert(0, cls)
    return cls


def register_function(cls):
    """Decorator for registering a new convenience function to GDB."""
    global __functions__
    __functions__.append(cls)
    return cls


class GenericCommand(gdb.Command):
    """This is an abstract class for invoking commands, should not be instantiated."""
    __metaclass__ = abc.ABCMeta

    def __init__(self, *args, **kwargs):
        self.pre_load()
        syntax = Color.yellowify("\nSyntax: ") + self._syntax_
        example = Color.yellowify("\nExample: ") + self._example_ if self._example_ else ""
        aliases = Color.yellowify("\nAliases: ") + str(self._aliases_) if hasattr(self, "_aliases_") else ""
        self.__doc__ = self.__doc__.replace(" " * 4, "") + syntax + example + aliases
        self.repeat = False
        self.repeat_count = 0
        self.__last_command = None
        command_type = kwargs.get("command", gdb.COMMAND_OBSCURE)
        complete_type = kwargs.get("complete", gdb.COMPLETE_NONE)
        prefix = kwargs.get("prefix", False)
        super().__init__(self._cmdline_, command_type, complete_type, prefix)
        self.post_load()
        return

    def invoke(self, args, from_tty):
        try:
            argv = gdb.string_to_argv(args)
            self.__set_repeat_count(argv, from_tty)
            bufferize(self.do_invoke)(argv)
        except Exception as e:
            # Note: since we are intercepting cleaning exceptions here, commands preferably should avoid
            # catching generic Exception, but rather specific ones. This is allows a much cleaner use.
            if is_debug():
                show_last_exception()
            else:
                err("Command '{:s}' failed to execute properly, reason: {:s}".format(self._cmdline_, str(e)))
        return

    def usage(self):
        if self._example_:
            err("Syntax\n{}\n\nExample\n{}".format(self._syntax_, self._example_.lstrip()))
        else:
            err("Syntax\n{}".format(self._syntax_))
        return

    @abc.abstractproperty
    def _cmdline_(self):
        pass

    @abc.abstractproperty
    def _syntax_(self):
        pass

    @abc.abstractproperty
    def _example_(self):
        return ""

    @abc.abstractmethod
    def do_invoke(self, argv):
        pass

    def pre_load(self):
        pass

    def post_load(self):
        pass

    def __get_setting_name(self, name):
        def __sanitize_class_name(clsname):
            if " " not in clsname:
                return clsname
            return "-".join(clsname.split())

        class_name = __sanitize_class_name(self.__class__._cmdline_)
        return "{:s}.{:s}".format(class_name, name)

    @property
    def settings(self):
        """Return the list of settings for this command."""
        return [x.split(".", 1)[1] for x in __config__ if x.startswith("{:s}.".format(self._cmdline_))]

    def get_setting(self, name):
        key = self.__get_setting_name(name)
        setting = __config__[key]
        return setting[1](setting[0])

    def has_setting(self, name):
        key = self.__get_setting_name(name)
        return key in __config__

    def add_setting(self, name, value, description=""):
        # make sure settings are always associated to the root command (which derives from GenericCommand)
        if "GenericCommand" not in [x.__name__ for x in self.__class__.__bases__]:
            return
        key = self.__get_setting_name(name)
        __config__[key] = [value, type(value), description]
        get_gef_setting.cache_clear()
        return

    def del_setting(self, name):
        key = self.__get_setting_name(name)
        del __config__[key]
        get_gef_setting.cache_clear()
        return

    def __set_repeat_count(self, argv, from_tty):
        if not from_tty:
            self.repeat = False
            self.repeat_count = 0
            return

        command = gdb.execute("show commands", to_string=True).strip().split("\n")[-1]
        self.repeat = self.__last_command == command
        self.repeat_count = self.repeat_count + 1 if self.repeat else 0
        self.__last_command = command
        return


# Copy/paste this template for new command
# @register_command
# class TemplateCommand(GenericCommand):
#     """TemplateCommand: description here will be seen in the help menu for the command."""
#     _cmdline_ = "template-fake"
#     _syntax_ = "{:s}".format(_cmdline_)
#     _aliases_ = ["tpl-fk",]
#     _category_ = "Misc"
#     def __init__(self):
#         super().__init__(complete=gdb.COMPLETE_FILENAME)
#         return
#     def do_invoke(self, argv):
#         self.dont_repeat()
#         return


@register_command
class NiCommand(GenericCommand):
    """nexti wrapper for s390x because s390x sometimes returns `PC not saved` when nexti command is executed."""
    _cmdline_ = "ni"
    _syntax_ = _cmdline_
    _category_ = "Debugging Support"

    def do_invoke(self, argv):
        cmd = "nexti " + ' '.join(argv)
        try:
            gdb.execute(cmd.rstrip())
        except gdb.error:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            if str(exc_value) == "PC not saved":
                gdb.execute("context")
            else:
                err(exc_value)
        return


@register_command
class SiCommand(GenericCommand):
    """stepi wrapper for s390x because s390x sometimes returns `PC not saved` when stepi command is executed."""
    _cmdline_ = "si"
    _syntax_ = _cmdline_
    _category_ = "Debugging Support"

    def do_invoke(self, argv):
        cmd = "stepi " + ' '.join(argv)
        try:
            gdb.execute(cmd.rstrip())
        except gdb.error:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            if str(exc_value) == "PC not saved":
                gdb.execute("context")
            else:
                err(exc_value)
        return


@register_command
class ContCommand(GenericCommand):
    """qemu-user does not trap SIGINT during "continue". Realize a pseudo SIGINT trap by trapping
    SIGINT on the python side and throwing SIGINT back to qemu-user."""
    _cmdline_ = "c"
    _syntax_ = _cmdline_
    _category_ = "Debugging Support"

    def do_invoke(self, argv):
        self.dont_repeat()

        if is_qemu_usermode() and get_pid():

            import threading
            import signal
            thread_started = False
            thread_finished = False

            def continue_thread():
                nonlocal thread_started, thread_finished
                thread_started = True
                gdb.execute("continue")
                thread_finished = True
                return

            def sig_handler(signum, frame):
                os.kill(get_pid(), signal.SIGINT)
                return

            th = threading.Thread(target=continue_thread, daemon=True)
            th.start()
            while thread_started is False:
                pass
            old = signal.signal(signal.SIGINT, sig_handler)
            while thread_finished is False:
                time.sleep(0.1)
            th.join()
            signal.signal(signal.SIGINT, old)
        else:
            try:
                cmd = "continue " + ' '.join(argv)
                gdb.execute(cmd.rstrip())
            except Exception:
                exc_type, exc_value, exc_traceback = sys.exc_info()
                err(exc_value)
        return


@register_command
class PrintFormatCommand(GenericCommand):
    """Print bytes format in high level languages."""
    _cmdline_ = "print-format"
    _syntax_ = "{:s} [-f FORMAT] [-b BITSIZE] [-l LENGTH] [-c] [-h] LOCATION\n".format(_cmdline_)
    _syntax_ += "  -f FORMAT   specifies the output format, avaliable value: py, c, js, asm, hex (default py).\n"
    _syntax_ += "  -b BITSIZE  sepecifies size of bit, avaliable values is 8, 16, 32, 64 (default is 8).\n"
    _syntax_ += "  -l LENGTH   specifies length of array (default is 256).\n"
    _syntax_ += "  -c          The result of data will copied to clipboard\n"
    _syntax_ += "  LOCATION    specifies where the address of bytes is stored."
    _example_ = "{:s} -f py -b 8 -l 256 $rsp".format(_cmdline_)
    _category_ = "Exploit Development"
    _aliases_ = ["pf"]

    bitformat = {8: "<B", 16: "<H", 32: "<I", 64: "<Q"}
    c_type = {8: "char", 16: "short", 32: "int", 64: "long long"}
    asm_type = {8: "db", 16: "dw", 32: "dd", 64: "dq"}

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    def clip(self, data):
        if sys.platform == "linux":
            try:
                xclip = which("xclip")
            except FileNotFoundError as e:
                err("{}".format(e))
                return False
            prog = [xclip, "-selection", "clipboard", "-i"] # For linux

        elif sys.platform == "darwin":
            try:
                pbcopy = which("pbcopy")
            except FileNotFoundError as e:
                err("{}".format(e))
                return False
            prog = [pbcopy] # For OSX

        else:
            warn("Can't copy to clipboard, platform not supported")
            return False

        try:
            p = subprocess.Popen(prog, stdin=subprocess.PIPE)
        except Exception:
            warn("Can't copy to clipboard, Something went wrong while copying")
            return False

        p.stdin.write(data)
        p.stdin.close()
        p.wait()
        return True

    def do_invoke(self, argv):
        """Default value for print-format command."""
        self.dont_repeat()
        lang = "py"
        length = 256
        bitlen = 8
        copy_to_clipboard = False
        supported_formats = ["py", "c", "js", "asm", "hex"]

        try:
            opts, args = getopt.getopt(argv, "f:l:b:ch")
            for o, a in opts:
                if o == "-f":
                    lang = a
                elif o == "-l":
                    length = int(gdb.parse_and_eval(a))
                elif o == "-b":
                    bitlen = int(a)
                elif o == "-c":
                    copy_to_clipboard = True
                elif o == "-h":
                    self.usage()
                    return
        except Exception:
            self.usage()
            return

        if not args:
            err("No address specified")
            return

        start_addr = int(gdb.parse_and_eval(args[0]))

        if bitlen not in [8, 16, 32, 64]:
            err("Size of bit must be in 8, 16, 32, or 64")
            return

        if lang == "hex" and bitlen != 8:
            err("hex must be bit == 8")
            return

        if lang not in supported_formats:
            err("Language must be : {}".format(str(supported_formats)))
            return

        size = int(bitlen / 8)
        end_addr = start_addr + length * size
        bf = self.bitformat[bitlen]
        data = []
        out = ""

        for address in range(start_addr, end_addr, size):
            try:
                mem = read_memory(address, size)
            except gdb.MemoryError:
                err("Memory read error")
                return None
            value = struct.unpack(bf, mem)[0]
            data += [value]

        sdata = ""
        if lang == "hex":
            for i, x in enumerate(data):
                sdata += "{:02x}".format(x)
                if (i % 16) == 15:
                    sdata += "\n"
        else:
            for i, x in enumerate(data):
                sdata += "{:#0{}x}, ".format(x, bitlen // 4 + 2)
                if (i % 8) == 7:
                    sdata += "\n"
        sdata = sdata.rstrip()

        if lang == "py":
            out = "buf = [\n{}\n]".format(sdata)
        elif lang == "c":
            out = "unsigned {0} buf[{1}] = {{\n{2}\n}};".format(self.c_type[bitlen], length, sdata)
        elif lang == "js":
            out = "var buf = [\n{}\n]".format(sdata)
        elif lang == "asm":
            out += "buf {0}\n{1}".format(self.asm_type[bitlen], sdata)
        elif lang == "hex":
            out += "{0}".format(sdata)

        if copy_to_clipboard:
            if self.clip(bytes(out, "utf-8")):
                info("Copied to clipboard")
            else:
                warn("There's a problem while copying")

        gef_print(out)
        return


@register_command
class SmartEvalCommand(GenericCommand):
    """SmartEval: Smart eval (vague approach to mimic WinDBG `?`)."""
    _cmdline_ = "$"
    _syntax_ = "\n"
    _syntax_ += "{:s} EXPR\n".format(_cmdline_)
    _syntax_ += "{:s} ADDRESS1 ADDRESS2".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} $pc+1\n".format(_cmdline_)
    _example_ += "{:s} 0x00007ffff7a10000 0x00007ffff7bce000".format(_cmdline_)
    _category_ = "Misc"
    _aliases_ = ["smart-eval"]

    def do_invoke(self, argv):
        self.dont_repeat()
        argc = len(argv)
        if argc == 1:
            self.evaluate(argv)
            return

        if argc == 2:
            self.distance(argv)
        return

    def evaluate(self, expr):
        def show_as_int(i):
            off = current_arch.ptrsize * 8

            def comp2_x(x):
                return "{:x}".format((x + (1 << off)) % (1 << off))

            def comp2_b(x):
                return "{:b}".format((x + (1 << off)) % (1 << off))

            try:
                s_i = comp2_x(res)
                s_i = s_i.rjust(len(s_i) + 1, "0") if len(s_i) % 2 else s_i
                gef_print("decimal      : {:d}".format(i))
                gef_print("hex          : 0x" + comp2_x(res))
                gef_print("binary       : 0b" + comp2_b(res))
                gef_print("big-endian   : {}".format(binascii.unhexlify(s_i)))
                gef_print("little-endian: {}".format(binascii.unhexlify(s_i)[::-1]))
            except Exception:
                pass
            return

        parsed_expr = []
        for xp in expr:
            try:
                xp = gdb.parse_and_eval(xp)
                xp = int(xp)
                parsed_expr.append("{:d}".format(xp))
            except gdb.error:
                parsed_expr.append(str(xp))

        try:
            res = eval(" ".join(parsed_expr))
            if type(res) is int:
                show_as_int(res)
            else:
                gef_print("{}".format(res))
        except SyntaxError:
            gef_print(" ".join(parsed_expr))
        return

    def distance(self, args):
        try:
            x = int(args[0], 16) if is_hex(args[0]) else int(args[0])
            y = int(args[1], 16) if is_hex(args[1]) else int(args[1])
            gef_print("{}".format(abs(x - y)))
        except ValueError:
            warn("Distance requires 2 numbers: {} 0 0xffff".format(self._cmdline_))
        return


@register_command
class CanaryCommand(GenericCommand):
    """Shows the canary value of the current process. Apply the techique detailed in
    https://www.elttam.com.au/blog/playing-with-canaries/ to show the canary."""
    _cmdline_ = "canary"
    _syntax_ = _cmdline_
    _category_ = "Process Information"

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        filepath = get_filepath()
        if filepath is None:
            err("Missing info about architecture. Please set: `file /path/to/target_binary`")
            return

        res = checksec(filepath)
        has_canary = res["Canary"]
        if not has_canary:
            warn("This binary was not compiled with SSP.")
            return

        res = gef_read_canary()
        if not res:
            err("Failed to get the canary")
            return

        canary, location = res
        info("Found AT_RANDOM at {:#x}, reading {} bytes".format(location, current_arch.ptrsize))
        info("The canary of process {:d} is {:s}".format(get_pid(), Color.boldify("{:#x}".format(canary))))
        gef_print(titlify("found canary"))

        vmmap = get_process_maps()
        unpack = u32 if current_arch.ptrsize == 4 else u64

        tls = None
        if is_x86_64():
            tls = TlsCommand.getfs()
        elif is_x86_32():
            tls = TlsCommand.getgs()

        sp = get_register("$sp")
        for m in vmmap:
            if not (m.permission & Permission.READ) or not (m.permission & Permission.WRITE):
                continue
            if m.path == "[vvar]":
                continue
            try:
                data = read_memory(m.page_start, m.page_end - m.page_start)
            except gdb.MemoryError:
                continue
            prev_addr = -1
            for pos in range(0, m.page_end - m.page_start, current_arch.ptrsize):
                addr = m.page_start + pos
                d = data[pos: pos + current_arch.ptrsize]
                if canary != unpack(d):
                    continue
                if m.path == "":
                    if tls and tls <= addr < ((tls + 0x1000) & 0xfffffffffffff000):
                        path = "tls"
                    else:
                        path = "unknown"
                else:
                    path = m.path
                if prev_addr <= sp <= addr:
                    info("(Stack pointer is at {:#x})".format(sp))
                info("Found at {:#x} in {:s}".format(addr, repr(path)))
                prev_addr = addr
        return


@register_command
class PidCommand(GenericCommand):
    """Show pid."""
    _cmdline_ = "pid"
    _syntax_ = _cmdline_
    _category_ = "Process Information"

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()
        pid = get_pid()
        if pid is None:
            err("Unsupported")
            return
        gef_print(pid)
        return


@register_command
class GetFileCommand(GenericCommand):
    """Show current debugged filename."""
    _cmdline_ = "filename"
    _syntax_ = _cmdline_
    _category_ = "Process Information"

    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()
        gef_print(repr(gdb.current_progspace().filename))
        return


@register_command
class ProcessStatusCommand(GenericCommand):
    """Extends the info given by GDB `info proc`, by giving an exhaustive description of the
    process status (file descriptors, ancestor, descendants, etc.)."""
    _cmdline_ = "process-status"
    _syntax_ = _cmdline_
    _aliases_ = ["status", "procinfo", "pr"]
    _category_ = "Process Information"

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()
        gef_print(titlify("Process information"))
        self.show_info_proc()
        self.show_info_proc2()
        self.show_ancestor()
        self.show_descendants()
        self.show_info_thread()
        self.show_info_proc_ns()
        self.show_fds()
        self.show_connections()
        return

    def get_state_of(self, pid):
        try:
            status = open("/proc/{}/status".format(pid), "r").read()
        except Exception:
            return {}
        res = {}
        for line in status.splitlines():
            key, value = line.split(":", 1)
            res[key.strip()] = value.strip()
        return res

    def get_stat_of(self, pid):
        try:
            stat = open("/proc/{}/stat".format(pid), "r").read()
        except Exception:
            return []
        name = re.search(r"\((.+)\)", stat)
        other = re.sub(r"\(.+\) ", "", stat).split()
        res = [int(other[0]), name, other[1]] + [int(x) for x in other[2:]]
        return res

    def get_cmdline_of(self, pid):
        try:
            cmdline = open("/proc/{}/cmdline".format(pid), "r").read()
        except Exception:
            return ""
        return cmdline.replace("\x00", "\x20").strip()

    def get_process_path_of(self, pid):
        try:
            return os.readlink("/proc/{}/exe".format(pid))
        except Exception:
            return "Not Found"

    def get_process_cwd(self, pid):
        try:
            return os.readlink("/proc/{}/cwd".format(pid))
        except Exception:
            return "Not Found"

    def get_process_root(self, pid):
        try:
            return os.readlink("/proc/{}/root".format(pid))
        except Exception:
            return "Not Found"

    def get_thread_ids(self, pid):
        try:
            tids = os.listdir("/proc/{}/task".format(pid))
            return [int(x) for x in tids]
        except Exception:
            return []

    def get_children_pids(self, pid):
        try:
            ps = which("ps")
        except FileNotFoundError as e:
            err("{}".format(e))
            return []

        cmd = [ps, "-o", "pid", "--ppid", "{}".format(pid), "--noheaders"]
        try:
            return [int(x) for x in gef_execute_external(cmd, as_list=True)]
        except Exception:
            return []

    def get_uid_map(self, pid):
        try:
            uid_map = open("/proc/{}/uid_map".format(pid), "r").read().strip()
        except Exception:
            return []
        return slicer([int(x) for x in uid_map.split()], 3)

    def get_gid_map(self, pid):
        try:
            gid_map = open("/proc/{}/gid_map".format(pid), "r").read().strip()
        except Exception:
            return []
        return slicer([int(x) for x in gid_map.split()], 3)

    def get_tty_str(self, major, minor):
        try:
            file = which("file")
        except FileNotFoundError as e:
            err("{}".format(e))
            return "Not Found"

        if not os.path.exists("/dev"):
            return "Not Found"
        if not os.path.exists("/proc/devices"):
            return "Not Found"

        try:
            devices = open("/proc/devices", "r").read()
        except Exception:
            return "Not found"
        for line in devices.splitlines():
            if not line or line.endswith(":"):
                continue
            n, name = line.strip().split()
            if major == int(n):
                if not name.startswith("/dev"):
                    name = os.path.join("/dev", name)
                break
        else:
            return "Not Found"

        if os.path.islink(name):
            return "Not Found"
        elif os.path.isfile(name):
            res = gef_execute_external([file, name], as_iist=True)
            m = re.search(r"\((\d+)/(\d+)\)", res)
            if m and int(m.group(1)) == major and int(m.group(2)) == minor:
                return name
            else:
                return "Not Found"
        elif os.path.isdir(name):
            for root, dirs, files in os.walk(name, followlinks=False):
                for f in files:
                    path = os.path.join(root, f)
                    if os.path.islink(path):
                        continue
                    res = gef_execute_external([file, path], as_iist=True)
                    m = re.search(r"\((\d+)/(\d+)\)", res)
                    if m and int(m.group(1)) == major and int(m.group(2)) == minor:
                        return path
            return "Not Found"

    def show_info_proc(self):
        info("Process Information")
        pid = get_pid()
        cmdline = self.get_cmdline_of(pid)
        gef_print("  {:32s} {} {}".format("PID", RIGHT_ARROW, pid))
        gef_print("  {:32s} {} {}".format("Executable", RIGHT_ARROW, repr(self.get_process_path_of(pid))))
        gef_print("  {:32s} {} {}".format("Command Line", RIGHT_ARROW, repr(cmdline)))
        gef_print("  {:32s} {} {}".format("Current Working Directory", RIGHT_ARROW, repr(self.get_process_cwd(pid))))
        gef_print("  {:32s} {} {}".format("Root Directory", RIGHT_ARROW, repr(self.get_process_root(pid))))
        return

    def show_info_proc2(self):
        info("Process Information Additional")
        pid = get_pid()
        pgid = self.get_stat_of(pid)[4]
        gef_print("  {:32s} {} {}".format("Process Group ID", RIGHT_ARROW, pgid))
        gef_print("  {:32s} {} {}".format("Process Group ID Executable", RIGHT_ARROW, repr(self.get_process_path_of(pgid))))
        sid = self.get_stat_of(pid)[5]
        gef_print("  {:32s} {} {}".format("Session ID", RIGHT_ARROW, sid))
        gef_print("  {:32s} {} {}".format("Session ID Executable", RIGHT_ARROW, repr(self.get_process_path_of(sid))))
        ttynr = self.get_stat_of(pid)[6]
        major, minor = (ttynr >> 8) & 0xff, ((ttynr >> 20) << 8) | (ttynr & 0xff)
        ttystr = self.get_tty_str(major, minor)
        gef_print("  {:32s} {} {} (Major:{} Minor:{} Dev:{})".format("TTY Device Number", RIGHT_ARROW, ttynr, major, minor, repr(ttystr)))
        tpgid = self.get_stat_of(pid)[7]
        gef_print("  {:32s} {} {}".format("TTY Process Group ID", RIGHT_ARROW, tpgid))
        gef_print("  {:32s} {} {}".format("TTY Process Group ID Executable", RIGHT_ARROW, repr(self.get_process_path_of(tpgid))))
        gef_print("  {:32s} {} {}".format("RUID : EUID : SavedUID : FSUID", RIGHT_ARROW, re.sub(r"\s+", " : ", self.get_state_of(pid)['Uid'])))
        gef_print("  {:32s} {} {}".format("RGID : EGID : SavedGID : FSGID", RIGHT_ARROW, re.sub(r"\s+", " : ", self.get_state_of(pid)['Gid'])))
        seccomp_n = self.get_state_of(pid)['Seccomp']
        seccomp_s = {'0': 'Disabled', '1': 'Strict', '2': 'Filter'}
        gef_print("  {:32s} {} {} ({})".format("Seccomp Mode", RIGHT_ARROW, seccomp_n, seccomp_s[seccomp_n]))
        return

    def show_ancestor(self):
        info("Parent Process Information")
        ppid = int(self.get_state_of(get_pid())["PPid"])
        state = self.get_state_of(ppid)
        cmdline = self.get_cmdline_of(ppid)
        gef_print("  {:32s} {} {}".format("Parent PID", RIGHT_ARROW, state["Pid"]))
        gef_print("  {:32s} {} {}".format("Command Line", RIGHT_ARROW, repr(cmdline)))
        return

    def show_descendants(self):
        info("Children Process Information")
        children = self.get_children_pids(get_pid())
        if not children:
            gef_print("  No child process")
            return

        for child_pid in children:
            state = self.get_state_of(child_pid)
            pid = state["Pid"]
            pid_path = self.get_process_path_of(pid)
            pid_cmdline = self.get_cmdline_of(pid)
            gef_print("  {:32s} {} {} (Name: '{}', CmdLine: '{}')".format("PID", RIGHT_ARROW, pid, pid_path, pid_cmdline))
        return

    def show_info_thread(self):
        info("Thread Information")
        pid = get_pid()
        gef_print("  {:32s} {} {}".format("Num of Threads", RIGHT_ARROW, self.get_state_of(pid)['Threads']))
        gef_print("  {:32s} {} {}".format("Thread Group ID", RIGHT_ARROW, self.get_state_of(pid)['Tgid']))
        tids = self.get_thread_ids(pid)
        split = 8
        if len(tids) <= split:
            gef_print("  {:32s} {} {}".format("Thread ID List", RIGHT_ARROW, tids))
        else:
            gef_print("  {:32s} {} {}".format("Thread ID List", RIGHT_ARROW, tids[:split]))
            for i in range(split, len(tids), split):
                gef_print("  {:32s} {} {}".format("", RIGHT_ARROW, tids[i:i + split]))
        return

    def show_info_proc_ns(self):
        info("Process Information in Namespace")
        pid = get_pid()
        if len(self.get_state_of(pid)['NSpid'].split()) == 1:
            gef_print("  No namespace")
            return
        state = self.get_state_of(pid)
        gef_print("  {:32s} {} {}".format("Host PID  : Namespace PID", RIGHT_ARROW, re.sub(r"\s+", " : ", state['NSpid'])))
        gef_print("  {:32s} {} {}".format("Host PGID : Namespace PGID", RIGHT_ARROW, re.sub(r"\s+", " : ", state['NSpgid'])))
        gef_print("  {:32s} {} {}".format("Host SID  : Namespace SID", RIGHT_ARROW, re.sub(r"\s+", " : ", state['NSsid'])))
        gef_print("  {:32s} {} {}".format("Host TGID : Namespace TGID", RIGHT_ARROW, re.sub(r"\s+", " : ", state['NStgid'])))
        for u in self.get_uid_map(pid):
            gef_print("  {:32s} {} [{} : {} : {}]".format("UID_MAP [NS : Host : Range]", RIGHT_ARROW, u[0], u[1], u[2]))
        for g in self.get_gid_map(pid):
            gef_print("  {:32s} {} [{} : {} : {}]".format("GID_MAP [NS : Host : Range]", RIGHT_ARROW, g[0], g[1], g[2]))
        return

    def show_fds(self):
        pid = get_pid()
        path = "/proc/{:d}/fd".format(pid)

        info("File Descriptors:")
        gef_print("  {:32s} {} {}".format("Num of FD slots", RIGHT_ARROW, self.get_state_of(pid)['FDSize']))
        items = os.listdir(path)
        if not items:
            gef_print("  No FD opened")
            return

        for fname in items:
            fullpath = os.path.join(path, fname)
            if os.path.islink(fullpath):
                gef_print("  {:32s} {:s} {:s}".format(fullpath, RIGHT_ARROW, os.readlink(fullpath)))
        return

    def list_sockets(self, pid):
        sockets = []
        path = "/proc/{:d}/fd".format(pid)
        items = os.listdir(path)
        for fname in items:
            fullpath = os.path.join(path, fname)
            if os.path.islink(fullpath) and os.readlink(fullpath).startswith("socket:"):
                p = os.readlink(fullpath).replace("socket:", "")[1:-1]
                sockets.append(int(p))
        return sockets

    def parse_ip_port(self, addr):
        ip, port = addr.split(":")
        return socket.inet_ntoa(struct.pack("<I", int(ip, 16))), int(port, 16)

    def show_connections(self):
        # https://github.com/torvalds/linux/blob/v4.7/include/net/tcp_states.h#L16
        tcp_states_str = {
            0x01: "TCP_ESTABLISHED",
            0x02: "TCP_SYN_SENT",
            0x03: "TCP_SYN_RECV",
            0x04: "TCP_FIN_WAIT1",
            0x05: "TCP_FIN_WAIT2",
            0x06: "TCP_TIME_WAIT",
            0x07: "TCP_CLOSE",
            0x08: "TCP_CLOSE_WAIT",
            0x09: "TCP_LAST_ACK",
            0x0A: "TCP_LISTEN",
            0x0B: "TCP_CLOSING",
            0x0C: "TCP_NEW_SYN_RECV",
        }

        udp_states_str = {
            0x07: "UDP_LISTEN",
        }

        info("Network Connections")
        pid = get_pid()
        sockets = self.list_sockets(pid)
        if not sockets:
            gef_print("  No open connections")
            return

        entries = {}
        entries["TCP"] = [x.split() for x in open("/proc/{:d}/net/tcp".format(pid), "r").readlines()[1:]]
        entries["UDP"] = [x.split() for x in open("/proc/{:d}/net/udp".format(pid), "r").readlines()[1:]]

        for proto in entries:
            for entry in entries[proto]:
                local, remote, state = entry[1:4]
                inode = int(entry[9])
                if inode in sockets:
                    local = self.parse_ip_port(local)
                    remote = self.parse_ip_port(remote)
                    state = int(state, 16)
                    state_str = tcp_states_str[state] if proto == "TCP" else udp_states_str[state]

                    conn_local = "{}:{}".format(local[0], local[1])
                    conn_remote = "{}:{}".format(remote[0], remote[1])
                    gef_print("  {:32s} {} {} ({})".format(conn_local, RIGHT_ARROW, conn_remote, state_str))
        return


@register_command
class CapabilityCommand(GenericCommand):
    """Show the capabilities of the debugging process."""
    _cmdline_ = "capability"
    _syntax_ = "{:s} [-v]".format(_cmdline_)
    _category_ = "Process Information"

    def get_thread_ids(self, pid):
        try:
            tids = os.listdir("/proc/{}/task".format(pid))
            return [int(x) for x in tids]
        except Exception:
            return []

    def print_cap_details(self, name, cap):
        bit_info = [
            [40, "CAP_CHECKPOINT_RESTORE", "Update /proc/sys/kernel/ns_last_pid; read /proc/[another_pid]/map_files; etc.", ""],
            [39, "CAP_BPF", "Allow privileged BPF operations", ""],
            [38, "CAP_PERFMON", "Allow various performance-monitoring mechanisms; allow perf_event_open(2); allow some BPF operations", ""],
            [37, "CAP_AUDIT_READ", "Allow reading the audit log via a multicast netlink socket", ""],
            [36, "CAP_BLOCK_SUSPEND", "Allow features that can block system suspend", ""],
            [35, "CAP_WAKE_ALARM", "Trigger something that will wake up the system", ""],
            [34, "CAP_SYSLOG", "Allow privileged syslog(2) operations; View kernel addresses exposed via /proc even if kptr_restrict=1", ""],
            [33, "CAP_MAC_ADMIN", "Allow MAC configuration or state changes", ""],
            [32, "CAP_MAC_OVERRIDE", "Override MAC", ""],
            [31, "CAP_SETFCAP", "Set arbitrary capabilities on a file", ""],
            [30, "CAP_AUDIT_CONTROL", "Enable/disable kernel audit; change audit filter rules; retrieve audit status and filter rules", ""],
            [29, "CAP_AUDIT_WRITE", "Write records to kernel audit log", ""],
            [28, "CAP_LEASE", "Establish leases", ""],
            [27, "CAP_MKNOD", "Create special files using mknod(2)", ""],
            [26, "CAP_SYS_TTY_CONFIG", "Allow vhangup(2); allow various privileged ioctl(2) operations on virtual terminals", ""],
            [25, "CAP_SYS_TIME", "Set system cloc; set real-time (hardware) clock", ""],
            [24, "CAP_SYS_RESOURCE", "Override disk quota limits; override RLIMIT_NPROC resource limit; etc.", ""],
            [23, "CAP_SYS_NICE", "Lower the process nice value and change the nice value for arbitrary processes; etc.", ""],
            [22, "CAP_SYS_BOOT", "Allow reboot(2) and kexec_load(2)", ""],
            [21, "CAP_SYS_ADMIN", "Allow various privileges operations", ""],
            [20, "CAP_SYS_PACCT", "Allow acct(2)", ""],
            [19, "CAP_SYS_PTRACE", "Trace arbitrary processes using ptrace(2); etc.", ""],
            [18, "CAP_SYS_CHROOT", "Allow chroot(2); change mount namespaces using setns(2)", ""],
            [17, "CAP_SYS_RAWIO", "Perform I/O port operations; etc.", ""],
            [16, "CAP_SYS_MODULE", "Load and unload kernel modules", ""],
            [15, "CAP_IPC_OWNER", "Bypass permission checks for operations on SystemV IPC objects", ""],
            [14, "CAP_IPC_LOCK", "Lock memory; allocate memory using huge pages", ""],
            [13, "CAP_NET_RAW", "Use RAW and PACKET sockets; bind to any address for transparent proxying", ""],
            [12, "CAP_NET_ADMIN", "Perform various network-related operations", ""],
            [11, "CAP_NET_BROADCASTE", "(Unused) Make socket broadcasts, and listen to multicast", ""],
            [10, "CAP_NET_BIND_SERVICE", "Bind a socket to Internet domain privileged ports (less than 1024)", ""],
            [9, "CAP_LINUX_IMMUTABLE", "Set the FS_APPEND_FL and FS_IMMUTABLE_FL inode flags", ""],
            [8, "CAP_SETPCAP", "Add any capability from the calling thread's bounding set to its inheritable set; etc.", ""],
            [7, "CAP_SETUID", "Make arbitrary manipulations of process UIDs; etc.", ""],
            [6, "CAP_SETGID", "Make arbitrary manipulations of process GIDs and supplementary GID list; etc.", ""],
            [5, "CAP_KILL", "Bypass permission checks for sending signals", ""],
            [4, "CAP_FSETID", "Don't clear SUID and SGID bits when a file is modified; etc.", ""],
            [3, "CAP_FOWNER", "Bypass permission checks whether FSUID == file UID; set ACLs; etc.", ""],
            [2, "CAP_DAC_READ_SEARCH", "Bypass permission checks of file read, dir read/exec; etc.", ""],
            [1, "CAP_DAC_OVERRIDE", "Bypass permission checks of file read/write/exec", ""],
            [0, "CAP_CHOWN", "Make arbitrary changes to file UIDs and GIDs", ""],
        ]
        PrintBitInfo(name, 64, None, bit_info).print(cap)
        return

    def print_capability_from_pid(self):
        pid = get_pid()
        if pid is None:
            return

        tids = self.get_thread_ids(pid)
        for tid in tids:
            gef_print(titlify("Thread capability set [PID={:d}, TID={:d}]".format(pid, tid)))
            try:
                status_path = "/proc/{:d}/task/{:d}/status".format(pid, tid)
                status = open(status_path, "r").read()
            except Exception:
                err("Failed to get the information of capability from {:s}".format(status_path))
                continue

            caps = {}
            m = re.search(r"CapInh:\s+(.+)", status)
            if m:
                caps["cap_inh"] = int(m.group(1), 16)
            m = re.search(r"CapPrm:\s+(.+)", status)
            if m:
                caps["cap_prm"] = int(m.group(1), 16)
            m = re.search(r"CapEff:\s+(.+)", status)
            if m:
                caps["cap_eff"] = int(m.group(1), 16)
            m = re.search(r"CapBnd:\s+(.+)", status)
            if m:
                caps["cap_bnd"] = int(m.group(1), 16)
            m = re.search(r"CapAmb:\s+(.+)", status)
            if m:
                caps["cap_amb"] = int(m.group(1), 16)

            if "cap_prm" in caps:
                msg = "Capability set that Effective and Inheritable are allowed to have"
                gef_print("Permitted  : {:#018x} - {:s}".format(caps["cap_prm"], msg))
                if self.verbose:
                    self.print_cap_details("cap_prm", caps["cap_prm"])
            if "cap_inh" in caps:
                msg = "Capability set that can be inherited when execve(2)"
                gef_print("Inheritable: {:#018x} - {:s}".format(caps["cap_inh"], msg))
                if self.verbose:
                    self.print_cap_details("cap_inh", caps["cap_inh"])
            if "cap_amb" in caps:
                msg = "Capability set that inherited when execve(2) not suid/sgid program"
                gef_print("Ambient    : {:#018x} - {:s}".format(caps["cap_amb"], msg))
                if self.verbose:
                    self.print_cap_details("cap_amb", caps["cap_amb"])
            if "cap_eff" in caps:
                msg = "Capability set that kernel actually uses to determine privileges"
                gef_print("Effective  : {:#018x} - {:s}".format(caps["cap_eff"], msg))
                self.print_cap_details("cap_eff", caps["cap_eff"])
            if "cap_bnd" in caps:
                msg = "Capability set that limits the capabilities set that can be acquired"
                gef_print("Bounding   : {:#018x} - {:s}".format(caps["cap_bnd"], msg))
                if self.verbose:
                    self.print_cap_details("cap_bnd", caps["cap_bnd"])
        return

    def print_capability_from_file(self):
        filepath = get_filepath()
        if filepath is None:
            return

        gef_print(titlify("File capability set [{:s}]".format(filepath)))
        try:
            raw_caps = os.getxattr(filepath, "security.capability")
        except OSError:
            err("No data available")
            return

        caps = {}
        magic = struct.unpack("<I", raw_caps[:4])[0]
        caps["magic"] = magic & ~1
        caps["cap_eff"] = magic & 1
        if caps["magic"] == 0x01000000:
            cap_prm, cap_inh = struct.unpack("<II", raw_caps[4:12])
        elif caps["magic"] == 0x02000000:
            cap_prm_low, cap_inh_low, cap_prm_high, cap_inh_high = struct.unpack("<IIII", raw_caps[4:20])
            cap_prm = (cap_prm_high << 32) | cap_prm_low
            cap_inh = (cap_inh_high << 32) | cap_inh_low
        elif caps["magic"] == 0x03000000:
            cap_prm_low, cap_inh_low, cap_prm_high, cap_inh_high, rootid = struct.unpack("<IIIII", raw_caps[4:24])
            cap_prm = (cap_prm_high << 32) | cap_prm_low
            cap_inh = (cap_inh_high << 32) | cap_inh_low
            caps["rootid"] = rootid
        else:
            err("Invalid magic values: {:#x}".format(magic))
            return
        caps["cap_prm"] = cap_prm
        caps["cap_inh"] = cap_inh

        if "magic" in caps:
            msg = "Magic number: ver1: 0x01000000, ver2:0x02000000, ver3:0x03000000"
            gef_print("Magic      : {:#010x} - {:s}".format(caps["magic"], msg))
        if "cap_eff" in caps:
            msg = "If 1, new cap_prm are added to new cap_eff after execve(2)"
            gef_print("Effective  : {:#03x} - {:s}".format(caps["cap_eff"], msg))
        if "cap_prm" in caps:
            msg = "Capability set that permitted to the thread, regardless of the thread's cap_inh"
            gef_print("Permitted  : {:#018x} - {:s}".format(caps["cap_prm"], msg))
            if self.verbose:
                self.print_cap_details("cap_prm", caps["cap_prm"])
        if "cap_inh" in caps:
            msg = "Capability set that is ANDed with thread cap_inh to determine cap_inh after execve(2)"
            gef_print("Inheritable: {:#018x} - {:s}".format(caps["cap_inh"], msg))
            if self.verbose:
                self.print_cap_details("cap_inh", caps["cap_inh"])
        if "rootid" in caps:
            msg = "UID of root in user namespace"
            gef_print("Root ID    : {:#010x} - {:s}".format(caps["rootid"], msg))
        return

    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        self.verbose = False
        if "-v" in argv:
            self.verbose = True
            argv.remove("-v")

        self.print_capability_from_pid()
        self.print_capability_from_file()
        return


@register_command
class SmartMemoryDumpCommand(GenericCommand):
    """Smart dump the process memory."""
    _cmdline_ = "smart-memory-dump"
    _syntax_ = _cmdline_
    _category_ = "Misc"

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        pid = get_pid()
        if pid is None:
            err("Failed to get pid")
            return

        maps = get_process_maps()
        if maps is None:
            err("Failed to get maps")
            return

        addr_len = current_arch.ptrsize * 2
        for entry in maps:
            start = entry.page_start
            end = entry.page_end
            perm = str(entry.permission)

            if entry.path in ["[vvar]", "[vsyscall]"]:
                continue

            if not entry.path.startswith("["):
                path = os.path.basename(entry.path)
            else:
                path = entry.path
                path = path.replace("[", "").replace("]", "") # consider [heap], [stack], [vdso]
                path = path.replace("<", "").replace(">", "") # consider under qemu-user. ex: <explored>
                path = path.replace(" ", "_") # consider deleted case. ex: /path/to/file (deleted)

            try:
                data = read_memory(start, end - start)
            except gdb.MemoryError:
                continue

            dumpfile_name = "{:05d}_{:0{}x}-{:0{}x}_{:s}_{:s}.raw".format(pid, start, addr_len, end, addr_len, perm, path)
            open(dumpfile_name, "wb").write(data)
        return


@register_priority_command
class GefThemeCommand(GenericCommand):
    """Customize GEF appearance."""
    _cmdline_ = "theme"
    _syntax_ = "{:s} [KEY [VALUE]]".format(_cmdline_)
    _category_ = "GEF Maintenance Command"

    def __init__(self, *args, **kwargs):
        super().__init__()
        self.add_setting("context_title_line", "gray", "Color of the borders in context window")
        self.add_setting("context_title_message", "cyan", "Color of the title in context window")
        self.add_setting("default_title_line", "gray", "Default color of borders")
        self.add_setting("default_title_message", "cyan", "Default color of title")
        self.add_setting("table_heading", "blue bold", "Color of the column headings to tables (e.g. vmmap)")
        self.add_setting("old_context", "gray", "Color to use to show things such as code that is not immediately relevant")
        self.add_setting("disassemble_current_instruction", "green", "Color to use to highlight the current $pc when disassembling")
        self.add_setting("dereference_string", "yellow", "Color of dereferenced string")
        self.add_setting("dereference_code", "gray", "Color of dereferenced code")
        self.add_setting("dereference_base_address", "cyan", "Color of dereferenced address")
        self.add_setting("dereference_register_value", "bold blue" , "Color of dereferenced register")
        self.add_setting("registers_register_name", "blue", "Color of the register name in the register window")
        self.add_setting("registers_value_changed", "bold red", "Color of the changed register in the register window")
        self.add_setting("address_stack", "pink", "Color to use when a stack address is found")
        self.add_setting("address_heap", "green", "Color to use when a heap address is found")
        self.add_setting("address_code", "red", "Color to use when a code address is found")
        self.add_setting("source_current_line", "green", "Color to use for the current code line in the source window")
        return

    def do_invoke(self, args):
        self.dont_repeat()
        argc = len(args)

        if argc == 0:
            for setting in sorted(self.settings):
                value = self.get_setting(setting)
                value = Color.colorify(value, value)
                gef_print("{:40s}: {:s}".format(setting, value))
            return

        setting = args[0]
        if not self.has_setting(setting):
            err("Invalid key")
            return

        if argc == 1:
            value = self.get_setting(setting)
            value = Color.colorify(value, value)
            gef_print("{:40s}: {:s}".format(setting, value))
            return

        val = [x for x in args[1:] if x in Color.colors]
        self.add_setting(setting, " ".join(val))
        return


@register_command
class ChangeFdCommand(GenericCommand):
    """ChangeFdCommand: redirect file descriptor during runtime."""
    _cmdline_ = "hijack-fd"
    _syntax_ = "{:s} FD_NUM NEW_OUTPUT".format(_cmdline_)
    _example_ = "{:s} 2 /tmp/stderr_output.txt".format(_cmdline_)
    _category_ = "Debugging Support"

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()
        if len(argv) != 2:
            self.usage()
            return

        if not os.access("/proc/{:d}/fd/{:s}".format(get_pid(), argv[0]), os.R_OK):
            self.usage()
            return

        old_fd = int(argv[0])
        new_output = argv[1]

        if ":" in new_output:
            address = socket.gethostbyname(new_output.split(":")[0])
            port = int(new_output.split(":")[1])

            AF_INET = 2
            SOCK_STREAM = 1
            res = gdb.execute("""call (int)socket({}, {}, 0)""".format(AF_INET, SOCK_STREAM), to_string=True)
            new_fd = self.get_fd_from_result(res)

            # fill in memory with sockaddr_in struct contents
            # we will do this in the stack, since connect() wants a pointer to a struct
            vmmap = get_process_maps()
            stack_addr = [entry.page_start for entry in vmmap if entry.path == "[stack]"][0]
            original_contents = read_memory(stack_addr, 8)

            write_memory(stack_addr, "\x02\x00", 2)
            write_memory(stack_addr + 0x2, struct.pack("<H", socket.htons(port)), 2)
            write_memory(stack_addr + 0x4, socket.inet_aton(address), 4)

            info("Trying to connect to {}".format(new_output))
            res = gdb.execute("""call (int)connect({}, {}, {})""".format(new_fd, stack_addr, 16), to_string=True)

            # recover stack state
            write_memory(stack_addr, original_contents, 8)

            res = self.get_fd_from_result(res)
            if res == -1:
                err("Failed to connect to {}:{}".format(address, port))
                return

            info("Connected to {}".format(new_output))
        else:
            res = gdb.execute("""call (int)open("{:s}", 66, 0666)""".format(new_output), to_string=True)
            new_fd = self.get_fd_from_result(res)

        info("Opened '{:s}' as fd #{:d}".format(new_output, new_fd))
        gdb.execute("""call (int)dup2({:d}, {:d})""".format(new_fd, old_fd), to_string=True)
        info("Duplicated fd #{:d}{:s}#{:d}".format(new_fd, RIGHT_ARROW, old_fd))
        gdb.execute("""call (int)close({:d})""".format(new_fd), to_string=True)
        info("Closed extra fd #{:d}".format(new_fd))
        ok("Success")
        return

    def get_fd_from_result(self, res):
        # Output example: $1 = 3
        res = int(res.split()[2], 0)
        res = gdb.execute("""p/d {}""".format(res), to_string=True)
        res = int(res.split()[2], 0)
        return res


@register_command
class ScanSectionCommand(GenericCommand):
    """Search for addresses that are located in a memory mapping (haystack) that belonging
    to another (needle)."""
    _cmdline_ = "scan"
    _syntax_ = "{:s} HAYSTACK NEEDLE".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} stack binary # scan binary address from stack\n".format(_cmdline_)
    _example_ += "{:s} stack libc # scan libc address from stack\n".format(_cmdline_)
    _example_ += "{:s} stack heap # scan heap address from stack\n".format(_cmdline_)
    _example_ += "{:s} heap libc # scan libc address from heap\n".format(_cmdline_)
    _example_ += "{:s} 0x0000555555772000-0x0000555555774000 libc".format(_cmdline_)
    _category_ = "Show/Modify Memory"
    _aliases_ = ["lookup"]

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()
        if len(argv) != 2:
            self.usage()
            return

        haystack = argv[0]
        needle = argv[1]

        info("Searching for addresses in '{:s}' that point to '{:s}'"
             .format(Color.yellowify(haystack), Color.yellowify(needle)))

        if haystack in ["binary", "bin"]:
            haystack = get_filepath(for_vmmap=True)

        if needle in ["binary", "bin"]:
            needle = get_filepath(for_vmmap=True)

        needle_sections = []
        haystack_sections = []

        if "0x" in haystack:
            try:
                start, end = parse_string_range(haystack)
                haystack_sections.append((start, end, ""))
            except Exception:
                pass

        if "0x" in needle:
            try:
                start, end = parse_string_range(needle)
                needle_sections.append((start, end))
            except Exception:
                pass

        for sect in get_process_maps():
            if haystack in sect.path:
                haystack_sections.append((sect.page_start, sect.page_end, os.path.basename(sect.path)))
            if needle in sect.path:
                needle_sections.append((sect.page_start, sect.page_end))

        step = current_arch.ptrsize
        unpack = u32 if step == 4 else u64

        for hstart, hend, hname in haystack_sections:
            try:
                mem = read_memory(hstart, hend - hstart)
            except gdb.MemoryError:
                continue

            for i in range(0, len(mem), step):
                target = unpack(mem[i:i + step])
                for nstart, nend in needle_sections:
                    if not (nstart <= target < nend):
                        continue
                    deref = to_string_dereference_from(hstart + i)
                    if hname != "":
                        name = Color.colorify(hname, "yellow")
                        gef_print("{:s}: {:s}".format(name, deref))
                    else:
                        gef_print(" {:s}".format(deref))
        return


@register_command
class SearchPatternCommand(GenericCommand):
    """SearchPatternCommand: search a pattern in memory. If given an hex value (starting with 0x)
    the command will also try to look for upwards cross-references to this address."""
    _cmdline_ = "search-pattern"
    _syntax_ = "{:s} [-h] PATTERN|--hex=PATTERN [little|big] [section] [--aligned N] [-v] [--disable-utf16]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} AAAAAAAA # search 'AAAAAAAA' from whole memory\n".format(_cmdline_)
    _example_ += "{:s} 0x555555554000 little stack # search 0x555555554000 (6byte) from stack\n".format(_cmdline_)
    _example_ += "{:s} 0x0000555555554000 little stack # search 0x0000555555554000 (8byte) from stack\n".format(_cmdline_)
    _example_ += "{:s} 0x079ee018 little 0x600000-0x601000 # hex must start by '0x' with ** 0-padding **\n".format(_cmdline_)
    _example_ += "{:s} AAAA little binary # 'binary' means executable mapped area itself (supported only usermode)\n".format(_cmdline_)
    _example_ += "{:s} AAAA little heap --aligned 16 # search with aligned\n".format(_cmdline_)
    _example_ += "{:s} --hex=\"00 00 00 00\" little stack # another valid format (invalid char is ignored)\n".format(_cmdline_)
    _example_ += "{:s} AAAA -v # verbose output".format(_cmdline_)
    _category_ = "Show/Modify Memory"
    _aliases_ = ["find"]

    def print_section(self, section):
        if isinstance(section, Address):
            section = section.section

        if section is None:
            return

        title = "In "
        if section.path:
            title += "'{}' ".format(Color.blueify(section.path))

        title += "({:#x}-{:#x} [{}])".format(section.page_start, section.page_end, section.permission)
        ok(title)
        return

    def print_loc(self, loc):
        if self.aligned and loc[0] % self.aligned:
            return
        gef_print('''  {:#x} - {:#x} {}  "{}"'''.format(loc[0], loc[1], RIGHT_ARROW, Color.pinkify(loc[2]),))
        return

    def search_pattern_by_address(self, pattern, start_address, end_address):
        """Search a pattern within a range defined by arguments."""
        pattern = gef_pybytes(pattern)
        if is_qemu_system():
            step = gef_getpagesize()
        else:
            step = 0x400 * gef_getpagesize()
        locations = []

        for chunk_addr in range(start_address, end_address, step):
            if chunk_addr + step > end_address:
                chunk_size = end_address - chunk_addr
            else:
                chunk_size = step

            try:
                mem = read_memory(chunk_addr, chunk_size)
            except gdb.MemoryError:
                # cannot access memory this range. It doesn't make sense to try any more
                break

            for match in re.finditer(pattern, mem):
                start = chunk_addr + match.start()
                ustr = gef_pystring(pattern)
                end = start + len(pattern.decode("unicode-escape"))
                locations.append((start, end, ustr))
            del mem
        return locations

    @staticmethod
    def get_process_maps_qemu_system():
        res = get_maps_by_pagewalk("pagewalk -q")
        res = sorted(set(res.splitlines()))
        res = list(filter(lambda line: line.endswith("]"), res))
        res = list(filter(lambda line: "[+]" not in line, res))
        res = list(filter(lambda line: "*" not in line, res))
        for line in res:
            if is_x86() and "ACCESSED" not in line:
                continue
            lines = line.split()
            addr_start, addr_end = [int(x, 16) for x in lines[0].split("-")]
            if is_x86():
                perm = Permission.from_process_maps(lines[5][1:].lower())
            elif is_arm32():
                perm = line.split("/")[-1][:3]
                perm = Permission.from_process_maps(perm.lower())
            elif is_arm64():
                if 0xffff000008010000 <= addr_start < 0xffff000008020000 : # qemu process will be die if touch
                    continue
                if 0xffff000008030000 <= addr_start < 0xffff000008040000 : # qemu process will be die if touch
                    continue
                perm = line.split("/")[-1][:3]
                perm = Permission.from_process_maps(perm.lower())
            yield Section(page_start=addr_start, page_end=addr_end, permission=perm, path="")

    def search_pattern(self, pattern, section_name):
        """Search a pattern within the whole userland memory."""
        if is_qemu_system():
            maps_generator = self.get_process_maps_qemu_system()
        else:
            maps_generator = get_process_maps()

        for section in maps_generator:
            if not section.permission & Permission.READ:
                continue
            if section.path == "[vvar]":
                continue
            if section_name not in section.path:
                continue

            if self.verbose:
                self.print_section(section) # verbose: always print section before search

            start = section.page_start
            end = section.page_end
            ret = self.search_pattern_by_address(pattern, start, end) # search

            if ret:
                if not self.verbose:
                    self.print_section(section) # default: print section if found

            for loc in ret:
                self.print_loc(loc)

            if not is_alive():
                err("The process is dead")
                break
        return

    def isascii(self, string):
        val = codecs.escape_decode(string)[0]
        return all([0x20 <= c < 0x7f for c in val])

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        self.verbose = False
        if "-v" in argv:
            self.verbose = True
            argv.remove("-v")

        self.aligned = None
        if "--aligned" in argv:
            idx = argv.index("--aligned")
            self.aligned = int(argv[idx + 1])
            argv = argv[:idx] + argv[idx + 2:]

        self.disable_utf16 = False
        if "--disable-utf16" in argv:
            self.disable_utf16 = True
            argv.remove("--disable-utf16")

        if len(argv) < 1:
            self.usage()
            return

        # endianness
        if len(argv) >= 2:
            if argv[1].lower() == "big":
                endian = Elf.BIG_ENDIAN
            elif argv[1].lower() == "little":
                endian = Elf.LITTLE_ENDIAN
            else:
                self.usage()
                return
        else:
            endian = get_endian()

        # pattern replace
        pattern = argv[0]
        if pattern.startswith("--hex="): # "--hex=41414141" -> "\x41\x41\x41\x41"
            _pattern = ""
            for c in pattern[6:].lower():
                if c in '0123456789abcdef':
                    _pattern += c
            if len(_pattern) % 2 != 0:
                self.usage()
                return
            pattern = "".join(["\\x" + _pattern[i:i + 2] for i in range(0, len(_pattern), 2)])
        elif is_hex(pattern): # "0x41414141" -> "\x41\x41\x41\x41"
            if endian == Elf.BIG_ENDIAN:
                pattern = "".join(["\\x" + pattern[i:i + 2] for i in range(2, len(pattern), 2)])
            else:
                pattern = "".join(["\\x" + pattern[i:i + 2] for i in range(len(pattern) - 2, 0, -2)])

        # create utf16 pattern
        pattern_utf16 = None
        if not self.disable_utf16 and self.isascii(pattern):
            pattern_utf16 = "".join([x + "\\x00" for x in pattern])

        if len(argv) == 3:
            if re.match(r"(0x)?[0-9a-fA-F]+-(0x)?[0-9a-fA-F]+", argv[2]):
                # specified range -> call search_pattern_by_address directly
                search_area = argv[2]
                info("Searching '{:s}' in {:s}".format(Color.yellowify(pattern), search_area))
                start, end = parse_string_range(search_area)

                loc = lookup_address(start)
                if loc.valid:
                    if self.verbose:
                        self.print_section(loc) # verbose: always print section before search
                else:
                    err("Not found valid memory area")
                    return

                ret = self.search_pattern_by_address(pattern, start, end) # search

                if ret and not self.verbose:
                    self.print_section(loc) # default: print section if found

                for found_loc in ret:
                    self.print_loc(found_loc)

                if pattern_utf16 is not None:
                    info("Searching '{:s}' in {:s}".format(Color.yellowify(pattern_utf16), search_area))
                    ret = self.search_pattern_by_address(pattern_utf16, start, end)
                    for found_loc in ret:
                        self.print_loc(found_loc)
            else:
                # section name -> call search wrapper
                section_name = argv[2]
                if section_name in ["binary", "bin"] and not is_qemu_system():
                    section_name = get_filepath(for_vmmap=True)

                info("Searching '{:s}' in {:s}".format(Color.yellowify(pattern), section_name))
                self.search_pattern(pattern, section_name)

                if pattern_utf16 is not None:
                    info("Searching '{:s}' in {:s}".format(Color.yellowify(pattern_utf16), section_name))
                    self.search_pattern(pattern_utf16, section_name)
        else:
            # whole memory -> call search wrapper
            info("Searching '{:s}' in memory".format(Color.yellowify(pattern)))
            self.search_pattern(pattern, "")
            if pattern_utf16 is not None:
                info("Searching '{:s}' in memory".format(Color.yellowify(pattern_utf16)))
                self.search_pattern(pattern_utf16, "")
        return


@register_command
class DemanglePtrCommand(GenericCommand):
    """Demangle a mangled value by PTR_MANGLE."""
    _cmdline_ = "ptr-demangle"
    _syntax_ = "{:s} [-h] VALUE|--source".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    @staticmethod
    def get_cookie():
        if is_x86_64():
            tls = TlsCommand.getfs()
            cookie = read_int_from_memory(tls + 0x30)
        elif is_x86_32():
            tls = TlsCommand.getgs()
            cookie = read_int_from_memory(tls + 0x18)
        elif is_arm32() or is_arm64():
            if is_arm32():
                try:
                    tls = parse_address("(unsigned int)__aeabi_read_tp()")
                except Exception:
                    err("Not found symbol (__aeabi_read_tp)")
                    return None
            else:
                try:
                    tls = get_register("$TPIDR_EL0")
                except Exception:
                    err("Fail reading $TPIDR_EL0 register")
                    return None
            try:
                cookie_ptr = parse_address("&__pointer_chk_guard_local")
            except Exception:
                err("Not found symbol (__pointer_chk_guard_local)")
                return None
            cookie = read_int_from_memory(cookie_ptr)
        return cookie

    @staticmethod
    def decode(value, cookie):
        def ror(val, bits, arch_bits):
            new_val = (val >> bits) | (val << (arch_bits - bits))
            mask = (1 << arch_bits) - 1
            return new_val & mask

        if is_x86_64():
            decoded = ror(value, 17, 64) ^ cookie
        elif is_x86_32():
            decoded = ror(value, 9, 32) ^ cookie
        elif is_arm32() or is_arm64():
            decoded = value ^ cookie
        return decoded

    @only_if_gdb_running
    @only_if_specific_arch(arch=["x86_32", "x86_64", "ARM32", "ARM64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        if "--source" in argv:
            s = inspect.getsource(self.decode).rstrip()
            gef_print(s)
            return

        cookie = self.get_cookie()
        if cookie is None:
            return
        info("Cookie is {:#x}".format(cookie))

        try:
            target = int(argv[0], 0)
        except Exception:
            self.usage()
            return
        decoded = self.decode(target, cookie)
        color_decoded = Color.colorify("{:#x}".format(decoded), "white bold")
        decoded_sym = get_symbol_string(decoded)
        try:
            read_memory(decoded, 1)
            valid_msg = Color.colorify("valid", "bold green")
        except gdb.MemoryError:
            valid_msg = Color.colorify("invalid", "bold red")
        info("Decoded value is {:s}{:s} [{:s}]".format(color_decoded, decoded_sym, valid_msg))
        return


@register_command
class SearchMangledPtrCommand(GenericCommand):
    """Search a mangled pointer value in memory."""
    _cmdline_ = "search-mangled-ptr"
    _syntax_ = "{:s} [-h] [-v]".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def print_section(self, section):
        if isinstance(section, Address):
            section = section.section

        if section is None:
            return

        title = "In "
        if section.path:
            title += "'{}' ".format(Color.blueify(section.path))

        title += "({:#x}-{:#x} [{}])".format(section.page_start, section.page_end, section.permission)
        ok(title)
        return

    def print_loc(self, loc):
        addr, value, decoded = loc[0], loc[1], loc[2]
        addr_sym = get_symbol_string(addr)
        decoded_sym = get_symbol_string(decoded)
        try:
            read_memory(decoded, 1)
            valid_msg = Color.colorify("valid", "bold green")
        except gdb.MemoryError:
            valid_msg = Color.colorify("invalid", "bold red")
        decoded = Color.colorify("{:#x}".format(decoded), "white bold")
        gef_print("  {:#x}{:s}: {:#x} (={:s}{:s}) [{:s}]".format(addr, addr_sym, value, decoded, decoded_sym, valid_msg))
        return

    def search_mangled_ptr(self, start_address, end_address):
        """Search a mangled pointer within a range defined by arguments."""
        if is_qemu_system():
            step = gef_getpagesize()
        else:
            step = 0x400 * gef_getpagesize()
        locations = []

        for chunk_addr in range(start_address, end_address, step):
            if chunk_addr + step > end_address:
                chunk_size = end_address - chunk_addr
            else:
                chunk_size = step

            try:
                mem = read_memory(chunk_addr, chunk_size)
            except gdb.MemoryError:
                # cannot access memory this range. It doesn't make sense to try any more
                break

            for i, value in enumerate(slice_unpack(mem, current_arch.ptrsize)):
                decoded = DemanglePtrCommand.decode(value, self.cookie)
                try:
                    read_memory(decoded, 1)
                except gdb.MemoryError:
                    continue
                addr = chunk_addr + i * current_arch.ptrsize
                locations.append((addr, value, decoded))
            del mem
        return locations

    @only_if_gdb_running
    @only_if_specific_arch(arch=["x86_32", "x86_64", "ARM32", "ARM64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        self.verbose = False
        if "-v" in argv:
            self.verbose = True
            argv.remove("-v")

        # init
        self.cookie = DemanglePtrCommand.get_cookie()
        if self.cookie is None:
            return
        info("Cookie is {:#x}".format(self.cookie))

        # search
        if is_qemu_system():
            maps_generator = self.get_process_maps_qemu_system()
        else:
            maps_generator = get_process_maps()
        for section in maps_generator:
            if not section.permission & Permission.READ:
                continue
            if not section.permission & Permission.WRITE:
                continue
            if self.verbose:
                self.print_section(section) # verbose: always print section before search

            start = section.page_start
            end = section.page_end
            ret = self.search_mangled_ptr(start, end)

            if ret:
                if not self.verbose:
                    self.print_section(section) # default: print section if found

            for loc in ret:
                self.print_loc(loc)

            if not is_alive():
                err("The process is dead")
                break
        return


@register_command
class FlagsCommand(GenericCommand):
    """Edit flags in a human friendly way."""
    _cmdline_ = "edit-flags"
    _syntax_ = "{:s} [(+|-|~)FLAGNAME ...] [-v] [-h]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s}\n".format(_cmdline_)
    _example_ += "{:s} +zero # sets ZERO flag\n".format(_cmdline_)
    _example_ += "{:s} -direction # unsets DIRECTION flag\n".format(_cmdline_)
    _example_ += "{:s} ~sign # toggle SIGN flag\n".format(_cmdline_)
    _example_ += "{:s} -v # print verbose".format(_cmdline_)
    _category_ = "Show/Modify Register"
    _aliases_ = ["flags"]

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        self.verbose = False
        if "-v" in argv:
            self.verbose = True
            argv.remove("-v")

        for flag in argv:
            if len(flag) < 2:
                continue

            action = flag[0]
            if action not in ("+", "-", "~"):
                err("Invalid action for flag '{:s}'".format(flag))
                continue

            name = flag[1:].lower()

            if is_x86():
                dic = {
                    "id": "identification",
                    "ac": "align",
                    "vm": "virtualx86",
                    "rf": "resume",
                    "nt": "nested",
                    "of": "overflow",
                    "df": "direction",
                    "if": "interrupt",
                    "tf": "trap",
                    "sf": "sign",
                    "zf": "zero",
                    "af": "adjust",
                    "pf": "parity",
                    "cf": "carry",
                }
                if name in dic:
                    name = dic[name]

            if name not in current_arch.flags_table.values():
                err("Invalid flag name '{:s}'".format(flag[1:]))
                continue

            for off in current_arch.flags_table:
                if current_arch.flags_table[off] == name:
                    old_flag = get_register(current_arch.flag_register)
                    if action == "+":
                        new_flags = old_flag | (1 << off)
                    elif action == "-":
                        new_flags = old_flag & ~(1 << off)
                    else:
                        new_flags = old_flag ^ (1 << off)

                    gdb.execute("set ({:s}) = {:#x}".format(current_arch.flag_register, new_flags))

        gef_print(current_arch.flag_register_to_human())
        if self.verbose:
            if is_x86():
                self.verbose_x86()
            elif is_arm32():
                self.verbose_arm32()
            elif is_arm64():
                self.verbose_arm64()
        return

    def bits_split(self, x, bits=32):
        out = ""
        for i in range(bits):
            if x & (1 << i):
                out = "1" + out
            else:
                out = "0" + out
            if i % 4 == 3:
                out = "_" + out
        return "0b" + out[1:]

    def verbose_x86(self):
        eflags = get_register("$eflags")
        gef_print("{:s}  {:s}".format(self.bits_split(eflags), Color.colorify("MASK", "bold")))

        def c(msg):
            mask = int(msg.split()[0], 16)
            color = ["bold", ""][(eflags & mask) == 0]
            return Color.colorify(msg, color)

        gef_print(" " * 14 + "|| |||| |||| |||| |||| |||+- " + c("0x000001 [CF]   Carry flag"))
        gef_print(" " * 14 + "|| |||| |||| |||| |||| ||+-- " + c("0x000002        Reserved (always 1)"))
        gef_print(" " * 14 + "|| |||| |||| |||| |||| |+--- " + c("0x000004 [PF]   Parity flag"))
        gef_print(" " * 14 + "|| |||| |||| |||| |||| +---- " + c("0x000008        Reserved (always 0)"))
        gef_print(" " * 14 + "|| |||| |||| |||| ||||")
        gef_print(" " * 14 + "|| |||| |||| |||| |||+------ " + c("0x000010 [AF]   Adjust flag (for BCD calc)"))
        gef_print(" " * 14 + "|| |||| |||| |||| ||+------- " + c("0x000020        Reserved (always 0)"))
        gef_print(" " * 14 + "|| |||| |||| |||| |+-------- " + c("0x000040 [ZF]   Zero flag"))
        gef_print(" " * 14 + "|| |||| |||| |||| +--------- " + c("0x000080 [SF]   Sign flag"))
        gef_print(" " * 14 + "|| |||| |||| ||||")
        gef_print(" " * 14 + "|| |||| |||| |||+----------- " + c("0x000100 [TF]   Trap flag (single step)"))
        gef_print(" " * 14 + "|| |||| |||| ||+------------ " + c("0x000200 [IF]   Interrupt enable flag"))
        gef_print(" " * 14 + "|| |||| |||| |+------------- " + c("0x000400 [DF]   Direction flag"))
        gef_print(" " * 14 + "|| |||| |||| +-------------- " + c("0x000800 [OF]   Overflow flag"))
        gef_print(" " * 14 + "|| |||| ||||")
        gef_print(" " * 14 + "|| |||| ||++---------------- " + c("0x003000 [IOPL] I/O privilege level (2bit)"))
        gef_print(" " * 14 + "|| |||| |+------------------ " + c("0x004000 [NT]   Nested task flag"))
        gef_print(" " * 14 + "|| |||| +------------------- " + c("0x008000        Reserved (always 0)"))
        gef_print(" " * 14 + "|| ||||")
        gef_print(" " * 14 + "|| |||+--------------------- " + c("0x010000 [RF]   Resume flag"))
        gef_print(" " * 14 + "|| ||+---------------------- " + c("0x020000 [VM]   Virtual 8086 mode flag"))
        gef_print(" " * 14 + "|| |+----------------------- " + c("0x040000 [AC]   Alignment check flag"))
        gef_print(" " * 14 + "|| +------------------------ " + c("0x080000 [VIF]  Virtual interrupt flag"))
        gef_print(" " * 14 + "||")
        gef_print(" " * 14 + "|+-------------------------- " + c("0x100000 [VIP]  Virtual interrupt pending"))
        gef_print(" " * 14 + "+--------------------------- " + c("0x200000 [ID]   Able to use CPUID instruction"))
        return

    def verbose_arm32(self):
        cpsr = get_register("$cpsr")
        gef_print("{:s}  {:s}".format(self.bits_split(cpsr), Color.colorify("MASK", "bold")))

        def c(msg):
            mask = int(msg.split()[0], 16)
            color = ["bold", ""][(cpsr & mask) == 0]
            return Color.colorify(msg, color)

        gef_print("  |||| |||| |||| |||| |||| |||| |||+-++++- " + c("0x0000001f [M]  Mode field (5bit)"))
        gef_print("  |||| |||| |||| |||| |||| |||| |||        " + "  User:0b10000 FIQ:0b10001 IRQ:0b10010")
        gef_print("  |||| |||| |||| |||| |||| |||| |||        " + "  Supervisor:0b10011 Monitor:0b10110 Abort:0b10111")
        gef_print("  |||| |||| |||| |||| |||| |||| |||        " + "  Hyp:0b11010 Undefined:0b11011 System:0b11111")
        gef_print("  |||| |||| |||| |||| |||| |||| |||")
        gef_print("  |||| |||| |||| |||| |||| |||| ||+------- " + c("0x00000020 [T]  Thumb execution state bit"))
        gef_print("  |||| |||| |||| |||| |||| |||| |+-------- " + c("0x00000040 [F]  FIQ mask bit"))
        gef_print("  |||| |||| |||| |||| |||| |||| +--------- " + c("0x00000080 [I]  IRQ mask bit"))
        gef_print("  |||| |||| |||| |||| |||| ||||")
        gef_print("  |||| |||| |||| |||| |||| |||+----------- " + c("0x00000100 [A]  Asynchronous abort mask bit"))
        gef_print("  |||| |||| |||| |||| |||| ||+------------ " + c("0x00000200 [E]  Endianness execution state bit"))
        gef_print("  |||| |++------------++++-++------------- " + c("0x0600fc00 [IT] If-Then execution state bits for Thumb IT instruction"))
        gef_print("  |||| |  | |||| ||||")
        gef_print("  |||| |  | |||| ++++--------------------- " + c("0x000f0000 [GE] Greater than or Equal flags for SIMD instruction"))
        gef_print("  |||| |  | ||||")
        gef_print("  |||| |  | ++++-------------------------- " + c("0x00f00000      Reserved"))
        gef_print("  |||| |  |")
        gef_print("  |||| |  +------------------------------- " + c("0x01000000 [J]  Jazelle bit"))
        gef_print("  |||| +---------------------------------- " + c("0x08000000 [Q]  Cumulative saturation bit"))
        gef_print("  ||||")
        gef_print("  |||+------------------------------------ " + c("0x10000000 [V]  Overflow condition flag"))
        gef_print("  ||+------------------------------------- " + c("0x20000000 [C]  Carry condition flag"))
        gef_print("  |+-------------------------------------- " + c("0x40000000 [Z]  Zero condition flag"))
        gef_print("  +--------------------------------------- " + c("0x80000000 [N]  Negative condition flag"))
        return

    def verbose_arm64(self):
        cpsr = get_register("$cpsr")
        gef_print("{:s}  {:s}".format(self.bits_split(cpsr), Color.colorify("MASK", "bold")))

        def c(msg):
            mask = int(msg.split()[0], 16)
            color = ["bold", ""][(cpsr & mask) == 0]
            return Color.colorify(msg, color)

        if ((cpsr >> 4) & 1) == 0: # AArch64 state
            gef_print("  |||| |||| |||| |||| |||| |||| |||| ||++- " + c("0x00000003 [M.SP]  Selected stack pointer (2bit)"))
            gef_print("  |||| |||| |||| |||| |||| |||| |||| ++--- " + c("0x0000000c [M.EL]  Exception level (2bit)"))
            gef_print("  |||| |||| |||| |||| |||| |||| ||||")
            gef_print("  |||| |||| |||| |||| |||| |||| |||+------ " + c("0x00000010 [M.S]   Execution state (AArch64:0, AArch32:1)"))
            gef_print("  |||| |||| |||| |||| |||| |||| ||+------- " + c("0x00000020         Reserved (always 0)"))
            gef_print("  |||| |||| |||| |||| |||| |||| |+-------- " + c("0x00000040 [F]     FIQ interrupt mask bit"))
            gef_print("  |||| |||| |||| |||| |||| |||| +--------- " + c("0x00000080 [I]     IRQ interrupt mask bit"))
            gef_print("  |||| |||| |||| |||| |||| ||||")
            gef_print("  |||| |||| |||| |||| |||| |||+----------- " + c("0x00000100 [A]     SError interrupt mask bit"))
            gef_print("  |||| |||| |||| |||| |||| ||+------------ " + c("0x00000200 [D]     Debug exception mask bit"))
            gef_print("  |||| |||| |||| |||| |||| ++------------- " + c("0x00000c00 [BTYPE] Branch Type Indicator when FEAT_BTI is implemented"))
            gef_print("  |||| |||| |||| |||| ||||")
            gef_print("  |||| |||| |||| |||| |||+---------------- " + c("0x00001000 [SSBS]  Speculative Store Bypass when FEAT_SSBS is implemented"))
            gef_print("  |||| |||| |||| ++++-+++----------------- " + c("0x000fe000         Reserved"))
            gef_print("  |||| |||| ||||")
            gef_print("  |||| |||| |||+-------------------------- " + c("0x00100000 [IL]    Illegal execution state"))
            gef_print("  |||| |||| ||+--------------------------- " + c("0x00200000 [SS]    Software step flag"))
            gef_print("  |||| |||| |+---------------------------- " + c("0x00400000 [PAN]   Privileged Access Never when FEAT_PAN is implemented"))
            gef_print("  |||| |||| +----------------------------- " + c("0x00800000 [UAO]   User Access Override when FEAT_UAO is implemented"))
            gef_print("  |||| ||||")
            gef_print("  |||| |||+------------------------------- " + c("0x01000000 [DIT]   Data Independent Timing when FEAT_DIT is implemented"))
            gef_print("  |||| ||+-------------------------------- " + c("0x02000000 [TCO]   Tag Check Override when FEAT_MTE is implemented"))
            gef_print("  |||| ++--------------------------------- " + c("0x0c000000         Reserved"))
            gef_print("  ||||")
            gef_print("  |||+------------------------------------ " + c("0x10000000 [V]     Overflow condition flag"))
            gef_print("  ||+------------------------------------- " + c("0x20000000 [C]     Carry condition flag"))
            gef_print("  |+-------------------------------------- " + c("0x40000000 [Z]     Zero condition flag"))
            gef_print("  +--------------------------------------- " + c("0x80000000 [N]     Negative condition flag"))
        else: # AArch32 state
            gef_print("  |||| |||| |||| |||| |||| |||| |||| ++++- " + c("0x0000000f [M.A32] AArch32 mode (4bit)"))
            gef_print("  |||| |||| |||| |||| |||| |||| ||||       " + "   User:0b0000 FIQ:0b0001 IRQ:0b0010")
            gef_print("  |||| |||| |||| |||| |||| |||| ||||       " + "   Supervisor:0b0011 Monitor:0b0110 Abort:0b0111")
            gef_print("  |||| |||| |||| |||| |||| |||| ||||       " + "   Hyp:0b1010 Undefined:0b1011 System:0b1111")
            gef_print("  |||| |||| |||| |||| |||| |||| ||||")
            gef_print("  |||| |||| |||| |||| |||| |||| |||+------ " + c("0x00000010 [M.S]   Execution state (AAch64:0, AArch32:1)"))
            gef_print("  |||| |||| |||| |||| |||| |||| ||+------- " + c("0x00000020 [T]     T32 instruction set (Thumb) state bit"))
            gef_print("  |||| |||| |||| |||| |||| |||| |+-------- " + c("0x00000040 [F]     FIQ interrupt mask bit"))
            gef_print("  |||| |||| |||| |||| |||| |||| +--------- " + c("0x00000080 [I]     IRQ interrupt mask bit"))
            gef_print("  |||| |||| |||| |||| |||| ||||")
            gef_print("  |||| |||| |||| |||| |||| |||+----------- " + c("0x00000100 [A]     SError interrupt mask bit"))
            gef_print("  |||| |||| |||| |||| |||| ||+------------ " + c("0x00000200 [E]     Endianness execution state bit"))
            gef_print("  |||| |++------------++++-++------------- " + c("0x0600fc00 [IT]    If-Then execution state bits for Thumb IT instruction"))
            gef_print("  |||| |  | |||| ||||")
            gef_print("  |||| |  | |||| ++++--------------------- " + c("0x000f0000 [GE]    Greater than or Equal flags for SIMD instruction"))
            gef_print("  |||| |  | ||||")
            gef_print("  |||| |  | |||+-------------------------- " + c("0x00100000 [IL]    Illegal execution state"))
            gef_print("  |||| |  | ||+--------------------------- " + c("0x00200000 [SS]    Software step flag"))
            gef_print("  |||| |  | |+---------------------------- " + c("0x00400000 [PAN]   Privileged Access Never when FEAT_PAN is implemented"))
            gef_print("  |||| |  | +----------------------------- " + c("0x00800000 [SSBS]  Speculative Store Bypass when FEAT_SBSS is implemented"))
            gef_print("  |||| |  |")
            gef_print("  |||| |  +------------------------------- " + c("0x01000000 [DIT]   Data Independent Timing when FEAT_DIT is implemented"))
            gef_print("  |||| +---------------------------------- " + c("0x08000000 [Q]     Overflow or saturation flag"))
            gef_print("  ||||")
            gef_print("  |||+------------------------------------ " + c("0x10000000 [V]     Overflow condition flag"))
            gef_print("  ||+------------------------------------- " + c("0x20000000 [C]     Carry condition flag"))
            gef_print("  |+-------------------------------------- " + c("0x40000000 [Z]     Zero condition flag"))
            gef_print("  +--------------------------------------- " + c("0x80000000 [N]     Negative condition flag"))
        return


@register_command
class ChangePermissionCommand(GenericCommand):
    """Change a page permission. By default, it will change it to RWX."""
    _cmdline_ = "set-permission"
    _syntax_ = "{:s} [-h] LOCATION [PERMISSION]".format(_cmdline_)
    _example_ = "{:s} $sp 7".format(_cmdline_)
    _category_ = "Debugging Support"
    _aliases_ = ["mprotect"]

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    @load_keystone
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        if len(argv) not in (1, 2):
            self.usage()
            return

        if len(argv) == 2:
            if re.match(r"[rwx-]{3}", argv[1]):
                perm = Permission.NONE
                if argv[1][0] == "r":
                    perm |= Permission.READ
                if argv[1][1] == "w":
                    perm |= Permission.WRITE
                if argv[1][2] == "x":
                    perm |= Permission.EXECUTE
            else:
                try:
                    perm = int(argv[1])
                except Exception:
                    err("Invalid permission")
                    return
        else:
            perm = Permission.READ | Permission.WRITE | Permission.EXECUTE

        loc = safe_parse_and_eval(argv[0])
        if loc is None:
            err("Invalid address")
            return

        try:
            loc = to_unsigned_long(loc)
        except gdb.error:
            err("Invalid address")
            return

        sect = process_lookup_address(loc)
        if sect is None:
            err("Unmapped address")
            return

        size = sect.page_end - sect.page_start
        original_pc = current_arch.pc
        if is_arm32() and current_arch.is_thumb():
            original_pc -= 1

        fmt = "Generating sys_mprotect({:#x}, {:#x}, '{:s}') stub for arch {:s}"
        info(fmt.format(sect.page_start, size, str(Permission(value=perm)), get_arch()))
        stub = self.get_stub_by_arch(sect.page_start, size, perm)
        if stub is None:
            err("Failed to generate mprotect opcodes")
            return

        info("Saving original code")
        try:
            original_code = read_memory(original_pc, len(stub))
        except gdb.MemoryError:
            err("Failed to read memory")
            return

        info("Saving original registers value")
        try:
            original_regs = {}
            for r in current_arch.all_registers:
                v = get_register(r)
                original_regs[r] = v
        except Exception:
            err("Failed to read register")
            return

        bp_loc = "*{:#x}".format(original_pc + len(stub))
        info("Setting a restore breakpoint at {:s}".format(bp_loc))
        ChangePermissionBreakpoint(bp_loc, original_code, original_pc, original_regs)

        info("Overwriting current memory at {:#x} ({:d} bytes)".format(loc, len(stub)))
        write_memory(original_pc, stub, len(stub))
        after_data = read_memory(original_pc, len(stub))
        if stub != after_data:
            err("Failed to write memory (qemu doesn't support writing to code area?)")
            return

        info("Resuming execution")
        gdb.execute("continue")
        return

    def get_stub_by_arch(self, addr, size, perm):
        code = current_arch.mprotect_asm(addr, size, perm)
        arch, mode = get_keystone_arch()
        raw_insns = keystone_assemble(code, arch, mode, raw=True)
        return raw_insns


@register_command
class MmapMemoryCommand(GenericCommand):
    """Allocate a new memory (syntax sugar of `call mmap(...)`)."""
    _cmdline_ = "mmap"
    _syntax_ = "{:s} [-h] [LOCATION [SIZE [PERMISSION]]]".format(_cmdline_)
    _example_ = "{:s} 0x10000 0x1000 rwx".format(_cmdline_)
    _category_ = "Debugging Support"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        try:
            parse_address("mmap")
        except gdb.error:
            err("Not found mmap function")
            return

        location = 0
        size = gef_getpagesize()
        perm = Permission.READ | Permission.WRITE | Permission.EXECUTE
        flags = 0x22 # MAP_ANONYMOUS | MAP_PRIVATE

        if len(argv) >= 1:
            location = safe_parse_and_eval(argv[0])
            if location is None:
                err("Invalid address")
                return
            location = to_unsigned_long(location)
            if location % gef_getpagesize():
                err("Address is not a multiple of {:#x}".format(gef_getpagesize()))
                return
            if location != 0:
                flags |= 0x10 # MAP_FIXED

        if len(argv) >= 2:
            try:
                size = int(argv[1], 0)
            except Exception:
                err("Invalid size")
                return
            if size % gef_getpagesize():
                err("Size is not a multiple of {:#x}".format(gef_getpagesize()))
                return

        if len(argv) >= 3:
            if re.match(r"[rwx-]{3}", argv[2]):
                perm = Permission.NONE
                if argv[2][0] == "r":
                    perm |= Permission.READ
                if argv[2][1] == "w":
                    perm |= Permission.WRITE
                if argv[2][2] == "x":
                    perm |= Permission.EXECUTE
            else:
                try:
                    perm = int(argv[2])
                except Exception:
                    err("Invalid permission")
                    return

        cmd = "call mmap({:#x}, {:#x}, {:#x}, {:#x}, -1, 0)".format(location, size, perm, flags)
        gef_print(titlify(cmd))
        gdb.execute(cmd)
        reset_all_caches()
        return


@register_command
class UnicornEmulateCommand(GenericCommand):
    """Use Unicorn-Engine to emulate the behavior of the binary, without affecting the GDB runtime.
    By default the command will emulate only the next instruction, but location and number of
    instruction can be changed via arguments to the command line. By default, it will emulate
    the next instruction from current PC."""
    _cmdline_ = "unicorn-emulate"
    _syntax_ = "{:s} [-h] [-f LOCATION] [-t LOCATION] [-n NB_INSTRUCTION] [-s] [-o PATH]\n".format(_cmdline_)
    _syntax_ += "  -f LOCATION            specifies the start address of the emulated run (default $pc).\n"
    _syntax_ += "  -t LOCATION            specifies the end address of the emulated run.\n"
    _syntax_ += "  -s                     do not execute the script once generated.\n"
    _syntax_ += "  -o /PATH/TO/SCRIPT.py  writes the persistent Unicorn script into this file.\n"
    _syntax_ += "  -n NB_INSTRUCTION      indicates the number of instructions to execute (mutually exclusive with `-t` and `-g`).\n"
    _syntax_ += "  -g NB_GADGET           indicates the number of gadgets to execute (mutually exclusive with `-t` and `-n`).\n"
    _syntax_ += "  -v                     displays the registers for each instruction.\n"
    _syntax_ += "  -q                     quiet execution.\n"
    _syntax_ += "Additional options can be setup via `gef config unicorn-emulate`\n"
    _syntax_ += "\n"
    _syntax_ += "NOTE\n"
    _syntax_ += "* unicorn does not support some instructions (ex: xsavec, xrstor, vpbroadcastb, etc)\n"
    _syntax_ += "* unicorn does not emulate ARM kernel-provided-user-helpers like $pc=0xffff0fe0, 0xffff0fc0, etc.\n"
    _syntax_ += "  see: https://www.kernel.org/doc/Documentation/arm/kernel_user_helpers.txt\n"
    _example_ = "\n"
    _example_ += "{:s} -n 5 # from $pc to 5 later asm\n".format(_cmdline_)
    _example_ += "{:s} -g 4 # from $pc to the point where 4 instructions are executed\n".format(_cmdline_)
    _example_ += "{:s} -f 0x8056770c -t 0x805678a4 -o /tmp/emu.py # from/to specified address with saving script".format(_cmdline_)
    _category_ = "Debugging Support"
    _aliases_ = ["emulate"]

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    @exclude_specific_arch(arch=["PPC64", "MIPS64"])
    @load_capstone
    @load_unicorn
    def do_invoke(self, argv):
        self.dont_repeat()

        start_insn = None
        end_insn = -1
        nb_insn = -1
        nb_gadget = -1
        to_file = None
        skip_emulation = False
        verbose = False
        quiet = False
        try:
            opts = getopt.getopt(argv, "f:t:n:g:so:vqh")[0]
            for o, a in opts:
                if o == "-f":
                    start_insn = int(a, 16)

                elif o == "-t":
                    end_insn = int(a, 16)
                    nb_insn = -1
                    nb_gadget = -1

                elif o == "-n":
                    end_insn = -1
                    nb_insn = int(a)
                    nb_gadget = -1

                elif o == "-g":
                    end_insn = -1
                    nb_insn = -1
                    nb_gadget = int(a)

                elif o == "-s":
                    skip_emulation = True

                elif o == "-o":
                    to_file = a

                elif o == "-v":
                    verbose = True

                elif o == "-q":
                    quiet = True

                elif o == "-h":
                    self.usage()
                    return
        except Exception:
            self.usage()
            return

        if start_insn is None:
            start_insn = current_arch.pc

        thumb_mode = False
        if is_arm32():
            thumb_mode = start_insn & 1

        if end_insn < 0 and nb_insn < 0 and nb_gadget < 0:
            err("No stop condition (-t|-n|-g) defined.")
            return

        kwargs = {
            "skip_emulation": skip_emulation,
            "to_file": to_file,
            "verbose": verbose,
            "nb_gadget": nb_gadget,
            "quiet": quiet,
            "thumb_mode": thumb_mode,
        }

        if end_insn > 0:
            self.run_unicorn(start_insn, end_insn, **kwargs)

        elif nb_insn > 0:
            end_insn = self.get_unicorn_end_addr(start_insn, nb_insn)
            self.run_unicorn(start_insn, end_insn, **kwargs)

        elif nb_gadget > 0:
            end_insn = 0x0
            self.run_unicorn(start_insn, end_insn, **kwargs)

        else:
            raise Exception("Should never be here")
        return

    def get_unicorn_end_addr(self, start_addr, nb):
        dis = list(gef_disassemble(start_addr, nb + 1))
        last_insn = dis[-1]
        return last_insn.address

    def run_unicorn(self, start_insn_addr, end_insn_addr, *args, **kwargs):
        arch, mode = get_unicorn_arch(to_string=True)
        unicorn_registers = get_unicorn_registers(to_string=True)
        cs_arch, cs_mode = get_capstone_arch(to_string=True)

        pythonbin = which("python3")

        content = "#!{:s} -i\n".format(pythonbin)
        content += "#\n"
        content += "# Emulation script for '{:s}'".format(get_filename())
        if kwargs["nb_gadget"]:
            content += " from {:#x} to after {:#x} gadgets\n".format(start_insn_addr, kwargs["nb_gadget"])
        else:
            content += " from {:#x} to {:#x}\n".format(start_insn_addr, end_insn_addr)
        content += "#\n"
        content += "# Powered by gef, unicorn-engine, and capstone-engine\n"
        content += "#\n"
        content += "# original:  by @_hugsy_\n"
        content += "# improvement: by @bata_24\n"
        content += "#\n"
        content += "from __future__ import print_function\n"
        content += "import sys\n"
        content += "import traceback\n"
        content += "import collections\n"
        content += "import capstone\n"
        content += "import unicorn\n"
        if is_ppc64() or is_ppc32():
            content += "import unicorn.ppc_const\n"
        content += "\n"

        content += "registers = collections.OrderedDict({\n"
        for r in unicorn_registers:
            content += "    '{:s}': {:s},\n".format(r.strip(), unicorn_registers[r])
        content += "})\n"
        content += "uc = None\n"
        content += "verbose = {:s}\n".format(str(kwargs["verbose"]))
        content += "quiet = {:s}\n".format(str(kwargs["quiet"]))
        content += "syscall_register = '{:s}'\n".format(current_arch.syscall_register)
        content += "count = 0\n"
        content += "changed_mem = {}\n"
        if is_arm32():
            content += "enable_thumb = {:d}\n".format(int(kwargs["thumb_mode"]))
            content += "\n"
            content += "\n"
            content += "def thumb_check(emu, insn):\n"
            content += "    global enable_thumb\n"
            content += "    if insn.mnemonic in ['blx', 'bx']:\n"
            content += "        enable_thumb = emu.reg_read(registers['$' + insn.op_str]) & 1\n"
            content += "    return\n"

            # hack: unicorn can handle if thumb or not, but capstone can't.
            # we have to handle it manually for capstone.
            # since CS_MODE_ARM is 0x0, it can be ignored. we represent
            # status of thumb: CS_MODE_THUMB * (0 or 1).
            endian = cs_mode.split(" + ")[-1]
            cs_mode = "capstone.CS_MODE_THUMB * enable_thumb + " + endian

        content += "\n"
        content += "\n"
        content += "def disassemble(code, addr):\n"
        content += "    cs = capstone.Cs({:s}, {:s})\n".format(cs_arch, cs_mode)
        content += "    for i in cs.disasm(code, addr):\n"
        content += "        return i\n"
        content += "\n"
        content += "\n"
        content += "def code_hook(emu, address, size, user_data):\n"
        content += "    global count\n"
        content += "    if not quiet:\n"
        # min() is the workaround since unicorn passes 0xf1f1f1f1 as size if opcode is unsupported.
        # The execution will be failed, but the information of the error message increases.
        content += "        code = emu.mem_read(address, min(size, 0x10))\n"
        content += "        insn = disassemble(code, address)\n"
        content += "        code_hex = code[:insn.size].hex()\n"
        content += "        if verbose:\n"
        content += "            print_regs(emu, registers)\n"
        content += "        fmt = '>>> {:d} {:#x}: {:24s} {:s} {:s}'\n"
        content += "        print(fmt.format(count, insn.address, code_hex, insn.mnemonic, insn.op_str))\n"
        if is_arm32():
            content += "        thumb_check(emu, insn)\n"
        content += "    count += 1\n"
        content += "    return\n"
        content += "\n"
        content += "\n"
        content += "def mem_invalid_hook(emu, access, address, size, value, user_data):\n"
        content += "    if access == unicorn.UC_MEM_WRITE_INVALID:\n"
        content += "        fmt = '  --> Invalid memory access; addr:{:#x}, size:{:#x}, value:{:#x}'\n"
        content += "        print(fmt.format(address, size, value))\n"
        content += "    elif access == unicorn.UC_MEM_READ_INVALID:\n"
        content += "        fmt = '  --> Invalid memory access; addr:{:#x}, size:{:#x}'\n"
        content += "        print(fmt.format(address, size))\n"
        content += "    return\n"
        content += "\n"
        content += "\n"
        content += "def mem_write_hook(emu, access, address, size, value, user_data):\n"
        content += "    before = emu.mem_read(address, size)\n"
        content += "    for i in range(size):\n"
        content += "        accessed_address = address + i\n"
        content += "        if accessed_address not in changed_mem:\n"
        content += "            changed_mem[accessed_address] = {}\n"
        content += "            changed_mem[accessed_address]['before'] = before[i]\n"
        content += "        changed_mem[accessed_address]['after'] = (value >> (8 * i)) & 0xff\n"
        content += "        changed_mem[accessed_address]['type'] = 'modified'\n"
        content += "    return\n"
        content += "\n"
        content += "\n"
        content += "def intr_hook(emu, intno, data):\n"
        content += "    print('  --> interrupt={:d}'.format(intno))\n"
        content += "    raise\n"
        content += "\n"
        content += "\n"
        content += "def syscall_hook(emu, user_data):\n"
        content += "    sysno = emu.reg_read(registers[syscall_register])\n"
        content += "    print('  --> syscall={:d} (not emulated)'.format(sysno))\n"
        content += "    return\n"
        content += "\n"
        content += "\n"
        content += "def print_regs(emu, regs):\n"
        content += "    for i, r in enumerate(regs):\n"
        content += "        fmt = '{{:7s}} = {{:#0{:d}x}}  '\n".format(current_arch.ptrsize * 2 + 2)
        content += "        print(fmt.format(r, emu.reg_read(regs[r])), end='')\n"
        content += "        if (i % 4 == 3) or (i == len(regs) - 1):\n"
        content += "            print('')\n"
        content += "    return\n"
        content += "\n"
        content += "\n"
        content += "def print_mems(emu):\n"
        content += "    aligned_addrs = set([x & ~0xf for x in changed_mem.keys()])\n"
        content += "    for aligned_addr in aligned_addrs:\n"
        content += "        for pad_addr in range(aligned_addr, aligned_addr + 0x10):\n"
        content += "            if pad_addr in changed_mem:\n"
        content += "                pass\n"
        content += "            else:\n"
        content += "                changed_mem[pad_addr] = {}\n"
        content += "                changed_mem[pad_addr]['before'] = emu.mem_read(pad_addr, 1)[0]\n"
        content += "                changed_mem[pad_addr]['after'] = emu.mem_read(pad_addr, 1)[0]\n"
        content += "                changed_mem[pad_addr]['type'] = None\n"
        content += "    sorted_data = sorted(changed_mem.items())\n"
        content += "    sliced = [sorted_data[i:i + 16] for i in range(0, len(sorted_data), 16)]\n"
        content += "    prev_address = None\n"
        content += "    for chunk in sliced:\n"
        content += "        address = chunk[0][0]\n"
        content += "        prefix = '{:#018x}'.format(address)\n"
        content += "        before = ''\n"
        content += "        after = ''\n"
        content += "        for i in range(16):\n"
        content += "            a = chunk[i][1]['after']\n"
        content += "            b = chunk[i][1]['before']\n"
        content += "            if a == b:\n"
        content += "                if chunk[i][1]['type'] is None:\n"
        content += "                    before += '{:02x} '.format(b)\n"
        content += "                    after += '{:02x} '.format(a)\n"
        content += "                else:\n"
        content += "                    before += '\033[2m{:02x}\033[0m '.format(b)\n"
        content += "                    after += '\033[2m{:02x}\033[0m '.format(a)\n"
        content += "            else:\n"
        content += "                before += '\033[2m\033[1m{:02x}\033[0m '.format(b)\n"
        content += "                after += '\033[2m\033[1m{:02x}\033[0m '.format(a)\n"
        content += "        line = '{:s} | {:s}| {:s}|'.format(prefix, before, after)\n"
        content += "        if prev_address is not None and prev_address + 0x10 != address:\n"
        content += "            print('*')\n"
        content += "        print(line)\n"
        content += "        prev_address = address\n"
        content += "    print('\033[2m00\033[0m: write accessed, ', end='')\n"
        content += "    print('\033[2m\033[1m00\033[0m: value changes')\n"
        content += "    return\n"

        if is_x86():
            # need to handle segmentation (and pagination) via MSR
            content += "\n"
            content += "\n"
            content += "# from https://github.com/unicorn-engine/unicorn/blob/master/tests/regress/x86_64_msr.py\n"
            content += "SCRATCH_ADDR = 0xf000\n"
            content += "FSMSR = 0xC0000100\n"
            content += "GSMSR = 0xC0000101\n"
            content += "\n"
            content += "\n"
            content += "def set_msr(uc, msr, value, scratch=SCRATCH_ADDR):\n"
            content += "    buf = b'\\x0f\\x30' # x86: wrmsr\n"
            content += "    uc.mem_map(scratch, 0x1000)\n"
            content += "    uc.mem_write(scratch, buf)\n"
            content += "    uc.reg_write(unicorn.x86_const.UC_X86_REG_RAX, value & 0xFFFFFFFF)\n"
            content += "    uc.reg_write(unicorn.x86_const.UC_X86_REG_RDX, (value >> 32) & 0xFFFFFFFF)\n"
            content += "    uc.reg_write(unicorn.x86_const.UC_X86_REG_RCX, msr & 0xFFFFFFFF)\n"
            content += "    uc.emu_start(scratch, scratch+len(buf), count=1)\n"
            content += "    uc.mem_unmap(scratch, 0x1000)\n"
            content += "    return\n"
            content += "\n"
            content += "\n"
            content += "def set_gs(uc, addr):\n"
            content += "    return set_msr(uc, GSMSR, addr)\n"
            content += "\n"
            content += "\n"
            content += "def set_fs(uc, addr):\n"
            content += "    return set_msr(uc, FSMSR, addr)\n"

        content += "\n"
        content += "\n"
        content += "def reset():\n"
        content += "    emu = unicorn.Uc({arch}, {mode})\n".format(arch=arch, mode=mode)

        if is_x86():
            content += "\n"
            content += "\n"
            content += "    set_fs(emu, {:#x})\n".format(TlsCommand.getfs() if is_x86_64() else 0)
            content += "    set_gs(emu, {:#x})\n".format(TlsCommand.getgs() if is_x86_32() else 0)

        if kwargs["verbose"]:
            info("Duplicating registers")

        if is_arm32() or is_arm64():
            # need first. because other register values may be broken when $cpsr is set
            gregval = get_register("$cpsr")
            content += "    emu.reg_write({:s}, {:#x})\n".format(unicorn_registers["$cpsr"], gregval)
        for r in current_arch.all_registers:
            if is_x86_64() and r == "$fs":
                continue
            if is_x86_32() and r == "$gs":
                continue
            if (is_arm32() or is_arm64()) and r == "$cpsr":
                continue
            if r not in unicorn_registers:
                continue
            gregval = get_register(r)
            content += "    emu.reg_write({:s}, {:#x})\n".format(unicorn_registers[r], gregval)
        content += "\n"

        clear_explored_regions()
        vmmap = get_process_maps()
        if not vmmap:
            warn("An error occurred when reading memory map.")
            return

        if kwargs["verbose"]:
            info("Duplicating memory map")

        for sect in vmmap:
            if sect.path == "[vvar]":
                # this section is for GDB only, skip it
                continue

            content += "    # Mapping {:s}: {:#x}-{:#x}\n".format(sect.path, sect.page_start, sect.page_end)
            content += "    emu.mem_map({:#x}, {:#x}, {})\n".format(sect.page_start, sect.size, oct(sect.permission.value))

            if sect.permission & Permission.READ:
                code = read_memory(sect.page_start, sect.size)
                loc = "/tmp/gef-{:s}-{:#x}.raw".format(get_filename(), sect.page_start)
                open(loc, "wb").write(bytes(code))
                content += "    emu.mem_write({:#x}, open('{:s}', 'rb').read())\n".format(sect.page_start, loc)
                content += "\n"

        content += "    emu.hook_add(unicorn.UC_HOOK_CODE, code_hook)\n"
        content += "    emu.hook_add(unicorn.UC_HOOK_INTR, intr_hook)\n"
        if is_x86_64():
            content += "    emu.hook_add(unicorn.UC_HOOK_INSN, syscall_hook, None, 1, 0, unicorn.x86_const.UC_X86_INS_SYSCALL)\n"
        content += "    emu.hook_add(unicorn.UC_HOOK_MEM_READ_INVALID | unicorn.UC_HOOK_MEM_WRITE_INVALID, mem_invalid_hook)\n"
        content += "    emu.hook_add(unicorn.UC_HOOK_MEM_WRITE, mem_write_hook)\n"
        content += "    return emu\n"

        content += "\n"
        content += "\n"
        content += "def emulate(emu, start_addr, end_addr, count):\n"
        content += "    print('========================= Initial registers =========================')\n"
        content += "    print_regs(emu, registers)\n"
        content += "\n"
        content += "    try:\n"
        content += "        print('========================= Starting emulation =========================')\n"
        content += "        emu.emu_start(start_addr, end_addr, count=count)\n"
        content += "    except Exception:\n"
        content += "        emu.emu_stop()\n"
        content += "        print('========================= Emulation failed =========================')\n"
        content += "        traceback.print_exc(file=sys.stdout)\n"
        content += "\n"
        content += "    print('========================= Final registers =========================')\n"
        content += "    print_regs(emu, registers)\n"
        content += "    print('========================= Modified memories (before | after) =========================')\n"
        content += "    print_mems(emu)\n"
        content += "    return\n"
        content += "\n"
        content += "\n"
        content += "uc = reset()\n"
        content += "emulate(uc, {:#x}, {:#x}, {:#x})\n".format(start_insn_addr, end_insn_addr, kwargs["nb_gadget"])
        content += "\n"
        content += "\n"
        content += "# unicorn-engine script generated by gef\n"

        if kwargs["to_file"]:
            tmp_filename = kwargs["to_file"]
            tmp_fd_ = open(kwargs["to_file"], "w")
            tmp_fd = tmp_fd_.fileno()
        else:
            tmp_fd, tmp_filename = tempfile.mkstemp(suffix=".py", prefix="gef-uc-")
        os.write(tmp_fd, gef_pybytes(content))
        os.close(tmp_fd)
        if kwargs["to_file"]:
            info("Unicorn script generated as '{:s}'".format(tmp_filename))
            os.chmod(tmp_filename, 0o700)

        if kwargs["skip_emulation"]:
            return

        if kwargs["nb_gadget"] == -1:
            fmt = "Starting emulation: {:#x} {:s} {:#x}"
            ok(fmt.format(start_insn_addr, RIGHT_ARROW, end_insn_addr))
        else:
            fmt = "Starting emulation: {:#x} {:s} after {:d} instructions are executed"
            ok(fmt.format(start_insn_addr, RIGHT_ARROW, kwargs["nb_gadget"]))

        try:
            res = gef_execute_external([pythonbin, tmp_filename], as_list=True)
            gef_print("\n".join(res))
        except subprocess.CalledProcessError as e:
            gef_print(e.output.decode("utf-8").rstrip())

        if not kwargs["to_file"]:
            os.unlink(tmp_filename)
        return


@register_command
class StubCommand(GenericCommand):
    """Stub out the specified function. This function is useful when needing to skip one
    function to be called and disrupt your runtime flow (ex. fork)."""
    _cmdline_ = "stub"
    _syntax_ = "{:s} [-h] [-r RETVAL] [LOCATION]\n".format(_cmdline_)
    _syntax_ += "  LOCATION   address/symbol to stub out\n"
    _syntax_ += "  -r RETVAL  Set the return value"
    _example_ = "{:s} -r 0 fork".format(_cmdline_)
    _category_ = "Debugging Support"
    _aliases_ = ["deactive"]

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        try:
            opts, args = getopt.getopt(argv, "r:")
            retval = 0
            for o, a in opts:
                if o == "-r":
                    retval = int(a, 0)
        except getopt.GetoptError:
            self.usage()
            return

        loc = args[0] if args else "*{:#x}".format(current_arch.pc)
        StubBreakpoint(loc, retval)
        return


@register_command
class CapstoneDisassembleCommand(GenericCommand):
    """Use capstone disassembly framework to disassemble code."""
    _cmdline_ = "capstone-disassemble"
    _syntax_ = "{:s} [-h] [LOCATION] [[length=LENGTH] [OPCODES] [option=VALUE]] ".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} $pc length=50 # dump from $pc up to 50 lines later\n".format(_cmdline_)
    _example_ += "{:s} $pc length=50 OPCODES # show opcodes\n".format(_cmdline_)
    _example_ += "{:s} $pc length=50 OPCODES arch=ARM mode=ARM endian=1 # specify arch, mode and endian (1:big endian)\n".format(_cmdline_)
    _example_ += "{:s} OPCODES code=\"9090\" # disassemble specified byte patterns ".format(_cmdline_)
    _category_ = "Assemble"
    _aliases_ = ["cs-dis"]

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        self.valid_arch_modes = {
            "ARM" : ["ARM", "THUMB"],
            "ARM64" : ["ARM"],
            "MIPS" : ["MIPS32", "MIPS64"],
            "PPC" : ["PPC32", "PPC64"],
            "SPARC" : ["SPARC32", "SPARC64"],
            "X86" : ["16", "32", "64"],
        }
        return

    def help(self):
        self.usage()
        gef_print("\nAvailable architectures/modes:")
        # for updates, see https://github.com/keystone-engine/keystone/blob/master/include/keystone/keystone.h
        for arch in self.valid_arch_modes:
            gef_print(" - {} ".format(arch))
            gef_print("  * {}".format(" / ".join(self.valid_arch_modes[arch])))
        return

    @only_if_gdb_running
    @load_capstone
    def do_invoke(self, argv):
        self.dont_repeat()

        location = None
        show_opcodes = False

        if "-h" in argv:
            self.help()
            return

        try:
            kwargs = {}
            for arg in argv:
                if "=" in arg:
                    key, value = arg.split("=", 1)
                    kwargs[key] = value

                elif "opcodes".startswith(arg.lower()):
                    show_opcodes = True

                elif location is None:
                    location = parse_address(arg)
        except Exception:
            self.help()
            return

        if "code" in kwargs:
            location = 0
        else:
            location = location or current_arch.pc
        length = int(kwargs.get("length", get_gef_setting("context.nb_lines_code")))

        try:
            for insn in capstone_disassemble(location, length, skip=length * self.repeat_count, **kwargs):
                insn_fmt = "{:12o}" if show_opcodes else "{}"
                text_insn = insn_fmt.format(insn)
                msg = ""

                if insn.address == current_arch.pc:
                    msg = Color.colorify("{}  {}".format(RIGHT_ARROW, text_insn), "bold red")
                    reason = self.capstone_analyze_pc(insn, length)[0]
                    if reason:
                        gef_print(msg)
                        gef_print(reason)
                        break
                else:
                    msg = "{} {}".format(" " * 5, text_insn)

                gef_print(msg)
        except AttributeError:
            err("Maybe unsupported architecture")
        except gdb.error:
            pass
        return

    def capstone_analyze_pc(self, insn, nb_insn):
        if current_arch.is_conditional_branch(insn):
            is_taken, reason = current_arch.is_branch_taken(insn)
            if is_taken:
                reason = "[Reason: {:s}]".format(reason) if reason else ""
                msg = Color.colorify("\tTAKEN {:s}".format(reason), "bold green")
            else:
                reason = "[Reason: !({:s})]".format(reason) if reason else ""
                msg = Color.colorify("\tNOT taken {:s}".format(reason), "bold red")
            return (is_taken, msg)

        if current_arch.is_call(insn):
            try:
                target_address = int(insn.operands[-1].split()[0], 16)
                msg = []
                for i, new_insn in enumerate(capstone_disassemble(target_address, nb_insn)):
                    msg.append("   {}  {}".format(DOWN_ARROW if i == 0 else " ", str(new_insn)))
                return (True, "\n".join(msg))
            except Exception:
                pass

        return (False, "")


@register_command
class GlibcHeapCommand(GenericCommand):
    """Base command to get information about the Glibc heap structure."""
    _cmdline_ = "heap"
    _syntax_ = "{:s} (chunk|chunks|bins|arenas|binsize-info)".format(_cmdline_)
    _category_ = "Heap"

    def __init__(self):
        super().__init__(prefix=True)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()
        self.usage()
        return


@register_command
class GlibcHeapArenaCommand(GenericCommand):
    """Display information on a heap chunk."""
    _cmdline_ = "heap arenas"
    _syntax_ = _cmdline_
    _aliases_ = ["arena"]
    _category_ = "Heap"

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        try:
            arena = GlibcArena(__gef_default_main_arena__)
        except gdb.error:
            err("Could not find Glibc main arena")
            return

        while True:
            gef_print("{}".format(arena))
            arena = arena.get_next()
            if arena is None:
                break

        info("additionally, you can see struct member by following")
        gef_print("p ((struct malloc_state*) ADDRESS)[0]")
        gef_print("p ((struct _heap_info*) ADDRESS)[0]")
        return


@register_command
class GlibcHeapBinSizeInfoCommand(GenericCommand):
    """Display heap bin size info."""
    _cmdline_ = "heap binsize-info"
    _syntax_ = _cmdline_
    _category_ = "Heap"

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        gef_print(titlify("tcache size"))
        if is_64bit():
            for i in range(64):
                gef_print("tcache[{:2d}]: {:#x}".format(i, i * 0x10 + 0x20))
        elif is_32bit():
            gef_print("MALLOC_ALIGNMENT is changed from libc 2.26,")
            gef_print("for 32 bit arch, tcache 0x8 align is no longer used.")
            for i in range(64):
                gef_print("tcache[{:2d}]: {:#x}".format(i, i * 0x10 + 0x10))

        gef_print(titlify("fastbin size"))
        if is_64bit():
            for i in range(7):
                gef_print("fastbins[{:d}]: {:#x}".format(i, i * 0x10 + 0x20))
        elif is_32bit():
            gef_print("MALLOC_ALIGNMENT is changed from libc 2.26.")
            gef_print("for 32 bit arch, fastbin exists every 8 bytes, but only used every 16 bytes.")
            gef_print("fastbins[0]: 0x10")
            gef_print("fastbins[1]: 0x18 # unused")
            gef_print("fastbins[2]: 0x20")
            gef_print("fastbins[3]: 0x28 # unused")
            gef_print("fastbins[4]: 0x30")
            gef_print("fastbins[5]: 0x38 # unused")
            gef_print("fastbins[6]: 0x40")

        gef_print(titlify("unsorted_bin / small_bin / large_bin size"))
        gef_print("bins[{:3d}]: unsorted_bin".format(0))
        if is_64bit():
            for i in range(1, 63):
                gef_print("bins[{:3d}]: small_bins[{:3d}]: {:#x}".format(i * 2, i, (i - 1) * 0x10 + 0x20))
            gef_print("bins[126]: large_bins[ 63]: 0x400 - 0x430")
            gef_print("bins[128]: large_bins[ 64]: 0x440 - 0x470")
            gef_print("bins[130]: large_bins[ 65]: 0x480 - 0x4b0")
            gef_print("bins[132]: large_bins[ 66]: 0x4c0 - 0x4f0")
            gef_print("bins[134]: large_bins[ 67]: 0x500 - 0x530")
            gef_print("bins[136]: large_bins[ 68]: 0x540 - 0x570")
            gef_print("bins[138]: large_bins[ 69]: 0x580 - 0x5b0")
            gef_print("bins[140]: large_bins[ 70]: 0x5c0 - 0x5f0")
            gef_print("bins[142]: large_bins[ 71]: 0x600 - 0x630")
            gef_print("bins[144]: large_bins[ 72]: 0x640 - 0x670")
            gef_print("bins[146]: large_bins[ 73]: 0x680 - 0x6b0")
            gef_print("bins[148]: large_bins[ 74]: 0x6c0 - 0x6f0")
            gef_print("bins[150]: large_bins[ 75]: 0x700 - 0x730")
            gef_print("bins[152]: large_bins[ 76]: 0x740 - 0x770")
            gef_print("bins[154]: large_bins[ 77]: 0x780 - 0x7b0")
            gef_print("bins[156]: large_bins[ 78]: 0x7c0 - 0x7f0")
            gef_print("bins[158]: large_bins[ 79]: 0x800 - 0x830")
            gef_print("bins[160]: large_bins[ 80]: 0x840 - 0x870")
            gef_print("bins[162]: large_bins[ 81]: 0x880 - 0x8b0")
            gef_print("bins[164]: large_bins[ 82]: 0x8c0 - 0x8f0")
            gef_print("bins[166]: large_bins[ 83]: 0x900 - 0x930")
            gef_print("bins[168]: large_bins[ 84]: 0x940 - 0x970")
            gef_print("bins[170]: large_bins[ 85]: 0x980 - 0x9b0")
            gef_print("bins[172]: large_bins[ 86]: 0x9c0 - 0x9f0")
            gef_print("bins[174]: large_bins[ 87]: 0xa00 - 0xa30")
            gef_print("bins[176]: large_bins[ 88]: 0xa40 - 0xa70")
            gef_print("bins[178]: large_bins[ 89]: 0xa80 - 0xab0")
            gef_print("bins[180]: large_bins[ 90]: 0xac0 - 0xaf0")
            gef_print("bins[182]: large_bins[ 91]: 0xb00 - 0xb30")
            gef_print("bins[184]: large_bins[ 92]: 0xb40 - 0xb70")
            gef_print("bins[186]: large_bins[ 93]: 0xb80 - 0xbb0")
            gef_print("bins[188]: large_bins[ 94]: 0xbc0 - 0xbf0")
            gef_print("bins[190]: large_bins[ 95]: 0xc00 - 0xc30")
            gef_print("bins[192]: large_bins[ 96]: 0xc40 - 0xdf0")
        elif is_32bit():
            for i in range(1, 63):
                gef_print("bins[{:3d}]: small_bins[{:3d}]: {:#x}".format(i * 2, i, (i - 1) * 0x10 + 0x10))
            gef_print("bins[126]: large_bins[ 63]: 0x3f0")
            gef_print("bins[128]: large_bins[ 64]: 0x400 - 0x430")
            gef_print("bins[130]: large_bins[ 65]: 0x440 - 0x470")
            gef_print("bins[132]: large_bins[ 66]: 0x480 - 0x4b0")
            gef_print("bins[134]: large_bins[ 67]: 0x4c0 - 0x4f0")
            gef_print("bins[136]: large_bins[ 68]: 0x500 - 0x530")
            gef_print("bins[138]: large_bins[ 69]: 0x540 - 0x570")
            gef_print("bins[140]: large_bins[ 70]: 0x580 - 0x5b0")
            gef_print("bins[142]: large_bins[ 71]: 0x5c0 - 0x5f0")
            gef_print("bins[144]: large_bins[ 72]: 0x600 - 0x630")
            gef_print("bins[146]: large_bins[ 73]: 0x640 - 0x670")
            gef_print("bins[148]: large_bins[ 74]: 0x680 - 0x6b0")
            gef_print("bins[150]: large_bins[ 75]: 0x6c0 - 0x6f0")
            gef_print("bins[152]: large_bins[ 76]: 0x700 - 0x730")
            gef_print("bins[154]: large_bins[ 77]: 0x740 - 0x770")
            gef_print("bins[156]: large_bins[ 78]: 0x780 - 0x7b0")
            gef_print("bins[158]: large_bins[ 79]: 0x7c0 - 0x7f0")
            gef_print("bins[160]: large_bins[ 80]: 0x800 - 0x830")
            gef_print("bins[162]: large_bins[ 81]: 0x840 - 0x870")
            gef_print("bins[164]: large_bins[ 82]: 0x880 - 0x8b0")
            gef_print("bins[166]: large_bins[ 83]: 0x8c0 - 0x8f0")
            gef_print("bins[168]: large_bins[ 84]: 0x900 - 0x930")
            gef_print("bins[170]: large_bins[ 85]: 0x940 - 0x970")
            gef_print("bins[172]: large_bins[ 86]: 0x980 - 0x9b0")
            gef_print("bins[174]: large_bins[ 87]: 0x9c0 - 0x9f0")
            gef_print("bins[176]: large_bins[ 88]: 0xa00 - 0xa30")
            gef_print("bins[178]: large_bins[ 89]: 0xa40 - 0xa70")
            gef_print("bins[180]: large_bins[ 90]: 0xa80 - 0xab0")
            gef_print("bins[182]: large_bins[ 91]: 0xac0 - 0xaf0")
            gef_print("bins[184]: large_bins[ 92]: 0xb00 - 0xb30")
            gef_print("bins[186]: large_bins[ 93]: 0xb40 - 0xb70")
            gef_print("bins[190]: large_bins[ 95]: 0xb80 - 0xbf0")
            gef_print("bins[192]: large_bins[ 96]: 0xc00 - 0xdf0")
        gef_print("bins[194]: large_bins[ 97]: 0xe00 - 0xff0")
        gef_print("bins[196]: large_bins[ 98]: 0x1000 - 0x11f0")
        gef_print("bins[198]: large_bins[ 99]: 0x1200 - 0x13f0")
        gef_print("bins[200]: large_bins[100]: 0x1400 - 0x15f0")
        gef_print("bins[202]: large_bins[101]: 0x1600 - 0x17f0")
        gef_print("bins[204]: large_bins[102]: 0x1800 - 0x19f0")
        gef_print("bins[206]: large_bins[103]: 0x1a00 - 0x1bf0")
        gef_print("bins[208]: large_bins[104]: 0x1c00 - 0x1df0")
        gef_print("bins[210]: large_bins[105]: 0x1e00 - 0x1ff0")
        gef_print("bins[212]: large_bins[106]: 0x2000 - 0x21f0")
        gef_print("bins[214]: large_bins[107]: 0x2200 - 0x23f0")
        gef_print("bins[216]: large_bins[108]: 0x2400 - 0x25f0")
        gef_print("bins[218]: large_bins[109]: 0x2600 - 0x27f0")
        gef_print("bins[220]: large_bins[110]: 0x2800 - 0x29f0")
        gef_print("bins[222]: large_bins[111]: 0x2a00 - 0x2ff0")
        gef_print("bins[224]: large_bins[112]: 0x3000 - 0x3ff0")
        gef_print("bins[226]: large_bins[113]: 0x4000 - 0x4ff0")
        gef_print("bins[228]: large_bins[114]: 0x5000 - 0x5ff0")
        gef_print("bins[230]: large_bins[115]: 0x6000 - 0x6ff0")
        gef_print("bins[232]: large_bins[116]: 0x7000 - 0x7ff0")
        gef_print("bins[234]: large_bins[117]: 0x8000 - 0x8ff0")
        gef_print("bins[236]: large_bins[118]: 0x9000 - 0x9ff0")
        gef_print("bins[238]: large_bins[119]: 0xa000 - 0xfff0")
        gef_print("bins[240]: large_bins[120]: 0x10000 - 0x17ff0")
        gef_print("bins[242]: large_bins[121]: 0x18000 - 0x1fff0")
        gef_print("bins[244]: large_bins[122]: 0x20000 - 0x27ff0")
        gef_print("bins[246]: large_bins[123]: 0x28000 - 0x3fff0")
        gef_print("bins[248]: large_bins[124]: 0x40000 - 0x7fff0")
        gef_print("bins[250]: large_bins[125]:")
        gef_print("bins[252]: large_bins[126]:")
        return


@register_command
class GlibcHeapChunkCommand(GenericCommand):
    """Display information on a heap chunk.
    See https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1123."""
    _cmdline_ = "heap chunk"
    _syntax_ = "{:s} LOCATION".format(_cmdline_)
    _category_ = "Heap"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if not argv:
            err("Missing chunk address")
            self.usage()
            return

        if get_main_arena() is None:
            return

        addr = parse_address(argv[0])
        chunk = GlibcChunk(addr)
        gef_print(chunk.psprint())
        return


@register_command
class GlibcHeapChunksCommand(GenericCommand):
    """Display information all heap chunks."""
    _cmdline_ = "heap chunks"
    _syntax_ = "{:s} [LOCATION] [-a ARENA_ADDRESS]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s}\n".format(_cmdline_)
    _example_ += "{:s} -a 0x7ffff0000020".format(_cmdline_)
    _category_ = "Heap"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        self.add_setting("peek_nb_byte", 16, "Hexdump N first byte(s) inside the chunk data (0 to disable)")
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        # parse arena
        if "-a" in argv:
            idx = argv.index("-a")
            self.arena = GlibcArena("*{:s}".format(argv[idx + 1]))
            argv = argv[:idx] + argv[idx + 2:]
        else:
            self.arena = get_main_arena()
        if self.arena is None:
            err("No valid arena")
            return
        if self.arena.heap_base is None:
            err("Heap is not initialized")
            return

        # parse start address
        if len(argv) == 1:
            self.dump_start = int(argv[0], 16)
            argv = None
        elif len(argv) == 0:
            self.dump_start = self.arena.heap_base
            # specified pattern
            if current_arch.ptrsize == 4 and self.arena.is_main_arena():
                self.dump_start += 8
        else:
            self.usage()
            return

        self.print_heap_chunks()
        return

    def print_heap_chunks(self):
        nb = self.get_setting("peek_nb_byte")
        current_chunk = GlibcChunk(self.dump_start, from_base=True)
        tcache_list = self.arena.tcache_list()
        fastbin_list = self.arena.fastbin_list()
        unsortedbin_list = self.arena.unsortedbin_list()
        smallbin_list = self.arena.smallbin_list()
        largebin_list = self.arena.largebin_list()
        while True:
            if current_chunk.chunk_base_address == self.arena.top:
                gef_print("{} {} {}".format(str(current_chunk), LEFT_ARROW, Color.greenify("top chunk")))
                break
            if current_chunk.chunk_base_address > self.arena.top:
                break
            if current_chunk.size == 0:
                # EOF
                break
            line = str(current_chunk)
            if nb:
                line += "\n    [" + hexdump(read_memory(current_chunk.address, nb), nb, base=current_chunk.address) + "]"
                for k, v in tcache_list.items():
                    if current_chunk.address in v:
                        line += " {} {}".format(LEFT_ARROW, Color.greenify("tcache[{}]".format(k)))
                for k, v in fastbin_list.items():
                    if current_chunk.address in v:
                        line += " {} {}".format(LEFT_ARROW, Color.greenify("fastbin[{}]".format(k)))
                for k, v in unsortedbin_list.items():
                    if current_chunk.address in v:
                        line += " {} {}".format(LEFT_ARROW, Color.greenify("unsortedbin"))
                for k, v in smallbin_list.items():
                    if current_chunk.address in v:
                        line += " {} {}".format(LEFT_ARROW, Color.greenify("smallbin[{}]".format(k)))
                for k, v in largebin_list.items():
                    if current_chunk.address in v:
                        line += " {} {}".format(LEFT_ARROW, Color.greenify("largebin[{}]".format(k)))
            gef_print(line)
            next_chunk = current_chunk.get_next_chunk()
            if next_chunk is None:
                break
            next_chunk_addr = Address(value=next_chunk.address)
            if not next_chunk_addr.valid:
                # corrupted
                break
            current_chunk = next_chunk
        return


@register_command
class GlibcHeapBinsCommand(GenericCommand):
    """Display information on the bins on an arena (default: main_arena).
    See https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1123."""
    _bin_types_ = ["tcache", "fast", "unsorted", "small", "large"]
    _cmdline_ = "heap bins"
    _syntax_ = "{:s} [{:s}] [-a ARENA_ADDRESS] [-v]".format(_cmdline_, "|".join(_bin_types_))
    _example_ = "\n"
    _example_ += "{:s}\n".format(_cmdline_)
    _example_ += "{:s} fast\n".format(_cmdline_)
    _example_ += "{:s} fast -a 0x7ffff0000020".format(_cmdline_)
    _category_ = "Heap"

    def __init__(self):
        super().__init__(prefix=True)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        # parse arena
        arena_addr = None
        if "-a" in argv:
            idx = argv.index("-a")
            arena_addr = int(argv[-1], 16)
            argv = argv[:idx] + argv[idx + 2:]

        verbose = ""
        if "-v" in argv:
            verbose = "-v"
            argv.remove("-v")

        if not argv:
            for bin_t in GlibcHeapBinsCommand._bin_types_:
                if arena_addr:
                    gdb.execute("heap bins {:s} -a {:#x} {:s}".format(bin_t, arena_addr, verbose))
                else:
                    gdb.execute("heap bins {:s} {:s}".format(bin_t, verbose))
            return

        bin_t = argv[0]
        if bin_t not in GlibcHeapBinsCommand._bin_types_:
            self.usage()
            return

        gdb.execute("heap bins {} {:s}".format(bin_t, verbose))
        return

    @staticmethod
    def pprint_bin(arena_addr, index, _type="", verbose=False):
        arena = GlibcArena(arena_addr)
        fw, bk = arena.bin(index)

        if bk == 0x00 and fw == 0x00:
            warn("Invalid backward and forward bin pointers(fw==bk==NULL)")
            return -1

        nb_chunk = 0
        head = GlibcChunk(bk, from_base=True).fwd
        if fw == head and not verbose:
            return nb_chunk

        ok("{:s}bins[idx={:d}]: fw={:#x}, bk={:#x}".format(_type, index, fw, bk))

        m = []
        while fw != head:
            chunk = GlibcChunk(fw, from_base=True)
            if _type == "large_":
                m.append("{:s} {:s}".format(RIGHT_ARROW, chunk.str_large()))
            else:
                m.append("{:s} {:s}".format(RIGHT_ARROW, str(chunk)))
            fw = chunk.fwd
            nb_chunk += 1

        if m:
            gef_print("\n".join(m))
        return nb_chunk


@register_command
class GlibcHeapTcachebinsCommand(GenericCommand):
    """Display information on the Tcachebins on an arena (default: main_arena).
    See https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc."""
    _cmdline_ = "heap bins tcache"
    _syntax_ = "{:s} [-a ARENA_ADDRESS] [-v]".format(_cmdline_)
    _category_ = "Heap"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        verbose = False
        if "-v" in argv:
            verbose = True
            argv.remove("-v")

        if argv and "-a" != argv[0]:
            self.usage()
            return

        # Determine if we are using libc with tcache built in (2.26+)
        if get_libc_version() < (2, 26):
            info("No Tcache in this version of libc")
            return

        arena = GlibcArena("*{:s}".format(argv[1])) if len(argv) == 2 else get_main_arena()

        if arena is None:
            err("Invalid Glibc arena")
            return

        # Get tcache_perthread_struct for this arena
        if arena.heap_base is None:
            err("No heap section")
            return
        tcache_perthread_struct = arena.heap_base + 0x10
        arena_addr = "*{:s}".format(argv[1]) if len(argv) == 2 else __gef_default_main_arena__
        gef_print(titlify("Tcachebins for arena '{:s}'".format(arena_addr)))
        for i in range(GlibcArena.TCACHE_MAX_BINS):
            if get_libc_version() < (2, 30):
                count = ord(read_memory(tcache_perthread_struct + i, 1))
            else:
                count = u16(read_memory(tcache_perthread_struct + 2 * i, 2))
            chunk = arena.tcachebin(i)
            chunks = set()
            m = []

            # Only print the entry if there are valid chunks. Don't trust count
            while True:
                if chunk is None:
                    break
                try:
                    m.append("{:s} {:s} ".format(RIGHT_ARROW, str(chunk)))
                    if chunk.address in chunks:
                        m.append("{:s} [loop detected]".format(RIGHT_ARROW))
                        break

                    chunks.add(chunk.address)

                    next_chunk = chunk.get_fwd_ptr(True)
                    if next_chunk == 0:
                        break

                    chunk = GlibcChunk(next_chunk)
                except gdb.MemoryError:
                    m.append("{:s} [Corrupted chunk at {:#x}]".format(LEFT_ARROW, chunk.address))
                    break
            if m or verbose:
                gef_print("Tcachebins[idx={:d}, size={:#x}] count={:d}\n".format(i, current_arch.ptrsize * 4 + i * 0x10, count), end="")
                if m:
                    gef_print("\n".join(m))
        return


@register_command
class GlibcHeapFastbinsYCommand(GenericCommand):
    """Display information on the fastbinsY on an arena (default: main_arena).
    See: https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1123."""
    _cmdline_ = "heap bins fast"
    _syntax_ = "{:s} [-a ARENA_ADDRESS]".format(_cmdline_)
    _category_ = "Heap"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-v" in argv:
            argv.remove("-v") # no effect

        if argv and "-a" != argv[0]:
            self.usage()
            return

        def fastbin_index(sz):
            return (sz >> 4) - 2 if SIZE_SZ == 8 else (sz >> 3) - 2

        SIZE_SZ = current_arch.ptrsize
        MAX_FAST_SIZE = 80 * SIZE_SZ // 4
        NFASTBINS = fastbin_index(MAX_FAST_SIZE) - 1

        arena = GlibcArena("*{:s}".format(argv[1])) if len(argv) == 2 else get_main_arena()

        if arena is None:
            err("Invalid Glibc arena")
            return

        arena_addr = "*{:s}".format(argv[1]) if len(argv) == 2 else __gef_default_main_arena__
        gef_print(titlify("Fastbins for arena '{:s}'".format(arena_addr)))
        for i in range(NFASTBINS):
            gef_print("Fastbins[idx={:d}, size={:#x}] ".format(i, (i + 2) * SIZE_SZ * 2), end="")
            chunk = arena.fastbin(i)
            chunks = set()

            while True:
                if chunk is None:
                    break

                try:
                    gef_print("\n{:s} {:s} ".format(RIGHT_ARROW, str(chunk)), end="")
                    if chunk.address in chunks:
                        gef_print("{:s} [loop detected]".format(RIGHT_ARROW), end="")
                        break

                    if fastbin_index(chunk.get_chunk_size()) != i:
                        gef_print("[incorrect fastbin_index] ", end="")

                    chunks.add(chunk.address)

                    next_chunk = chunk.get_fwd_ptr(True)
                    if next_chunk == 0:
                        break

                    chunk = GlibcChunk(next_chunk, from_base=True)
                except gdb.MemoryError:
                    gef_print("{:s} [Corrupted chunk at {:#x}]".format(LEFT_ARROW, chunk.address), end="")
                    break
            gef_print()
        return


@register_command
class GlibcHeapUnsortedBinsCommand(GenericCommand):
    """Display information on the Unsorted Bins of an arena (default: main_arena).
    See: https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1689."""
    _cmdline_ = "heap bins unsorted"
    _syntax_ = "{:s} [-a ARENA_ADDRESS]".format(_cmdline_)
    _category_ = "Heap"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        verbose = False
        if "-v" in argv:
            verbose = True
            argv.remove("-v")

        if argv and "-a" != argv[0]:
            self.usage()
            return

        if get_main_arena() is None:
            err("Invalid Glibc arena")
            return

        arena_addr = "*{:s}".format(argv[1]) if len(argv) == 2 else __gef_default_main_arena__
        gef_print(titlify("Unsorted Bin for arena '{:s}'".format(arena_addr)))
        nb_chunk = GlibcHeapBinsCommand.pprint_bin(arena_addr, 0, "unsorted_", verbose)
        if nb_chunk >= 0:
            info("Found {:d} chunks in unsorted bin.".format(nb_chunk))
        return


@register_command
class GlibcHeapSmallBinsCommand(GenericCommand):
    """Convenience command for viewing small bins."""
    _cmdline_ = "heap bins small"
    _syntax_ = "{:s} [-a ARENA_ADDRESS] [-v]".format(_cmdline_)
    _category_ = "Heap"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        verbose = False
        if "-v" in argv:
            verbose = True
            argv.remove("-v")

        if argv and "-a" != argv[0]:
            self.usage()
            return

        if get_main_arena() is None:
            err("Invalid Glibc arena")
            return

        arena_addr = "*{:s}".format(argv[1]) if len(argv) == 2 else __gef_default_main_arena__
        gef_print(titlify("Small Bins for arena '{:s}'".format(arena_addr)))
        bins = {}
        for i in range(1, 63):
            nb_chunk = GlibcHeapBinsCommand.pprint_bin(arena_addr, i, "small_", verbose)
            if nb_chunk < 0:
                break
            if nb_chunk > 0:
                bins[i] = nb_chunk
        info("Found {:d} chunks in {:d} small non-empty bins.".format(sum(bins.values()), len(bins)))
        return


@register_command
class GlibcHeapLargeBinsCommand(GenericCommand):
    """Convenience command for viewing large bins."""
    _cmdline_ = "heap bins large"
    _syntax_ = "{:s} [-a ARENA_ADDRESS] [-v]".format(_cmdline_)
    _category_ = "Heap"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        verbose = False
        if "-v" in argv:
            verbose = True
            argv.remove("-v")

        if argv and "-a" != argv[0]:
            self.usage()
            return

        if get_main_arena() is None:
            err("Invalid Glibc arena")
            return

        arena_addr = "*{:s}".format(argv[1]) if len(argv) == 2 else __gef_default_main_arena__
        gef_print(titlify("Large Bins for arena '{:s}'".format(arena_addr)))
        bins = {}
        for i in range(63, 126):
            nb_chunk = GlibcHeapBinsCommand.pprint_bin(arena_addr, i, "large_", verbose)
            if nb_chunk < 0:
                break
            if nb_chunk > 0:
                bins[i] = nb_chunk
        info("Found {:d} chunks in {:d} large non-empty bins.".format(sum(bins.values()), len(bins)))
        return


@register_command
class DetailRegistersCommand(GenericCommand):
    """Display full details on one, many or all registers value from current architecture."""
    _cmdline_ = "registers"
    _syntax_ = "{:s} [[Register1][Register2] ... [RegisterN]]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s}\n".format(_cmdline_)
    _example_ += "{:s} $eax $eip $esp".format(_cmdline_)
    _category_ = "Show/Modify Register"

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        unchanged_color = get_gef_setting("theme.registers_register_name")
        changed_color = get_gef_setting("theme.registers_value_changed")

        if argv:
            argv = [arg if arg.startswith("$") else "$" + arg for arg in argv]
            regs = [reg for reg in current_arch.all_registers if reg in argv]
            if not regs:
                warn("No matching registers found")
        else:
            regs = current_arch.all_registers

        widest = current_arch.get_aliased_registers_name_max()
        special_line = ""

        for regname in regs:
            reg = gdb.parse_and_eval(regname)
            if reg.type.code == gdb.TYPE_CODE_VOID:
                continue

            # https://arvid.io/2016/08/21/test-if-a-variable-is-unavailable-in-gdb/
            if str(reg) == "<unavailable>":
                padreg = current_arch.get_aliased_registers()[regname].ljust(widest, " ")
                line = "{}: ".format(Color.colorify(padreg, unchanged_color))
                line += Color.colorify("no value", "yellow underline")
                gef_print(line)
                continue

            # colorling
            value = align_address(int(reg))
            old_value = ContextCommand.old_registers.get(regname, 0)
            if value == old_value:
                color = unchanged_color
            else:
                color = changed_color

            # Special (e.g. segment) registers go on their own line
            if regname in current_arch.special_registers:
                special_line += "{}: ".format(Color.colorify(regname, color))
                special_line += "{:#04x} ".format(get_register(regname))
                continue

            # reg name
            padreg = current_arch.get_aliased_registers()[regname].ljust(widest, " ")
            line = "{}: ".format(Color.colorify(padreg, color))

            # flag register
            if regname == current_arch.flag_register:
                line += current_arch.flag_register_to_human()
                gef_print(line)
                continue

            # dereference values
            line += to_string_dereference_from(value)

            gef_print(line)

        if special_line:
            gef_print(special_line)
        return


@register_command
class RopperCommand(GenericCommand):
    """Ropper (http://scoding.de/ropper) plugin."""
    _cmdline_ = "ropper"
    _syntax_ = "{:s} [-h] [ROPPER_OPTIONS]".format(_cmdline_)
    _category_ = "Exploit Development"

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        try:
            ropper = __import__("ropper")
        except ImportError:
            msg = "Missing `ropper` package for Python, install with: `pip install ropper`."
            raise ImportWarning(msg)

        if "-h" in argv:
            os.system("ropper --help")
            os.system("ropper --help-examples")
            return

        if "--file" not in argv:
            path = get_filepath()
            if path is None:
                err("Missing info about file. Please set: `file /path/to/target_binary`")
                return
            argv.append("--file")
            argv.append(path)
            if is_qemu_usermode():
                sect = next(filter(lambda x: x.path == "[code]", get_process_maps()))
            else:
                sect = next(filter(lambda x: x.path == get_filepath(for_vmmap=True), get_process_maps()))
            argv.append("-I")
            argv.append("{:#x}".format(sect.page_start))

        # ropper set up own autocompleter after which gdb/gef autocomplete don't work
        # due to fork/waitpid, child will be broken but parent will not change
        gef_print(titlify(path))
        pid = os.fork()
        if pid == 0:
            try:
                ropper.start(argv)
            except Exception:
                pass
            os._exit(0)
        else:
            os.waitpid(pid, 0)
        return


@register_command
class RpCommand(GenericCommand):
    """Exec `rp++`."""
    _cmdline_ = "rp"
    _syntax_ = "{:s} bin|libc|FILENAME|kernel [-f|--filter REGEXP] [-r|--rop ROP_N] [--no-print] [...]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} bin -f 'pop r[abcd]x'\n".format(_cmdline_)
    _example_ += "{:s} libc -f '(xchg|mov) [re]sp, \\\\w+' -f 'ret'\n".format(_cmdline_)
    _example_ += "{:s} kernel # under qemu-system (x86/x64) only".format(_cmdline_)
    _category_ = "Exploit Development"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_FILENAME)
        self.rp_version = 1
        return

    def exec_rp(self, ropN):
        out = "rop{}_{}_v{}.txt".format(ropN, os.path.basename(self.path), self.rp_version)
        cmd = f"{self.rp} --file='{self.path}' --rop={ropN} --unique > {out}"
        gef_print(titlify(cmd))
        if not os.path.exists(out):
            os.system(cmd)
        return out

    def apply_filter(self, out, filter_patterns, base_address):
        if not os.path.exists(out):
            err(f"{out} is not found")
            return
        lines = open(out, "r").read()

        _, tmp_path = tempfile.mkstemp()
        fp = open(tmp_path, "w")
        for line in lines.splitlines():
            line = re.sub(r"\x1B\[([0-9]{1,2}(;[0-9]{1,2})*)?m", "", line) # remove color

            match = True
            for pat in filter_patterns:
                if not re.search(pat, line):
                    match = False
                    break

            if match:
                if line.startswith("0x"):
                    x = line.split(":")
                    addr, gadget = int(x[0], 16), ':'.join(x[1:])
                    addr -= base_address # fix address
                    x = Color.redify("{:#08x}".format(addr)) + ":" + gadget # repaint color
                else:
                    x = line
                fp.write(x + "\n")
        fp.close()
        return tmp_path

    @only_if_gdb_running
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        # load rp path
        if self.rp_version == 1:
            try:
                self.rp = which("rp-lin-x64")
            except FileNotFoundError as e1:
                try:
                    self.rp = which("rp-lin-x86")
                except FileNotFoundError as e2:
                    err("{}".format(e1))
                    err("{}".format(e2))
                    return
        elif self.rp_version == 2:
            try:
                self.rp = which("rp-lin-x64-v2")
            except FileNotFoundError as e1:
                err("{}".format(e1))
                return

        # load less path
        try:
            self.less = which("less")
        except FileNotFoundError as e:
            err("{}".format(e))
            return

        # parse args
        try:
            ropN = 3
            while "-r" in argv:
                idx = argv.index("-r")
                ropN = int(argv[idx + 1])
                argv = argv[:idx] + argv[idx + 2:]
            while "--rop" in argv:
                idx = argv.index("--rop")
                ropN = int(argv[idx + 1])
                argv = argv[:idx] + argv[idx + 2:]
        except Exception:
            self.usage()
            return

        try:
            filter_patterns = []
            while "-f" in argv:
                idx = argv.index("-f")
                pattern = argv[idx + 1]
                filter_patterns.append(pattern)
                argv = argv[:idx] + argv[idx + 2:]
            while "--filter" in argv:
                idx = argv.index("--filter")
                pattern = argv[idx + 1]
                filter_patterns.append(pattern)
                argv = argv[:idx] + argv[idx + 2:]
        except Exception:
            self.usage()
            return

        do_print = True
        if "--no-print" in argv:
            do_print = False
            argv.remove("--no-print")

        if len(argv) != 1:
            self.usage()
            return

        if is_qemu_system():
            if argv[0] == "kernel":
                # dump kernel then apply vmlinux-to-elf
                dump_mem_file = "/tmp/gef-dump-memory.raw"
                self.path = symboled_vmlinux_file = "/tmp/gef-dump-memory.elf"
                addrs = VmlinuxToElfApplyCommand().dump_kernel_elf(dump_mem_file, symboled_vmlinux_file)
                if addrs is None:
                    err("Failed to get symboled ELF")
                    return
                base_address = addrs["kbase"]
            else:
                self.usage()
                return
        else:
            if argv[0] == "libc":
                libc = process_lookup_path(("libc-2.", "libc.so.6"))
                if libc is None:
                    err("libc is not found")
                    return
                self.path = libc.path
            elif argv[0] == "bin":
                binary = get_filepath()
                if binary is None:
                    err("binary is not found")
                    return
                self.path = binary
            else:
                if not os.path.exists(argv[0]):
                    err("{} is not found".format(argv[0]))
                    return
                self.path = argv[0]
            base_address = 0

        # invoke rp++
        out = self.exec_rp(ropN)

        # filtering
        tmp_path = self.apply_filter(out, filter_patterns, base_address)
        if tmp_path is None:
            return

        # print
        if do_print:
            os.system(f"{self.less} -R {tmp_path}")
            os.unlink(tmp_path)
        return


@register_command
class Rp2Command(RpCommand):
    """Exec `rp++-v2`."""
    _cmdline_ = "rp2"
    _syntax_ = "{:s} bin|libc|FILENAME|kernel [-f|--filter REGEXP] [-r|--rop ROP_N] [--no-print] [...]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} bin -f 'pop r[abcd]x'\n".format(_cmdline_)
    _example_ += "{:s} libc -f '(xchg|mov) [re]sp, \\\\w+' -f 'ret'\n".format(_cmdline_)
    _example_ += "{:s} kernel # under qemu-system (x86/x64) only".format(_cmdline_)
    _category_ = "Exploit Development"

    def __init__(self):
        super().__init__()
        self.rp_version = 2
        return


@register_command
class AssembleCommand(GenericCommand):
    """Inline code assemble by keystone. Architecture can be set in GEF runtime config (default x86-64). """
    _cmdline_ = "asm"
    _syntax_ = "{:s} [-h] [-a ARCH] [-m MODE] [-e] [-s] [-l LOCATION] instruction;[instruction;...instruction;]\n".format(_cmdline_)
    _syntax_ += "  -a ARCH      specify the architecture\n"
    _syntax_ += "  -m MODE      specify the mode\n"
    _syntax_ += "  -e           use big-endian\n"
    _syntax_ += "  -s           output like shellcode style\n"
    _syntax_ += "  -l LOCATION  write to memory address"
    # for updates, see https://github.com/keystone-engine/keystone/blob/master/include/keystone/keystone.h
    _example_ = "\n"
    _example_ += '{:s} -a X86 -m 64 "mov rax, qword ptr [rax] ; inc rax ;"\n'.format(_cmdline_)
    _example_ += '{:s} -a X86 -m 32 "mov eax, dword ptr [eax] ; inc eax ;"\n'.format(_cmdline_)
    _example_ += '{:s} -a X86 -m 16 "mov ax, word ptr [ax] ; inc ax"\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM -m ARM      "sub r1, r2, r3"\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM -m ARM -e   "sub r1, r2, r3"\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM -m THUMB    "movs r4, #0xf0"\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM -m THUMB -e "movs r4, #0xf0"\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM64 -m ARM    "ldr w1, [sp, #0x8]"\n'.format(_cmdline_)
    _example_ += '{:s} -a MIPS -m MIPS32    "and $9, $6, $7"\n'.format(_cmdline_)
    _example_ += '{:s} -a MIPS -m MIPS32 -e "and $9, $6, $7"\n'.format(_cmdline_)
    _example_ += '{:s} -a MIPS -m MIPS64    "and $9, $6, $7"\n'.format(_cmdline_)
    _example_ += '{:s} -a MIPS -m MIPS64 -e "and $9, $6, $7"\n'.format(_cmdline_)
    _example_ += '{:s} -a PPC -m PPC32 -e "add 1, 2, 3"\n'.format(_cmdline_)
    _example_ += '{:s} -a PPC -m PPC64    "add 1, 2, 3"\n'.format(_cmdline_)
    _example_ += '{:s} -a PPC -m PPC64 -e "add 1, 2, 3"\n'.format(_cmdline_)
    _example_ += '{:s} -a SPARC -m SPARC32 -e "add %g1, %g2, %g3"\n'.format(_cmdline_)
    _example_ += '{:s} -a SPARC -m SPARC64 -e "add %g1, %g2, %g3"\n'.format(_cmdline_)
    _example_ += '{:s} -a SYSTEMZ -e "a %r0, 4095(%r15,%r1)"'.format(_cmdline_)
    _category_ = "Assemble"

    @load_keystone
    def do_invoke(self, argv):
        self.dont_repeat()

        arch_s, mode_s, big_endian, as_shellcode, overwrite_location = None, None, False, False, None
        try:
            opts, args = getopt.getopt(argv, "a:m:l:esh")
            for o, a in opts:
                if o == "-a":
                    arch_s = a.upper()
                if o == "-m":
                    mode_s = a.upper()
                if o == "-e":
                    big_endian = True
                if o == "-s":
                    as_shellcode = True
                if o == "-l":
                    overwrite_location = int(gdb.parse_and_eval(a))
                if o == "-h":
                    self.usage()
                    return
        except Exception:
            self.usage()
            return

        if not args:
            self.usage()
            return

        if (arch_s, mode_s) == (None, None):
            if is_alive():
                arch_s, mode_s = current_arch.arch, current_arch.mode
                endian_s = "big" if is_big_endian() else "little"
                arch, mode = get_keystone_arch(arch=arch_s, mode=mode_s, endian=is_big_endian())
            else:
                # if not alive, defaults to x86-64
                arch_s, mode_s = "X86", "64"
                endian_s = "little"
                arch, mode = get_keystone_arch(arch=arch_s, mode=mode_s, endian=False)
        elif not arch_s:
            err("An architecture (-a) must be provided")
            return
        elif arch_s != "SYSTEMZ" and not mode_s:
            # keystone gives no error so check here
            err("A mode (-m) must be provided")
            return
        elif arch_s in ["SPARC", "SYSTEM_Z"] and big_endian is False:
            # keystone gives no error so check here
            err("A big endian flag (-e) must be provided")
            return
        else:
            endian_s = "big" if big_endian else "little"
            arch, mode = get_keystone_arch(arch=arch_s, mode=mode_s, endian=big_endian)

        insns = " ".join(args)
        insns = [x.strip() for x in insns.split(";") if x is not None and x.strip() != ""]

        arch_mode_s = ":".join([str(arch_s), str(mode_s)])
        info("Assembling {} instruction{} for {} ({} endian)".format(len(insns), "s" if len(insns) > 1 else "", arch_mode_s, endian_s))

        if as_shellcode:
            gef_print("""sc="" """)

        raw = b""
        for insn in insns:
            res = keystone_assemble(insn, arch, mode, raw=True)
            if not res:
                gef_print("(Invalid)")
                continue

            if overwrite_location:
                raw += res
                continue

            s = binascii.hexlify(res)
            res = b"\\x" + b"\\x".join([s[i:i + 2] for i in range(0, len(s), 2)])
            res = res.decode("utf-8")

            if as_shellcode:
                res = """sc+="{0:s}" """.format(res)

            gef_print("{0:60s} # {1}".format(res, insn))

        if overwrite_location:
            raw_sz = len(raw)
            info("Overwriting {:d} bytes at {:s}".format(raw_sz, format_address(overwrite_location)))
            write_memory(overwrite_location, raw, raw_sz)
        return


@register_command
class DisassembleCommand(GenericCommand):
    """Inline code disassemble by capstone. Architecture can be set in GEF runtime config (default x86-64). """
    _cmdline_ = "dasm"
    _syntax_ = "{:s} [-h] [-a ARCH] [-m MODE] [-e] hex-byte-code\n".format(_cmdline_)
    _syntax_ += "  -a ARCH      specify the architecture\n"
    _syntax_ += "  -m MODE      specify the mode\n"
    _syntax_ += "  -e           use big-endian"
    _example_ = "\n"
    _example_ += '{:s} -a X86 -m 64 "488b00 48ffc0"\n'.format(_cmdline_)
    _example_ += '{:s} -a X86 -m 32 "8b00 40"\n'.format(_cmdline_)
    _example_ += '{:s} -a X86 -m 16 "8b00 40"\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM -m ARM      "031042e0"\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM -m ARM -e   "e0421003"\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM -m THUMB    "f024"\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM -m THUMB -e "24f0"\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM64 -m ARM    "e10b40b9"\n'.format(_cmdline_)
    _example_ += '{:s} -a MIPS -m MIPS32    "2448c700"\n'.format(_cmdline_)
    _example_ += '{:s} -a MIPS -m MIPS32 -e "00c74824"\n'.format(_cmdline_)
    _example_ += '{:s} -a MIPS -m MIPS64    "2448c700"\n'.format(_cmdline_)
    _example_ += '{:s} -a MIPS -m MIPS64 -e "00c74824"\n'.format(_cmdline_)
    _example_ += '{:s} -a PPC -m 32 -e "7c221a14"\n'.format(_cmdline_)
    _example_ += '{:s} -a PPC -m 64    "141a227c"\n'.format(_cmdline_)
    _example_ += '{:s} -a PPC -m 64 -e "7c221a14"\n'.format(_cmdline_)
    _example_ += '{:s} -a SPARC -m SPARC32 -e "86004002"\n'.format(_cmdline_)
    _example_ += '{:s} -a SPARC -m SPARC64 -e "86004002"'.format(_cmdline_)
    _category_ = "Assemble"

    @load_capstone
    def do_invoke(self, argv):
        self.dont_repeat()

        arch_s, mode_s, big_endian = None, None, False
        try:
            opts, args = getopt.getopt(argv, "a:m:eh")
            for o, a in opts:
                if o == "-a":
                    arch_s = a.upper()
                if o == "-m":
                    mode_s = a.upper()
                if o == "-e":
                    big_endian = True
                if o == "-h":
                    self.usage()
                    return
        except Exception:
            self.usage()
            return

        if not args:
            self.usage()
            return

        if (arch_s, mode_s) == (None, None):
            if is_alive():
                arch_s, mode_s = current_arch.arch, current_arch.mode
                endian_s = "big" if is_big_endian() else "little"
                arch, mode = get_capstone_arch(arch=arch_s, mode=mode_s, endian=is_big_endian())
            else:
                # if not alive, defaults to x86-64
                arch_s, mode_s = "X86", "64"
                endian_s = "little"
                arch, mode = get_capstone_arch(arch=arch_s, mode=mode_s, endian=False)
        elif not arch_s:
            err("An architecture (-a) must be provided")
            return
        elif not mode_s:
            err("A mode (-m) must be provided")
            return
        elif arch_s == "SPARC" and big_endian is False:
            # capstone gives no error so check here
            err("A big endian flag (-e) must be provided")
            return
        else:
            endian_s = "big" if big_endian else "little"
            arch, mode = get_capstone_arch(arch=arch_s, mode=mode_s, endian=big_endian)

        insns = " ".join(args)
        insns = insns.replace(" ", "").replace("\t", "")
        try:
            insns = binascii.unhexlify(insns)
        except Exception:
            err("Invalid format")
            return

        arch_mode_s = ":".join([str(arch_s), str(mode_s)])
        info("Disassembling {} bytes for {} ({} endian)".format(len(insns), arch_mode_s, endian_s))

        capstone = sys.modules["capstone"]
        cs = capstone.Cs(arch, mode)
        cs.detail = True

        for insn in cs.disasm(insns, 0x0):
            b = binascii.hexlify(insn.bytes).decode("utf-8")
            gef_print("{:>#6x}:\t{:<10s}\t{:s}\t{:s}".format(insn.address, b, insn.mnemonic, insn.op_str))
        return


@register_command
class AsmListCommand(GenericCommand):
    """List up general instructions by capstone.(x64/x86 only) """
    _cmdline_ = "asm-list"
    _syntax_ = "{:s} [-h] [-a ARCH] [-m MODE] [-e] [-n NBYTE] [-f INCLUDE] [-v EXCLUDE] [-s]\n".format(_cmdline_)
    _syntax_ += "  -a ARCH      specify the architecture\n"
    _syntax_ += "  -m MODE      specify the mode\n"
    _syntax_ += "  -e           use big-endian (for future update)\n"
    _syntax_ += "  -s           use simple mode; exclude x87 fpu, SSE, etc.\n"
    _syntax_ += "  -n NBYE      filter by asm byte length\n"
    _syntax_ += "  -f INCLUDE   filter by string\n"
    _syntax_ += "  -v EXCLUDE   filter by string"
    _example_ = "\n"
    _example_ += '{:s} -a X86 -m 64\n'.format(_cmdline_)
    _example_ += '{:s} -a X86 -m 32\n'.format(_cmdline_)
    _example_ += '{:s} -a X86 -m 16\n'.format(_cmdline_)
    _example_ += '  F0 (LOCK prefix) is ignored\n'
    _example_ += '  F2/F3 (REPNE/REP prefix) are ignored\n'
    _example_ += '  2E/36/3E/26/64/65 (CS/SS/DS/ES/FS/GS override prefix) are ignored\n'
    _example_ += '  2E/3E (branch hint prefix) are ignored\n'
    _example_ += '  66 (operand size prefix) is included\n'
    _example_ += '  67 (address size prefix) is ignored\n'
    _example_ += '  40-4F (REX prefix) are ignored\n'
    _example_ += '  C4/C5 (VEX prefix) are ignored\n'
    _example_ += '  8F (XOP prefix) is ignored\n'
    _example_ += '  62 (EVEX prefix) is ignored'
    _category_ = "Assemble"

    def listup_x86(self, arch, mode):
        DISP64 = "1122334455667788"
        DISP32 = "11223344"
        DISP16 = "1122"
        DISP8 = "11"

        @functools.lru_cache()
        def get_typical_bytecodes_modrm(_reg):
            bytecodes = []
            for (mod, reg, rm) in itertools.product([0b00, 0b01, 0b10, 0b11], _reg, [0b000]):
                modrm = "%02X" % ((mod << 6) | (reg << 3) | rm)
                if mod == 0b00:
                    if rm == 0b101: # special case; [REG + disp32]
                        bytecode = modrm + DISP32
                    elif rm == 0b100: # use sib; [INDEX * SCALE + BASE]
                        for sib in filter(lambda x: x & 0b111 != 0b101, range(256)):
                            bytecode = modrm + "%02X" % sib
                    else: # [REG]
                        bytecode = modrm
                elif mod == 0b01:
                    if rm == 0b100: # use sib; [INDEX * SCALE + BASE + disp8]
                        bytecode = []
                        for sib in filter(lambda x: x & 0b111 != 0b101, range(256)):
                            b = modrm + ("%02X" % sib) + DISP8
                            bytecode.append(b)
                    else: # [REG + disp8]
                        bytecode = modrm + DISP8
                elif mod == 0b10:
                    if rm == 0b100: # use sib; [INDEX * SCALE + BASE + disp32]
                        bytecode = []
                        for sib in filter(lambda x: x & 0b111 != 0b101, range(256)):
                            b = modrm + ("%02X" % sib) + DISP32
                            bytecode.append(b)
                    else: # [REG + disp32]
                        bytecode = modrm + DISP32
                elif mod == 0b11: # REG
                    bytecode = modrm
                bytecodes.append(bytecode)
            return bytecodes

        @functools.lru_cache()
        def get_typical_bytecodes(opcodes):
            bytecodes = []
            for i, operand in enumerate(opcodes.split()):
                if operand in ["ib", "cb"]:
                    bytecode = [DISP8]
                elif operand in ["iw", "cw"]:
                    bytecode = [DISP16]
                elif operand in ["id", "cd"]:
                    bytecode = [DISP32]
                elif operand in ["iq"]:
                    bytecode = [DISP64]
                elif operand in ["/0", "/1", "/2", "/3", "/4", "/5", "/6", "/7"]:
                    bytecode = get_typical_bytecodes_modrm(tuple([int(operand[1])]))
                elif operand == "/r":
                    bytecode = get_typical_bytecodes_modrm(tuple([0]))
                elif operand.endswith(("+r", "+i")):
                    b = int(operand.split("+")[0], 16)
                    bytecode = ["%02X" % (b + x) for x in range(8)]
                else:
                    bytecode = [operand]
                bytecodes.append(bytecode)
            return [''.join(b) for b in itertools.product(*bytecodes)]

        # download defines
        url = 'https://raw.githubusercontent.com/bata24/gef/dev/asmdb/x86data.js'
        x86 = http_get(url)
        x86 = x86.split(b"// ${JSON:BEGIN}")[1].split(b"// ${JSON:END}")[0]
        x86 = json.loads(x86)

        x86_insns = x86["instructions"]
        # [opcode_str, unused, unused, opcodes, attr]
        x86_insns.append(["icebp", "", "", "F1", "Undocumented"])
        x86_insns.append(["salc", "", "", "D6", "Undocumented"])
        #x86_insns.append(["umov", "", "", "0F 10 /r", "Undocumented"]) # used by another opcode
        #x86_insns.append(["umov", "", "", "0F 11 /r", "Undocumented"]) # used by another opcode
        #x86_insns.append(["umov", "", "", "0F 12 /r", "Undocumented"]) # used by another opcode
        #x86_insns.append(["umov", "", "", "0F 13 /r", "Undocumented"]) # used by another opcode
        #x86_insns.append(["loadall", "", "", "0F 05", "Undocumented"]) # used by another opcode
        #x86_insns.append(["loadall", "", "", "0F 07", "Undocumented"]) # used by another opcode
        #x86_insns.append(["xbts", "", "", "0F A6", "Undocumented"]) # removed now
        #x86_insns.append(["ibts", "", "", "0F A7", "Undocumented"]) # removed now

        capstone = sys.modules["capstone"]
        cs = capstone.Cs(arch, mode)
        valid_patterns = []
        seen_patterns = []
        for insn in x86_insns:
            opcodes = insn[3]
            attr = insn[4].split()

            # filter ignore prefix pattern
            if "REX.W" in opcodes.split():
                continue
            if "VEX" in opcodes.split()[0].split("."):
                continue
            if "EVEX" in opcodes.split()[0].split("."):
                continue
            if "XOP" in opcodes.split()[0].split("."):
                continue

            # ex: "FF /2" -> ["FF10", "FF5011", ...]
            bytecodes = get_typical_bytecodes(opcodes)

            # check it is valid or not
            for hex_code in bytecodes:
                # dup check
                if hex_code in seen_patterns:
                    continue
                # disasm
                code = bytes.fromhex(hex_code)
                try:
                    asm = cs.disasm(code, 0).__next__()
                except Exception:
                    continue
                opstr = asm.mnemonic + " " + asm.op_str
                # add
                valid_patterns.append([hex_code, opstr, opcodes, attr])
                seen_patterns.append(hex_code)
        return valid_patterns

    @load_capstone
    def do_invoke(self, argv):
        self.dont_repeat()

        try:
            less = which("less")
        except FileNotFoundError as e:
            err("{}".format(e))
            return

        arch_s, mode_s, big_endian = None, None, False
        nbyte = None
        filter_include = []
        filter_exclude = []
        try:
            opts, args = getopt.getopt(argv, "a:m:n:f:v:eh")
            for o, a in opts:
                if o == "-a":
                    arch_s = a.upper()
                if o == "-m":
                    mode_s = a.upper()
                if o == "-e":
                    big_endian = True
                if o == "-n":
                    nbyte = int(a)
                if o == "-f":
                    filter_include.append(a)
                if o == "-v":
                    filter_exclude.append(a)
                if o == "-h":
                    self.usage()
                    return
        except Exception:
            self.usage()
            return

        if (arch_s, mode_s) == (None, None):
            if is_alive():
                arch_s, mode_s = current_arch.arch, current_arch.mode
                endian_s = "big" if is_big_endian() else "little"
                arch, mode = get_capstone_arch(arch=arch_s, mode=mode_s, endian=is_big_endian())
            else:
                # if not alive, defaults to x86-64
                arch_s, mode_s = "X86", "64"
                endian_s = "little"
                arch, mode = get_capstone_arch(arch=arch_s, mode=mode_s, endian=False)
        elif not arch_s:
            err("An architecture (-a) must be provided")
            return
        elif not mode_s:
            err("A mode (-m) must be provided")
            return
        else:
            endian_s = "big" if big_endian else "little"
            arch, mode = get_capstone_arch(arch=arch_s, mode=mode_s, endian=big_endian)

        endian_s # for future update

        # list up bytecode pattern
        if arch_s == "X86":
            patterns = self.listup_x86(arch, mode)
        else:
            err("Unsupported")
            return

        # filter and print
        fmt = "{:22s} {:60s} {:22s} {}\n"
        legend = ["Hex code", "Assembly code", "Opcode", "Attributes"]
        text = Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading"))
        for hex_code, opstr, opcodes, attr in patterns:
            # byte length filter
            if nbyte is not None and nbyte * 2 != len(hex_code):
                continue

            # keyword filter
            line = "{:22s} {:60s} {:22s} {}".format(hex_code, opstr, opcodes, ','.join(attr))
            if any([f not in line for f in filter_include]):
                continue
            if any([f in line for f in filter_exclude]):
                continue

            # not filtered
            text += line + "\n"

        _, tmp_path = tempfile.mkstemp()
        open(tmp_path, "w").write(text.rstrip())
        os.system(f"{less} -R {tmp_path}")
        os.unlink(tmp_path)
        return


@register_command
class ProcessListingCommand(GenericCommand):
    """List and filter process. If a PATTERN is given as argument, results shown will be grepped
    by this pattern."""
    _cmdline_ = "process-search"
    _syntax_ = "{:s} [REGEX_PATTERN]".format(_cmdline_)
    _example_ = "{:s} gdb.*".format(_cmdline_)
    _category_ = "Misc"
    _aliases_ = ["ps"]

    def __init__(self):
        super().__init__()
        ps = which("ps")
        self.add_setting("ps_command", "{:s} auxww".format(ps), "`ps` command to get process information")
        return

    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        do_attach = False
        smart_scan = False

        try:
            opts, args = getopt.getopt(argv, "as")
            for o, _ in opts:
                if o == "-a":
                    do_attach = True
                if o == "-s":
                    smart_scan = True
        except Exception:
            self.usage()
            return

        pattern = re.compile("^.*$") if not args else re.compile(args[0])

        for process in self.get_processes():
            pid = int(process["pid"])
            command = process["command"]
            process["user"] = process["user"].ljust(8)

            if not re.search(pattern, command):
                continue

            if smart_scan:
                if command.startswith("[") and command.endswith("]"):
                    continue
                if command.startswith("socat "):
                    continue
                if command.startswith("grep "):
                    continue
                if command.startswith("gdb "):
                    continue

            if args and do_attach:
                ok("Attaching to process='{:s}' pid={:d}".format(process["command"], pid))
                gdb.execute("attach {:d}".format(pid))
                return None

            line = [process[i] for i in ("pid", "user", "cpu", "mem", "tty", "command")]
            gef_print("\t".join(line))
        return None

    def get_processes(self):
        output = gef_execute_external(self.get_setting("ps_command").split(), True)
        names = [x.lower().replace("%", "") for x in output[0].split()]

        for line in output[1:]:
            fields = line.split()
            t = {}

            for i, name in enumerate(names):
                if i == len(names) - 1:
                    t[name] = " ".join(fields[i:])
                else:
                    t[name] = fields[i]
            yield t
        return


@register_command
class ElfInfoCommand(GenericCommand):
    """Display a limited subset of ELF header information. If no argument is provided, the command will
    show information about the current ELF being debugged."""
    _cmdline_ = "elf-info"
    _syntax_ = "{:s} [-h] [-r] [FILE|ADDRESS]".format(_cmdline_)
    _example_ = "{:s}                # parse binary itself\n".format(_cmdline_)
    _example_ += "{:s} /bin/ls        # parse binary specified\n".format(_cmdline_)
    _example_ += "{:s} 0x555555554000 # parse memory\n".format(_cmdline_)
    _example_ += "{:s} -r /bin/ls     # show `readelf -a FILE | less`".format(_cmdline_)
    _category_ = "Process Information"

    def __init__(self, *args, **kwargs):
        super().__init__(complete=gdb.COMPLETE_FILENAME)
        return

    def do_invoke(self, argv):
        self.dont_repeat()

        # http://www.sco.com/developers/gabi/latest/ch4.eheader.html
        classes = {
            Elf.ELF_32_BITS   : "32-bit",
            Elf.ELF_64_BITS   : "64-bit",
        }

        endianness = {
            Elf.LITTLE_ENDIAN : "Little-Endian",
            Elf.BIG_ENDIAN    : "Big-Endian",
        }

        osabi = {
            Elf.OSABI_SYSTEMV : "System V",
            Elf.OSABI_HPUX    : "HP-UX",
            Elf.OSABI_NETBSD  : "NetBSD",
            Elf.OSABI_LINUX   : "Linux",
            Elf.OSABI_SOLARIS : "Solaris",
            Elf.OSABI_AIX     : "AIX",
            Elf.OSABI_IRIX    : "IRIX",
            Elf.OSABI_FREEBSD : "FreeBSD",
            Elf.OSABI_OPENBSD : "OpenBSD",
        }

        types = {
            Elf.ET_RELOC      : "Relocatable",
            Elf.ET_EXEC       : "Executable",
            Elf.ET_DYN        : "Shared",
            Elf.ET_CORE       : "Core"
        }

        machines = {
            Elf.X86_64        : "x86-64",
            Elf.X86_32        : "x86",
            Elf.ARM           : "ARM",
            Elf.MIPS          : "MIPS",
            Elf.POWERPC       : "PowerPC",
            Elf.POWERPC64     : "PowerPC64",
            Elf.SPARC         : "SPARC",
            Elf.SPARC64       : "SPARC64",
            Elf.AARCH64       : "AArch64",
            Elf.RISCV         : "RISC-V",
            Elf.IA64          : "IA-64",
        }

        if "-h" in argv:
            self.usage()
            return

        use_readelf = False
        if "-r" in argv:
            argv.remove("-r")
            use_readelf = True

        if argv == []:
            if is_qemu_system():
                err("Argument-less calls are unsupported under qemu-system.")
                return

            filename = get_filepath()
            if filename is None:
                self.usage()
                return
            if use_readelf:
                os.system("readelf -a '{:s}' | less".format(filename))
                return
            elf = get_elf_headers(filename)

        else:
            filename = argv[0]
            if os.path.exists(filename):
                if use_readelf:
                    os.system("readelf -a '{:s}' | less".format(filename))
                    return
                elf = get_elf_headers(filename)
            elif use_readelf:
                self.usage()
                return
            else:
                try:
                    addr = int(argv[0], 0)
                    elf = Elf(addr)
                except Exception:
                    self.usage()
                    return

        if elf is None or not elf.is_valid():
            return

        data = [
            ("Magic", "{0!s}".format(hexdump(struct.pack(">I", elf.e_magic), show_raw=True))),
            ("Class", "{0:#x} - {1}".format(elf.e_class, classes[elf.e_class])),
            ("Endianness", "{0:#x} - {1}".format(elf.e_endianness, endianness[elf.e_endianness])),
            ("ELF Version", "{:#x}".format(elf.e_version)),
            ("OS ABI", "{0:#x} - {1}".format(elf.e_osabi, osabi[elf.e_osabi])),
            ("ABI Version", "{:#x}".format(elf.e_abiversion)),
            ("Type", "{0:#x} - {1}".format(elf.e_type, types[elf.e_type])),
            ("Machine", "{0:#x} - {1}".format(elf.e_machine, machines[elf.e_machine])),
            ("Version", "{:#x}".format(elf.e_eiversion)),
            ("Entry point", "{}".format(format_address(elf.e_entry))),
            ("Program Header Table" , "{}".format(format_address(elf.e_phoff))),
            ("Program Header Entry Size" , "{0} ({0:#x})".format(elf.e_phentsize)),
            ("Number of Program Headers" , "{}".format(elf.e_phnum)),
            ("Section Header Table" , "{}".format(format_address(elf.e_shoff))),
            ("Section Header Entry Size" , "{0} ({0:#x})".format(elf.e_shentsize)),
            ("Number of Section Headers" , "{}".format(elf.e_shnum)),
            ("ELF Header Size" , "{0} ({0:#x})".format(elf.e_ehsize)),
            ("Section Header String Table Index" , "{}".format(elf.e_shstrndx)),
        ]

        gef_print(titlify("ELF Header"))
        for title, content in data:
            gef_print("{:<34s}: {}".format(title, content))

        ptype = {
            Phdr.PT_NULL         : "NULL",
            Phdr.PT_LOAD         : "LOAD",
            Phdr.PT_DYNAMIC      : "DYNAMIC",
            Phdr.PT_INTERP       : "INTERP",
            Phdr.PT_NOTE         : "NOTE",
            Phdr.PT_SHLIB        : "SHLIB",
            Phdr.PT_PHDR         : "PHDR",
            Phdr.PT_TLS          : "TLS",
            Phdr.PT_GNU_EH_FRAME : "GNU_EH_FLAME",
            Phdr.PT_GNU_STACK    : "GNU_STACK",
            Phdr.PT_GNU_RELRO    : "GNU_RELRO",
            Phdr.PT_SUNWBSS      : "SUNWBSS",
            Phdr.PT_SUNWSTACK    : "SUNWSTACK",
            Phdr.PT_MIPS_REGINFO : "REGINFO",
            Phdr.PT_MIPS_RTPROC  : "RTPROC",
            Phdr.PT_MIPS_OPTIONS : "OPTIONS",
            Phdr.PT_MIPS_ABIFLAGS: "ABIFLAGS",
        }

        pflags = {
            0                                 : "---",
            Phdr.PF_X                         : "--X",
            Phdr.PF_W                         : "-W-",
            Phdr.PF_R                         : "R--",
            Phdr.PF_W | Phdr.PF_X             : "-WX",
            Phdr.PF_R | Phdr.PF_X             : "R-X",
            Phdr.PF_R | Phdr.PF_W             : "RW-",
            Phdr.PF_R | Phdr.PF_W | Phdr.PF_X : "RWX",
        }

        gef_print(titlify("Program Header"))
        fmt = "[{:>2s}] {:12s} {:>10s} {:>10s} {:>10s} {:>10s} {:>10s} {:5s} {:>8s}"
        legend = ["#", "Type", "Offset", "Virtaddr", "Physaddr", "FileSiz", "MemSiz", "Flags", "Align"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        for i, p in enumerate(elf.phdrs):
            p_type = ptype[p.p_type] if p.p_type in ptype else "UNKNOWN"
            p_flags = pflags[p.p_flags] if p.p_flags in pflags else "???"
            fmt = "[{:2d}] {:12s} {:#10x} {:#10x} {:#10x} {:#10x} {:#10x} {:5s} {:#8x}"
            gef_print(fmt.format(i, p_type, p.p_offset, p.p_vaddr, p.p_paddr, p.p_filesz, p.p_memsz, p_flags, p.p_align))

        stype = {
            Shdr.SHT_NULL           : "NULL",
            Shdr.SHT_PROGBITS       : "PROGBITS",
            Shdr.SHT_SYMTAB         : "SYMTAB",
            Shdr.SHT_STRTAB         : "STRTAB",
            Shdr.SHT_RELA           : "RELA",
            Shdr.SHT_HASH           : "HASH",
            Shdr.SHT_DYNAMIC        : "DYNAMIC",
            Shdr.SHT_NOTE           : "NOTE",
            Shdr.SHT_NOBITS         : "NOBITS",
            Shdr.SHT_REL            : "REL",
            Shdr.SHT_SHLIB          : "SHLIB",
            Shdr.SHT_DYNSYM         : "DYNSYM",
            Shdr.SHT_NUM            : "NUM",
            Shdr.SHT_INIT_ARRAY     : "INIT_ARRAY",
            Shdr.SHT_FINI_ARRAY     : "FINI_ARRAY",
            Shdr.SHT_PREINIT_ARRAY  : "PREINIT_ARRAY",
            Shdr.SHT_GROUP          : "GROUP",
            Shdr.SHT_SYMTAB_SHNDX   : "SYMTAB_SHNDX",
            Shdr.SHT_NUM            : "NUM",
            Shdr.SHT_GNU_ATTRIBUTES : "GNU_ATTRIBUTES",
            Shdr.SHT_GNU_HASH       : "GNU_HASH",
            Shdr.SHT_GNU_LIBLIST    : "GNU_LIBLIST",
            Shdr.SHT_CHECKSUM       : "CHECKSUM",
            Shdr.SHT_SUNW_move      : "SUNW_move",
            Shdr.SHT_SUNW_COMDAT    : "SUNW_COMDAT",
            Shdr.SHT_SUNW_syminfo   : "SUNW_syminfo",
            Shdr.SHT_GNU_verdef     : "GNU_verdef",
            Shdr.SHT_GNU_verneed    : "GNU_verneed",
            Shdr.SHT_GNU_versym     : "GNU_versym",
        }

        gef_print(titlify("Section Header"))
        if not elf.shdrs:
            gef_print("Not loaded")
        else:
            fmt = "[{:>2s}] {:40s} {:>15s} {:>10s} {:>10s} {:>10s} {:>10s} {:>5s} {:>5s} {:>5s} {:>8s}"
            legend = ["#", "Name", "Type", "Address", "Offset", "Size", "EntSiz", "Flags", "Link", "Info", "Align"]
            gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
            for i, s in enumerate(elf.shdrs):
                sh_type = stype[s.sh_type] if s.sh_type in stype else "UNKNOWN"
                sh_flags = ""
                if s.sh_flags & Shdr.SHF_WRITE:
                    sh_flags += "W"
                if s.sh_flags & Shdr.SHF_ALLOC:
                    sh_flags += "A"
                if s.sh_flags & Shdr.SHF_EXECINSTR:
                    sh_flags += "X"
                if s.sh_flags & Shdr.SHF_MERGE:
                    sh_flags += "M"
                if s.sh_flags & Shdr.SHF_STRINGS:
                    sh_flags += "S"
                if s.sh_flags & Shdr.SHF_INFO_LINK:
                    sh_flags += "I"
                if s.sh_flags & Shdr.SHF_LINK_ORDER:
                    sh_flags += "L"
                if s.sh_flags & Shdr.SHF_OS_NONCONFORMING:
                    sh_flags += "O"
                if s.sh_flags & Shdr.SHF_GROUP:
                    sh_flags += "G"
                if s.sh_flags & Shdr.SHF_TLS:
                    sh_flags += "T"
                if s.sh_flags & Shdr.SHF_EXCLUDE:
                    sh_flags += "E"
                if s.sh_flags & Shdr.SHF_COMPRESSED:
                    sh_flags += "C"

                fmt = "[{:2d}] {:40s} {:>15s} {:#10x} {:#10x} {:#10x} {:#10x} {:5s} {:#5x} {:#5x} {:#8x}"
                gef_print(fmt.format(i, s.sh_name, sh_type, s.sh_addr, s.sh_offset, s.sh_size,
                                     s.sh_entsize, sh_flags, s.sh_link, s.sh_info, s.sh_addralign))
        return


@register_command
class DwarfExceptionHandlerInfoCommand(GenericCommand):
    """Dump the DWARF exception handler informations"""
    _cmdline_ = "dwarf-exception-handler"
    _syntax_ = "{:s} [-f FILENAME] [-x]".format(_cmdline_)
    _example_ = "{:s} # parse loaded binary\n".format(_cmdline_)
    _example_ += "{:s} -f /path/to/binary # parse specified binary\n".format(_cmdline_)
    _example_ += "{:s} -x # with hexdump\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "Simplified DWARF Exception structure:\n"
    _example_ += "\n"
    _example_ += "\n"
    _example_ += "[OLD IMPLEMENTATION]\n"
    _example_ += " libgcc_s.so bss area               ELF Program Header (for .eh_frame_hdr)\n"
    _example_ += "+-----------------------+      +-> +----------------+\n"
    _example_ += "| ...                   |      |   | p_type         |\n"
    _example_ += "| frame_hdr_cache_head  |---+  |   | p_flags        |\n"
    _example_ += "+-frame_hdr_cache_entry-+ <-+  |   | p_offset       |\n"
    _example_ += "| pc_low                |      |   | p_vaddr        |----+\n"
    _example_ += "| pc_high               |      |   | p_paddr        |    |\n"
    _example_ += "| load_base             |      |   | p_filesz       |    |\n"
    _example_ += "| p_eh_frame_hdr        |------+   | p_memsz        |    |\n"
    _example_ += "| p_dynamic             |          | p_align        |    |         [NEW IMPLEMENTATION]\n"
    _example_ += "| link                  |---+      +----------------+    |          _dlfo_main@ld.so rodata area\n"
    _example_ += "+-frame_hdr_cache_entry-+ <-+                            |          _dlfo_nodelete_mappings@ld.so rodata area\n"
    _example_ += "| pc_low                |                                |         +-------------+\n"
    _example_ += "| pc_high               |                                |         | map_start   |\n"
    _example_ += "| load_base             |                                |         | map_end     |\n"
    _example_ += "| p_eh_frame_hdr        |                                |         | map         |\n"
    _example_ += "| p_dynamic             |                                | <-------| eh_frame    |\n"
    _example_ += "| link                  |                                |         | (eh_dbase)  |\n"
    _example_ += "+-----------------------+                                |         | (eh_count)  |\n"
    _example_ += "The frame_hdr_cache_head and frame_hdr_cache_entry are   |         +-------------+\n"
    _example_ += "initialized the first time they are called.              |\n"
    _example_ += "                                                         |\n"
    _example_ += "                           +-----------------------------+\n"
    _example_ += "                           |\n"
    _example_ += ".eh_frame_hdr              |      .eh_frame                                             .gcc_except_table\n"
    _example_ += "+----------------------+ <-+  +-> +-CIE---------------------+ <-+                   +-> +-LSDA-----------------+\n"
    _example_ += "| version              |      |   | length                  |   |                   |   | lpstart_enc          |\n"
    _example_ += "| eh_frame_ptr_enc     |      |   | cie_id (=0)             |   |                   |   | ttype_enc            |\n"
    _example_ += "| fde_count_enc        |      |   | version                 |   |                   |   | ttype_off            |\n"
    _example_ += "| table_enc            |      |   | augmentation_string     |   |                   |   | call_site_encoding   |\n"
    _example_ += "| eh_frame_ptr         |------+   | code_alignment_factor   |   |                   |   | call_site_table_len  |\n"
    _example_ += "| fde_count            |          | data_alignment_factor   |   |                   |   |+-CallSite-----------+|\n"
    _example_ += "| Table[0] initial_loc |          | return_address_register |   |                   |   || call_site_start    || try_start\n"
    _example_ += "| Table[0] fde         |---+      | augmentation_len        |   |                   |   || call_site_length   || try_end\n"
    _example_ += "| Table[1] initial_loc |   |      | augmentation_data[0]    |   |                   |   || landing_pad        || catch_start\n"
    _example_ += "| Table[1] fde         |   |      | ...                     |-(augmentation=='P')-+ |   || action             ||---+\n"
    _example_ += "| ...                  |   |      | ...                     |   |                 | |   |+-CallSite-----------+|   |\n"
    _example_ += "| Table[N] initial_loc |   |      | augmentation_data[N]    |   |                 | |   || ...                ||   |\n"
    _example_ += "| Table[N] fde         |   |      | program                 |   |                 | |   |+-ActionTable--------+| <-+\n"
    _example_ += "+----------------------+   +----> +-FDE---------------------+   |                 | |   || ar_filter          ||---+\n"
    _example_ += "                                  | length                  |   |                 | |   || ar_disp            ||   |\n"
    _example_ += "                                  | cie_pointer (!=0)       |---+                 | |   |+-ActionTable--------+|   |\n"
    _example_ += "                                  | pc_begin                | try_catch_base      | |   || ...                ||   |\n"
    _example_ += "                                  | pc_range                |                     | |   |+-TTypeTable---------+|   |\n"
    _example_ += "                                  | augmentation_len        |                     | |   || ...(stored upward) ||   |\n"
    _example_ += "                                  | augmentation_data[0]    |                     | |   |+-TTypeTable---------+| <-+\n"
    _example_ += "                                  | ...                     |-(augmentation=='L')-|-+   || ttype              ||---> type_info\n"
    _example_ += "                                  | augmentation_data[N]    |                     |     |+--------------------+|\n"
    _example_ += "                                  | program                 |                     |     +-LSDA-----------------+\n"
    _example_ += "                                  +-CIE---------------------+   +-----------------+     | ...                  |\n"
    _example_ += "                                  | ...                     |   |                       +----------------------+\n"
    _example_ += "                                  +-FDE---------------------+   |\n"
    _example_ += "                                  | ...                     |   |\n"
    _example_ += "                                  +-------------------------+   |\n"
    _example_ += "                                                                +----> personality_routine(=__gxx_personality_v0@libstdc++.so)"
    _category_ = "Process Information"

    # FDE data encoding
    DW_EH_PE_ptr      = 0x00
    DW_EH_PE_uleb128  = 0x01
    DW_EH_PE_udata2   = 0x02
    DW_EH_PE_udata4   = 0x03
    DW_EH_PE_udata8   = 0x04
    DW_EH_PE_signed   = 0x08
    DW_EH_PE_sleb128  = 0x09
    DW_EH_PE_sdata2   = 0x0a
    DW_EH_PE_sdata4   = 0x0b
    DW_EH_PE_sdata8   = 0x0c
    # FDE flags
    DW_EH_PE_absptr   = 0x00
    DW_EH_PE_pcrel    = 0x10
    DW_EH_PE_textrel  = 0x20
    DW_EH_PE_datarel  = 0x30
    DW_EH_PE_funcrel  = 0x40
    DW_EH_PE_aligned  = 0x50
    DW_EH_PE_indirect = 0x80
    DW_EH_PE_omit     = 0xff

    def format_entry(self, sec, entries):
        out = []
        out.append(titlify(sec["name"]))

        # hexdump
        if self.hexdump:
            out.append(hexdump(sec["data"], show_symbol=False, base=sec["offset"]))

        # print details
        fmt = "[{:<8}|+{:<6}] {:<23s} {:<30s}: {:<18s}  |  {:s}"
        legend = ["FileOff", "Offset", "Raw bytes", "Name", "Value", "Extra Information"]
        out.append(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))

        for entry in entries:
            if len(entry) == 1:
                out.append("[!] " + entry[0])

            elif len(entry) == 3: # separation
                pos, name, extra = entry
                if extra:
                    extra_s = "  |  {:s}".format(extra)
                else:
                    extra_s = ""
                out.append(titlify("[{:#06x}] {:4s}{:s}".format(pos, name, extra_s), color="red", msg_color="red"))

            elif len(entry) == 5: # data
                pos, raw_data, name, value, extra = entry

                pos_s = "[{:#08x}|+{:#06x}]".format(sec["offset"] + pos, pos)

                if raw_data is None:
                    raw_data_s = ""
                elif isinstance(raw_data, int):
                    raw_data_s = "{:02x}".format(raw_data)
                elif isinstance(raw_data, bytes):
                    raw_data_s = ' '.join(["{:02x}".format(x) for x in raw_data])
                else:
                    raise

                if isinstance(value, str):
                    value_s = value
                elif isinstance(value, int):
                    value_s = "{:#018x}".format(value)
                elif isinstance(value, list):
                    value_s = ' '.join(["{:#018x}".format(x) for x in value])

                if value is not None:
                    out.append("{:s} {:<23s} {:<30s}: {:<18s}  |  {:s}".format(pos_s, raw_data_s, name, value_s, extra))
                else:
                    out.append("{:s} {:<23s} {:<50s}  |  {:s}".format(pos_s, raw_data_s, name, extra))
        return out

    def get_uleb128(self, data, pos):
        acc = 0
        i = 0
        while True:
            if i == 10:
                return pos, 0xffffffffffffffff
            pos, b = self.read_1ubyte(data, pos)
            acc |= (b & 0x7f) << (i * 7)
            if (b & 0x80) == 0:
                return pos, acc
            i += 1

    def get_sleb128(self, data, pos):
        orig_pos = pos
        pos, acc = self.get_uleb128(data, pos)
        length = pos - orig_pos
        sleb_sign_mask = 1 << (length * 7 - 1)
        if (acc & sleb_sign_mask) == 0:
            return pos, acc
        else:
            sleb_value_mask = sleb_sign_mask - 1
            sleb_value = acc & sleb_value_mask
            bit_len = len("{:b}".format(sleb_value))
            real_sign_mask = 1 << bit_len
            real_value_mask = real_sign_mask - 1
            return pos, -1 * (((~sleb_value) & real_value_mask) + 1)

    def read_1ubyte(self, data, pos):
        acc = data[pos]
        return pos + 1, acc

    def read_1sbyte(self, data, pos):
        pB = lambda a: struct.pack("<B", a & 0xff)
        ub = lambda a: struct.unpack("<b", a)[0]
        u2i = lambda a: ub(pB(a))
        acc = data[pos]
        return pos + 1, u2i(acc)

    def read_2ubyte(self, data, pos):
        acc = (data[pos + 1] << 8) | data[pos]
        return pos + 2, acc

    def read_2sbyte(self, data, pos):
        pH = lambda a: struct.pack("<H", a & 0xffff)
        uh = lambda a: struct.unpack("<h", a)[0]
        u2i = lambda a: uh(pH(a))
        acc = (data[pos + 1] << 8) | data[pos]
        return pos + 2, u2i(acc)

    def read_4ubyte(self, data, pos):
        acc = (data[pos + 3] << 24) | (data[pos + 2] << 16) | (data[pos + 1] << 8) | data[pos]
        return pos + 4, acc

    def read_4sbyte(self, data, pos):
        pI = lambda a: struct.pack("<I", a & 0xffffffff)
        ui = lambda a: struct.unpack("<i", a)[0]
        u2i = lambda a: ui(pI(a))
        acc = (data[pos + 3] << 24) | (data[pos + 2] << 16) | (data[pos + 1] << 8) | data[pos]
        return pos + 4, u2i(acc)

    def read_8ubyte(self, data, pos):
        acc = (data[pos + 7] << 56) | (data[pos + 6] << 48) | (data[pos + 5] << 40) | (data[pos + 4] << 32)
        acc |= (data[pos + 3] << 24) | (data[pos + 2] << 16) | (data[pos + 1] << 8) | data[pos]
        return pos + 8, acc

    def read_8sbyte(self, data, pos):
        pQ = lambda a: struct.pack("<Q", a & 0xffffffffffffffff)
        uq = lambda a: struct.unpack("<q", a)[0]
        u2i = lambda a: uq(pQ(a))
        acc = (data[pos + 7] << 56) | (data[pos + 6] << 48) | (data[pos + 5] << 40) | (data[pos + 4] << 32)
        acc |= (data[pos + 3] << 24) | (data[pos + 2] << 16) | (data[pos + 1] << 8) | data[pos]
        return pos + 8, u2i(acc)

    def read_encoded(self, encoding, data, pos):
        if (encoding & 0xf) == self.DW_EH_PE_ptr:
            if self.elf.e_class == Elf.ELF_32_BITS:
                pos, res = self.read_4ubyte(data, pos)
            else:
                pos, res = self.read_8ubyte(data, pos)
        elif (encoding & 0xf) == self.DW_EH_PE_uleb128:
            pos, res = self.get_uleb128(data, pos)
        elif (encoding & 0xf) == self.DW_EH_PE_sleb128:
            pos, res = self.get_sleb128(data, pos)
        elif (encoding & 0xf) == self.DW_EH_PE_udata2:
            pos, res = self.read_2ubyte(data, pos)
        elif (encoding & 0xf) == self.DW_EH_PE_udata4:
            pos, res = self.read_4ubyte(data, pos)
        elif (encoding & 0xf) == self.DW_EH_PE_udata8:
            pos, res = self.read_8ubyte(data, pos)
        elif (encoding & 0xf) == self.DW_EH_PE_sdata2:
            pos, res = self.read_2sbyte(data, pos)
        elif (encoding & 0xf) == self.DW_EH_PE_sdata4:
            pos, res = self.read_4sbyte(data, pos)
        elif (encoding & 0xf) == self.DW_EH_PE_sdata8:
            pos, res = self.read_8sbyte(data, pos)
        else:
            raise
        return pos, res

    def get_encoding_str(self, fde_encoding):
        if fde_encoding == self.DW_EH_PE_omit:
            return "omit"
        s = []
        if (fde_encoding & 0xf) == self.DW_EH_PE_ptr:
            s.append("ptr")
        elif (fde_encoding & 0xf) == self.DW_EH_PE_uleb128:
            s.append("uleb128")
        elif (fde_encoding & 0xf) == self.DW_EH_PE_sleb128:
            s.append("sleb128")
        elif (fde_encoding & 0xf) == self.DW_EH_PE_udata2:
            s.append("udata2")
        elif (fde_encoding & 0xf) == self.DW_EH_PE_sdata2:
            s.append("sdata2")
        elif (fde_encoding & 0xf) == self.DW_EH_PE_udata4:
            s.append("udata4")
        elif (fde_encoding & 0xf) == self.DW_EH_PE_sdata4:
            s.append("sdata4")
        elif (fde_encoding & 0xf) == self.DW_EH_PE_udata8:
            s.append("udata8")
        elif (fde_encoding & 0xf) == self.DW_EH_PE_sdata8:
            s.append("sdata8")
        if (fde_encoding & 0x70) == self.DW_EH_PE_absptr:
            s.append("absptr")
        elif (fde_encoding & 0x70) == self.DW_EH_PE_pcrel:
            s.append("pcrel")
        elif (fde_encoding & 0x70) == self.DW_EH_PE_textrel:
            s.append("textrel")
        elif (fde_encoding & 0x70) == self.DW_EH_PE_datarel:
            s.append("datarel")
        elif (fde_encoding & 0x70) == self.DW_EH_PE_funcrel:
            s.append("funcrel")
        elif (fde_encoding & 0x70) == self.DW_EH_PE_aligned:
            s.append("aligned")
        if (fde_encoding & 0x80) == self.DW_EH_PE_indirect:
            s.append("indirect")
        return ','.join(s)

    def encoded_ptr_size(self, encoding, ptr_size):
        if (encoding & 0xf) == self.DW_EH_PE_ptr:
            return ptr_size
        elif (encoding & 0xf) in [self.DW_EH_PE_udata2, self.DW_EH_PE_sdata2]:
            return 2
        elif (encoding & 0xf) in [self.DW_EH_PE_udata4, self.DW_EH_PE_sdata4]:
            return 4
        elif (encoding & 0xf) in [self.DW_EH_PE_udata8, self.DW_EH_PE_sdata8]:
            return 8
        elif encoding == self.DW_EH_PE_omit:
            return 0
        err("Unsupported pointer encoding: {:#x}, assuming pointer size of {:d}.".format(encoding, ptr_size))
        return 0

    def parse_eh_frame_hdr(self, eh_frame_hdr):
        data = eh_frame_hdr["data"]
        shdr = [s for s in self.elf.shdrs if s.sh_name == ".eh_frame_hdr"][0]
        load_base = [phdr for phdr in self.elf.phdrs if phdr.p_type == Phdr.PT_LOAD][0].p_vaddr

        entries = []
        pos = 0

        try:
            new_pos, version = self.read_1ubyte(data, pos)
            entries.append([pos, data[pos:new_pos], "version", version, ""])
            pos = new_pos

            new_pos, eh_frame_ptr_enc = self.read_1ubyte(data, pos)
            encoding_str = self.get_encoding_str(eh_frame_ptr_enc)
            entries.append([pos, data[pos:new_pos], "eh_frame_ptr_enc", eh_frame_ptr_enc, "encoding: {:s}".format(encoding_str)])
            pos = new_pos

            new_pos, fde_count_enc = self.read_1ubyte(data, pos)
            encoding_str = self.get_encoding_str(fde_count_enc)
            entries.append([pos, data[pos:new_pos], "fde_count_enc", fde_count_enc, "encoding: {:s}".format(encoding_str)])
            pos = new_pos

            new_pos, table_enc = self.read_1ubyte(data, pos)
            encoding_str = self.get_encoding_str(table_enc)
            entries.append([pos, data[pos:new_pos], "table_enc", table_enc, "encoding: {:s}".format(encoding_str)])
            pos = new_pos

            eh_frame_ptr = 0
            if eh_frame_ptr_enc != self.DW_EH_PE_omit:
                new_pos, eh_frame_ptr = self.read_encoded(eh_frame_ptr_enc, data, pos)
                if (eh_frame_ptr_enc & 0x70) == self.DW_EH_PE_pcrel:
                    elf_offset = shdr.sh_offset + 4 + eh_frame_ptr
                    if self.is_pie:
                        extra_s = "vma: $codebase+{:#x}".format(load_base + elf_offset)
                    else:
                        extra_s = "vma: {:#x}".format(load_base + elf_offset)
                    entries.append([pos, data[pos:new_pos], "eh_frame_ptr", elf_offset, extra_s])
                else:
                    entries.append([pos, data[pos:new_pos], "eh_frame_ptr", eh_frame_ptr, ""])
                pos = new_pos

            fde_count = 0
            if fde_count_enc != self.DW_EH_PE_omit:
                new_pos, fde_count = self.read_encoded(fde_count_enc, data, pos)
                entries.append([pos, data[pos:new_pos], "fde_count", fde_count, ""])
                pos = new_pos

            table_cnt = 0
            if table_enc == (self.DW_EH_PE_datarel | self.DW_EH_PE_sdata4):
                while fde_count and data[pos:]:
                    entries.append([pos, "Table[{:4d}]".format(table_cnt), ""])

                    new_pos, initial_loc = self.read_4sbyte(data, pos)
                    initial_offset = shdr.sh_offset + initial_loc
                    if self.is_pie:
                        extra_s = "vma: $codebase+{:#x}".format(load_base + initial_offset)
                    else:
                        extra_s = "vma: {:#x}".format(load_base + initial_offset)
                    entries.append([pos, data[pos:new_pos], "initial_loc", initial_offset, extra_s])
                    pos = new_pos

                    new_pos, fde_offset = self.read_4sbyte(data, pos)
                    fde_offset_adjusted = fde_offset - (eh_frame_ptr + 4)
                    if self.is_pie:
                        extra_s = "vma: $codebase+{:#x}".format(load_base + shdr.sh_offset + fde_offset)
                    else:
                        extra_s = "vma: {:#x}".format(load_base + shdr.sh_offset + fde_offset)
                    entries.append([pos, data[pos:new_pos], "fde", fde_offset_adjusted, extra_s])
                    pos = new_pos

                    table_cnt += 1
        except Exception:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            entries.append(["Parse Error\n{}".format(exc_value)])
        return entries

    def parse_eh_frame(self, eh_frame):
        data = eh_frame["data"]
        shdr = [s for s in self.elf.shdrs if s.sh_name == ".eh_frame"][0]
        load_base = [phdr for phdr in self.elf.phdrs if phdr.p_type == Phdr.PT_LOAD][0].p_vaddr

        cies = []
        entries = []
        pos = 0

        try:
            while data[pos:]:
                offset = pos
                tmp_entries = []

                # parse length
                new_pos, unit_length = self.read_4ubyte(data, pos)
                length = 4 # default
                tmp_entries.append([pos, data[pos:new_pos], "length", unit_length, ""])
                pos = new_pos
                if unit_length == 0xffffffff:
                    new_pos, unit_length = self.read_8ubyte(data, pos)
                    length = 8
                    tmp_entries.append([pos, data[pos:new_pos], "extended_length", unit_length, ""])
                    pos = new_pos
                if unit_length == 0:
                    entries.append([offset, "Zero terminator", ""])
                    entries += tmp_entries
                    tmp_entries = []
                    continue

                ptr_size = 4 if self.elf.e_class == Elf.ELF_32_BITS else 8
                start = pos # use later
                cie_end = pos + unit_length

                # parse cie_id / cie_pointer
                if length == 4:
                    new_pos, cie_id = self.read_4ubyte(data, pos)
                else:
                    new_pos, cie_id = self.read_8ubyte(data, pos)
                if cie_id == 0:
                    tmp_entries.append([pos, data[pos:new_pos], "cie_id", cie_id, "type: CIE"])
                else:
                    extra_s = "type: FDE, Associated_CIE: {:#x}(={:#x}-{:#x})".format(start - cie_id, start, cie_id)
                    tmp_entries.append([pos, data[pos:new_pos], "cie_pointer", cie_id, extra_s])
                pos = new_pos

                version = 2
                fde_encoding = 0
                lsda_encoding = 0
                initial_location = 0
                vma_base = 0

                if cie_id == 0:  # CIE parsing
                    entries.append([offset, "CIE", ""])
                    entries += tmp_entries
                    tmp_entries = []

                    # parse version
                    new_pos, version = self.read_1ubyte(data, pos)
                    entries.append([pos, data[pos:new_pos], "version", version, ""])
                    pos = new_pos

                    # parse augmentation string
                    orig_pos = pos
                    augmentation = ""
                    while data[pos]:
                        augmentation += chr(data[pos])
                        pos += 1
                    pos += 1 # skip NUL
                    entries.append([orig_pos, data[orig_pos:pos], "augmentation_string", '"{:s}"'.format(augmentation), ""])

                    # parse ptr_size, segment_size
                    segment_size = 0
                    if version >= 4:
                        new_pos, ptr_size = self.raed_1ubyte(data, pos)
                        entries.append([pos, data[pos:new_pos], "ptr_size", ptr_size, ""])
                        pos = new_pos
                        new_pos, segment_size = self.read_1ubyte(data, pos)
                        entries.append([pos, data[pos:new_pos], "segment_size", segment_size, ""])
                        pos = new_pos

                    # parse code/data alignment factor
                    new_pos, code_alignment_factor = self.get_uleb128(data, pos)
                    entries.append([pos, data[pos:new_pos], "code_alignment_factor", code_alignment_factor, ""])
                    pos = new_pos
                    new_pos, data_alignment_factor = self.get_sleb128(data, pos)
                    entries.append([pos, data[pos:new_pos], "data_alignment_factor", data_alignment_factor, ""])
                    pos = new_pos

                    # parse augmentation data
                    if augmentation == "eh":
                        if self.elf.e_class == Elf.ELF_32_BITS:
                            new_pos, adjust = self.read_4ubyte(data, pos)
                        else:
                            new_pos, adjust = self.read_8ubyte(data, pos)
                        entries.append([pos, data[pos:new_pos], "eh_data", adjust, ""])
                        pos = new_pos

                    if version == 1:
                        new_pos, return_address_register = self.read_1ubyte(data, pos)
                        ra_reg_name = self.get_register_name(return_address_register)
                        extra_s = "Reg: {:s}".format(ra_reg_name)
                        entries.append([pos, data[pos:new_pos], "return_address_register", return_address_register, extra_s])
                        pos = new_pos
                    else:
                        new_pos, return_address_register = self.get_uleb128(data, pos)
                        ra_reg_name = self.get_register_name(return_address_register)
                        extra_s = "Reg: {:s}".format(ra_reg_name)
                        entries.append([pos, data[pos:new_pos], "return_address_register", return_address_register, extra_s])
                        pos = new_pos

                    if augmentation[0] == "z":
                        new_pos, augmentation_len = self.get_uleb128(data, pos)
                        entries.append([pos, data[pos:new_pos], "augmentation_len", augmentation_len, ""])
                        pos = new_pos

                        for cp in augmentation[1:]:
                            if cp == "R":
                                new_pos, fde_encoding = self.read_1ubyte(data, pos)
                                encoding_str = self.get_encoding_str(fde_encoding)
                                extra_s = "FDE address encoding: {:s}".format(encoding_str)
                                entries.append([pos, data[pos:new_pos], "augmentation_data(R)", fde_encoding, extra_s])
                                pos = new_pos
                            elif cp == "L":
                                new_pos, lsda_encoding = self.read_1ubyte(data, pos)
                                encoding_str = self.get_encoding_str(lsda_encoding)
                                extra_s = "LSDA pointer encoding: {:s}".format(encoding_str)
                                entries.append([pos, data[pos:new_pos], "augmentation_data(L)", lsda_encoding, extra_s])
                                pos = new_pos
                            elif cp == "P":
                                new_pos, p_encoding = self.read_1ubyte(data, pos)
                                encoding_str = self.get_encoding_str(p_encoding)
                                extra_s = "Personality pointer encoding: {:s}".format(encoding_str)
                                entries.append([pos, data[pos:new_pos], "augmentation_data(P)", p_encoding, extra_s])
                                pos = new_pos
                                new_pos, p_addr = self.read_encoded(p_encoding, data, pos)
                                if (p_encoding & 0x70) == self.DW_EH_PE_pcrel:
                                    p_addr += shdr.sh_offset + pos
                                    if self.is_pie:
                                        extra_s = "Personality pointer address: $codebase+{:#x}".format(load_base + p_addr)
                                    else:
                                        extra_s = "Personality pointer address: {:#x}".format(load_base + p_addr)
                                else:
                                    extra_s = "Personality pointer address"
                                entries.append([pos, data[pos:new_pos], "augmentation_data(P)", p_addr, extra_s])
                                pos = new_pos
                            else: # unknown
                                new_pos, x = self.read_1ubyte(data, pos)
                                entries.append([pos, data[pos:new_pos], "augmentation_data({:s})".format(cp), x, ""])
                                pos = new_pos
                    if ptr_size == 4 or ptr_size == 8:
                        cie = {}
                        cie["cie_offset"] = offset
                        cie["augmentation"] = augmentation
                        cie["fde_encoding"] = fde_encoding
                        cie["lsda_encoding"] = lsda_encoding
                        cie["address_size"] = ptr_size
                        cie["code_alignment_factor"] = code_alignment_factor
                        cie["data_alignment_factor"] = data_alignment_factor
                        cies.append(cie)

                else: # FDE parsing
                    cie = [x for x in cies if start - cie_id == x["cie_offset"]][0]

                    entries.append([offset, "FDE", ""])
                    entries += tmp_entries # unit_length, cie_pointer
                    tmp_entries = []

                    ptr_size = self.encoded_ptr_size(cie["fde_encoding"], cie["address_size"])
                    base = pos

                    # parse pc_begin
                    if ptr_size == 4:
                        new_pos, initial_location = self.read_4ubyte(data, pos)
                    elif ptr_size == 8:
                        new_pos, initial_location = self.read_8ubyte(data, pos)
                    if (cie["fde_encoding"] & 0x70) == self.DW_EH_PE_pcrel:
                        vma_base = shdr.sh_offset + base + initial_location
                        if ptr_size == 4:
                            vma_base &= 0xffffffff
                        elif ptr_size == 8:
                            vma_base &= 0xffffffffffffffff
                        if self.is_pie:
                            extra_s = "pc_begin vma: $codebase+{:#x}".format(load_base + vma_base)
                        else:
                            extra_s = "pc_begin vma: {:#x}".format(load_base + vma_base)
                        entries.append([pos, data[pos:new_pos], "pc_begin", vma_base, extra_s])
                    else:
                        entries.append([pos, data[pos:new_pos], "pc_begin", initial_location, ""])
                    pos = new_pos

                    # parse pc_range
                    if ptr_size == 4:
                        new_pos, pc_range = self.read_4ubyte(data, pos)
                    elif ptr_size == 8:
                        new_pos, pc_range = self.read_8ubyte(data, pos)
                    if (cie["fde_encoding"] & 0x70) == self.DW_EH_PE_pcrel:
                        end_off = vma_base + pc_range
                    else:
                        end_off = initial_location + pc_range
                    if ptr_size == 4:
                        end_off &= 0xffffffff
                    elif ptr_size == 8:
                        end_off &= 0xffffffffffffffff
                    if self.is_pie:
                        extra_s = "pc_end vma: $codebase+{:#x}".format(load_base + end_off)
                    else:
                        extra_s = "pc_end vma: {:#x}".format(load_base + end_off)
                    entries.append([pos, data[pos:new_pos], "pc_range", pc_range, extra_s])
                    pos = new_pos

                    # parse augmentation
                    if cie["augmentation"][0] == "z":
                        new_pos, augmentation_len = self.get_uleb128(data, pos)
                        entries.append([pos, data[pos:new_pos], "augmentation_len", augmentation_len, ""])
                        pos = new_pos

                        aug_end = pos + augmentation_len
                        if augmentation_len:
                            for cp in cie["augmentation"][1:]:
                                if cp == "L":
                                    new_pos, lsda_pointer = self.read_encoded(cie["lsda_encoding"], data, pos)
                                    if (cie["lsda_encoding"] & 0x70) == self.DW_EH_PE_pcrel:
                                        lsda_pointer += shdr.sh_offset + pos
                                        if self.is_pie:
                                            extra_s = "LSDA pointer vma: $codebase+{:#x}".format(load_base + lsda_pointer)
                                        else:
                                            extra_s = "LSDA pointer vma: {:#x}".format(load_base + lsda_pointer)
                                        entries.append([pos, data[pos:new_pos], "augmentation_data(L)", lsda_pointer, extra_s])
                                    else:
                                        entries.append([pos, data[pos:new_pos], "augmentation_data(L)", lsda_pointer, "LSDA pointer"])
                                    pos = new_pos
                            if pos < aug_end:
                                entries.append([pos, data[pos:aug_end], "?", "", ""])
                            pos = aug_end

                # common
                entries += self.parse_cfa_program(data, pos, cie_end, vma_base, version, cie)
                pos = cie_end
        except Exception:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            entries.append(["Parse Error\n{}".format(exc_value)])
        return entries

    DW_CFA_advance_loc                  = 0x40
    DW_CFA_offset                       = 0x80
    DW_CFA_restore                      = 0xc0
    DW_CFA_nop                          = 0x00
    DW_CFA_set_loc                      = 0x01
    DW_CFA_advance_loc1                 = 0x02
    DW_CFA_advance_loc2                 = 0x03
    DW_CFA_advance_loc4                 = 0x04
    DW_CFA_offset_extended              = 0x05
    DW_CFA_restore_extended             = 0x06
    DW_CFA_undefined                    = 0x07
    DW_CFA_same_value                   = 0x08
    DW_CFA_register                     = 0x09
    DW_CFA_remember_state               = 0x0a
    DW_CFA_restore_state                = 0x0b
    DW_CFA_def_cfa                      = 0x0c
    DW_CFA_def_cfa_register             = 0x0d
    DW_CFA_def_cfa_offset               = 0x0e
    DW_CFA_def_cfa_expression           = 0x0f
    DW_CFA_expression                   = 0x10
    DW_CFA_offset_extended_sf           = 0x11
    DW_CFA_def_cfa_sf                   = 0x12
    DW_CFA_def_cfa_offset_sf            = 0x13
    DW_CFA_val_offset                   = 0x14
    DW_CFA_val_offset_sf                = 0x15
    DW_CFA_val_expression               = 0x16
    DW_CFA_low_user                     = 0x1c
    DW_CFA_MIPS_advance_loc8            = 0x1d
    DW_CFA_GNU_window_save              = 0x2d
    DW_CFA_AARCH64_negate_ra_state      = 0x2d # dup
    DW_CFA_GNU_args_size                = 0x2e
    DW_CFA_GNU_negative_offset_extended = 0x2f
    DW_CFA_high_user                    = 0x3f

    def get_register_name(self, reg):
        if self.elf.e_machine == Elf.X86_64:
            REG_LIST = [
                "rax", "rdx", "rcx", "rbx", "rsi", "rdi", "rbp", "rsp",
                "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
                "rip", "xmm0", "xmm1", "xmm2", "xmm3", "xmm4", "xmm5", "xmm6",
                "xmm7", "xmm8", "xmm9", "xmm10", "xmm11", "xmm12", "xmm13", "xmm14",
                "xmm15", "st0", "st1", "st2", "st3", "st4", "st5", "st6", "st7",
                "mm0", "mm1", "mm2", "mm3", "mm4", "mm5", "mm6", "mm7",
                "rflags", "es", "cs", "ss", "ds", "fs", "gs", "???",
                "???", "fs.base", "gs.base", "???", "???", "tr", "ldtr", "mxcsr",
                "fcw", "fsw",
            ]
        elif self.elf.e_machine == Elf.X86_32:
            REG_LIST = [
                "eax", "ecx", "edx", "rbx", "esp", "ebp", "esi", "edi",
                "eip", "eflags", "trapno", "st0", "st1", "st2", "st3", "st4",
                "st5", "st6", "st7", "???", "???", "xmm0", "xmm1", "xmm2",
                "xmm3", "xmm4", "xmm5", "xmm6", "xmm7", "mm0", "mm1", "mm2",
                "mm3", "mm4", "mm5", "mm6", "mm7", "fctrl", "fstat", "mxcsr",
                "es", "cs", "ss", "ds", "fs", "gs",
            ]
        elif self.elf.e_machine == Elf.ARM:
            REG_LIST = [
                "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
                "r8", "r9", "r10", "r11", "r12", "sp", "lr", "pc",
                "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",
            ] + ["???"] * 40 + [
                "s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7",
                "s8", "s9", "s10", "s11", "s12", "s13", "s14", "s15",
                "s16", "s17", "s18", "s19", "s20", "s21", "s22", "s23",
                "s24", "s25", "s26", "s27", "s28", "s29", "s30", "s31",
                "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",
                "wcgr0", "wcgr1", "wcgr2", "wcgr3", "wcgr4", "wcgr5", "wcgr6", "wcgr7",
                "wr0", "wr1", "wr2", "wr3", "wr4", "wr5", "wr6", "wr7",
                "wr8", "wr9", "wr10", "wr11", "wr12", "wr13", "wr14", "wr15",
                "spsr", "spsr_fiq", "spsr_irq", "spsr_abt", "spsr_und", "spsr_svc",
            ] + ["???"] * 10 + [
                "r8_usr", "r9_usr", "r10_usr", "r11_usr", "r12_usr", "r13_usr", "r14_usr", "r8_fiq",
                "r9_fiq", "r10_fiq", "r11_fiq", "r12_fiq", "r13_fiq", "r14_fiq", "r13_irq", "r14_irq",
                "r13_abt", "r14_abt", "r13_und", "r14_und", "r13_svc", "r14_svc",
            ] + ["???"] * 26 + [
                "wc0", "wc1", "wc2", "wc3", "wc4", "wc5", "wc6", "wc7",
            ]
        elif self.elf.e_machine == Elf.AARCH64:
            REG_LIST = [
                "x0", "x1", "x2", "x3", "x4", "x5", "x6", "x7",
                "x8", "x9", "x10", "x11", "x12", "x13", "x14", "x15",
                "x16", "x17", "x18", "x19", "x20", "x21", "x22", "x23",
                "x24", "x25", "x26", "x27", "x28", "x29", "x30", "sp",
                "???", "elr",
            ] + ["???"] * 30 + [
                "v0", "v1", "v2", "v3", "v4", "v5", "v6", "v7",
                "v8", "v9", "v10", "v11", "v12", "v13", "v14", "v15",
                "v16", "v17", "v18", "v19", "v20", "v21", "v22", "v23",
                "v24", "v25", "v26", "v27", "v28", "v29", "v30", "v31",
            ]
        else:
            # other arch is unimplemented
            return "r{:d}".format(reg)

        if reg < len(REG_LIST):
            return REG_LIST[reg]
        return "???"

    def parse_cfa_program(self, data, pos, pos_end, vma_base, version, cie):
        encoding = cie["fde_encoding"]
        ptr_size = cie["address_size"]
        code_align = cie["code_alignment_factor"]
        data_align = cie["data_alignment_factor"]
        pc = vma_base
        indent = " " * 4

        entries = []
        entries.append([pos, b"", "program", None, ""])
        try:
            while pos < pos_end:
                new_pos, opcode = self.read_1ubyte(data, pos)

                if opcode < self.DW_CFA_advance_loc:
                    if opcode == self.DW_CFA_nop:
                        entries.append([pos, data[pos:new_pos], indent + "nop", None, ""])
                    elif opcode == self.DW_CFA_set_loc:
                        new_pos, op1 = self.read_encoded(encoding, data, new_pos)
                        pc = vma_base + op1
                        entries.append([pos, data[pos:new_pos], indent + "set_loc {:#x} to {:#x}".format(op1, pc), None, ""])
                    elif opcode == self.DW_CFA_advance_loc1:
                        op1 = data[new_pos]
                        new_pos += 1
                        pc += op1 * code_align
                        entries.append([pos, data[pos:new_pos], indent + "advance_loc1 {:#x} to {:#x}".format(op1, pc), None, ""])
                    elif opcode == self.DW_CFA_advance_loc2:
                        new_pos, op1 = self.read_2ubyte(data, new_pos)
                        pc += op1 * code_align
                        entries.append([pos, data[pos:new_pos], indent + "advance_loc2 {:#x} to {:#x}".format(op1, pc), None, ""])
                    elif opcode == self.DW_CFA_advance_loc4:
                        new_pos, op1 = self.read_4ubyte(data, new_pos)
                        pc += op1 * code_align
                        entries.append([pos, data[pos:new_pos], indent + "advance_loc4 {:#x} to {:#x}".format(op1, pc), None, ""])
                    elif opcode == self.DW_CFA_offset_extended:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        new_pos, op2 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        off = op2 * data_align
                        entries.append([pos, data[pos:new_pos], indent + "offset_extended r{:d} ({:s}) at cfa{:+#x}".format(op1, regname, off), None, ""])
                    elif opcode == self.DW_CFA_restore_extended:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        entries.append([pos, data[pos:new_pos], indent + "restore_extended r{:d} ({:s})".fomart(op1, regname), None, ""])
                    elif opcode == self.DW_CFA_undefined:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        entries.append([pos, data[pos:new_pos], indent + "undefined r{:d} ({:s})".format(op1, regname), None, ""])
                    elif opcode == self.DW_CFA_same_value:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        entries.append([pos, data[pos:new_pos], indent + "same_value r{:d} ({:s})".format(op1, regname), None, ""])
                    elif opcode == self.DW_CFA_register:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        new_pos, op2 = self.get_uleb128(data, new_pos)
                        regname1 = self.get_register_name(op1)
                        regname2 = self.get_register_name(op2)
                        entries.append([pos, data[pos:new_pos], indent + "register r{:d} ({:s}) in r{:d} ({:s})".format(op1, regname1, op2, regname2), None, ""])
                    elif opcode == self.DW_CFA_remember_state:
                        entries.append([pos, data[pos:new_pos], indent + "remember_state", None, ""])
                    elif opcode == self.DW_CFA_restore_state:
                        entries.append([pos, data[pos:new_pos], indent + "restore_state", None, ""])
                    elif opcode == self.DW_CFA_def_cfa:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        new_pos, op2 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        entries.append([pos, data[pos:new_pos], indent + "def_cfa r{:d} ({:s}) at offset {:#x}".format(op1, regname, op2), None, ""])
                    elif opcode == self.DW_CFA_def_cfa_register:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        entries.append([pos, data[pos:new_pos], indent + "def_cfa_register r{:d} ({:s})".format(op1, regname), None, ""])
                    elif opcode == self.DW_CFA_def_cfa_offset:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        entries.append([pos, data[pos:new_pos], indent + "def_cfa_offset {:#x}".format(op1), None, ""])
                    elif opcode == self.DW_CFA_def_cfa_expression:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        entries.append([pos, data[pos:new_pos], indent + "def_cfa_expression {:#x}".format(op1), None, ""])
                        entries += self.parse_ops(version, ptr_size, op1, data, new_pos)
                        new_pos += op1
                    elif opcode == self.DW_CFA_expression:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        new_pos, op2 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        entries.append([pos, data[pos:new_pos], indent + "expression r{:d} ({:s})".format(op1, regname), None, ""])
                        entries += self.parse_ops(version, ptr_size, op2, data, new_pos)
                        new_pos += op2
                    elif opcode == self.DW_CFA_offset_extended_sf:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        new_pos, op2 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        off = op2 * data_align
                        entries.append([pos, data[pos:new_pos], indent + "offset_extended_sf r{:d} ({:s}) at cfa{:+#x}".format(op1, regname, off), None, ""])
                    elif opcode == self.DW_CFA_def_cfa_sf:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        new_pos, op2 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        off = op2 * data_align
                        entries.append([pos, data[pos:new_pos], indent + "def_cfa_sf r{:d} ({:s}) at offset {:#x}".format(op1, regname, off), None, ""])
                    elif opcode == self.DW_CFA_def_cfa_offset_sf:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        entries.append([pos, data[pos:new_pos], indent + "def_cfa_offset_sf {:#x}".format(op1 * data_align), None, ""])
                    elif opcode == self.DW_CFA_val_offset:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        new_pos, op2 = self.get_uleb128(data, new_pos)
                        off = op2 * data_align
                        entries.append([pos, data[pos:new_pos], indent + "val_offset {:#x} at offset {:#x}".format(op1, off), None, ""])
                    elif opcode == self.DW_CFA_val_offset_sf:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        new_pos, op2 = self.get_uleb128(data, new_pos)
                        off = op2 * data_align
                        entries.append([pos, data[pos:new_pos], indent + "val_offset_sf {:#x} at offset {:#x}".format(op1, off), None, ""])
                    elif opcode == self.DW_CFA_val_expression:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        new_pos, op2 = self.get_uleb128(data, new_pos)
                        regname = self.get_register_name(op1)
                        entries.append([pos, data[pos:new_pos], indent + "val_expression r{:d} ({:s})".format(op1, regname), None, ""])
                        entries += self.parse_ops(version, ptr_size, op2, data, new_pos)
                        new_pos += op2
                    elif opcode == self.DW_CFA_MIPS_advance_loc8:
                        new_pos, op1 = self.read_8ubyte(data, new_pos)
                        pc += op1 * code_align
                        entries.append([pos, data[pos:new_pos], indent + "MIPS_advance_loc8 {:#x} to {:#x}".format(op1, pc), None, ""])
                    elif opcode == self.DW_CFA_GNU_window_save:
                        if self.elf.e_machine == Elf.AARCH64:
                            entries.append([pos, data[pos:new_pos], indent + "AARCH64_negate_ra_state", None, ""])
                        else:
                            entries.append([pos, data[pos:new_pos], indent + "GNU_window_save", None, ""])
                    elif opcode == self.DW_CFA_GNU_args_size:
                        new_pos, op1 = self.get_uleb128(data, new_pos)
                        entries.append([pos, data[pos:new_pos], indent + "args_size {:#x}".format(op1), None, ""])
                    else:
                        entries.append([pos, data[pos:new_pos], indent + "??? {:#x}".format(opcode), None, ""])
                elif opcode < self.DW_CFA_offset:
                    op1 = opcode & 0x3f
                    pc += op1 * code_align
                    entries.append([pos, data[pos:new_pos], indent + "advance_loc {:d} to {:#x}".format(op1, pc), None, ""])
                elif opcode < self.DW_CFA_restore:
                    op1 = opcode & 0x3f
                    new_pos, op2 = self.get_uleb128(data, new_pos)
                    regname = self.get_register_name(op1)
                    off = op2 * data_align
                    entries.append([pos, data[pos:new_pos], indent + "offset r{:d} ({:s}) at cfa{:+#x}".format(op1, regname, off), None, ""])
                else:
                    op1 = opcode & 0x3f
                    regname = self.get_register_name(op1)
                    entries.append([pos, data[pos:new_pos], indent + "restore r{:d}".format(op1), None, ""])
                pos = new_pos
        except Exception:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            entries.append(["Parse Error\n{}".format(exc_value)])
        return entries

    DW_OP_addr                 = 0x03  # Constant address
    DW_OP_deref                = 0x06  #
    DW_OP_const1u              = 0x08  # Unsigned 1-byte constant
    DW_OP_const1s              = 0x09  # Signed 1-byte constant
    DW_OP_const2u              = 0x0a  # Unsigned 2-byte constant
    DW_OP_const2s              = 0x0b  # Signed 2-byte constant
    DW_OP_const4u              = 0x0c  # Unsigned 4-byte constant
    DW_OP_const4s              = 0x0d  # Signed 4-byte constant
    DW_OP_const8u              = 0x0e  # Unsigned 8-byte constant
    DW_OP_const8s              = 0x0f  # Signed 8-byte constant
    DW_OP_constu               = 0x10  # Unsigned LEB128 constant
    DW_OP_consts               = 0x11  # Signed LEB128 constant
    DW_OP_dup                  = 0x12  #
    DW_OP_drop                 = 0x13  #
    DW_OP_over                 = 0x14  #
    DW_OP_pick                 = 0x15  # 1-byte stack index
    DW_OP_swap                 = 0x16  #
    DW_OP_rot                  = 0x17  #
    DW_OP_xderef               = 0x18  #
    DW_OP_abs                  = 0x19  #
    DW_OP_and                  = 0x1a  #
    DW_OP_div                  = 0x1b  #
    DW_OP_minus                = 0x1c  #
    DW_OP_mod                  = 0x1d  #
    DW_OP_mul                  = 0x1e  #
    DW_OP_neg                  = 0x1f  #
    DW_OP_not                  = 0x20  #
    DW_OP_or                   = 0x21  #
    DW_OP_plus                 = 0x22  #
    DW_OP_plus_uconst          = 0x23  # Unsigned LEB128 addend
    DW_OP_shl                  = 0x24  #
    DW_OP_shr                  = 0x25  #
    DW_OP_shra                 = 0x26  #
    DW_OP_xor                  = 0x27  #
    DW_OP_bra                  = 0x28  # Signed 2-byte constant
    DW_OP_eq                   = 0x29  #
    DW_OP_ge                   = 0x2a  #
    DW_OP_gt                   = 0x2b  #
    DW_OP_le                   = 0x2c  #
    DW_OP_lt                   = 0x2d  #
    DW_OP_ne                   = 0x2e  #
    DW_OP_skip                 = 0x2f  # Signed 2-byte constant
    DW_OP_lit0                 = 0x30  # Literal 0
    DW_OP_lit1                 = 0x31  # Literal 1
    DW_OP_lit2                 = 0x32  # Literal 2
    DW_OP_lit3                 = 0x33  # Literal 3
    DW_OP_lit4                 = 0x34  # Literal 4
    DW_OP_lit5                 = 0x35  # Literal 5
    DW_OP_lit6                 = 0x36  # Literal 6
    DW_OP_lit7                 = 0x37  # Literal 7
    DW_OP_lit8                 = 0x38  # Literal 8
    DW_OP_lit9                 = 0x39  # Literal 9
    DW_OP_lit10                = 0x3a  # Literal 10
    DW_OP_lit11                = 0x3b  # Literal 11
    DW_OP_lit12                = 0x3c  # Literal 12
    DW_OP_lit13                = 0x3d  # Literal 13
    DW_OP_lit14                = 0x3e  # Literal 14
    DW_OP_lit15                = 0x3f  # Literal 15
    DW_OP_lit16                = 0x40  # Literal 16
    DW_OP_lit17                = 0x41  # Literal 17
    DW_OP_lit18                = 0x42  # Literal 18
    DW_OP_lit19                = 0x43  # Literal 19
    DW_OP_lit20                = 0x44  # Literal 20
    DW_OP_lit21                = 0x45  # Literal 21
    DW_OP_lit22                = 0x46  # Literal 22
    DW_OP_lit23                = 0x47  # Literal 23
    DW_OP_lit24                = 0x48  # Literal 24
    DW_OP_lit25                = 0x49  # Literal 25
    DW_OP_lit26                = 0x4a  # Literal 26
    DW_OP_lit27                = 0x4b  # Literal 27
    DW_OP_lit28                = 0x4c  # Literal 28
    DW_OP_lit29                = 0x4d  # Literal 29
    DW_OP_lit30                = 0x4e  # Literal 30
    DW_OP_lit31                = 0x4f  # Literal 31
    DW_OP_reg0                 = 0x50  # Register 0
    DW_OP_reg1                 = 0x51  # Register 1
    DW_OP_reg2                 = 0x52  # Register 2
    DW_OP_reg3                 = 0x53  # Register 3
    DW_OP_reg4                 = 0x54  # Register 4
    DW_OP_reg5                 = 0x55  # Register 5
    DW_OP_reg6                 = 0x56  # Register 6
    DW_OP_reg7                 = 0x57  # Register 7
    DW_OP_reg8                 = 0x58  # Register 8
    DW_OP_reg9                 = 0x59  # Register 9
    DW_OP_reg10                = 0x5a  # Register 10
    DW_OP_reg11                = 0x5b  # Register 11
    DW_OP_reg12                = 0x5c  # Register 12
    DW_OP_reg13                = 0x5d  # Register 13
    DW_OP_reg14                = 0x5e  # Register 14
    DW_OP_reg15                = 0x5f  # Register 15
    DW_OP_reg16                = 0x60  # Register 16
    DW_OP_reg17                = 0x61  # Register 17
    DW_OP_reg18                = 0x62  # Register 18
    DW_OP_reg19                = 0x63  # Register 19
    DW_OP_reg20                = 0x64  # Register 20
    DW_OP_reg21                = 0x65  # Register 21
    DW_OP_reg22                = 0x66  # Register 22
    DW_OP_reg23                = 0x67  # Register 24
    DW_OP_reg24                = 0x68  # Register 24
    DW_OP_reg25                = 0x69  # Register 25
    DW_OP_reg26                = 0x6a  # Register 26
    DW_OP_reg27                = 0x6b  # Register 27
    DW_OP_reg28                = 0x6c  # Register 28
    DW_OP_reg29                = 0x6d  # Register 29
    DW_OP_reg30                = 0x6e  # Register 30
    DW_OP_reg31                = 0x6f  # Register 31
    DW_OP_breg0                = 0x70  # Base register 0
    DW_OP_breg1                = 0x71  # Base register 1
    DW_OP_breg2                = 0x72  # Base register 2
    DW_OP_breg3                = 0x73  # Base register 3
    DW_OP_breg4                = 0x74  # Base register 4
    DW_OP_breg5                = 0x75  # Base register 5
    DW_OP_breg6                = 0x76  # Base register 6
    DW_OP_breg7                = 0x77  # Base register 7
    DW_OP_breg8                = 0x78  # Base register 8
    DW_OP_breg9                = 0x79  # Base register 9
    DW_OP_breg10               = 0x7a  # Base register 10
    DW_OP_breg11               = 0x7b  # Base register 11
    DW_OP_breg12               = 0x7c  # Base register 12
    DW_OP_breg13               = 0x7d  # Base register 13
    DW_OP_breg14               = 0x7e  # Base register 14
    DW_OP_breg15               = 0x7f  # Base register 15
    DW_OP_breg16               = 0x80  # Base register 16
    DW_OP_breg17               = 0x81  # Base register 17
    DW_OP_breg18               = 0x82  # Base register 18
    DW_OP_breg19               = 0x83  # Base register 19
    DW_OP_breg20               = 0x84  # Base register 20
    DW_OP_breg21               = 0x85  # Base register 21
    DW_OP_breg22               = 0x86  # Base register 22
    DW_OP_breg23               = 0x87  # Base register 23
    DW_OP_breg24               = 0x88  # Base register 24
    DW_OP_breg25               = 0x89  # Base register 25
    DW_OP_breg26               = 0x8a  # Base register 26
    DW_OP_breg27               = 0x8b  # Base register 27
    DW_OP_breg28               = 0x8c  # Base register 28
    DW_OP_breg29               = 0x8d  # Base register 29
    DW_OP_breg30               = 0x8e  # Base register 30
    DW_OP_breg31               = 0x8f  # Base register 31
    DW_OP_regx                 = 0x90  # Unsigned LEB128 register
    DW_OP_fbreg                = 0x91  # Signed LEB128 offset
    DW_OP_bregx                = 0x92  # ULEB128 register followed by SLEB128 off
    DW_OP_piece                = 0x93  # ULEB128 size of piece addressed
    DW_OP_deref_size           = 0x94  # 1-byte size of data retrieved
    DW_OP_xderef_size          = 0x95  # 1-byte size of data retrieved
    DW_OP_nop                  = 0x96  #
    DW_OP_push_object_address  = 0x97  #
    DW_OP_call2                = 0x98  #
    DW_OP_call4                = 0x99  #
    DW_OP_call_ref             = 0x9a  #
    DW_OP_form_tls_address     = 0x9b  # TLS offset to address in current thread
    DW_OP_call_frame_cfa       = 0x9c  # CFA as determined by CFI
    DW_OP_bit_piece            = 0x9d  # ULEB128 size and ULEB128 offset in bits
    DW_OP_implicit_value       = 0x9e  # DW_FORM_block follows opcode
    DW_OP_stack_value          = 0x9f  # No operands, special like DW_OP_piece
    #
    DW_OP_implicit_pointer     = 0xa0  #
    DW_OP_addrx                = 0xa1  #
    DW_OP_constx               = 0xa2  #
    DW_OP_entry_value          = 0xa3  #
    DW_OP_const_type           = 0xa4  #
    DW_OP_regval_type          = 0xa5  #
    DW_OP_deref_type           = 0xa6  #
    DW_OP_xderef_type          = 0xa7  #
    DW_OP_convert              = 0xa8  #
    DW_OP_reinterpret          = 0xa9  #
    # GNU extensions
    DW_OP_GNU_push_tls_address = 0xe0  #
    DW_OP_GNU_uninit           = 0xf0  #
    DW_OP_GNU_encoded_addr     = 0xf1  #
    DW_OP_GNU_implicit_pointer = 0xf2  #
    DW_OP_GNU_entry_value      = 0xf3  #
    DW_OP_GNU_const_type       = 0xf4  #
    DW_OP_GNU_regval_type      = 0xf5  #
    DW_OP_GNU_deref_type       = 0xf6  #
    DW_OP_GNU_convert          = 0xf7  #
    DW_OP_GNU_reinterpret      = 0xf9  #
    DW_OP_GNU_parameter_ref    = 0xfa  #
    # GNU Debug Fission extensions
    DW_OP_GNU_addr_index       = 0xfb  #
    DW_OP_GNU_const_index      = 0xfc  #
    DW_OP_GNU_variable_value   = 0xfd  #
    DW_OP_lo_user              = 0xe0  # Implementation-defined range start
    DW_OP_hi_user              = 0xff  # Implementation-defined range end

    def dwarf_locexpr_opcode_string(self, code):
        DWARF_ONE_KNOWN_DW_OP = {
            self.DW_OP_GNU_addr_index       : "GNU_addr_index",
            self.DW_OP_GNU_const_index      : "GNU_const_index",
            self.DW_OP_GNU_const_type       : "GNU_const_type",
            self.DW_OP_GNU_convert          : "GNU_convert",
            self.DW_OP_GNU_deref_type       : "GNU_deref_type",
            self.DW_OP_GNU_encoded_addr     : "GNU_encoded_addr",
            self.DW_OP_GNU_entry_value      : "GNU_entry_value",
            self.DW_OP_GNU_implicit_pointer : "GNU_implicit_pointer",
            self.DW_OP_GNU_parameter_ref    : "GNU_parameter_ref",
            self.DW_OP_GNU_push_tls_address : "GNU_push_tls_address",
            self.DW_OP_GNU_regval_type      : "GNU_regval_type",
            self.DW_OP_GNU_reinterpret      : "GNU_reinterpret",
            self.DW_OP_GNU_uninit           : "GNU_uninit",
            self.DW_OP_GNU_variable_value   : "GNU_variable_value",
            self.DW_OP_abs                  : "abs",
            self.DW_OP_addr                 : "addr",
            self.DW_OP_addrx                : "addrx",
            self.DW_OP_and                  : "and",
            self.DW_OP_bit_piece            : "bit_piece",
            self.DW_OP_bra                  : "bra",
            self.DW_OP_breg0                : "breg0",
            self.DW_OP_breg1                : "breg1",
            self.DW_OP_breg2                : "breg2",
            self.DW_OP_breg3                : "breg3",
            self.DW_OP_breg4                : "breg4",
            self.DW_OP_breg5                : "breg5",
            self.DW_OP_breg6                : "breg6",
            self.DW_OP_breg7                : "breg7",
            self.DW_OP_breg8                : "breg8",
            self.DW_OP_breg9                : "breg9",
            self.DW_OP_breg10               : "breg10",
            self.DW_OP_breg11               : "breg11",
            self.DW_OP_breg12               : "breg12",
            self.DW_OP_breg13               : "breg13",
            self.DW_OP_breg14               : "breg14",
            self.DW_OP_breg15               : "breg15",
            self.DW_OP_breg16               : "breg16",
            self.DW_OP_breg17               : "breg17",
            self.DW_OP_breg18               : "breg18",
            self.DW_OP_breg19               : "breg19",
            self.DW_OP_breg20               : "breg20",
            self.DW_OP_breg21               : "breg21",
            self.DW_OP_breg22               : "breg22",
            self.DW_OP_breg23               : "breg23",
            self.DW_OP_breg24               : "breg24",
            self.DW_OP_breg25               : "breg25",
            self.DW_OP_breg26               : "breg26",
            self.DW_OP_breg27               : "breg27",
            self.DW_OP_breg28               : "breg28",
            self.DW_OP_breg29               : "breg29",
            self.DW_OP_breg30               : "breg30",
            self.DW_OP_breg31               : "breg31",
            self.DW_OP_bregx                : "bregx",
            self.DW_OP_call2                : "call2",
            self.DW_OP_call4                : "call4",
            self.DW_OP_call_frame_cfa       : "call_frame_cfa",
            self.DW_OP_call_ref             : "call_ref",
            self.DW_OP_const1s              : "const1s",
            self.DW_OP_const1u              : "const1u",
            self.DW_OP_const2s              : "const2s",
            self.DW_OP_const2u              : "const2u",
            self.DW_OP_const4s              : "const4s",
            self.DW_OP_const4u              : "const4u",
            self.DW_OP_const8s              : "const8s",
            self.DW_OP_const8u              : "const8u",
            self.DW_OP_const_type           : "const_type",
            self.DW_OP_consts               : "consts",
            self.DW_OP_constu               : "constu",
            self.DW_OP_constx               : "constx",
            self.DW_OP_convert              : "convert",
            self.DW_OP_deref                : "deref",
            self.DW_OP_deref_size           : "deref_size",
            self.DW_OP_deref_type           : "deref_type",
            self.DW_OP_div                  : "div",
            self.DW_OP_drop                 : "drop",
            self.DW_OP_dup                  : "dup",
            self.DW_OP_entry_value          : "entry_value",
            self.DW_OP_eq                   : "eq",
            self.DW_OP_fbreg                : "fbreg",
            self.DW_OP_form_tls_address     : "form_tls_address",
            self.DW_OP_ge                   : "ge",
            self.DW_OP_gt                   : "gt",
            self.DW_OP_implicit_pointer     : "implicit_pointer",
            self.DW_OP_implicit_value       : "implicit_value",
            self.DW_OP_le                   : "le",
            self.DW_OP_lit0                 : "lit0",
            self.DW_OP_lit1                 : "lit1",
            self.DW_OP_lit2                 : "lit2",
            self.DW_OP_lit3                 : "lit3",
            self.DW_OP_lit4                 : "lit4",
            self.DW_OP_lit5                 : "lit5",
            self.DW_OP_lit6                 : "lit6",
            self.DW_OP_lit7                 : "lit7",
            self.DW_OP_lit8                 : "lit8",
            self.DW_OP_lit9                 : "lit9",
            self.DW_OP_lit10                : "lit10",
            self.DW_OP_lit11                : "lit11",
            self.DW_OP_lit12                : "lit12",
            self.DW_OP_lit13                : "lit13",
            self.DW_OP_lit14                : "lit14",
            self.DW_OP_lit15                : "lit15",
            self.DW_OP_lit16                : "lit16",
            self.DW_OP_lit17                : "lit17",
            self.DW_OP_lit18                : "lit18",
            self.DW_OP_lit19                : "lit19",
            self.DW_OP_lit20                : "lit20",
            self.DW_OP_lit21                : "lit21",
            self.DW_OP_lit22                : "lit22",
            self.DW_OP_lit23                : "lit23",
            self.DW_OP_lit24                : "lit24",
            self.DW_OP_lit25                : "lit25",
            self.DW_OP_lit26                : "lit26",
            self.DW_OP_lit27                : "lit27",
            self.DW_OP_lit28                : "lit28",
            self.DW_OP_lit29                : "lit29",
            self.DW_OP_lit30                : "lit30",
            self.DW_OP_lit31                : "lit31",
            self.DW_OP_lt                   : "lt",
            self.DW_OP_minus                : "minus",
            self.DW_OP_mod                  : "mod",
            self.DW_OP_mul                  : "mul",
            self.DW_OP_ne                   : "ne",
            self.DW_OP_neg                  : "neg",
            self.DW_OP_nop                  : "nop",
            self.DW_OP_not                  : "not",
            self.DW_OP_or                   : "or",
            self.DW_OP_over                 : "over",
            self.DW_OP_pick                 : "pick",
            self.DW_OP_piece                : "piece",
            self.DW_OP_plus                 : "plus",
            self.DW_OP_plus_uconst          : "plus_uconst",
            self.DW_OP_push_object_address  : "push_object_address",
            self.DW_OP_reg0                 : "reg0",
            self.DW_OP_reg1                 : "reg1",
            self.DW_OP_reg2                 : "reg2",
            self.DW_OP_reg3                 : "reg3",
            self.DW_OP_reg4                 : "reg4",
            self.DW_OP_reg5                 : "reg5",
            self.DW_OP_reg6                 : "reg6",
            self.DW_OP_reg7                 : "reg7",
            self.DW_OP_reg8                 : "reg8",
            self.DW_OP_reg9                 : "reg9",
            self.DW_OP_reg10                : "reg10",
            self.DW_OP_reg11                : "reg11",
            self.DW_OP_reg12                : "reg12",
            self.DW_OP_reg13                : "reg13",
            self.DW_OP_reg14                : "reg14",
            self.DW_OP_reg15                : "reg15",
            self.DW_OP_reg16                : "reg16",
            self.DW_OP_reg17                : "reg17",
            self.DW_OP_reg18                : "reg18",
            self.DW_OP_reg19                : "reg19",
            self.DW_OP_reg20                : "reg20",
            self.DW_OP_reg21                : "reg21",
            self.DW_OP_reg22                : "reg22",
            self.DW_OP_reg23                : "reg23",
            self.DW_OP_reg24                : "reg24",
            self.DW_OP_reg25                : "reg25",
            self.DW_OP_reg26                : "reg26",
            self.DW_OP_reg27                : "reg27",
            self.DW_OP_reg28                : "reg28",
            self.DW_OP_reg29                : "reg29",
            self.DW_OP_reg30                : "reg30",
            self.DW_OP_reg31                : "reg31",
            self.DW_OP_regval_type          : "regval_type",
            self.DW_OP_regx                 : "regx",
            self.DW_OP_reinterpret          : "reinterpret",
            self.DW_OP_rot                  : "rot",
            self.DW_OP_shl                  : "shl",
            self.DW_OP_shr                  : "shr",
            self.DW_OP_shra                 : "shra",
            self.DW_OP_skip                 : "skip",
            self.DW_OP_stack_value          : "stack_value",
            self.DW_OP_swap                 : "swap",
            self.DW_OP_xderef               : "xderef",
            self.DW_OP_xderef_size          : "xderef_size",
            self.DW_OP_xderef_type          : "xderef_type",
            self.DW_OP_xor                  : "xor",
        }
        if code in DWARF_ONE_KNOWN_DW_OP:
            return DWARF_ONE_KNOWN_DW_OP[code]
        elif code >= self.DW_OP_lo_user:
            return "lo_user+{:#x}".format(code - self.DW_OP_lo_user)
        else:
            return "??? ({:#x})".format(code)

    def parse_ops(self, vers, addrsize, length, data, pos, indent_n=0):
        indent = " " * ((indent_n + 2) * 4)
        entries = []
        ref_size = addrsize if vers < 3 else 0

        if length == 0:
            entries.append([pos, b"", indent + "(empty)", None, ""])
            return entries

        offset = 0
        try:
            while length:
                new_pos, op = self.read_1ubyte(data, pos)
                op_name = self.dwarf_locexpr_opcode_string(op)

                if op in [self.DW_OP_addr]:
                    if addrsize == 4:
                        new_pos, d = self.read_4ubyte(data, new_pos)
                    elif addrsize == 8:
                        new_pos, d = self.read_8ubyte(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_call_ref, self.DW_OP_GNU_variable_value]:
                    if ref_size == 4:
                        new_pos, d = self.read_4ubyte(data, new_pos)
                    else:
                        new_pos, d = self.read_8ubyte(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, ""])
                elif op in [self.DW_OP_deref]:
                    typ = {4: "uint", 8: "ulong"}[addrsize]
                    extra_s = "pop; push *({:s}*)popped_value".format(typ)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s}".format(offset, op_name), None, extra_s])
                elif op in [self.DW_OP_xderef]:
                    typ = {4: "uint", 8: "ulong"}[addrsize]
                    extra_s = "pop; pop; push *({:s}*)(popped_value2_as_segment:popped_value1)".format(typ)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s}".format(offset, op_name), None, extra_s])
                elif op in [self.DW_OP_deref_size]:
                    new_pos, d = self.read_1ubyte(data, new_pos)
                    typ = {1: "uchar", 2: "ushort", 4: "uint", 8: "ulong"}[d]
                    extra_s = "pop; push *({:s}*)popped_value".format(typ)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_xderef_size]:
                    new_pos, d = self.read_1ubyte(data, new_pos)
                    typ = {1: "uchar", 2: "ushort", 4: "uint", 8: "ulong"}[d]
                    extra_s = "pop; pop; push *({:s}*)(popped_value2_as_segment:popped_value1)".forma(typ)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_pick]:
                    new_pos, d = self.read_1ubyte(data, new_pos)
                    extra_s = "push stack[{:d}]".format(d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_const1u]:
                    new_pos, d = self.read_1ubyte(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_const2u]:
                    new_pos, d = self.read_2ubyte(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_const4u]:
                    new_pos, d = self.read_4ubyte(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_const8u]:
                    new_pos, d = self.read_8ubyte(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_const1s]:
                    new_pos, d = self.read_1sbyte(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_const2u]:
                    new_pos, d = self.read_2sbyte(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_const4s]:
                    new_pos, d = self.read_4sbyte(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_const8s]:
                    new_pos, d = self.read_8sbyte(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_piece, self.DW_OP_regx, self.DW_OP_plus_uconst]:
                    new_pos, d = self.get_uleb128(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, ""])
                elif op in [self.DW_OP_constu]:
                    new_pos, d = self.get_uleb128(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_consts]:
                    new_pos, d = self.get_sleb128(data, new_pos)
                    extra_s = "push {:#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_addrx, self.DW_OP_GNU_addr_index, self.DW_OP_constx, self.DW_OP_GNU_const_index]:
                    new_pos, d = self.get_uleb128(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} [{:#x}]".format(offset, op_name, d), None, ""])
                elif op in [self.DW_OP_bit_piece]:
                    new_pos, d1 = self.get_uleb128(data, new_pos)
                    new_pos, d2 = self.get_uleb128(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x},{:#x}".format(offset, op_name, d1, d2), None, ""])
                elif op in [self.DW_OP_lit0, self.DW_OP_lit1, self.DW_OP_lit2, self.DW_OP_lit3, self.DW_OP_lit4,
                            self.DW_OP_lit5, self.DW_OP_lit6, self.DW_OP_lit7, self.DW_OP_lit8, self.DW_OP_lit9,
                            self.DW_OP_lit10, self.DW_OP_lit11, self.DW_OP_lit12, self.DW_OP_lit13, self.DW_OP_lit14,
                            self.DW_OP_lit15, self.DW_OP_lit16, self.DW_OP_lit17, self.DW_OP_lit18, self.DW_OP_lit19,
                            self.DW_OP_lit20, self.DW_OP_lit21, self.DW_OP_lit22, self.DW_OP_lit23, self.DW_OP_lit24,
                            self.DW_OP_lit25, self.DW_OP_lit26, self.DW_OP_lit27, self.DW_OP_lit28, self.DW_OP_lit29,
                            self.DW_OP_lit30, self.DW_OP_lit31]:
                    extra_s = "push {:#x}".format(op - 0x30)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s}".format(offset, op_name), None, extra_s])
                elif op in [self.DW_OP_reg0, self.DW_OP_reg1, self.DW_OP_reg2, self.DW_OP_reg3, self.DW_OP_reg4,
                            self.DW_OP_reg5, self.DW_OP_reg6, self.DW_OP_reg7, self.DW_OP_reg8, self.DW_OP_reg9,
                            self.DW_OP_reg10, self.DW_OP_reg11, self.DW_OP_reg12, self.DW_OP_reg13, self.DW_OP_reg14,
                            self.DW_OP_reg15, self.DW_OP_reg16, self.DW_OP_reg17, self.DW_OP_reg18, self.DW_OP_reg19,
                            self.DW_OP_reg20, self.DW_OP_reg21, self.DW_OP_reg22, self.DW_OP_reg23, self.DW_OP_reg24,
                            self.DW_OP_reg25, self.DW_OP_reg26, self.DW_OP_reg27, self.DW_OP_reg28, self.DW_OP_reg29,
                            self.DW_OP_reg30, self.DW_OP_reg31]:
                    regname = self.get_register_name(op - 0x50)
                    extra_s = "push {:s}".format(regname)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s}".format(offset, op_name), None, extra_s])
                elif op in [self.DW_OP_breg0, self.DW_OP_breg1, self.DW_OP_breg2, self.DW_OP_breg3, self.DW_OP_breg4,
                            self.DW_OP_breg5, self.DW_OP_breg6, self.DW_OP_breg7, self.DW_OP_breg8, self.DW_OP_breg9,
                            self.DW_OP_breg10, self.DW_OP_breg11, self.DW_OP_breg12, self.DW_OP_breg13, self.DW_OP_breg14,
                            self.DW_OP_breg15, self.DW_OP_breg16, self.DW_OP_breg17, self.DW_OP_breg18, self.DW_OP_breg19,
                            self.DW_OP_breg20, self.DW_OP_breg21, self.DW_OP_breg22, self.DW_OP_breg23, self.DW_OP_breg24,
                            self.DW_OP_breg25, self.DW_OP_breg26, self.DW_OP_breg27, self.DW_OP_breg28, self.DW_OP_breg29,
                            self.DW_OP_breg30, self.DW_OP_breg31]:
                    new_pos, d = self.get_sleb128(data, new_pos)
                    regname = self.get_register_name(op - 0x70)
                    extra_s = "push {:s}{:+#x}".format(regname, d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_fbreg]:
                    new_pos, d = self.get_sleb128(data, new_pos)
                    regname = "push frame_base{:*#x}".format(d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x}".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_bregx]:
                    new_pos, d1 = self.get_uleb128(data, new_pos)
                    new_pos, d2 = self.get_sleb128(data, new_pos)
                    regname = self.get_register_name(d1)
                    extra_s = "push {:s}{:+#x}".format(regname, d2)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x},{:#x}".format(offset, op_name, d1, d2), None, extra_s])
                elif op in [self.DW_OP_call2]:
                    new_pos, d = self.read_2ubyte(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} [{:#x}]".format(offset, op_name, d), None, ""])
                elif op in [self.DW_OP_call4]:
                    new_pos, d = self.read_4ubyte(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} [{:#x}]".format(offset, op_name, d), None, ""])
                elif op in [self.DW_OP_bra]:
                    new_pos, d = self.read_2sbyte(data, new_pos)
                    d += offset + 3
                    extra_s = "pop; jmp to [{:#x}] if popped_value != 0".format(d)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} [{:#x}]".format(offset, op_name, d), None, extra_s])
                elif op in [self.DW_OP_skip]:
                    new_pos, d = self.read_2sbyte(data, new_pos)
                    d += offset + 3
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} [{:#x}]".format(offset, op_name, d), None, ""])
                elif op in [self.DW_OP_implicit_value]:
                    new_pos, d = self.get_uleb128(data, new_pos)
                    block_s = ' '.join(["{:02x}".format(x) for x in data[new_pos:new_pos + d]])
                    new_pos += d
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:s}".format(offset, op_name, block_s), None, ""])
                elif op in [self.DW_OP_implicit_pointer, self.DW_OP_GNU_implicit_pointer]:
                    if ref_size == 4:
                        new_pos, d1 = self.read_4ubyte(data, new_pos)
                    elif ref_size == 8:
                        new_pos, d1 = self.read_8ubyte(data, new_pos)
                    new_pos, d2 = self.get_sleb128(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} [{:#x}] {:+#x}".format(offset, op_name, d1, d2), None, ""])
                elif op in [self.DW_OP_entry_value, self.DW_OP_GNU_entry_value]:
                    new_pos, d = self.get_uleb128(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s}".format(offset, op_name), None, ""])
                    entries += self.parse_ops(vers, addrsize, d, data, new_pos, indent=indent + 1)
                    new_pos += d
                elif op in [self.DW_OP_const_type, self.DW_OP_GNU_const_type]:
                    new_pos, d1 = self.get_uleb128(data, new_pos)
                    new_pos, d2 = self.read_1ubyte(data, new_pos)
                    block_s = ' '.join(["{:02x}".format(x) for x in data[new_pos:new_pos + d2]])
                    new_pos += d2
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} [{:#x}] {:s}".format(offset, op_name, d1, block_s), None, ""])
                elif op in [self.DW_OP_regval_type, self.DW_OP_GNU_regval_type]:
                    new_pos, d1 = self.get_uleb128(data, new_pos)
                    new_pos, d2 = self.get_uleb128(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x} [{:#x}]".format(offset, op_name, d1, d2), None, ""])
                elif op in [self.DW_OP_deref_type, self.DW_OP_GNU_deref_type]:
                    new_pos, d1 = self.read_1ubyte(data, new_pos)
                    new_pos, d2 = self.get_uleb128(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x} [{:#x}]".format(offset, op_name, d1, d2), None, ""])
                elif op in [self.DW_OP_xderef_type]:
                    new_pos, d1 = self.read_1ubyte(data, new_pos)
                    new_pos, d2 = self.get_uleb128(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} {:#x} [{:#x}]".format(offset, op_name, d1, d2), None, ""])
                elif op in [self.DW_OP_convert, self.DW_OP_GNU_convert, self.DW_OP_reinterpret, self.DW_OP_GNU_reinterpret]:
                    new_pos, d = self.get_uleb128(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} [{:#x}]".format(offset, op_name, d), None, ""])
                elif op in [self.DW_OP_GNU_parameter_ref]:
                    new_pos, d = self.read_4ubyte(data, new_pos)
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s} [{:#x}]".format(offset, op_name, d), None, ""])
                elif op in [self.DW_OP_drop]:
                    extra_s = "pop"
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s}".format(offset, op_name), None, extra_s])
                elif op in [self.DW_OP_dup]:
                    extra_s = "push stack[0]"
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s}".format(offset, op_name), None, extra_s])
                elif op in [self.DW_OP_over]:
                    extra_s = "push stack[1]"
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s}".format(offset, op_name), None, extra_s])
                elif op in [self.DW_OP_swap]:
                    extra_s = "stack[0],stack[1] = stack[1],stack[0]"
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s}".format(offset, op_name), None, extra_s])
                elif op in [self.DW_OP_rot]:
                    extra_s = "stack[0],stack[1],stack[2] = stack[1],stack[2],stack[0]"
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s}".format(offset, op_name), None, extra_s])
                else:
                    entries.append([pos, data[pos:new_pos], indent + "[{:#04x}] {:s}".format(offset, op_name), None, ""])
                length -= new_pos - pos
                offset += new_pos - pos
                pos = new_pos
        except Exception:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            entries.append(["Parse Error\n{}".format(exc_value)])
        return entries

    def parse_gcc_except_table(self, gcc_except_table, eh_frame_entries):
        def get_lsda_info(eh_frame_entries):
            dic = {}
            is_fde = False
            for entry in eh_frame_entries:
                if len(entry) != 5:
                    continue
                pos, raw_data, name, value, extra = entry
                if name == "cie_pointer":
                    is_fde = True
                    continue
                if name == "cie_id":
                    is_fde = False
                    continue
                if is_fde:
                    if name == "pc_begin":
                        pc_begin = value
                        continue
                    if name != "augmentation_data(L)":
                        continue
                    dic[value - load_base] = pc_begin + load_base
            return dic

        section_base = gcc_except_table["offset"]
        data = gcc_except_table["data"]
        shdr = [s for s in self.elf.shdrs if s.sh_name == ".gcc_except_table"][0]
        load_base = [phdr for phdr in self.elf.phdrs if phdr.p_type == Phdr.PT_LOAD][0].p_vaddr
        ptr_size = 4 if self.elf.e_class == Elf.ELF_32_BITS else 8
        lsda_pos_info = get_lsda_info(eh_frame_entries)

        entries = []
        pos = 0
        lsda_table_cnt = 0

        try:
            lsda_pos_padding = 0
            while data[pos:]:
                # search LSDA start address
                if (section_base + pos) not in lsda_pos_info:
                    lsda_pos_padding += 1
                    pos += 1
                    continue

                # Found
                if lsda_pos_padding:
                    entries.append([pos - lsda_pos_padding, "Padding", ""])
                    entries.append([pos - lsda_pos_padding, data[pos - lsda_pos_padding:pos], "padding", "", ""])
                    lsda_pos_padding = 0

                entries.append([pos, "LSDA Table[{:4d}]".format(lsda_table_cnt), ""])
                lpstart = lsda_pos_info[section_base + pos]

                # parse lpstart_encoding
                new_pos, lpstart_encoding = self.read_1ubyte(data, pos)
                encoding_str = self.get_encoding_str(lpstart_encoding)
                entries.append([pos, data[pos:new_pos], "landing_pad_start_encoding", lpstart_encoding, "encoding: {:s}".format(encoding_str)])
                pos = new_pos

                # parse lpstart
                if lpstart_encoding != self.DW_EH_PE_omit:
                    new_pos, lpstart = self.read_encoded(lpstart_encoding, data, pos) # overwrite lpstart
                    entries.append([pos, data[pos:new_pos], "landing_pad_start", lpstart, ""])
                    pos = new_pos

                # parse ttype_encoding
                new_pos, ttype_encoding = self.read_1ubyte(data, pos)
                encoding_str = self.get_encoding_str(ttype_encoding)
                entries.append([pos, data[pos:new_pos], "ttype_encoding", ttype_encoding, "encoding: {:s}".format(encoding_str)])
                pos = new_pos

                # parse ttype_base_offset
                ttype_base = None
                if ttype_encoding != self.DW_EH_PE_omit:
                    new_pos, ttype_base_offset = self.get_uleb128(data, pos)
                    ttype_base = new_pos + ttype_base_offset
                    entries.append([pos, data[pos:new_pos], "ttype_base_offset", ttype_base_offset, "ttype_base: {:#x}".format(ttype_base)])
                    pos = new_pos

                # parse call_site_encoding
                new_pos, call_site_encoding = self.read_1ubyte(data, pos)
                encoding_str = self.get_encoding_str(call_site_encoding)
                entries.append([pos, data[pos:new_pos], "call_site_encoding", call_site_encoding, "encoding: {:s}".format(encoding_str)])
                pos = new_pos

                # parse call_site_table_len
                new_pos, call_site_table_len = self.get_uleb128(data, pos)
                entries.append([pos, data[pos:new_pos], "call_site_table_len", call_site_table_len, ""])
                pos = new_pos

                # parse call_site_table
                action_table_pos = pos + call_site_table_len
                table_cnt = 0
                max_action = 0
                while pos < action_table_pos:
                    entries.append([pos, "Call site table[{:4d}]".format(table_cnt), ""])

                    new_pos, call_site_start = self.read_encoded(call_site_encoding, data, pos)
                    if self.is_pie:
                        extra_s = "try-start vma: $codebase+{:#x}".format(lpstart + call_site_start)
                    else:
                        extra_s = "try-start vma: {:#x}".format(lpstart + call_site_start)
                    entries.append([pos, data[pos:new_pos], "call_site_start", call_site_start, extra_s])
                    pos = new_pos

                    new_pos, call_site_length = self.read_encoded(call_site_encoding, data, pos)
                    if self.is_pie:
                        extra_s = "try-end vma: $codebase+{:#x}".format(lpstart + call_site_start + call_site_length)
                    else:
                        extra_s = "try-end vma: {:#x}".format(lpstart + call_site_start + call_site_length)
                    entries.append([pos, data[pos:new_pos], "call_site_length", call_site_length, extra_s])
                    pos = new_pos

                    new_pos, call_site_lpad = self.read_encoded(call_site_encoding, data, pos)
                    if call_site_lpad == 0:
                        extra_s = ""
                    elif self.is_pie:
                        extra_s = "catch vma: $codebase+{:#x}".format(lpstart + call_site_lpad)
                    else:
                        extra_s = "catch vma: {:#x}".format(lpstart + call_site_lpad)
                    entries.append([pos, data[pos:new_pos], "landing_pad", call_site_lpad, extra_s])
                    pos = new_pos

                    new_pos, action = self.get_uleb128(data, pos)
                    max_action = max(action, max_action)
                    if action == 0:
                        extra_s = "no action"
                    else:
                        extra_s = "action: {:#x}".format(action_table_pos + action - 1)
                    entries.append([pos, data[pos:new_pos], "action", action, extra_s])
                    pos = new_pos

                    table_cnt += 1

                # parse action_table
                max_ar_filter = 0
                table_cnt = 0
                if max_action:
                    action_table_end_pos = action_table_pos + max_action + 1
                    while pos < action_table_end_pos:
                        entries.append([pos, "Action table[{:4d}]".format(table_cnt), ""])

                        new_pos, ar_filter = self.get_sleb128(data, pos)
                        if ar_filter == 0:
                            extra_s = "cleanup"
                        else:
                            enc_size = self.encoded_ptr_size(ttype_encoding, ptr_size)
                            extra_s = "catch typeinfo: {:#x}".format(ttype_base - ar_filter * enc_size)
                        entries.append([pos, data[pos:new_pos], "action_record_filter", ar_filter, extra_s])
                        max_ar_filter = max(ar_filter, max_ar_filter)
                        pos = new_pos

                        new_pos, ar_disp = self.get_sleb128(data, pos)
                        if ar_disp & 1:
                            extra_s = "-> Action Table[{:4d}]".format(table_cnt + (ar_disp + 1) // 2)
                        elif ar_disp:
                            extra_s = "-> ???"
                        else:
                            extra_s = "list end"
                        entries.append([pos, data[pos:new_pos], "action_record_next", ar_disp, extra_s])
                        pos = new_pos

                        table_cnt += 1

                # parse ttype_table
                if max_ar_filter > 0 and ttype_base is not None:
                    enc_size = self.encoded_ptr_size(ttype_encoding, ptr_size)
                    new_pos = ttype_base - max_ar_filter * enc_size
                    if pos != new_pos:
                        entries.append([pos, "Padding", ""])
                        entries.append([pos, data[pos:new_pos], "padding", "", ""])
                        pos = new_pos
                    current_ar_filter = max_ar_filter
                    while pos < ttype_base:
                        entries.append([pos, "TType table[{:4d}]".format(current_ar_filter), ""])
                        new_pos, ttype = self.read_encoded(ttype_encoding, data, pos)
                        if (ttype_encoding & 0x70) == self.DW_EH_PE_pcrel:
                            ttype_pointer = shdr.sh_offset + pos + ttype
                            if ttype:
                                if self.is_pie:
                                    extra_s = "TType pointer vma: $codebase+{:#x}".format(load_base + ttype_pointer)
                                else:
                                    extra_s = "TType pointer vma: {:#x}".format(load_base + ttype_pointer)
                            else:
                                extra_s = ""
                            entries.append([pos, data[pos:new_pos], "ttype", ttype, extra_s])
                        else:
                            entries.append([pos, data[pos:new_pos], "ttype", ttype, "TType pointer"])
                        pos = new_pos
                        current_ar_filter -= 1
                if ttype_base is not None:
                    entries.append([ttype_base, "TType table base (Stored upwards)", ""])

                # next LSDA
                if ttype_base is None:
                    pass
                else:
                    pos = ttype_base
                lsda_table_cnt += 1
        except Exception:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            entries.append(["Parse Error\n{}".format(exc_value)])
        return entries

    def read_section(self, section_name):
        for s in self.elf.shdrs:
            if s.sh_name != section_name:
                continue
            f = open(self.elf.filename, "rb")
            f.seek(s.sh_offset)
            data = f.read(s.sh_size)
            f.close()
            info("Found {} section".format(section_name))
            return {"name": section_name, "offset": s.sh_offset, "data": data}
        err("Not found {} section".format(section_name))
        return None

    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        try:
            less = which("less")
        except FileNotFoundError as e:
            err("{}".format(e))
            return

        # with hexdump or not
        if "-x" in argv:
            idx = argv.index("-x")
            self.hexdump = True
            argv = argv[:idx] + argv[idx + 1:]
        else:
            self.hexdump = False

        # read file
        if "-f" in argv:
            idx = argv.index("-f")
            filename = argv[idx + 1]
            argv = argv[:idx] + argv[idx + 2:]
        else:
            filename = get_filepath()
            if filename is None:
                err("No executable/library specified")
                return
        if not os.path.exists(filename):
            err("{} is not found".format(filename))
            return
        self.elf = get_elf_headers(filename)
        self.is_pie = is_pie(filename)
        if not self.elf.is_valid():
            err("Elf parsing error")
            return

        # read section
        eh_frame_hdr = self.read_section(".eh_frame_hdr")
        if eh_frame_hdr is None:
            return
        eh_frame = self.read_section(".eh_frame")
        if eh_frame is None:
            return
        gcc_except_table = self.read_section(".gcc_except_table")
        if gcc_except_table is None:
            return

        # parse section
        out = []
        eh_frame_hdr_entries = self.parse_eh_frame_hdr(eh_frame_hdr)
        out += self.format_entry(eh_frame_hdr, eh_frame_hdr_entries)
        eh_frame_entries = self.parse_eh_frame(eh_frame)
        out += self.format_entry(eh_frame, eh_frame_entries)
        gcc_except_table_entries = self.parse_gcc_except_table(gcc_except_table, eh_frame_entries)
        out += self.format_entry(gcc_except_table, gcc_except_table_entries)

        # print
        _, tmp_path = tempfile.mkstemp()
        open(tmp_path, "w").write('\n'.join(out))
        os.system(f"{less} -R {tmp_path}")
        os.unlink(tmp_path)
        return


@register_command
class EntryPointBreakCommand(GenericCommand):
    """Tries to find best entry point and sets a temporary breakpoint on it. The command will test for
    well-known symbols for entry points, such as `main`, `_main`, `__libc_start_main`, etc. defined by
    the setting `entrypoint_symbols`."""
    _cmdline_ = "entry-break"
    _syntax_ = _cmdline_
    _aliases_ = ["start"]
    _category_ = "Debugging Support"

    def __init__(self, *args, **kwargs):
        super().__init__()
        self.add_setting("entrypoint_symbols", "main _main __libc_start_main __uClibc_main start _start", "Possible symbols for entry points")
        return

    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        fpath = get_filepath()
        if fpath is None:
            warn("No executable to debug, use `file` to load a binary")
            return

        if not os.access(fpath, os.X_OK):
            warn("The file '{}' is not executable.".format(fpath))
            return

        if is_alive() and not __gef_qemu_mode__:
            warn("gdb is already running")
            return

        bp = None
        entrypoints = self.get_setting("entrypoint_symbols").split()

        for sym in entrypoints:
            try:
                value = parse_address(sym)
                info("Breaking at '{:s}'".format(str(value)))
                bp = EntryBreakBreakpoint(sym)
                gdb.execute("run {}".format(" ".join(argv)))
                return

            except gdb.error as gdb_error:
                if 'The "remote" target does not support "run".' in str(gdb_error):
                    # this case can happen when doing remote debugging
                    gdb.execute("continue")
                    return
                continue

        # if here, clear the breakpoint if any set
        if bp:
            bp.delete()

        # break at entry point
        entry = get_entry_point()
        if entry is None:
            return

        if is_pie(fpath):
            self.set_init_tbreak_pie(entry, argv)
            try:
                gdb.execute("continue")
            except Exception:
                exc_type, exc_value, exc_traceback = sys.exc_info()
                err(exc_value)
            return

        self.set_init_tbreak(entry)
        gdb.execute("run {}".format(" ".join(argv)))
        return

    def set_init_tbreak(self, addr):
        info("Breaking at entry-point: {:#x}".format(addr))
        bp = EntryBreakBreakpoint("*{:#x}".format(addr))
        return bp

    def set_init_tbreak_pie(self, addr, argv):
        warn("PIC binary detected, retrieving text base address")
        gdb.execute("set stop-on-solib-events 1")
        hide_context()
        gdb.execute("run {}".format(" ".join(argv)))
        unhide_context()
        gdb.execute("set stop-on-solib-events 0")
        vmmap = get_process_maps()
        base_address = [x.page_start for x in vmmap if x.path == get_filepath(for_vmmap=True)][0]
        return self.set_init_tbreak(base_address + addr)


@register_command
class NamedBreakpointCommand(GenericCommand):
    """Sets a breakpoint and assigns a name to it, which will be shown, when it's hit."""
    _cmdline_ = "name-break"
    _syntax_ = "{:s} NAME [LOCATION]".format(_cmdline_)
    _example_ = "{:s} main *0x4008a9".format(_cmdline_)
    _category_ = "Debugging Support"
    _aliases_ = ["nb"]

    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if not argv:
            err("Missing name for breakpoint")
            self.usage()
            return

        name = argv[0]
        location = argv[1] if len(argv) > 1 else "*{}".format(hex(current_arch.pc))

        NamedBreakpoint(location, name)
        return


@register_command
class ContextCommand(GenericCommand):
    """Displays a comprehensive and modular summary of runtime context. Unless setting `enable` is
    set to False, this command will be spawned automatically every time GDB hits a breakpoint, a
    watchpoint, or any kind of interrupt. By default, it will show panes that contain the register
    states, the stack, and the disassembly code around $pc."""
    _cmdline_ = "context"
    _syntax_ = "{:s} [legend|regs|stack|code|args|memory|source|trace|threads|extra]".format(_cmdline_)
    _aliases_ = ["ctx"]
    _category_ = "Debugging Support"

    old_registers = {}

    def __init__(self):
        super().__init__()
        self.add_setting("enable", True, "Enable/disable printing the context when breaking")
        self.add_setting("show_source_code_variable_values", True, "Show extra PC context info in the source code")
        self.add_setting("show_stack_raw", False, "Show the stack pane as raw hexdump (no dereference)")
        self.add_setting("show_registers_raw", False, "Show the registers pane with raw values (no dereference)")
        self.add_setting("show_opcodes_size", 8, "Number of bytes of opcodes to display next to the disassembly")
        self.add_setting("peek_calls", True, "Peek into calls")
        self.add_setting("peek_ret", True, "Peek at return address")
        self.add_setting("nb_lines_stack", 8, "Number of line in the stack pane")
        self.add_setting("grow_stack_down", False, "Order of stack downward starts at largest down to stack pointer")
        self.add_setting("nb_lines_backtrace", 10, "Number of line in the backtrace pane")
        self.add_setting("nb_lines_backtrace_before", 2, "Number of line in the backtrace pane before selected frame")
        self.add_setting("nb_lines_threads", -1, "Number of line in the threads pane")
        self.add_setting("nb_lines_code", 6, "Number of instruction after $pc")
        self.add_setting("nb_lines_code_prev", 3, "Number of instruction before $pc")
        self.add_setting("ignore_registers", "", "Space-separated list of registers not to display (e.g. '$cs $ds $gs')")
        self.add_setting("clear_screen", True, "Clear the screen before printing the context")
        self.add_setting("layout", "legend regs stack code args source memory threads trace extra", "Change the order/presence of the context sections")
        self.add_setting("redirect", "", "Redirect the context information to another TTY")
        self.add_setting("libc_args", False, "Show libc function call args description")
        self.add_setting("libc_args_path", "", "Path to libc function call args json files, provided via gef-extras")
        self.add_setting("smart_cpp_function_name", False, "Print cpp function name without args if demangled")
        self.add_setting("use_native_x_command", False, "Use x/16i insted of gdb_disasembe/capstone")
        self.add_setting("use_capstone", False, "Use capstone as disassembler in the code pane (instead of GDB)")

        self.layout_mapping = {
            "legend" : self.show_legend,
            "regs"   : self.context_regs,
            "stack"  : self.context_stack,
            "code"   : self.context_code,
            "args"   : self.context_args,
            "memory" : self.context_memory,
            "source" : self.context_source,
            "trace"  : self.context_trace,
            "threads": self.context_threads,
            "extra"  : self.context_additional_information,
        }
        return

    def post_load(self):
        gef_on_continue_hook(self.update_registers)
        gef_on_continue_hook(self.empty_extra_messages)
        return

    def show_legend(self):
        if get_gef_setting("gef.disable_color") is not True:
            str_color = get_gef_setting("theme.dereference_string")
            code_addr_color = get_gef_setting("theme.address_code")
            stack_addr_color = get_gef_setting("theme.address_stack")
            heap_addr_color = get_gef_setting("theme.address_heap")
            changed_register_color = get_gef_setting("theme.registers_value_changed")

            gef_print("[ Legend: {} | {} | {} | {} | {} ]".format(
                Color.colorify("Modified register", changed_register_color),
                Color.colorify("Code", code_addr_color),
                Color.colorify("Heap", heap_addr_color),
                Color.colorify("Stack", stack_addr_color),
                Color.colorify("String", str_color)
            ))
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if not self.get_setting("enable") or context_hidden:
            return

        if not all(_ in self.layout_mapping for _ in argv):
            self.usage()
            return

        if len(argv) > 0:
            current_layout = argv
        else:
            current_layout = self.get_setting("layout").strip().split()

        if not current_layout:
            return

        self.tty_rows, self.tty_columns = get_terminal_size()

        redirect = self.get_setting("redirect")
        if redirect and os.access(redirect, os.W_OK):
            enable_redirect_output(to_file=redirect)

        if self.get_setting("clear_screen") and len(argv) == 0:
            clear_screen(redirect)

        for section in current_layout:
            if section[0] == "-":
                continue
            try:
                self.layout_mapping[section]()
            except gdb.MemoryError as e:
                # a MemoryError will happen when $pc is corrupted (invalid address)
                err(str(e))
        self.context_title("")

        if redirect and os.access(redirect, os.W_OK):
            disable_redirect_output()
        return

    def context_title(self, m):
        line_color = get_gef_setting("theme.context_title_line")
        msg_color = get_gef_setting("theme.context_title_message")

        if not m:
            gef_print(Color.colorify(HORIZONTAL_LINE * self.tty_columns, line_color))
            return

        trail_len = len(m) + 6
        title = ""
        width = max(self.tty_columns - trail_len, 0)
        title += Color.colorify("{:{padd}<{width}} ".format("", width=width, padd=HORIZONTAL_LINE), line_color)
        title += Color.colorify(m, msg_color)
        title += Color.colorify(" {:{padd}<4}".format("", padd=HORIZONTAL_LINE), line_color)
        gef_print(title)
        return

    def context_regs(self):
        self.context_title("registers")
        ignored_registers = set(self.get_setting("ignore_registers").split())

        if current_arch is None and is_remote_debug():
            err("Missing info about architecture. Please set: `file /path/to/target_binary`")
            return

        if self.get_setting("show_registers_raw") is False:
            regs = set(current_arch.all_registers)
            printable_registers = " ".join(list(regs - ignored_registers))
            gdb.execute("registers {}".format(printable_registers))
            return

        widest = x = current_arch.get_aliased_registers_name_max()
        x += 5
        x += current_arch.ptrsize * 2
        nb = get_terminal_size()[1] // x
        i = 1
        line = ""
        changed_color = get_gef_setting("theme.registers_value_changed")
        regname_color = get_gef_setting("theme.registers_register_name")

        for regname in current_arch.all_registers:
            if regname in ignored_registers:
                continue

            try:
                reg = gdb.parse_and_eval(regname)
                if reg.type.code == gdb.TYPE_CODE_VOID:
                    continue

                new_value_type_flag = (reg.type.code == gdb.TYPE_CODE_FLAGS)
                new_value = int(reg)

            except (gdb.MemoryError, gdb.error):
                # If this exception is triggered, it means that the current register
                # is corrupted. Just use the register "raw" value (not eval-ed)
                new_value = get_register(regname)
                new_value_type_flag = False

            except Exception:
                new_value = 0
                new_value_type_flag = False

            padreg = current_arch.get_aliased_registers()[regname].ljust(widest, " ")
            old_value = self.old_registers.get(regname, 0)

            value = align_address(new_value)
            old_value = align_address(old_value)

            if value == old_value:
                line += "{}: ".format(Color.colorify(padreg, regname_color))
            else:
                line += "{}: ".format(Color.colorify(padreg, changed_color))
            if new_value_type_flag:
                line += "{:s} ".format(format_address_spaces(value))
            else:
                addr = lookup_address(align_address(int(value)))
                if addr.valid:
                    line += "{:s} ".format(str(addr))
                else:
                    line += "{:s} ".format(format_address_spaces(value))

            if i % nb == 0:
                gef_print(line)
                line = ""
            i += 1

        if line:
            gef_print(line)

        gef_print("Flags: {:s}".format(current_arch.flag_register_to_human()))
        return

    def context_stack(self):
        self.context_title("stack")

        show_raw = self.get_setting("show_stack_raw")
        nb_lines = self.get_setting("nb_lines_stack")

        if current_arch is None and is_remote_debug():
            err("Missing info about architecture. Please set: `file /path/to/target_binary`")
            return

        try:
            sp = current_arch.sp
            if show_raw is True:
                mem = read_memory(sp, 0x10 * nb_lines)
                gef_print(hexdump(mem, base=sp))
            else:
                gdb.execute("dereference {:#x} l{:d}".format(sp, nb_lines))

        except gdb.MemoryError:
            err("Cannot read memory from $SP (corrupted stack pointer?)")

        return

    def addr_has_breakpoint(self, address, bp_locations):
        return any(hex(address) in b for b in bp_locations)

    def context_code(self):
        use_native_x_command = self.has_setting("use_native_x_command") and self.get_setting("use_native_x_command")
        nb_insn = self.get_setting("nb_lines_code")
        nb_insn_prev = self.get_setting("nb_lines_code_prev")
        use_capstone = self.has_setting("use_capstone") and self.get_setting("use_capstone")
        past_insns_color = get_gef_setting("theme.old_context")
        show_opcodes_size = self.has_setting("show_opcodes_size") and self.get_setting("show_opcodes_size")
        cur_insn_color = get_gef_setting("theme.disassemble_current_instruction")

        if current_arch is None and is_remote_debug():
            self.context_title("code")
            err("Missing info about architecture. Please set: `file /path/to/target_binary`")
            return

        pc = current_arch.pc
        breakpoints = gdb.breakpoints() or []
        bp_locations = [b.location for b in breakpoints if b.location and b.location.startswith("*")]

        try:
            frame = gdb.selected_frame()
            arch_name = "{}:{}".format(current_arch.arch.lower(), current_arch.mode)
        except gdb.error:
            # For unknown reasons, gdb.selected_frame() may cause an error (often occurs during kernel startup).
            arch_name = "{}:{}".format(current_arch.arch.lower(), "???")

        self.context_title("code:{}".format(arch_name))
        if use_native_x_command:
            gdb.execute("x/16i {:#x}".format(current_arch.pc))
            return

        try:
            instruction_iterator = capstone_disassemble if use_capstone else gef_disassemble

            for insn in instruction_iterator(pc, nb_insn, nb_prev=nb_insn_prev):
                line = []
                is_taken = False
                target = None
                bp_prefix = Color.redify(BP_GLYPH) if self.addr_has_breakpoint(insn.address, bp_locations) else " "

                if show_opcodes_size == 0:
                    text = str(insn)
                else:
                    insn_fmt = "{{:{}o}}".format(show_opcodes_size)
                    text = insn_fmt.format(insn)

                if insn.address < pc:
                    line += "{}{}{}".format(bp_prefix, " " * len(RIGHT_ARROW[1:]), Color.colorify(text, past_insns_color))

                elif insn.address == pc:
                    line += "{}{}".format(bp_prefix, Color.colorify("{:s}{:s}".format(RIGHT_ARROW[1:], text), cur_insn_color))

                    if current_arch.is_conditional_branch(insn):
                        is_taken, reason = current_arch.is_branch_taken(insn)
                        if is_taken:
                            target = insn.operands[-1].split()[0]
                            reason = "[Reason: {:s}]".format(reason) if reason else ""
                            line += Color.colorify("\tTAKEN {:s}".format(reason), "bold green")
                        else:
                            reason = "[Reason: !({:s})]".format(reason) if reason else ""
                            line += Color.colorify("\tNOT taken {:s}".format(reason), "bold red")
                    elif current_arch.is_call(insn) and self.get_setting("peek_calls") is True:
                        target = insn.operands[-1].split()[0]
                    elif current_arch.is_ret(insn) and self.get_setting("peek_ret") is True:
                        target = current_arch.get_ra(insn, frame)

                else:
                    line += "{}{}{}".format(bp_prefix, " " * len(RIGHT_ARROW[1:]), text)

                gef_print("".join(line))

                if target:
                    try:
                        target = int(target, 0)
                    except TypeError: # Already an int
                        pass
                    except ValueError:
                        # If the operand isn't an address right now we can't parse it
                        continue
                    try:
                        for i, tinsn in enumerate(instruction_iterator(target, nb_insn)):
                            if show_opcodes_size == 0:
                                text = str(tinsn)
                            else:
                                text = insn_fmt.format(tinsn)
                            text = "   {}  {}".format(DOWN_ARROW if i == 0 else " ", text)
                            gef_print(text)
                    except Exception:
                        pass
                    break

            self.context_memory_access()
            self.context_memory_access2() # for x86/x64 - fs/gs
            self.context_memory_access3() # for x86/x64 - cs/ss/ds/es

        except gdb.MemoryError:
            err("Cannot disassemble from $PC")
        return

    def context_memory_access(self):
        if not (is_x86() or is_arm32() or is_arm64()):
            return

        inst_iter = gef_disassemble(current_arch.pc, 2)
        insn_here = inst_iter.__next__()
        if insn_here.operands == []:
            return

        insn = ','.join(insn_here.operands)
        insn = re.sub(r"<.+>", "", insn)
        r = re.findall(r"[^:](\[.+?\])", str(insn)) # Unsupported: seg:[reg]
        if not r:
            return

        insn_next = inst_iter.__next__()
        codesize = insn_next.address - insn_here.address

        for code in r:
            code = code[1:-1] # skip "[" and "]"

            if is_x86():
                # add "$" to resiter
                code = code.replace("+", " + ")
                code = code.replace("-", " - ")
                code = code.replace("*", " * ")
                code = code.replace("eiz", " 0 ") # $eiz is always 0x0
                code = code.split()
                code = ["$" + x if x.isalpha() or re.match(r"r\d+d?", x) else x for x in code]
                code = ''.join(code)
                # $rip/$eip points next instruction
                code_orig, code = code, code.replace("$rip", f"$rip+{codesize:#x}")

            elif is_arm32():
                # add "$" to resiter
                code = code.replace(" ", "")
                code = code.replace("#", "")
                code = code.replace("lsl", "<<")
                code = code.split(",")
                code = ["$" + x if x.isalpha() or re.match(r"r\d+", x) else x for x in code]
                if "<<" in code[-1]:
                    code = code[:-2] + ["(" + code[-2] + code[-1] + ")"]
                code = '+'.join(code)
                # $pc points next next instruction
                code_orig, code = code, code.replace("$pc", f"$pc+{codesize*2:#x}")

            elif is_arm64():
                # add "$" to resiter
                code = code.replace(" ", "")
                code = code.replace("#", "")
                code = code.replace("lsl", "<<").replace("sxtw", "<<").replace("uxtw", "<<")
                code = code.replace("xzr", " 0 ") # $xzr is always 0x0
                code = code.replace("wzr", " 0 ") # $wzr is always 0x0
                code = code.replace("wsp", " ($sp&0xffff) ") # $wsp is a half of $sp
                code = code.split(",")
                code = ["$" + x if x.isalpha() or re.match(r"[xw]\d+", x) else x for x in code]
                if "<<" == code[-1]:
                    code[-1] += "0"
                if "<<" in code[-1]:
                    code = code[:-2] + ["(" + code[-2] + code[-1] + ")"]
                code = '+'.join(code)
                # $pc points next next instruction
                code_orig, code = code, code.replace("$pc", f"$pc+{codesize*2:#x}")

            # print
            try:
                code = code.replace("$", "(long)$")
                addr = parse_address(code)
            except Exception:
                # some binary fails to resolve "(long)"
                addr = parse_address(code_orig)
            self.context_title(f"memory access: {code_orig} = {addr:#x}")
            gdb.execute(f"telescope {addr:#x} 4")
        return

    def context_memory_access2(self):
        if not is_x86():
            return

        inst_iter = gef_disassemble(current_arch.pc, 1)
        insn_here = inst_iter.__next__()
        if insn_here.operands == []:
            return

        insn = ','.join(insn_here.operands)
        insn = re.sub(r"<.+>", "", insn)

        r = re.findall(r"((fs|gs):\[?([^,\]]+)\]?)", str(insn))
        if r:
            code, fsgs, offset = r[0][0], r[0][1], r[0][2]
            tls = TlsCommand.getfs() if fsgs == "fs" else TlsCommand.getgs()
            offset = offset.replace("+", " + ")
            offset = offset.replace("-", " - ")
            offset = offset.replace("*", " * ")
            offset = offset.replace("eiz", " 0 ") # $eiz is always 0x0
            offset = offset.split()
            offset = ["$" + x if x.isalpha() or re.match(r"r\d+d?", x) else x for x in offset]
            offset = ''.join(offset)
            offset = parse_address(offset)
            mask = ((1 << 32) - 1) if is_32bit() else ((1 << 64) - 1)
            addr = (tls + offset) & mask
            self.context_title(f"memory access: {code} = {addr:#x}")
            gdb.execute(f"telescope {addr:#x} 4")
        return

    def context_memory_access3(self):
        if not is_x86():
            return

        inst_iter = gef_disassemble(current_arch.pc, 1)
        insn_here = inst_iter.__next__()
        if insn_here.operands == []:
            return

        insn = ','.join(insn_here.operands)
        insn = re.sub(r"<.+>", "", insn)

        r = re.findall(r"((es|ds|ss|cs):\[?([^,\]]+)\]?)", str(insn))
        for rr in r:
            code, addr = rr[0], rr[2]
            addr = addr.replace("+", " + ")
            addr = addr.replace("-", " - ")
            addr = addr.replace("*", " * ")
            addr = addr.replace("eiz", " 0 ") # $eiz is always 0x0
            addr = addr.split()
            addr = ["$" + x if x.isalpha() or re.match(r"r\d+d?", x) else x for x in addr]
            addr = ''.join(addr)
            addr = parse_address(addr)
            self.context_title(f"memory access: {code} = {addr:#x}")
            gdb.execute(f"telescope {addr:#x} 4")
        return

    def context_args(self):
        if current_arch is None and is_remote_debug():
            err("Missing info about architecture. Please set: `file /path/to/target_binary`")
            return

        insn = gef_current_instruction(current_arch.pc)
        if current_arch.is_syscall(insn):
            self.context_title("arguments")
            gdb.execute("syscall-args")
            return

        insn = gef_current_instruction(current_arch.pc)
        if not current_arch.is_call(insn):
            return

        self.size2type = {
            1: "BYTE",
            2: "WORD",
            4: "DWORD",
            8: "QWORD",
        }

        if insn.operands[-1].startswith(self.size2type[current_arch.ptrsize] + " PTR"):
            target = "*" + insn.operands[-1].split()[-1]
        elif "$" + insn.operands[0] in current_arch.all_registers:
            target = "*{:#x}".format(get_register("$" + insn.operands[0]))
        else:
            # is there a symbol?
            ops = " ".join(insn.operands)
            if "<" in ops and ">" in ops:
                # extract it
                target = re.sub(r".*<([^\(> ]*).*", r"\1", ops)
            else:
                # it's an address, just use as is
                target = re.sub(r".*(0x[a-fA-F0-9]*).*", r"\1", ops)

        sym = gdb.lookup_global_symbol(target)
        if sym is None:
            self.print_guessed_arguments(target)
            return

        if sym.type.code != gdb.TYPE_CODE_FUNC:
            err("Symbol '{}' is not a function: type={}".format(target, sym.type.code))
            return

        self.print_arguments_from_symbol(target, sym)
        return

    def print_arguments_from_symbol(self, function_name, symbol):
        """If symbols were found, parse them and print the argument adequately."""
        args = []

        for i, f in enumerate(symbol.type.fields()):
            _value = current_arch.get_ith_parameter(i, in_func=False)[1]
            if _value is None:
                break
            _value = to_string_dereference_from(_value)
            _name = f.name or "var_{}".format(i)
            _type = f.type.name or self.size2type[f.type.sizeof]
            args.append("{} {} = {}".format(_type, _name, _value))

        self.context_title("arguments")

        if not args:
            gef_print("{} (<void>)".format(function_name))
            return

        gef_print("{} (".format(function_name))
        gef_print("   " + ",\n   ".join(args))
        gef_print(")")
        return

    def print_guessed_arguments(self, function_name):
        """When no symbol, read the current basic block and look for "interesting" instructions."""
        def __get_current_block_start_address():
            pc = current_arch.pc
            try:
                block = gdb.block_for_pc(pc)
                if block and 0 <= pc - block.start <= 0x100:
                    block_start = block.start
                else:
                    block_start = gdb_get_nth_previous_instruction_address(pc, 5)
            except RuntimeError:
                block_start = gdb_get_nth_previous_instruction_address(pc, 5)
            return block_start

        parameter_set = set()
        pc = current_arch.pc
        block_start = __get_current_block_start_address()
        if not block_start:
            return
        use_capstone = self.has_setting("use_capstone") and self.get_setting("use_capstone")
        instruction_iterator = capstone_disassemble if use_capstone else gef_disassemble
        function_parameters = current_arch.function_parameters
        arg_key_color = get_gef_setting("theme.registers_register_name")

        for insn in instruction_iterator(block_start, pc - block_start):
            if not insn.operands:
                continue

            if is_x86_32():
                if insn.mnemonic == "push":
                    parameter_set.add(insn.operands[0])
            else:
                op = "$" + insn.operands[0]
                if op in function_parameters:
                    parameter_set.add(op)

                if is_x86_64():
                    # also consider extended registers
                    extended_registers = {
                        "$rdi": ["$edi", "$di"],
                        "$rsi": ["$esi", "$si"],
                        "$rdx": ["$edx", "$dx"],
                        "$rcx": ["$ecx", "$cx"],
                    }
                    for exreg in extended_registers:
                        if op in extended_registers[exreg]:
                            parameter_set.add(exreg)

        nb_argument = 0
        _arch_mode = "{}_{}".format(current_arch.arch.lower(), current_arch.mode)
        _function_name = None
        if function_name.endswith("@plt"):
            _function_name = function_name.split("@")[0]
            try:
                nb_argument = len(libc_args_definitions[_arch_mode][_function_name])
            except KeyError:
                pass

        if not nb_argument and len(parameter_set) > 0:
            if is_x86_32():
                nb_argument = len(parameter_set)
            else:
                nb_argument = max(function_parameters.index(p) + 1 for p in parameter_set)

        args = []
        for i in range(nb_argument):
            _key, _value = current_arch.get_ith_parameter(i, in_func=False)
            _value = to_string_dereference_from(_value)
            try:
                args.append("{} = {} (def: {})".format(Color.colorify(_key, arg_key_color), _value,
                                                       libc_args_definitions[_arch_mode][_function_name][_key]))
            except KeyError:
                args.append("{} = {}".format(Color.colorify(_key, arg_key_color), _value))

        self.context_title("arguments (guessed)")
        gef_print("{} (".format(function_name))
        if args:
            gef_print("   " + ",\n   ".join(args))
        gef_print(")")
        return

    def line_has_breakpoint(self, file_name, line_number, bp_locations):
        filename_line = "{}:{}".format(file_name, line_number)
        return any(filename_line in loc for loc in bp_locations)

    def context_source(self):
        try:
            pc = current_arch.pc
            symtabline = gdb.find_pc_line(pc)
            symtab = symtabline.symtab
            line_num = symtabline.line - 1 # we subtract one because line number returned by gdb start at 1
            if not symtab.is_valid():
                return

            fpath = symtab.fullname()
            with open(fpath, "r") as f:
                lines = [x.rstrip() for x in f.readlines()]

        except Exception:
            return

        file_base_name = os.path.basename(symtab.filename)
        breakpoints = gdb.breakpoints() or []
        bp_locations = [b.location for b in breakpoints if b.location and file_base_name in b.location]
        past_lines_color = get_gef_setting("theme.old_context")

        nb_line = self.get_setting("nb_lines_code")
        fn = symtab.filename
        title = "source:{}+{}".format(fn, line_num + 1)
        cur_line_color = get_gef_setting("theme.source_current_line")
        self.context_title(title)
        show_extra_info = self.get_setting("show_source_code_variable_values")

        for i in range(line_num - nb_line + 1, line_num + nb_line):
            if i < 0:
                continue

            bp_prefix = Color.redify(BP_GLYPH) if self.line_has_breakpoint(file_base_name, i + 1, bp_locations) else " "

            if i < line_num:
                past_line = Color.colorify("{:4d}   {:s}".format(i + 1, lines[i]), past_lines_color)
                gef_print("{:1s}{:2s}{:s}".format(bp_prefix, "", past_line))

            elif i == line_num:
                prefix = "{:1s}{:2s}{:4d}   ".format(bp_prefix, RIGHT_ARROW[1:-1], i + 1)
                leading = len(lines[i]) - len(lines[i].lstrip())
                if show_extra_info:
                    extra_info = self.get_pc_context_info(pc, lines[i])
                    for ext in extra_info:
                        gef_print("{}// {}".format(" " * (len(prefix) + leading), ext))
                gef_print(Color.colorify("{}{:s}".format(prefix, lines[i]), cur_line_color))

            elif i > line_num:
                try:
                    future_line = "{:4d}   {:s}".format(i + 1, lines[i])
                    gef_print("{:1s}{:2s}{:s}".format(bp_prefix, "", future_line))
                except IndexError:
                    break
        return

    def get_pc_context_info(self, pc, line):
        try:
            current_block = gdb.block_for_pc(pc)
            if not current_block or not current_block.is_valid():
                return ""
            m = collections.OrderedDict()
            while current_block and not current_block.is_static:
                for sym in current_block:
                    symbol = sym.name
                    if not sym.is_function and re.search(r"\W{}\W".format(symbol), line):
                        val = gdb.parse_and_eval(symbol)
                        if val.type.code in (gdb.TYPE_CODE_PTR, gdb.TYPE_CODE_ARRAY):
                            addr = int(val.address)
                            val = to_string_dereference_from(addr)
                        elif val.type.code == gdb.TYPE_CODE_INT:
                            val = hex(int(val))
                        else:
                            continue

                        if symbol not in m:
                            m[symbol] = val
                current_block = current_block.superblock

            if m:
                return ["{} = {}".format(Color.yellowify(a), b) for a, b in m.items()]
        except Exception:
            pass
        return []

    def context_trace(self):
        try:
            self.context_title("trace")

            nb_backtrace = self.get_setting("nb_lines_backtrace")
            if nb_backtrace <= 0:
                return

            # backward compat for gdb (gdb < 7.10)
            if not hasattr(gdb, "FrameDecorator"):
                gdb.execute("backtrace {:d}".format(nb_backtrace))
                return

            try:
                orig_frame = gdb.selected_frame()
                current_frame = gdb.newest_frame()
            except Exception:
                # For unknown reasons, gdb.selected_frame() may cause an error (often occurs during kernel startup).
                err("Faild to get frame information.")
                return

            frames = [current_frame]
            while current_frame != orig_frame:
                current_frame = current_frame.older()
                frames.append(current_frame)

            nb_backtrace_before = self.get_setting("nb_lines_backtrace_before")
            level = max(len(frames) - nb_backtrace_before - 1, 0)
            current_frame = frames[level]

            while current_frame:
                current_frame.select()
                if not current_frame.is_valid():
                    continue

                pc = current_frame.pc()
                name = Instruction.smartify_text(current_frame.name())
                items = []
                items.append("{:#x}".format(pc))
                if name:
                    frame_args = gdb.FrameDecorator.FrameDecorator(current_frame).frame_args() or []
                    m = Color.greenify(name)
                    fargs = ["{}={!s}".format(Color.yellowify(x.sym), x.sym.value(current_frame)) for x in frame_args]
                    m += "({})".format(", ".join(fargs))
                    items.append(m)
                else:
                    try:
                        insn = next(gef_disassemble(pc, 1))
                    except gdb.MemoryError:
                        break
                    items.append(Color.redify("{} {}".format(insn.mnemonic, ", ".join(insn.operands))))

                idx = Color.colorify("#{}".format(level), "bold green" if current_frame == orig_frame else "bold pink")
                gef_print("[{}] {}".format(idx, RIGHT_ARROW.join(items)))
                current_frame = current_frame.older()
                level += 1
                nb_backtrace -= 1
                if nb_backtrace == 0:
                    break

            orig_frame.select()
        except Exception:
            err("No such process")
        return

    def context_threads(self):
        def reason():
            res = gdb.execute("info program", to_string=True).splitlines()
            if not res:
                return "NOT RUNNING"

            for line in res:
                line = line.strip()
                if line.startswith("It stopped with signal "):
                    return line.replace("It stopped with signal ", "").split(",", 1)[0]
                if line == "The program being debugged is not being run.":
                    return "NOT RUNNING"
                if line == "It stopped at a breakpoint that has since been deleted.":
                    return "TEMPORARY BREAKPOINT"
                if line.startswith("It stopped at breakpoint "):
                    return "BREAKPOINT"
                if line == "It stopped after being stepped.":
                    return "SINGLE STEP"

            return "STOPPED"

        self.context_title("threads")

        threads = gdb.selected_inferior().threads()[::-1]
        idx = self.get_setting("nb_lines_threads")
        if idx > 0:
            threads = threads[0:idx]

        if idx == 0:
            return

        if not threads:
            err("No thread selected")
            return

        selected_thread = gdb.selected_thread()
        try:
            selected_frame = gdb.selected_frame()
        except Exception:
            # For unknown reasons, gdb.selected_frame() may cause an error (often occurs during kernel startup).
            selected_frame = None

        for i, thread in enumerate(threads):
            line = "[{:s}]".format(Color.colorify("#{:d}".format(i), "bold green" if thread == selected_thread else "bold pink"))
            line += " Id {:d}, ".format(thread.num)
            if thread.name:
                line += 'Name: "{:s}", '.format(thread.name)
            if thread.is_running():
                line += Color.colorify("running", "bold green")
            elif thread.is_stopped():
                line += Color.colorify("stopped", "bold red")
                try:
                    thread.switch()
                except Exception:
                    line += " - Failed to switch to this thread"
                    gef_print(line)
                    continue
                try:
                    frame = gdb.selected_frame()
                except Exception:
                    # For unknown reasons, gdb.selected_frame() may cause an error (often occurs during kernel startup).
                    # if failed, print thread information without frame (but with $pc).
                    line += " {:s} in".format(Color.colorify("{:#x}".format(get_register("$pc")), "blue"))
                    line += " {:s}".format(Color.colorify("unknown_frame", "bold yellow"))
                    line += ", reason: {}".format(Color.colorify(reason(), "bold pink"))
                    gef_print(line)
                    continue
                frame_name = Instruction.smartify_text(frame.name())
                line += " {:s} in".format(Color.colorify("{:#x}".format(frame.pc()), "blue"))
                line += " {:s}".format(Color.colorify(frame_name or "unknown_frame", "bold yellow"))
                line += ", reason: {}".format(Color.colorify(reason(), "bold pink"))
            elif thread.is_exited():
                line += Color.colorify("exited", "bold yellow")
            gef_print(line)

        selected_thread.switch()
        if selected_frame is not None:
            selected_frame.select()
        return

    def context_additional_information(self):
        if not __context_messages__:
            return

        self.context_title("extra")
        for level, text in __context_messages__:
            if level == "error":
                err(text)
            elif level == "warn":
                warn(text)
            elif level == "success":
                ok(text)
            else:
                info(text)
        return

    def context_memory(self):
        global __watches__
        for address, opt in sorted(__watches__.items()):
            sz, fmt = opt[0:2]
            self.context_title("memory:{:#x}".format(address))
            if fmt == "pointers":
                gdb.execute("dereference {address:#x} L{size:d}".format(address=address, size=sz,))
            else:
                gdb.execute("hexdump {fmt:s} {address:#x} {size:d}".format(address=address, size=sz, fmt=fmt,))
        return

    @classmethod
    def update_registers(cls, event):
        try:
            for reg in current_arch.all_registers:
                try:
                    cls.old_registers[reg] = get_register(reg)
                except Exception:
                    cls.old_registers[reg] = 0
            return
        except Exception:
            return

    def empty_extra_messages(self, event):
        global __context_messages__
        __context_messages__ = []
        return


@register_command
class MemoryCommand(GenericCommand):
    """Add or remove address ranges to the memory view."""
    _cmdline_ = "memory"
    _syntax_ = "{:s} (watch|unwatch|reset|list)".format(_cmdline_)
    _category_ = "Debugging Support"

    def __init__(self):
        super().__init__(prefix=True)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()
        self.usage()
        return


@register_command
class MemoryWatchCommand(GenericCommand):
    """Adds address ranges to the memory view."""
    _cmdline_ = "memory watch"
    _syntax_ = "{:s} ADDRESS [SIZE] [(qword|dword|word|byte|pointers)]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} 0x603000 0x100 byte\n".format(_cmdline_)
    _example_ += "{:s} $sp".format(_cmdline_)
    _category_ = "Debugging Support"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        global __watches__

        if len(argv) not in (1, 2, 3):
            self.usage()
            return

        try:
            address = parse_address(argv[0])
            size = parse_address(argv[1]) if len(argv) > 1 else 0x10
        except Exception:
            self.usage()
            return
        group = "byte"

        if len(argv) == 3:
            group = argv[2].lower()
            if group not in ("qword", "dword", "word", "byte", "pointers"):
                warn("Unexpected grouping '{}'".format(group))
                self.usage()
                return
        else:
            if current_arch.ptrsize == 4:
                group = "dword"
            elif current_arch.ptrsize == 8:
                group = "qword"

        __watches__[address] = (size, group)
        ok("Adding memwatch to {:#x}".format(address))
        return


@register_command
class MemoryUnwatchCommand(GenericCommand):
    """Removes address ranges to the memory view."""
    _cmdline_ = "memory unwatch"
    _syntax_ = "{:s} ADDRESS".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} 0x603000\n".format(_cmdline_)
    _example_ += "{:s} $sp".format(_cmdline_)
    _category_ = "Debugging Support"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        global __watches__
        if not argv:
            self.usage()
            return

        address = parse_address(argv[0])
        res = __watches__.pop(address, None)
        if not res:
            warn("You weren't watching {:#x}".format(address))
        else:
            ok("Removed memwatch of {:#x}".format(address))
        return


@register_command
class MemoryWatchResetCommand(GenericCommand):
    """Removes all watchpoints."""
    _cmdline_ = "memory reset"
    _syntax_ = "{:s}".format(_cmdline_)
    _category_ = "Debugging Support"

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        global __watches__
        __watches__.clear()
        ok("Memory watches cleared")
        return


@register_command
class MemoryWatchListCommand(GenericCommand):
    """Lists all watchpoints to display in context layout."""
    _cmdline_ = "memory list"
    _syntax_ = "{:s}".format(_cmdline_)
    _category_ = "Debugging Support"

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        global __watches__

        if not __watches__:
            info("No memory watches")
            return

        info("Memory watches:")
        for address, opt in sorted(__watches__.items()):
            gef_print("- {:#x} ({}, {})".format(address, opt[0], opt[1]))
        return


@register_command
class HexdumpCommand(GenericCommand):
    """Display SIZE lines of hexdump from the memory location pointed by ADDRESS."""
    _cmdline_ = "hexdump"
    _syntax_ = "{:s} [-h] qword|dword|word|byte [--phys] [ADDRESS [SIZE]] [REVERSE] [FULL]".format(_cmdline_)
    _example_ = "{:s} byte                  # dump from $sp as byte (0x10 bytes)\n".format(_cmdline_)
    _example_ += "{:s} qword                 # dump from $sp as qword (0x100 bytes)\n".format(_cmdline_)
    _example_ += "{:s} byte $rax 0x64        # dump from $rax as byte (100 bytes)\n".format(_cmdline_)
    _example_ += "{:s} byte $rax 100 FULL    # print the same line without omitting (byte mode only)\n".format(_cmdline_)
    _example_ += "{:s} byte $rax 100 REVERSE # print in reverse order line by line".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def __init__(self, *args, **kwargs):
        prefix = kwargs.get("prefix", True)
        complete_type = kwargs.get("complete", gdb.COMPLETE_NONE)
        super().__init__(prefix=prefix, complete=complete_type)
        self.add_setting("always_show_ascii", False, "If true, hexdump will always display the ASCII dump")
        self.format = None
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        if "-h" in argv:
            self.usage()
            return

        if not self.format:
            err("Incomplete command")
            return

        fmt = self.format
        target = ""
        valid_formats = ["byte", "word", "dword", "qword"]
        read_len = None
        reverse = False
        full_mode = False

        self.phys_mode = False
        if "--phys" in argv:
            if not is_qemu_system():
                err("Unsupported")
                return
            self.phys_mode = True
            argv.remove("--phys")

        try:
            for arg in argv:
                arg_lower = arg.lower()
                if arg_lower in valid_formats:
                    fmt = arg_lower
                    continue
                if "reverse" == arg_lower:
                    reverse = True
                    continue
                if "full" == arg_lower:
                    full_mode = True
                    continue
                if target:
                    if read_len:
                        self.usage()
                        return
                    read_len = int(arg_lower, 0)
                    continue
                target = arg

            if not target:
                target = "$sp"

            start_addr = parse_address(target)
            read_from = align_address(start_addr)
        except Exception:
            self.usage()
            return

        if not read_len:
            read_len = 0x100 if fmt == "byte" else 0x10

        if fmt == "byte":
            lines = self._hexdump_byte(read_from, read_len, full_mode)
        else:
            lines = self._hexdump(read_from, read_len, fmt)

        if reverse:
            lines.reverse()

        if lines:
            gef_print("\n".join(lines))
        return

    def _hexdump_byte(self, read_from, read_len, full):
        read_from += self.repeat_count * read_len
        mem = self._read_memory(read_from, read_len)
        if mem is None:
            err("cannot access memory")
            return []
        lines_unmerged = hexdump(mem, show_symbol=False, base=read_from).splitlines()
        if full:
            return lines_unmerged

        # merge
        lines = []
        keep_asterisk = False
        for line in lines_unmerged:
            if lines == []:
                lines.append(line)
                continue
            if lines[-1].split("    ")[1] == line.split("    ")[1]:
                if not keep_asterisk:
                    keep_asterisk = True
            else:
                if keep_asterisk:
                    lines.append("*")
                    keep_asterisk = False
                lines.append(line)
        if keep_asterisk:
            lines.append("*")
        return lines

    def _read_memory(self, read_from, read_len):
        if read_len > 0x1000000: # Too large
            return None

        try:
            if self.phys_mode:
                mem = read_physmem(read_from, read_len)
            else:
                mem = read_memory(read_from, read_len)
            return mem
        except Exception:
            pass

        read_end = read_from + read_len
        read_end &= gef_getpagesize_mask()
        while read_end - read_from > 0:
            try:
                if self.phys_mode:
                    mem = read_physmem(read_from, read_end - read_from)
                else:
                    mem = read_memory(read_from, read_end - read_from)
                return mem
            except Exception:
                pass
            read_end -= gef_getpagesize()
        return None

    def _hexdump(self, start_addr, length, arrange_as):
        offset = self.repeat_count * length

        endianness = endian_str()

        base_address_color = get_gef_setting("theme.dereference_base_address")
        show_ascii = get_gef_setting("hexdump.always_show_ascii")

        formats = {
            "qword": ("Q", 8),
            "dword": ("I", 4),
            "word": ("H", 2),
        }

        spec, sz = formats[arrange_as]
        fmt_str = "{{base}}{v}+{{offset:#06x}}   {{sym}}{{val:#0{prec}x}}   {{text}}".format(v=VERTICAL_LINE, prec=sz * 2 + 2)
        fmt_pack = endianness + spec
        lines = []

        i = 0
        text = ""
        while i < length:
            cur_addr = start_addr + (i + offset) * sz
            sym = gdb_get_location_from_symbol(cur_addr)
            sym = "<{:s}+{:04x}> ".format(*sym) if sym else ""
            try:
                if self.phys_mode:
                    mem = read_physmem(cur_addr, sz)
                else:
                    mem = read_memory(cur_addr, sz)
            except Exception:
                break
            val = struct.unpack(fmt_pack, mem)[0]
            if show_ascii:
                text = "".join([chr(b) if 0x20 <= b < 0x7F else "." for b in mem])
            cur_addr_c = Color.colorify(format_address(cur_addr), base_address_color)
            line = fmt_str.format(base=cur_addr_c, offset=(i + offset) * sz, sym=sym, val=val, text=text)
            lines.append(line)
            i += 1
        return lines


@register_command
class HexdumpQwordCommand(HexdumpCommand):
    """Display SIZE lines of hexdump as QWORD from the memory location pointed by ADDRESS."""
    _cmdline_ = "hexdump qword"
    _syntax_ = "{:s} [-h] [--phys] [ADDRESS [SIZE]] [REVERSE]".format(_cmdline_)
    _example_ = "{:s} qword $rsp 16 REVERSE".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        self.format = "qword"
        return


@register_command
class HexdumpDwordCommand(HexdumpCommand):
    """Display SIZE lines of hexdump as DWORD from the memory location pointed by ADDRESS."""
    _cmdline_ = "hexdump dword"
    _syntax_ = "{:s} [-h] [--phys] [ADDRESS [SIZE]] [REVERSE]".format(_cmdline_)
    _example_ = "{:s} $esp 16 REVERSE".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        self.format = "dword"
        return


@register_command
class HexdumpWordCommand(HexdumpCommand):
    """Display SIZE lines of hexdump as WORD from the memory location pointed by ADDRESS."""
    _cmdline_ = "hexdump word"
    _syntax_ = "{:s} [-h] [--phys] [ADDRESS [SIZE]] [REVERSE]".format(_cmdline_)
    _example_ = "{:s} $esp 16 REVERSE".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        self.format = "word"
        return


@register_command
class HexdumpByteCommand(HexdumpCommand):
    """Display SIZE lines of hexdump as BYTE from the memory location pointed by ADDRESS."""
    _cmdline_ = "hexdump byte"
    _syntax_ = "{:s} [-h] [--phys] [ADDRESS [SIZE]] [REVERSE] [FULL]".format(_cmdline_)
    _example_ = "{:s} $rsp 16".format(_cmdline_)
    _aliases_ = ["xxd", ]
    _category_ = "Show/Modify Memory"

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        self.format = "byte"
        return


@register_command
class PatchCommand(GenericCommand):
    """Write specified values to the specified address."""
    _cmdline_ = "patch"
    _syntax_ = "{:s} [-h] qword|dword|word|byte [--phys] LOCATION VALUES\n".format(_cmdline_)
    _syntax_ += "{:s} [-h] string [--phys] LOCATION \"double-escaped string\" [LENGTH]\n".format(_cmdline_)
    _syntax_ += "{:s} [-h] pattern [--phys] LOCATION LENGTH\n".format(_cmdline_)
    _syntax_ += "{:s} [-h] nop [--phys] [LOCATION] [-b BYTE_LENGTH|-i INST_COUNT]\n".format(_cmdline_)
    _syntax_ += "{:s} [-h] inf|trap|ret [--phys] [LOCATION]\n".format(_cmdline_)
    _syntax_ += "{:s} [-h] history\n".format(_cmdline_)
    _syntax_ += "{:s} [-h] revert [HISTORY_NUMBER]".format(_cmdline_)
    _category_ = "Show/Modify Memory"
    SUPPORTED_SIZES = {
        "qword": (8, "Q"),
        "dword": (4, "L"),
        "word": (2, "H"),
        "byte": (1, "B"),
    }
    history = []

    def __init__(self, *args, **kwargs):
        prefix = kwargs.get("prefix", True)
        complete_type = kwargs.get("complete", gdb.COMPLETE_NONE)
        super().__init__(prefix=prefix, complete=complete_type)
        self.format = None
        return

    def patch(self, addr, data, length):
        try:
            before_data = read_memory(addr, length=length)
            write_memory(addr, data, length=length)
            after_data = read_memory(addr, length=length)
        except gdb.MemoryError:
            err("Failed to access memory")
            return
        if data != after_data:
            err("Failed to write memory (qemu doesn't support writing to code area?)")
            return
        history_info = {"addr": addr, "before_data": before_data, "after_data": after_data, "physmode": get_current_mmu_mode()}
        self.history.insert(0, history_info)
        ok("Patching {:d} bytes from {:s}".format(length, format_address(addr)))
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        phys_mode = False
        if not self.format:
            self.usage()
            return

        if "--phys" in argv:
            if not is_supported_physmode():
                err("Unsupported. Check qemu version (at least: 4.1.0-rc0~, recommend: 5.x~)")
                return
            phys_mode = True
            orig_mode = get_current_mmu_mode()
            argv.remove("--phys")

        argc = len(argv)
        if argc < 2:
            self.usage()
            return

        location, values = argv[0], argv[1:]
        fmt = self.format
        if fmt not in self.SUPPORTED_SIZES:
            self.usage()
            return

        if phys_mode:
            if orig_mode == "virt":
                enable_phys()

        addr = align_address(parse_address(location))
        size, fcode = self.SUPPORTED_SIZES[fmt]

        d = "<" if is_little_endian() else ">"
        for value in values:
            value = parse_address(value) & ((1 << size * 8) - 1)
            vstr = struct.pack(d + fcode, value)
            self.patch(addr, vstr, size)
            addr += size

        if phys_mode:
            if orig_mode == "virt":
                disable_phys()
        return


@register_command
class PatchQwordCommand(PatchCommand):
    """Write specified QWORD to the specified address."""
    _cmdline_ = "patch qword"
    _syntax_ = "{:s} [-h] [--phys] LOCATION QWORD1 [QWORD2 [QWORD3..]]".format(_cmdline_)
    _example_ = "{:s} $rip 0x4141414141414141".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        self.format = "qword"
        return


@register_command
class PatchDwordCommand(PatchCommand):
    """Write specified DWORD to the specified address."""
    _cmdline_ = "patch dword"
    _syntax_ = "{:s} [-h] [--phys] LOCATION DWORD1 [DWORD2 [DWORD3..]]".format(_cmdline_)
    _example_ = "{:s} $rip 0x41414141".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        self.format = "dword"
        return


@register_command
class PatchWordCommand(PatchCommand):
    """Write specified WORD to the specified address."""
    _cmdline_ = "patch word"
    _syntax_ = "{:s} [-h] [--phys] LOCATION WORD1 [WORD2 [WORD3..]]".format(_cmdline_)
    _example_ = "{:s} $rip 0x4141".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        self.format = "word"
        return


@register_command
class PatchByteCommand(PatchCommand):
    """Write specified BYTE to the specified address."""
    _cmdline_ = "patch byte"
    _syntax_ = "{:s} [-h] [--phys] LOCATION BYTE1 [BYTE2 [BYTE3..]]".format(_cmdline_)
    _example_ = "{:s} $rip 0x41 0x41 0x41 0x41 0x41".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        self.format = "byte"
        return


@register_command
class PatchStringCommand(PatchCommand):
    """Write specified string to the specified memory location pointed by LOCATION."""
    _cmdline_ = "patch string"
    _syntax_ = '{:s} [-h] [--phys] LOCATION "double backslash-escaped string" [LENGTH]'.format(_cmdline_)
    _example_ = '{:s} $sp "GEFROCKS"'.format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        phys_mode = False
        if "--phys" in argv:
            if not is_supported_physmode():
                err("Unsupported. Check qemu version (at least: 4.1.0-rc0~, recommend: 5.x~)")
                return
            phys_mode = True
            orig_mode = get_current_mmu_mode()
            argv.remove("--phys")

        length = None
        if len(argv) == 3:
            length = int(argv[-1], 0)
            argv = argv[:-1]

        argc = len(argv)
        if argc != 2:
            self.usage()
            return

        if phys_mode:
            if orig_mode == "virt":
                enable_phys()

        location, s = argv[0:2]
        addr = align_address(parse_address(location))

        try:
            s = codecs.escape_decode(s)[0]
        except binascii.Error:
            gef_print("Could not decode '\\xXX' encoded string \"{}\"".format(s))
            return

        if length:
            s = s * (length // len(s) + 1)
            s = s[:length]

        self.patch(addr, s, len(s))

        if phys_mode:
            if orig_mode == "virt":
                disable_phys()
        return


@register_command
class PatchPatternCommand(PatchCommand):
    """Write pattern string to the specified memory location pointed by LOCATION."""
    _cmdline_ = "patch pattern"
    _syntax_ = "{:s} [-h] [--phys] LOCATION LENGTH".format(_cmdline_)
    _example_ = "{:s} $sp 128".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        phys_mode = False
        if "--phys" in argv:
            if not is_supported_physmode():
                err("Unsupported. Check qemu version (at least: 4.1.0-rc0~, recommend: 5.x~)")
                return
            phys_mode = True
            orig_mode = get_current_mmu_mode()
            argv.remove("--phys")

        argc = len(argv)
        if argc != 2:
            self.usage()
            return

        if phys_mode:
            if orig_mode == "virt":
                enable_phys()

        location, length = argv[0:2]
        addr = align_address(parse_address(location))
        s = gef_pystring(generate_cyclic_pattern(int(length, 0)))

        self.patch(addr, s, len(s))

        if phys_mode:
            if orig_mode == "virt":
                disable_phys()
        return


@register_command
class PatchNopCommand(PatchCommand):
    """Patch the instruction(s) pointed by parameters with NOP. Note: this command is architecture aware."""
    _cmdline_ = "patch nop"
    _syntax_ = "{:s} [-h] [--phys] [LOCATION] [-b BYTE_LENGTH|-i INST_COUNT]".format(_cmdline_)
    _example_ = "{:s} $pc -i 2".format(_cmdline_)
    _category_ = "Show/Modify Memory"
    _aliases_ = ["nop", ]

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        return

    def get_insns_size(self, addr, num_insts):
        addr_after_n = gef_instruction_n(addr, num_insts)
        return addr_after_n.address - addr

    def patch_nop(self, addr, num_bytes):
        if num_bytes == 0:
            info("Not patching since num_bytes == 0")
            return

        if is_arm32() and current_arch.is_thumb() and addr & 1:
            addr -= 1

        nop_op_len = len(current_arch.nop_insn)

        if nop_op_len > num_bytes:
            err("Cannot patch instruction at {:#x} (nop_size is:{:d},insn_size is:{:d})".format(addr, nop_op_len, num_bytes))
            return

        count = num_bytes // nop_op_len
        real_num_bytes = nop_op_len * count

        if real_num_bytes != num_bytes:
            err("Cannot patch instruction at {:#x} (nop instruction does not evenly fit in requested size)".format(addr))
            return

        if is_big_endian():
            insn = b''.join([x[::-1] for x in slicer(current_arch.nop_insn, 4)])
        else:
            insn = current_arch.nop_insn
        self.patch(addr, insn * count, real_num_bytes)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        if current_arch.nop_insn is None:
            err("This command cannot work under this architecture.")
            return

        phys_mode = False
        if "--phys" in argv:
            if not is_supported_physmode():
                err("Unsupported. Check qemu version (at least: 4.1.0-rc0~, recommend: 5.x~)")
                return
            phys_mode = True
            orig_mode = get_current_mmu_mode()
            argv.remove("--phys")

        num_bytes = None
        num_insts = None
        if "-b" in argv:
            try:
                idx = argv.index("-b")
                num_bytes = int(argv[idx + 1], 0)
                argv = argv[:idx] + argv[idx + 2:]
            except Exception:
                self.usage()
                return
        elif "-i" in argv:
            try:
                idx = argv.index("-i")
                num_insts = int(argv[idx + 1], 0)
                argv = argv[:idx] + argv[idx + 2:]
            except Exception:
                self.usage()
                return
        else:
            num_insts = 1

        if phys_mode:
            if orig_mode == "virt":
                enable_phys()

        if argv:
            try:
                addr = parse_address(' '.join(argv))
            except Exception:
                self.usage()
                if phys_mode:
                    if orig_mode == "virt":
                        disable_phys()
                return
        else:
            addr = current_arch.pc

        if num_insts:
            try:
                num_bytes = self.get_insns_size(addr, num_insts)
            except Exception:
                self.usage()
                return
        self.patch_nop(addr, num_bytes)

        if phys_mode:
            if orig_mode == "virt":
                disable_phys()
        return


@register_command
class PatchInfloopCommand(PatchCommand):
    """Patch the instruction(s) pointed by parameters with Infinity loop. Note: this command is architecture aware."""
    _cmdline_ = "patch inf"
    _syntax_ = "{:s} [-h] [--phys] [LOCATION]".format(_cmdline_)
    _example_ = "{:s} $pc".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        return

    def patch_infloop(self, addr):
        if is_arm32() and current_arch.is_thumb() and addr & 1:
            addr -= 1

        num_bytes = len(current_arch.infloop_insn)

        if is_big_endian():
            insn = b''.join([x[::-1] for x in slicer(current_arch.infloop_insn, 4)])
        else:
            insn = current_arch.infloop_insn

        self.patch(addr, insn, num_bytes)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        if current_arch.infloop_insn is None:
            err("This command cannot work under this architecture.")
            return

        phys_mode = False
        if "--phys" in argv:
            if not is_supported_physmode():
                err("Unsupported. Check qemu version (at least: 4.1.0-rc0~, recommend: 5.x~)")
                return
            phys_mode = True
            orig_mode = get_current_mmu_mode()
            argv.remove("--phys")

        if phys_mode:
            if orig_mode == "virt":
                enable_phys()

        if argv:
            try:
                addr = parse_address(' '.join(argv))
            except Exception:
                self.usage()
                if phys_mode:
                    if orig_mode == "virt":
                        disable_phys()
                return
        else:
            addr = current_arch.pc

        self.patch_infloop(addr)

        if phys_mode:
            if orig_mode == "virt":
                disable_phys()
        return


@register_command
class PatchTrapCommand(PatchCommand):
    """Patch the instruction(s) pointed by parameters with BKPT. Note: this command is architecture aware."""
    _cmdline_ = "patch trap"
    _syntax_ = "{:s} [-h] [--phys] [LOCATION]".format(_cmdline_)
    _example_ = "{:s} $pc".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        return

    def patch_trap(self, addr):
        if is_arm32() and current_arch.is_thumb() and addr & 1:
            addr -= 1

        num_bytes = len(current_arch.trap_insn)

        if is_big_endian():
            insn = b''.join([x[::-1] for x in slicer(current_arch.trap_insn, 4)])
        else:
            insn = current_arch.trap_insn

        self.patch(addr, insn, num_bytes)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        if current_arch.trap_insn is None:
            err("This command cannot work under this architecture.")
            return

        phys_mode = False
        if "--phys" in argv:
            if not is_supported_physmode():
                err("Unsupported. Check qemu version (at least: 4.1.0-rc0~, recommend: 5.x~)")
                return
            phys_mode = True
            orig_mode = get_current_mmu_mode()
            argv.remove("--phys")

        if phys_mode:
            if orig_mode == "virt":
                enable_phys()

        if argv:
            try:
                addr = parse_address(' '.join(argv))
            except Exception:
                self.usage()
                if phys_mode:
                    if orig_mode == "virt":
                        disable_phys()
                return
        else:
            addr = current_arch.pc

        self.patch_trap(addr)

        if phys_mode:
            if orig_mode == "virt":
                disable_phys()
        return


@register_command
class PatchRetCommand(PatchCommand):
    """Patch the instruction(s) pointed by parameters with RET. Note: this command is architecture aware."""
    _cmdline_ = "patch ret"
    _syntax_ = "{:s} [-h] [--phys] [LOCATION]".format(_cmdline_)
    _example_ = "{:s} $pc".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def __init__(self):
        super().__init__(prefix=False, complete=gdb.COMPLETE_LOCATION)
        return

    def patch_ret(self, addr):
        if is_arm32() and current_arch.is_thumb() and addr & 1:
            addr -= 1

        num_bytes = len(current_arch.ret_insn)

        if is_big_endian():
            insn = b''.join([x[::-1] for x in slicer(current_arch.ret_insn, 4)])
        else:
            insn = current_arch.ret_insn

        self.patch(addr, insn, num_bytes)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        if current_arch.nop_insn is None:
            err("This command cannot work under this architecture.")
            return

        phys_mode = False
        if "--phys" in argv:
            if not is_supported_physmode():
                err("Unsupported. Check qemu version (at least: 4.1.0-rc0~, recommend: 5.x~)")
                return
            phys_mode = True
            orig_mode = get_current_mmu_mode()
            argv.remove("--phys")

        if phys_mode:
            if orig_mode == "virt":
                enable_phys()

        if argv:
            try:
                addr = parse_address(' '.join(argv))
            except Exception:
                self.usage()
                if phys_mode:
                    if orig_mode == "virt":
                        disable_phys()
                return
        else:
            addr = current_arch.pc

        self.patch_ret(addr)

        if phys_mode:
            if orig_mode == "virt":
                disable_phys()
        return


@register_command
class PatchHistoryCommand(PatchCommand):
    """Show patch history."""
    _cmdline_ = "patch history"
    _syntax_ = _cmdline_
    _category_ = "Show/Modify Memory"

    def __init__(self):
        super().__init__(prefix=False)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if self.history:
            gef_print("[Newer]")
            for i, hist in enumerate(self.history):
                b = ' '.join(["{:02x}".format(x) for x in hist["before_data"][:0x10]])
                if len(hist["before_data"]) > 0x10:
                    b += "..."
                a = ' '.join(["{:02x}".format(x) for x in hist["after_data"][:0x10]])
                if len(hist["after_data"]) > 0x10:
                    a += "..."
                sym = get_symbol_string(hist["addr"])
                i_str = Color.boldify("{:d}".format(i))
                gef_print("[{:s}] {:#x}{:s}: {:s} -> {:s}".format(i_str, hist["addr"], sym, b, a))
            gef_print("[Older]")
        else:
            info("Patch history is empty.")
        return


@register_command
class PatchRevertCommand(PatchCommand):
    """Revert patch history."""
    _cmdline_ = "patch revert"
    _syntax_ = "{:s} [-h] HISTORY_NUMBER".format(_cmdline_)
    _category_ = "Show/Modify Memory"
    _example_ = "{:s} 0 # revert to patch history stack[0]\n".format(_cmdline_)
    _example_ += "{:s} 3 # revert to patch history stack[3] ([0]-[2] are also reverted)".format(_cmdline_)

    def __init__(self):
        super().__init__(prefix=False)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        try:
            revert_target = int(argv[0])
        except Exception:
            self.usage()
            gef_print(titlify("Patch history"))
            gdb.execute("patch history")
            return

        if not (0 <= revert_target < len(self.history)):
            err("Invalid target index")
            return

        revert_count = revert_target + 1
        while self.history and revert_count > 0:
            hist = self.history.pop(0)
            b = ' '.join(["{:02x}".format(x) for x in hist["before_data"][:0x10]])
            if len(hist["before_data"]) > 0x10:
                b += "..."
            a = ' '.join(["{:02x}".format(x) for x in hist["after_data"][:0x10]])
            if len(hist["after_data"]) > 0x10:
                a += "..."
            sym = get_symbol_string(hist["addr"])
            info("revert {:#x}{:s}: {:s} -> {:s}".format(hist["addr"], sym, a, b))

            if is_supported_physmode():
                orig_mode = get_current_mmu_mode()
                if orig_mode == "virt" and hist["physmode"] == "phys":
                    enable_phys()
                elif orig_mode == "phys" and hist["physmode"] == "virt":
                    disable_phys()

            write_memory(hist["addr"], hist["before_data"], length=len(hist["before_data"]))

            if is_supported_physmode():
                if orig_mode == "virt" and get_current_mmu_mode() == "phys":
                    disable_phys()
                elif orig_mode == "phys" and get_current_mmu_mode() == "virt":
                    enable_phys()

            revert_count -= 1
        return


@functools.lru_cache()
def dereference_from(addr):
    """Create array like [Address(rax), Address(deref_of_rax), Address(deref_of_deref_of_rax), ..., str(msg)]"""

    @functools.lru_cache()
    def get_blacklist():
        return eval(get_gef_setting("dereference.blacklist")) or []

    if not is_alive():
        return [format_address(addr)]

    string_color = get_gef_setting("theme.dereference_string")
    max_recursion = get_gef_setting("dereference.max_recursion") or 4

    blacklist = get_blacklist()
    addr = lookup_address(align_address(int(addr)))
    msg = []
    seen_addrs = set()
    recursion = 0

    # parse pattern
    #   ... -> addr -> seen_address (loop)
    #   ... -> addr (blacklist)
    #   ... -> addr -> ...
    #   ... -> string
    #   ... -> value
    while recursion < max_recursion + 1: # +1 is to determine adding "..." or not
        # check loop
        #   ... -> addr -> seen_address (loop)
        if addr.value in seen_addrs:
            # If the address 0x0 is mapped, the loop is detected at the address 0x0.
            # but it is generally unnecessary information, so it is omitted.
            if addr.value != 0:
                msg.append("[loop detected]")
            return msg
        else:
            seen_addrs.add(addr.value)

        #   ... -> addr (blacklist)
        for baddr in blacklist:
            if baddr[0] <= addr.value < baddr[1]:
                msg.append(addr)
                msg.append("[blacklist detected]")
                return msg

        try:
            # Is this value a pointer or a value?
            # -- If it's a pointer, dereference
            # -- If it's a value, deref is None
            deref = addr.dereference()
        except Exception:
            # if addr is mapped to the HW device, an exception occurs. (not return None)
            # So we add the address to blacklilst -> exit
            start = addr.value & gef_getpagesize_mask()
            end = start + gef_getpagesize()
            err("Receive ignoring packets during access at {:#x}.".format(addr.value))
            err("Add {:#x}-{:#x} to blacklist addresses".format(start, end))
            new_blacklist = blacklist + [[start, end]]
            set_gef_setting("dereference.blacklist", new_blacklist, str, "dereference blacklist to avoid timeout")
            gdb.execute("gef save")
            info("blacklist saved to .gef.rc, edit manually to clear")
            info("try to exit. do restart")
            os._exit(0)

        # reach to max_recursion. add "..." instead of addr object
        if recursion == max_recursion:
            msg.append("...")
            return msg

        if deref is not None:
            # it can be referenced
            #   ... -> addr -> ...
            msg.append(addr)
            addr = lookup_address(deref)
            recursion += 1
            continue # goto next loop

        else:
            # if here, dereferencing addr has triggered a MemoryError, no need to go further
            # but we should check if it is string or value

            # try to parse the string from prev
            #   ... -> string
            if len(msg) > 0: # need address of string
                prev = msg[-1]
                if is_ascii_string(prev.value):
                    s = read_cstring_from_memory(prev.value)
                    if len(s) < get_memory_alignment():
                        txt = '{:s} ({:s}?)'.format(format_address(addr.value), Color.colorify(repr(s), string_color))
                    elif len(s) > GEF_MAX_STRING_LENGTH:
                        txt = Color.colorify('{:s}[...]'.format(repr(s[:GEF_MAX_STRING_LENGTH])), string_color)
                    else:
                        txt = Color.colorify('{:s}'.format(repr(s)), string_color)
                    msg.append(txt)
                    return msg

            # if not able to parse cleanly, simply use itself
            #   ... -> value
            msg.append(addr)
            return msg

    # something is wrong
    raise


@functools.lru_cache()
def to_string_dereference_from(value, join_start_idx=0):
    """Create link list string like 0xXXXXXXXX -> 0xYYYYYYYY -> 0xZZZZZZZZ -> '...'"""
    # dereference
    addrs = dereference_from(value)

    # value is not address
    if join_start_idx == 0 and len(addrs) == 1:
        return hex(value)

    # create link list
    link = ""
    for addr in addrs[join_start_idx:]:
        if link:
            link += " {:s} ".format(RIGHT_ARROW)
        if isinstance(addr, Address):
            link += str(addr) + get_symbol_string(addr.value)
        else:
            link += addr # actually this is msg
    return link


@register_command
class DereferenceCommand(GenericCommand):
    """Dereference recursively from an address and display information. This acts like WinDBG `dps` command."""
    _cmdline_ = "dereference"
    _syntax_ = "{:s} [-h] [LOCATION] [[L]NUM]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} $sp L20 # print 20 lines from $sp\n".format(_cmdline_)
    _example_ += "{:s} $sp 20 # same as above".format(_cmdline_)
    _category_ = "Show/Modify Memory"
    _aliases_ = ["telescope", ]
    _repeat_ = True

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        self.add_setting("max_recursion", 4, "Maximum level of pointer recursion")
        self.add_setting("blacklist", "[]", "Dereference black address")
        return

    @staticmethod
    def pprint_dereferenced(addr, idx):
        base_address_color = get_gef_setting("theme.dereference_base_address")
        registers_color = get_gef_setting("theme.dereference_register_value")
        memalign = current_arch.ptrsize

        offset = idx * memalign
        current_address = align_address(addr + offset)

        # addrs: [Address(rax), Address(deref_of_rax), Address(deref_of_deref_of_rax), ..., str(msg)]
        addrs = dereference_from(current_address)
        if len(addrs) == 1: # cannot access this area
            raise

        # create address link list
        link = to_string_dereference_from(current_address, join_start_idx=1)

        # craete line of one entry
        addr_colored = Color.colorify(format_address(addrs[0].value), base_address_color)
        line = f"{addr_colored}{VERTICAL_LINE}+{offset:#06x}{VERTICAL_LINE}{idx:03d}: {link:{memalign * 2 + 2}s}"

        # add extra info
        current_address_value = read_int_from_memory(current_address)

        # retaddr info
        @functools.lru_cache()
        def get_frame_pcs():
            frames = []
            try:
                frame = gdb.newest_frame()
                while frame:
                    pc = frame.pc()
                    if pc == 0 or pc in frames:
                        break
                    frames.append(pc)
                    frame = frame.older()
            except Exception:
                pass
            return frames

        for i, frame_pc in enumerate(get_frame_pcs()):
            if current_address_value == frame_pc:
                m = " {:s} retaddr[{:d}]".format(LEFT_ARROW, i)
                line += Color.colorify(m, registers_color)

        # canary info
        res = gef_read_canary()
        if res:
            canary, location = res
            if current_address_value == canary:
                m = " {:s} canary".format(LEFT_ARROW)
                line += Color.colorify(m, registers_color)

        # register info
        @functools.lru_cache()
        def get_register_values():
            regs = []
            for regname in current_arch.all_registers:
                try:
                    regvalue = get_register(regname)
                except Exception:
                    continue
                regs.append([regname, regvalue])
            return regs

        m = ""
        for regname, regvalue in get_register_values():
            if current_address == regvalue:
                if m:
                    m += ", " + regname
                else:
                    m += regname
        if m:
            m = " {:s} {:s}".format(LEFT_ARROW, m)
            line += Color.colorify(m, registers_color)

        return line

    @only_if_gdb_running
    def do_invoke(self, argv):
        if "-h" in argv:
            self.usage()
            return

        target = "$sp"
        nb = 10

        for arg in argv:
            if arg.isdigit():
                nb = int(arg)
            elif arg[0] in ("l", "L") and arg[1:].isdigit():
                nb = int(arg[1:])
            else:
                target = arg

        try:
            start_address = to_unsigned_long(safe_parse_and_eval(target))
        except Exception:
            err("Invalid address")
            return

        if get_gef_setting("context.grow_stack_down") is True:
            from_insnum = nb * (self.repeat_count + 1) - 1
            to_insnum = self.repeat_count * nb - 1
            insnum_step = -1
        else:
            from_insnum = 0 + self.repeat_count * nb
            to_insnum = nb * (self.repeat_count + 1)
            insnum_step = 1

        for idx in range(from_insnum, to_insnum, insnum_step):
            try:
                line = DereferenceCommand.pprint_dereferenced(start_address, idx)
                gef_print(line)
            except Exception:
                # ex: nop DWORD PTR [rax+rax*1+0x0]
                err("Cannot access memory at address {:#x}".format(start_address + idx * current_arch.ptrsize))
                break
        return


@register_command
class ASLRCommand(GenericCommand):
    """View/modify the ASLR setting of GDB. By default, GDB will disable ASLR when it starts the process (i.e. not
    attached). This command allows to change that setting."""
    _cmdline_ = "aslr"
    _syntax_ = "{:s} (on|off)".format(_cmdline_)
    _category_ = "Process Information"

    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        argc = len(argv)

        if argc == 0:
            ret = gdb.execute("show disable-randomization", to_string=True)
            i = ret.find("virtual address space is ")
            if i < 0:
                return
            msg = "ASLR is currently "
            if ret[i + 25:].strip() == "on.":
                msg += Color.redify("disabled")
            else:
                msg += Color.greenify("enabled")
            gef_print(msg)
            return

        elif argc == 1:
            if argv[0] == "on":
                info("Enabling ASLR")
                gdb.execute("set disable-randomization off")
                return
            elif argv[0] == "off":
                info("Disabling ASLR")
                gdb.execute("set disable-randomization on")
                return
            warn("Invalid command")
        self.usage()
        return


@register_command
class ResetCacheCommand(GenericCommand):
    """Reset cache of all stored data. This command is here for debugging and test purposes, GEF
    handles properly the cache reset under "normal" scenario."""
    _cmdline_ = "reset-cache"
    _syntax_ = _cmdline_
    _category_ = "GEF Maintenance Command"

    def do_invoke(self, argv):
        self.dont_repeat()
        reset_all_caches()
        return


@register_command
class VMMapCommand(GenericCommand):
    """Display a comprehensive layout of the virtual memory mapping. If a filter argument, GEF will
    filter out the mapping whose pathname do not match that filter."""
    _cmdline_ = "vmmap"
    _syntax_ = "{:s} [--outer] [-v] [FILTER]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} libc # print entry only `libc`\n".format(_cmdline_)
    _example_ += "{:s} --outer # show qemu-user memory map; only valid in qemu-user mode\n".format(_cmdline_)
    _example_ += "{:s} -v # show register info".format(_cmdline_)
    _category_ = "Process Information"

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if is_qemu_system():
            info("Redirect to pagewalk")
            gdb.execute("pagewalk {:s} {:s}".format(current_arch.arch.lower(), ' '.join(argv)))
            return

        outer = False
        if "--outer" in argv:
            argv.remove("--outer")
            if is_qemu_usermode():
                outer = True
            else:
                err("Unsupported")
                return

        self.verbose = False
        if "-v" in argv:
            argv.remove("-v")
            self.verbose = True

        if is_qemu_usermode():
            clear_explored_auxv()
            clear_explored_regions()

        vmmap = get_process_maps(outer)
        if not vmmap:
            for line in gdb.execute('info files', to_string=True).splitlines():
                if line.startswith("Symbols from"):
                    break
            else:
                err("Missing info about architecture. Please set: `file /path/to/target_binary`")
            err("No address mapping information found")
            return

        if not get_gef_setting("gef.disable_color"):
            self.show_legend()

        headers = ["Start", "End", "Size", "Offset", "Perm", "Path"]
        legend = "{:<{w}s}{:<{w}s}{:<{w}s}{:<{w}s}{:<4s} {:s}".format(*headers, w=get_memory_alignment() * 2 + 3)
        gef_print(Color.colorify(legend, get_gef_setting("theme.table_heading")))

        for entry in vmmap:
            if not argv:
                self.print_entry(entry, outer)
                continue
            if argv[0] in entry.path:
                self.print_entry(entry, outer)
            elif self.is_integer(argv[0]):
                addr = int(argv[0], 0)
                if addr >= entry.page_start and addr < entry.page_end:
                    self.print_entry(entry, outer)

        if is_qemu_usermode() and not outer:
            info("Searched from auxv, registers, stack values. There may be areas that cannot be detected.")
        return

    def print_entry(self, entry, outer):
        line_color = ""
        if entry.path == "[stack]":
            line_color = get_gef_setting("theme.address_stack")
        elif entry.path == "[heap]":
            line_color = get_gef_setting("theme.address_heap")
        elif entry.permission.value & Permission.READ and entry.permission.value & Permission.EXECUTE:
            line_color = get_gef_setting("theme.address_code")

        lines = []
        # if qemu-xxx(32bit arch) runs on x86-64 machine, memalign_size does not match get_memory_alignment()
        memalign_size = 8 if outer else None
        lines.append(Color.colorify(format_address(entry.page_start, memalign_size), line_color))
        lines.append(Color.colorify(format_address(entry.page_end, memalign_size), line_color))
        lines.append(Color.colorify(format_address(entry.size, memalign_size), line_color))
        lines.append(Color.colorify(format_address(entry.offset, memalign_size), line_color))

        if entry.permission.value == (Permission.READ | Permission.WRITE | Permission.EXECUTE):
            lines.append(Color.colorify(str(entry.permission), "underline " + line_color))
        else:
            lines.append(Color.colorify(str(entry.permission), line_color))

        lines.append(Color.colorify(entry.path, line_color))
        line = " ".join(lines)

        # register info
        if self.verbose:
            register_hints = []
            for regname in current_arch.all_registers:
                regvalue = get_register(regname)
                if entry.page_start <= regvalue < entry.page_end:
                    register_hints.append(regname)
            if register_hints:
                m = " {:s} {:s}".format(LEFT_ARROW, ", ".join(list(register_hints)))
                registers_color = get_gef_setting("theme.dereference_register_value")
                line += Color.colorify(m, registers_color)

        gef_print(line)
        return

    def show_legend(self):
        code_addr_color = get_gef_setting("theme.address_code")
        stack_addr_color = get_gef_setting("theme.address_stack")
        heap_addr_color = get_gef_setting("theme.address_heap")

        code = Color.colorify("Code", code_addr_color)
        heap = Color.colorify("Heap", heap_addr_color)
        stack = Color.colorify("Stack", stack_addr_color)

        gef_print("[ Legend:  {} | {} | {} ]".format(code, heap, stack))
        return

    def is_integer(self, n):
        try:
            int(n, 0)
        except ValueError:
            return False
        return True


@register_command
class XFilesCommand(GenericCommand):
    """Shows all libraries (and sections) loaded by binary. This command extends the GDB command
    `info files`, by retrieving more information from extra sources, and providing a better
    display with REGEX filtering."""
    _cmdline_ = "xfiles"
    _syntax_ = "{:s} [REGEX]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} libc\n".format(_cmdline_)
    _example_ += "{:s} IO_vtables".format(_cmdline_)
    _category_ = "Process Information"

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        headers = ["Start", "End", "Name", "File"]
        legend = "{:<{w}s}{:<{w}s}{:<21s} {:s}".format(*headers, w=get_memory_alignment() * 2 + 3)
        gef_print(Color.colorify(legend, get_gef_setting("theme.table_heading")))

        filter_patterns = argv

        for xfile in get_info_files():
            lines = []
            lines.append(format_address(xfile.zone_start))
            lines.append(format_address(xfile.zone_end))
            lines.append("{:<21s}".format(xfile.name))
            lines.append(xfile.filename)
            line = " ".join(lines)

            if not filter_patterns:
                gef_print(line)
            else:
                for filt in filter_patterns:
                    if re.search(filt, line):
                        gef_print(line)
        return


@register_command
class XAddressInfoCommand(GenericCommand):
    """Retrieve and display runtime information for the location(s) given as parameter."""
    _cmdline_ = "xinfo"
    _syntax_ = "{:s} LOCATION".format(_cmdline_)
    _example_ = "{:s} $pc".format(_cmdline_)
    _category_ = "Process Information"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if not argv:
            err("At least one valid address must be specified")
            self.usage()
            return

        for sym in argv:
            try:
                addr = align_address(parse_address(sym))
                gef_print(titlify("xinfo: {:#x}".format(addr)))
                self.infos(addr)

            except gdb.error as gdb_err:
                err("{:s}".format(str(gdb_err)))
        return

    def infos(self, address):
        addr = lookup_address(address)
        if not addr.valid:
            warn("Cannot reach {:#x} in memory space".format(address))
            return

        sect = addr.section
        info = addr.info

        if sect:
            page_start = format_address(sect.page_start)
            page_end = format_address(sect.page_end)
            page_size = sect.page_end - sect.page_start
            gef_print("Page: {:s} {:s} {:s} (size={:#x})".format(page_start, RIGHT_ARROW, page_end, page_size))
            gef_print("Permissions: {}".format(sect.permission))
            gef_print("Pathname: {:s}".format(sect.path))
            gef_print("Offset (from page): {:#x}".format(addr.value - sect.page_start))
            if sect.inode:
                gef_print("Inode: {:s}".format(sect.inode))

        if info:
            zone_start = format_address(info.zone_start)
            zone_end = format_address(info.zone_end)
            gef_print("Segment: {:s} ({:s}-{:s})".format(info.name, zone_start, zone_end))
            gef_print("Offset (from segment): {:#x}".format(addr.value - info.zone_start))

        sym = gdb_get_location_from_symbol(address)
        if sym:
            name, offset = sym
            msg = "Symbol: {:s}".format(name)
            if offset:
                msg += "+{:d}".format(offset)
            gef_print(msg)

        return


@register_command
class XorMemoryCommand(GenericCommand):
    """XOR a block of memory. The command allows to simply display the result, or patch it
    runtime at runtime."""
    _cmdline_ = "xor-memory"
    _syntax_ = "{:s} (display|patch) ADDRESS SIZE KEY".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def __init__(self):
        super().__init__(prefix=True)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()
        self.usage()
        return


@register_command
class XorMemoryDisplayCommand(GenericCommand):
    """Display a block of memory pointed by ADDRESS by xor-ing each byte with KEY. The key must be
    provided in hexadecimal format."""
    _cmdline_ = "xor-memory display"
    _syntax_ = "{:s} ADDRESS SIZE KEY".format(_cmdline_)
    _example_ = "{:s} $sp 16 41414141".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) != 3:
            self.usage()
            return

        address = parse_address(argv[0])
        length = int(argv[1], 0)
        key = argv[2]
        try:
            block = read_memory(address, length)
        except gdb.MemoryError:
            err("Failed to read memory")
            return
        info("Displaying XOR-ing {:#x}-{:#x} with {:s}".format(address, address + len(block), repr(key)))

        gef_print(titlify("Original block"))
        gef_print(hexdump(block, base=address))

        gef_print(titlify("XOR-ed block"))
        gef_print(hexdump(xor(block, key), base=address))
        return


@register_command
class XorMemoryPatchCommand(GenericCommand):
    """Patch a block of memory pointed by ADDRESS by xor-ing each byte with KEY. The key must be
    provided in hexadecimal format."""
    _cmdline_ = "xor-memory patch"
    _syntax_ = "{:s} ADDRESS SIZE KEY".format(_cmdline_)
    _example_ = "{:s} $sp 16 41414141".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) != 3:
            self.usage()
            return

        address = parse_address(argv[0])
        length = int(argv[1], 0)
        key = argv[2]
        try:
            block = read_memory(address, length)
        except gdb.MemoryError:
            err("Failed to read memory")
            return
        info("Patching XOR-ing {:#x}-{:#x} with '{:s}'".format(address, address + len(block), key))
        xored_block = xor(block, key)
        write_memory(address, xored_block, length)
        return


@register_command
class TraceRunCommand(GenericCommand):
    """Create a runtime trace of all instructions executed from $pc to LOCATION specified. The
    trace is stored in a text file that can be next imported in IDA Pro to visualize the runtime path."""
    _cmdline_ = "trace-run"
    _syntax_ = "{:s} LOCATION [MAX_CALL_DEPTH]".format(_cmdline_)
    _example_ = "{:s} 0x555555554610".format(_cmdline_)
    _category_ = "Debugging Support"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        self.add_setting("max_tracing_recursion", 1, "Maximum depth of tracing")
        self.add_setting("tracefile_prefix", "./gef-trace-", "Specify the tracing output file prefix")
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) not in (1, 2):
            self.usage()
            return

        if len(argv) == 2 and argv[1].isdigit():
            depth = int(argv[1])
        else:
            depth = 1

        try:
            loc_start = current_arch.pc
            loc_end = parse_address(argv[0])
        except gdb.error as e:
            err("Invalid location: {:s}".format(e))
            return

        self.trace(loc_start, loc_end, depth)
        return

    def get_frames_size(self):
        n = 0
        f = gdb.newest_frame()
        while f:
            n += 1
            f = f.older()
        return n

    def trace(self, loc_start, loc_end, depth):
        info("Tracing from {:#x} to {:#x} (max depth={:d})".format(loc_start, loc_end, depth))
        logfile = "{:s}{:#x}-{:#x}.txt".format(self.get_setting("tracefile_prefix"), loc_start, loc_end)
        enable_redirect_output(to_file=logfile)
        hide_context()
        self.start_tracing(loc_start, loc_end, depth)
        unhide_context()
        disable_redirect_output()
        ok("Done, logfile stored as '{:s}'".format(logfile))
        return

    def start_tracing(self, loc_start, loc_end, depth):
        loc_cur = loc_start
        frame_count_init = self.get_frames_size()

        gef_print("#")
        gef_print("# Execution tracing of {:s}".format(get_filepath()))
        gef_print("# Start address: {:s}".format(format_address(loc_start)))
        gef_print("# End address: {:s}".format(format_address(loc_end)))
        gef_print("# Recursion level: {:d}".format(depth))
        gef_print("# automatically generated by gef.py")
        gef_print("#\n")

        while loc_cur != loc_end:
            try:
                delta = self.get_frames_size() - frame_count_init

                if delta <= depth:
                    gdb.execute("stepi")
                else:
                    gdb.execute("finish")

                loc_cur = current_arch.pc
                gdb.flush()

            except gdb.error as e:
                gef_print("#")
                gef_print("# Execution interrupted at address {:s}".format(format_address(loc_cur)))
                gef_print("# Exception: {:s}".format(e))
                gef_print("#\n")
                break
        return


@register_command
class PatternCommand(GenericCommand):
    """This command will create or search a De Bruijn cyclic pattern to facilitate
    determining the offset in memory. The algorithm used is the same as the one
    used by pwntools, and can therefore be used in conjunction."""
    _cmdline_ = "pattern"
    _syntax_ = "{:s} (create|search) ARGS".format(_cmdline_)
    _category_ = "Exploit Development"

    def __init__(self, *args, **kwargs):
        super().__init__(prefix=True)
        self.add_setting("length", 1024, "Initial length of a cyclic buffer to generate")
        return

    def do_invoke(self, argv):
        self.dont_repeat()
        self.usage()
        return


@register_command
class PatternCreateCommand(GenericCommand):
    """Generate a de Bruijn cyclic pattern. It will generate a pattern long of SIZE,
    incrementally varying of one byte at each generation. The length of each block is
    equal to sizeof(void*).
    Note: This algorithm is the same than the one used by pwntools library."""
    _cmdline_ = "pattern create"
    _syntax_ = "{:s} [SIZE]".format(_cmdline_)
    _aliases_ = ["pattc"]
    _category_ = "Exploit Development"

    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) == 1:
            try:
                sz = int(argv[0], 0)
            except ValueError:
                err("Invalid size")
                return
            set_gef_setting("pattern.length", sz)
        elif len(argv) > 1:
            err("Invalid syntax")
            return

        size = get_gef_setting("pattern.length")
        info("Generating a pattern of {:d} bytes".format(size))
        pattern_str = gef_pystring(generate_cyclic_pattern(size))
        gef_print(pattern_str)
        ok("Saved as '{:s}'".format(gef_convenience(pattern_str)))
        return


@register_command
class PatternSearchCommand(GenericCommand):
    """Search for the cyclic de Bruijn pattern generated by the `pattern create` command. The
    PATTERN argument can be a GDB symbol (such as a register name) or an hexadecimal value."""
    _cmdline_ = "pattern search"
    _syntax_ = "{:s} PATTERN [SIZE]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} $pc\n".format(_cmdline_)
    _example_ += "{:s} 0x61616164\n".format(_cmdline_)
    _example_ += "{:s} aaab".format(_cmdline_)
    _category_ = "Exploit Development"
    _aliases_ = ["patto"]

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        argc = len(argv)
        if argc not in (1, 2):
            self.usage()
            return

        if argc == 2:
            try:
                size = int(argv[1], 0)
            except ValueError:
                err("Invalid size")
                return
        else:
            size = get_gef_setting("pattern.length")

        pattern = argv[0]
        info("Searching '{:s}'".format(pattern))
        self.search(pattern, size)
        return

    def search(self, pattern, size):
        pattern_be, pattern_le = None, None

        # 1. check if it's a symbol (like "$sp" or "0x1337")
        symbol = safe_parse_and_eval(pattern)
        if symbol:
            addr = to_unsigned_long(symbol)
            dereferenced_value = dereference(addr)
            # 1-bis. try to dereference
            if dereferenced_value:
                addr = int(dereferenced_value)

            if current_arch.ptrsize == 4:
                pattern_be = struct.pack(">I", addr)
                pattern_le = struct.pack("<I", addr)
            else:
                pattern_be = struct.pack(">Q", addr)
                pattern_le = struct.pack("<Q", addr)

        else:
            # 2. assume it's a plain string
            pattern_be = gef_pybytes(pattern)
            pattern_le = gef_pybytes(pattern[::-1])

        pattern_be = pattern_be.strip(b"\0")
        pattern_le = pattern_le.strip(b"\0")

        cyclic_pattern = generate_cyclic_pattern(size)
        found = False
        off = cyclic_pattern.find(pattern_le)
        if off >= 0:
            fmt = "Found at offset {:d} (little-endian search) {:s}"
            ok(fmt.format(off, Color.colorify("likely", "bold red") if is_little_endian() else ""))
            found = True

        off = cyclic_pattern.find(pattern_be)
        if off >= 0:
            fmt = "Found at offset {:d} (big-endian search) {:s}"
            ok(fmt.format(off, Color.colorify("likely", "bold green") if is_big_endian() else ""))
            found = True

        if not found:
            err("Pattern '{}' not found".format(pattern))
        return


@register_command
class ChecksecCommand(GenericCommand):
    """Checksec the security properties of the current executable or passed as argument. The
    command checks for the following protections: Canary, NX, PIE, RELRO, Fortify, CET, RPATH, RUNPATH, ASLR"""
    _cmdline_ = "checksec"
    _syntax_ = "{:s} [-h] [FILENAME]".format(_cmdline_)
    _example_ = "{:s} /bin/ls".format(_cmdline_)
    _category_ = "Process Information"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_FILENAME)
        return

    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        if is_qemu_system():
            self.print_security_properties_qemu_system()
            return

        argc = len(argv)

        if argc == 0:
            filename = get_filepath()
            if filename is None or open(filename, "rb").read(4) != b"\x7fELF":
                if is_qemu_usermode():
                    err("Missing info about architecture. Please set: `file /path/to/target_binary`")
                    return
                else:
                    err("No executable/library specified")
                    return
        elif argc == 1:
            filename = os.path.realpath(os.path.expanduser(argv[0]))
            if not os.access(filename, os.R_OK):
                err("Invalid filename")
                return
        else:
            self.usage()
            return

        info("{:s} for '{:s}'".format(self._cmdline_, filename))
        self.print_security_properties(filename)
        return

    def print_security_properties(self, filename):

        def get_colored_msg(val):
            if val is True:
                msg = Color.greenify(Color.boldify("Enabled"))
            elif val is False:
                msg = Color.redify(Color.boldify("Disabled"))
            elif val is None:
                msg = Color.grayify(Color.boldify("Unknown"))
            return msg

        sec = checksec(filename)
        if sec is False:
            err("checksec is failed")
            return

        # Static
        if sec["Static"]:
            gef_print("{:<30s}: {:s}".format("Static/Dynamic", "Static"))
        else:
            gef_print("{:<30s}: {:s}".format("Static/Dynamic", "Dynamic"))

        # Stripped
        if sec["Stripped"]:
            gef_print("{:<30s}: {:s}".format("Stripped", Color.colorify("Yes", "green bold")))
        else:
            gef_print("{:<30s}: {:s}".format("Stripped", Color.colorify("No", "red bold") + " (The symbol remains)"))

        # Canary
        msg = get_colored_msg(sec["Canary"])
        if sec["Canary"] is True and is_alive():
            res = gef_read_canary()
            if not res:
                msg += " (Could not get the canary value)"
            else:
                msg += " (value: {:#x})".format(res[0])
        gef_print("{:<30s}: {:s}".format("Canary", msg))

        # NX
        gef_print("{:<30s}: {:s}".format("NX", get_colored_msg(sec["NX"])))

        # PIE
        gef_print("{:<30s}: {:s}".format("PIE", get_colored_msg(sec["PIE"])))

        # RELRO
        if sec["Full RELRO"]:
            gef_print("{:<30s}: {:s}".format("RELRO", Color.colorify("Full RELRO", "green bold")))
        elif sec["Partial RELRO"]:
            gef_print("{:<30s}: {:s}".format("RELRO", Color.colorify("Partial RELRO", "yellow bold")))
        else:
            gef_print("{:<30s}: {:s}".format("RELRO", Color.colorify("No RELRO", "red bold")))

        # Fortify
        if sec["Fortify"]:
            gef_print("{:<30s}: {:s}".format("Fortify", Color.colorify("Found", "green bold")))
        else:
            gef_print("{:<30s}: {:s}".format("Fortify", Color.colorify("Not Found", "red bold")))

        # CET
        if sec["Intel CET"]:
            gef_print("{:<30s}: {:s}".format("Intel CET", Color.colorify("Found", "green bold") + " (endbr64/endbr32 is found)"))
        else:
            gef_print("{:<30s}: {:s}".format("Intel CET", Color.colorify("Not Found", "red bold") + " (endbr64/endbr32 is not found)"))

        # RPATH
        if not sec["RPATH"]:
            gef_print("{:<30s}: {:s}".format("RPATH", Color.colorify("Not Found", "green bold")))
        else:
            gef_print("{:<30s}: {:s}".format("RPATH", Color.colorify("Found", "red bold")))

        # RUNPATH
        if not sec["RUNPATH"]:
            gef_print("{:<30s}: {:s}".format("RUNPATH", Color.colorify("Not Found", "green bold")))
        else:
            gef_print("{:<30s}: {:s}".format("RUNPATH", Color.colorify("Found", "red bold")))

        # Clang CFI
        if sec["Clang CFI"]:
            gef_print("{:<30s}: {:s}".format("Clang CFI", get_colored_msg(sec["Clang CFI"])))

        # Clang SafeStack
        if sec["Clang SafeStack"]:
            gef_print("{:<30s}: {:s}".format("Clang SafeStack", get_colored_msg(sec["Clang SafeStack"])))

        # System-ASLR
        if not is_remote_debug() or is_remote_but_same_host():
            try:
                system_aslr = int(open("/proc/sys/kernel/randomize_va_space").read())
                if system_aslr == 0:
                    gef_print("{:<30s}: {:s} (randomize_va_space: 0)".format("System ASLR", Color.colorify("Disabled", "red bold")))
                elif system_aslr == 1:
                    gef_print("{:<30s}: {:s} (randomize_va_space: 1)".format("System ASLR", Color.colorify("Partially Enabled", "yellow bold")))
                elif system_aslr == 2:
                    gef_print("{:<30s}: {:s} (randomize_va_space: 2)".format("System ASLR", Color.colorify("Enabled", "green bold")))
            except Exception:
                gef_print("{:<30s}: {:s} (randomize_va_space: error)".format("System-ASLR", Color.colorify("Unknown", "gray bold")))
        else:
            gef_print("{:<30s}: {:s} (attached remote process)".format("System-ASLR", Color.colorify("Unknown", "gray bold")))

        # attached or not
        ret = gdb.execute("info files", to_string=True)
        if "Using the running image of child Thread" in ret or "Using the running image of child process" in ret:
            # gdb ASLR
            ret = gdb.execute("show disable-randomization", to_string=True)
            if "virtual address space is on." in ret:
                gef_print("{:<30s}: {:s} (disable-randomization: on)".format("GDB ASLR setting", Color.colorify("Disabled", "red bold")))
            elif "virtual address space is off." in ret:
                gef_print("{:<30s}: {:s} (disable-randomization: off)".format("GDB ASLR setting", Color.colorify("Enabled", "green bold")))
            else:
                gef_print("{:<30s}: {:s}".format("GDB ASLR setting", Color.colorify("Unknown", "gray bold")))
        elif "Using the running image of attached process" in ret:
            gef_print("{:<30s}: {:s} (attached process)".format("GDB ASLR setting", Color.colorify("Ignored", "gray bold")))
        elif "Debugging a target over a serial line." in ret:
            gef_print("{:<30s}: {:s} (attached process)".format("GDB ASLR setting", Color.colorify("Ignored", "gray bold")))
        return

    def print_security_properties_qemu_system(self):
        if not is_x86():
            return
        ret = gdb.execute("qreg -v", to_string=True)
        flag = False
        for line in ret.splitlines():
            if "CR0 (Control Register 0)" in line:
                flag = True
            if "CR1 (Control Register 1)" in line:
                flag = False
            if "CR4 (Control Register 4)" in line:
                flag = True
            if "DR0-DR3 (Debug Address Register 0-3)" in line:
                flag = False
            if flag:
                gef_print(line)
        return


@register_command
class SropHintCommand(GenericCommand):
    """Hint for sigreturn oriented programming."""
    _cmdline_ = "srop-hint"
    _syntax_ = "{:s} [-a x86|x64|arm|aarch64]".format(_cmdline_)
    _category_ = "Exploit Development"

    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        if len(argv) >= 2:
            if argv[0] == "-a" and argv[1] in ["x86", "x64", "arm", "aarch64"]:
                mode = argv[1]
            else:
                self.usage()
                return
        else:
            if is_x86_64():
                mode = "x64"
            elif is_x86_32():
                mode = "x86"
            elif is_arm32():
                mode = "arm"
            elif is_arm64():
                mode = "aarch64"
            else:
                mode = "x64"

        s = ""
        if mode == "x64":
            s += 'exp  = struct.pack("<Q", syscall)    # rax = 15 (rt_sigreturn)\n'
            s += 'exp += struct.pack("<Q", 0xcafebabe) # rt_sigframe.pretcode\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_flags\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_link\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_stack.ss_sp\n'
            s += 'exp += struct.pack("<I", 0x0)        # rt_sigframe.uc.uc_stack.ss_flags\n'
            s += 'exp += struct.pack("<I", 0x0)        # rt_sigframe.uc.uc_stack.ss_size\n'
            s += 'exp += struct.pack("<Q", 0x08)       # rt_sigframe.uc.uc_mcontext.r8\n'
            s += 'exp += struct.pack("<Q", 0x09)       # rt_sigframe.uc.uc_mcontext.r9\n'
            s += 'exp += struct.pack("<Q", 0x0a)       # rt_sigframe.uc.uc_mcontext.r10\n'
            s += 'exp += struct.pack("<Q", 0x0b)       # rt_sigframe.uc.uc_mcontext.r11\n'
            s += 'exp += struct.pack("<Q", 0x0c)       # rt_sigframe.uc.uc_mcontext.r12\n'
            s += 'exp += struct.pack("<Q", 0x0d)       # rt_sigframe.uc.uc_mcontext.r13\n'
            s += 'exp += struct.pack("<Q", 0x0e)       # rt_sigframe.uc.uc_mcontext.r14\n'
            s += 'exp += struct.pack("<Q", 0x0f)       # rt_sigframe.uc.uc_mcontext.r15\n'
            s += 'exp += struct.pack("<Q", 0x07)       # rt_sigframe.uc.uc_mcontext.rdi\n'
            s += 'exp += struct.pack("<Q", 0x06)       # rt_sigframe.uc.uc_mcontext.rsi\n'
            s += 'exp += struct.pack("<Q", 0x05)       # rt_sigframe.uc.uc_mcontext.rbp\n'
            s += 'exp += struct.pack("<Q", 0x02)       # rt_sigframe.uc.uc_mcontext.rbx\n'
            s += 'exp += struct.pack("<Q", 0x04)       # rt_sigframe.uc.uc_mcontext.rdx\n'
            s += 'exp += struct.pack("<Q", 0x01)       # rt_sigframe.uc.uc_mcontext.rax\n'
            s += 'exp += struct.pack("<Q", 0x03)       # rt_sigframe.uc.uc_mcontext.rcx\n'
            s += 'exp += struct.pack("<Q", 0xdeadface) # rt_sigframe.uc.uc_mcontext.rsp\n'
            s += 'exp += struct.pack("<Q", 0xdeadbeef) # rt_sigframe.uc.uc_mcontext.rip\n'
            s += 'exp += struct.pack("<Q", 0x00)       # rt_sigframe.uc.uc_mcontext.rflags\n'
            s += 'exp += struct.pack("<H", 0x33)       # rt_sigframe.uc.uc_mcontext.cs\n'
            s += 'exp += struct.pack("<H", 0x00)       # rt_sigframe.uc.uc_mcontext.gs\n'
            s += 'exp += struct.pack("<H", 0x00)       # rt_sigframe.uc.uc_mcontext.fs\n'
            s += 'exp += struct.pack("<H", 0x00)       # rt_sigframe.uc.uc_mcontext.__pad0\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_mcontext.err\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_mcontext.trapno\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_mcontext.oldmask\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_mcontext.cr2\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_mcontext.fpstate # fpu/xmm are not restored if NULL\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_mcontext.reserved[8]\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_sigmask\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.info\n'
        elif mode == "x86":
            s += 'exp  = struct.pack("<I", syscall)    # eax = 119 (sigreturn)\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.gs\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.fs\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.es\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.ds\n'
            s += 'exp += struct.pack("<I", 0x7)        # sigframe.sc.edi\n'
            s += 'exp += struct.pack("<I", 0x6)        # sigframe.sc.esi\n'
            s += 'exp += struct.pack("<I", 0x5)        # sigframe.sc.ebp\n'
            s += 'exp += struct.pack("<I", 0xdeadface) # sigframe.sc.esp\n'
            s += 'exp += struct.pack("<I", 0x2)        # sigframe.sc.ebx\n'
            s += 'exp += struct.pack("<I", 0x4)        # sigframe.sc.edx\n'
            s += 'exp += struct.pack("<I", 0x3)        # sigframe.sc.ecx\n'
            s += 'exp += struct.pack("<I", 0x1)        # sigframe.sc.eax\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.trapno\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.err\n'
            s += 'exp += struct.pack("<I", 0xdeadbeef) # sigframe.sc.eip\n'
            s += 'exp += struct.pack("<I", 0x23)       # sigframe.sc.cs # use 0x73 if 32bit native machine\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.eflags\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.esp_at_signal\n'
            s += 'exp += struct.pack("<I", 0x2b)       # sigframe.sc.ss # use 0x7b if 32bit native machine\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.fpstate # fpu/xmm are not restored if NULL\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.oldmask\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.sc.cr2\n'
            s += '\n'
        elif mode == "arm":
            s += 'exp += struct.pack("<I", pop_r7_pc)  # pop {r7, pc};\n'
            s += 'exp += struct.pack("<I", 119)        # r7 = 119 (sigreturn)\n'
            s += 'exp += struct.pack("<I", call_svc)   #\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_flags\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_link\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_stack.ss_sp\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_stack.ss_flags\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_stack.ss_size\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_mcontext.trapno\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_mcontext.error_code\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_mcontext.oldmask\n'
            s += 'exp += struct.pack("<I", 0x00)       # sigframe.uc.uc_mcontext.arm_r0\n'
            s += 'exp += struct.pack("<I", 0x01)       # sigframe.uc.uc_mcontext.arm_r1\n'
            s += 'exp += struct.pack("<I", 0x02)       # sigframe.uc.uc_mcontext.arm_r2\n'
            s += 'exp += struct.pack("<I", 0x03)       # sigframe.uc.uc_mcontext.arm_r3\n'
            s += 'exp += struct.pack("<I", 0x04)       # sigframe.uc.uc_mcontext.arm_r4\n'
            s += 'exp += struct.pack("<I", 0x05)       # sigframe.uc.uc_mcontext.arm_r5\n'
            s += 'exp += struct.pack("<I", 0x06)       # sigframe.uc.uc_mcontext.arm_r6\n'
            s += 'exp += struct.pack("<I", 0x07)       # sigframe.uc.uc_mcontext.arm_r7\n'
            s += 'exp += struct.pack("<I", 0x08)       # sigframe.uc.uc_mcontext.arm_r8\n'
            s += 'exp += struct.pack("<I", 0x09)       # sigframe.uc.uc_mcontext.arm_r9\n'
            s += 'exp += struct.pack("<I", 0x0a)       # sigframe.uc.uc_mcontext.arm_r10\n'
            s += 'exp += struct.pack("<I", 0x0b)       # sigframe.uc.uc_mcontext.arm_fp\n'
            s += 'exp += struct.pack("<I", 0x0c)       # sigframe.uc.uc_mcontext.arm_ip\n'
            s += 'exp += struct.pack("<I", 0xdeadface) # sigframe.uc.uc_mcontext.arm_sp\n'
            s += 'exp += struct.pack("<I", 0x0d)       # sigframe.uc.uc_mcontext.arm_lr\n'
            s += 'exp += struct.pack("<I", 0xdeadbeef) # sigframe.uc.uc_mcontext.arm_pc\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_mcontext.arm_cpsr\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_mcontext.fault_address\n'
            s += 'exp += struct.pack("<I", 0x0)        # sigframe.uc.uc_sigmask\n'
        elif mode == "aarch64":
            s += 'exp += struct.pack("<Q", ldp_x8_x9)  # ldp x8, x9, [sp], #16; ret x9;\n'
            s += 'exp += struct.pack("<Q", 139)        # x8 = 139\n'
            s += 'exp += struct.pack("<Q", call_svc)   # \n'
            s += 'exp += struct.pack("<I", 0x0)*32     # rt_sigframe.info\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_flags\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_link\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_stack.ss_sp\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_stack.ss_flags\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_stack.ss_size\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_stack.__unused\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_sigmask\n'
            s += 'exp += struct.pack("<B", 0x0)*120    # rt_sigframe.uc.__unused[120]\n'
            s += 'exp += struct.pack("<Q", 0x0)        # rt_sigframe.uc.uc_mcontext.fault_address\n'
            s += 'exp += struct.pack("<Q", 0x00)       # rt_sigframe.uc.uc_mcontext.regs[31].x0\n'
            s += 'exp += struct.pack("<Q", 0x01)       # rt_sigframe.uc.uc_mcontext.regs[31].x1\n'
            s += 'exp += struct.pack("<Q", 0x02)       # rt_sigframe.uc.uc_mcontext.regs[31].x2\n'
            s += 'exp += struct.pack("<Q", 0x03)       # rt_sigframe.uc.uc_mcontext.regs[31].x3\n'
            s += 'exp += struct.pack("<Q", 0x04)       # rt_sigframe.uc.uc_mcontext.regs[31].x4\n'
            s += 'exp += struct.pack("<Q", 0x05)       # rt_sigframe.uc.uc_mcontext.regs[31].x5\n'
            s += 'exp += struct.pack("<Q", 0x06)       # rt_sigframe.uc.uc_mcontext.regs[31].x6\n'
            s += 'exp += struct.pack("<Q", 0x07)       # rt_sigframe.uc.uc_mcontext.regs[31].x7\n'
            s += 'exp += struct.pack("<Q", 0x08)       # rt_sigframe.uc.uc_mcontext.regs[31].x8\n'
            s += 'exp += struct.pack("<Q", 0x09)       # rt_sigframe.uc.uc_mcontext.regs[31].x9\n'
            s += 'exp += struct.pack("<Q", 0x0a)       # rt_sigframe.uc.uc_mcontext.regs[31].x10\n'
            s += 'exp += struct.pack("<Q", 0x0b)       # rt_sigframe.uc.uc_mcontext.regs[31].x11\n'
            s += 'exp += struct.pack("<Q", 0x0c)       # rt_sigframe.uc.uc_mcontext.regs[31].x12\n'
            s += 'exp += struct.pack("<Q", 0x0d)       # rt_sigframe.uc.uc_mcontext.regs[31].x13\n'
            s += 'exp += struct.pack("<Q", 0x0e)       # rt_sigframe.uc.uc_mcontext.regs[31].x14\n'
            s += 'exp += struct.pack("<Q", 0x0f)       # rt_sigframe.uc.uc_mcontext.regs[31].x15\n'
            s += 'exp += struct.pack("<Q", 0x10)       # rt_sigframe.uc.uc_mcontext.regs[31].x16\n'
            s += 'exp += struct.pack("<Q", 0x11)       # rt_sigframe.uc.uc_mcontext.regs[31].x17\n'
            s += 'exp += struct.pack("<Q", 0x12)       # rt_sigframe.uc.uc_mcontext.regs[31].x18\n'
            s += 'exp += struct.pack("<Q", 0x13)       # rt_sigframe.uc.uc_mcontext.regs[31].x19\n'
            s += 'exp += struct.pack("<Q", 0x14)       # rt_sigframe.uc.uc_mcontext.regs[31].x20\n'
            s += 'exp += struct.pack("<Q", 0x15)       # rt_sigframe.uc.uc_mcontext.regs[31].x21\n'
            s += 'exp += struct.pack("<Q", 0x16)       # rt_sigframe.uc.uc_mcontext.regs[31].x22\n'
            s += 'exp += struct.pack("<Q", 0x17)       # rt_sigframe.uc.uc_mcontext.regs[31].x23\n'
            s += 'exp += struct.pack("<Q", 0x18)       # rt_sigframe.uc.uc_mcontext.regs[31].x24\n'
            s += 'exp += struct.pack("<Q", 0x19)       # rt_sigframe.uc.uc_mcontext.regs[31].x25\n'
            s += 'exp += struct.pack("<Q", 0x1a)       # rt_sigframe.uc.uc_mcontext.regs[31].x26\n'
            s += 'exp += struct.pack("<Q", 0x1b)       # rt_sigframe.uc.uc_mcontext.regs[31].x27\n'
            s += 'exp += struct.pack("<Q", 0x1c)       # rt_sigframe.uc.uc_mcontext.regs[31].x28\n'
            s += 'exp += struct.pack("<Q", 0x1d)       # rt_sigframe.uc.uc_mcontext.regs[31].x29\n'
            s += 'exp += struct.pack("<Q", 0x1e)       # rt_sigframe.uc.uc_mcontext.regs[31].x30\n'
            s += 'exp += struct.pack("<Q", 0xdeadface) # rt_sigframe.uc.uc_mcontext.sp\n'
            s += 'exp += struct.pack("<Q", 0xdeadbeef) # rt_sigframe.uc.uc_mcontext.pc\n'
            s += 'exp += struct.pack("<Q", 0x00)       # rt_sigframe.uc.uc_mcontext.pstate\n'
        gef_print(s.rstrip())
        return


@register_command
class Ret2dlHintCommand(GenericCommand):
    """Hint for ret2dl."""
    _cmdline_ = "ret2dl-hint"
    _syntax_ = "{:s}".format(_cmdline_)
    _category_ = "Exploit Development"

    def do_invoke(self, argv):
        self.dont_repeat()

        s = ""
        s += "  +---.got/.got.plt @ itself-------+\n"
        s += "  | GOT[0]: _DYNAMIC               |\n"
        s += "  | GOT[1]: link_map               |\n"
        s += "  | GOT[2]: _dl_runtime_resolve@ld |\n"
        s += "  | GOT[3]: func1                  |\n"
        s += "  | GOT[4]: func2                  |\n"
        s += "  | GOT[5]: func3                  |\n"
        s += "  | ...                            |\n"
        s += "  +--------------------------------+\n"
        s += "\n"
        s += "If `link_map` and `_dl_runtime_resolve` are non-zero, just use them.\n"
        s += "If they are zero, you have to resolve them from DT_DEBUG entry of _DYNAMIC.\n"
        s += "\n"
        s += "  +---_DYNAMIC @ itself------+     +---> +---r_debug--------+\n"
        s += "  | QWORD tag                |     |     | QWORD r_version  |\n"
        s += "  | QWORD value              |     |     | QWORD link_map   | <-- HERE\n"
        s += "  +--------------------------+     |     | QWORD r_brk      |\n"
        s += "  | ...                      |     |     | QWORD r_ldbase   |\n"
        s += "  +--------------------------+     |     +------------------+\n"
        s += "  | QWORD tag(0x15:DT_DEBUG) |     |\n"
        s += "  | QWORD value              |-----+\n"
        s += "  +--------------------------+\n"
        s += "\n"
        s += "  (binary itself)              (libc.so)                    (ld-linux.so)\n"
        s += "  +---link_map---+     +-----> +---link_map---+     +-----> +---link_map---+\n"
        s += "  | QWORD l_addr |     |       | QWORD l_addr |     |       | QWORD l_addr |\n"
        s += "  | QWORD l_name |     |       | QWORD l_name |     |       | QWORD l_name |\n"
        s += "  | QWORD l_ld   |     |       | QWORD l_ld   |---+ |       | QWORD l_ld   |\n"
        s += "  | QWORD l_next |-----+       | QWORD l_next |---|-+       | QWORD l_next |\n"
        s += "  | QWORD l_prev |             | QWORD l_prev |   |         | QWORD l_prev |\n"
        s += "  +--------------+             +--------------+   |         +--------------+\n"
        s += "                                                  |\n"
        s += "        +-----------------------------------------+\n"
        s += "        |\n"
        s += "        +--> +---_DYNAMIC @ libc--------+     +---> +---.got/.got.plt @ libc---------+\n"
        s += "             | QWORD tag                |     |     | GOT[0]: _DYNAMIC               |\n"
        s += "             | QWORD value              |     |     | GOT[1]: link_map               |\n"
        s += "             +--------------------------+     |     | GOT[2]: _dl_runtime_resolve@ld | <-- HERE\n"
        s += "             | ...                      |     |     | GOT[3]: func1                  |\n"
        s += "             +--------------------------+     |     | GOT[4]: func2                  |\n"
        s += "             | QWORD tag(0x3:DT_PLTGOT) |     |     | GOT[5]: func3                  |\n"
        s += "             | QWORD value              |-----+     | ...                            |\n"
        s += "             +--------------------------+           +--------------------------------+\n"
        s += "\n"
        s += "\n"
        s += "  _dl_runtime_resolve@.plt.got(link_map, reloc_arg)\n"
        s += "    -> _dl_fixup@ld(link_map, reloc_arg)\n"
        s += "                                   |\n"
        s += "                                   |\n"
        if is_32bit():
            s = s.replace("QWORD", "DWORD")
            s += "  +-------reloc_arg as offset------+\n"
            s += "  |\n"
            s += "  |      +---.rel.plt-----------------------+                           +---.dynsym----------+          +---.dynstr-------+\n"
            s += "  |      | DWORD r_offset                   |                           | DWORD st_name      |          | char[] symbol   |\n"
            s += "  |      | DWORD r_info                     |                           | DWORD st_value     |     +--->| char[] symbol   |\n"
            s += "  |      +----------------------------------+                           | DWORD st_size      |     |    | char[] symbol   |\n"
            s += "  +----> | DWORD r_offset(=writable area)   |   (r_info>>8) * 0x18      | BYTE  st_info      |     |    | char[] symbol   |\n"
            s += "         | DWORD r_info(=(dynsym_idx<<8)|7) |-------------+             | BYTE  st_other     |     |    | ...             |\n"
            s += "         +----------------------------------+             |             | WORD  st_shndx     |     |    +-----------------+\n"
            s += "         | ...                              |             +------------>+--------------------+     |\n"
            s += "         +----------------------------------+                           | DWORD st_name      |-----+\n"
            s += "                                                                        | DWORD st_value     |\n"
            s += "                                                                        | DWORD st_size      |\n"
            s += "                                                                        | BYTE  st_info      |\n"
            s += "                                                                        | BYTE  st_other(=0) |\n"
            s += "                                                                        | WORD  st_shndx     |\n"
            s += "                                                                        +--------------------+\n"
            s += "                                                                        | ...                |\n"
            s += "                                                                        +--------------------+\n"
        else:
            s += "  +---reloc_arg * 0x18 as offset---+\n"
            s += "  |\n"
            s += "  |      +---.rela.plt----------------------+                           +---.dynsym----------+          +---.dynstr-------+\n"
            s += "  |      | QWORD r_offset                   |                           | DWORD st_name      |          | char[] symbol   |\n"
            s += "  |      | QWORD r_info                     |                           | BYTE  st_info      |     +--->| char[] symbol   |\n"
            s += "  |      | QWORD r_addend                   |                           | BYTE  st_other     |     |    | char[] symbol   |\n"
            s += "  +----> +----------------------------------+                           | WORD  st_shndx     |     |    | char[] symbol   |\n"
            s += "         | QWORD r_offset(=writable area)   |   (r_info>>32) * 0x18     | QWORD st_value     |     |    | ...             |\n"
            s += "         | QWORD r_info(=(dynsym_idx<<32)|7)|-------------+             | QWORD st_size      |     |    +-----------------+\n"
            s += "         | QWORD r_addend                   |             +------------>+--------------------+     |\n"
            s += "         +----------------------------------+                           | DWORD st_name      |-----+\n"
            s += "         | ...                              |                           | BYTE  st_info      |\n"
            s += "         +----------------------------------+                           | BYTE  st_other(=0) |\n"
            s += "                                                                        | WORD  st_shndx     |\n"
            s += "                                                                        | QWORD st_value     |\n"
            s += "                                                                        | QWORD st_size      |\n"
            s += "                                                                        +--------------------+\n"
            s += "                                                                        | ...                |\n"
            s += "                                                                        +--------------------+\n"
        s += "\n"
        s += "Use `dynamic` and `linkmap` to display the structure.\n"
        gef_print(s.rstrip())
        return


@register_command
class LinkmapCommand(GenericCommand):
    """Dump link_map with iterating."""
    _cmdline_ = "linkmap"
    _syntax_ = "{:s} [-h] [-a LINK_MAP_ADDRESS]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} # dump itself\n".format(_cmdline_)
    _example_ += "{:s} -a 0x00007ffff7ffe190 # dump specified address".format(_cmdline_)
    _category_ = "Process Information"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    def dump_linkmap(self, link_map):
        section = process_lookup_address(link_map)
        info("link_map: {:#x} [{:s}]".format(link_map, str(section.permission)))

        current = link_map
        while True:
            addr = current
            l_addr = read_int_from_memory(current)
            current += current_arch.ptrsize
            l_name = read_int_from_memory(current)
            name = read_cstring_from_memory(l_name)
            current += current_arch.ptrsize
            l_ld = read_int_from_memory(current)
            current += current_arch.ptrsize
            l_next = read_int_from_memory(current)
            current += current_arch.ptrsize
            l_prev = read_int_from_memory(current)
            current += current_arch.ptrsize

            if not name:
                name = "(binary itself)"
            gef_print(titlify(name))
            if is_32bit():
                gef_print("{:#010x}:  {:#010x} {:#010x}  |  load_address, name".format(addr, l_addr, l_name))
                gef_print("{:#010x}:  {:#010x} {:#010x}  |  dynamic, next".format(addr + current_arch.ptrsize * 2, l_ld, l_next))
                gef_print("{:#010x}:  {:#010x} {:10s}  |  prev".format(addr + current_arch.ptrsize * 4, l_prev, ""))
            else:
                gef_print("{:#018x}:  {:#018x} {:#018x}  |  load_address, name".format(addr, l_addr, l_name))
                gef_print("{:#018x}:  {:#018x} {:#018x}  |  dynamic, next".format(addr + current_arch.ptrsize * 2, l_ld, l_next))
                gef_print("{:#018x}:  {:#018x} {:18s}  |  prev".format(addr + current_arch.ptrsize * 4, l_prev, ""))

            if l_next == 0:
                break
            current = l_next
        return

    @staticmethod
    def get_linkmap(filename, silent=False):
        current = dynamic = DynamicCommand.get_dynamic(filename, silent)
        while True:
            tag = read_int_from_memory(current)
            current += current_arch.ptrsize
            val = read_int_from_memory(current)
            current += current_arch.ptrsize
            if tag not in DynamicCommand.DT_TABLE:
                link_map = None
                if not silent:
                    info("Not found link_map")
                break
            if DynamicCommand.DT_TABLE[tag] == "DT_DEBUG":
                dt_debug = val
                val_addr = current - current_arch.ptrsize
                if not silent:
                    info("_DYNAMIC+{:#x}(=DT_DEBUG): {:#x} -> {:#x}".format(val_addr - dynamic, val_addr, dt_debug))
                link_map = read_int_from_memory(dt_debug + current_arch.ptrsize)
                if not silent:
                    info("DT_DEBUG+{:#x}: {:#x} -> {:#x}".format(current_arch.ptrsize, dt_debug + current_arch.ptrsize, link_map))
                break
        return link_map

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        filename = None
        link_map = None

        if "-a" in argv:
            try:
                idx = argv.index("-a")
                link_map = int(argv[idx + 1], 0)
                argv = argv[:idx] + argv[idx + 2:]
            except Exception:
                self.usage()
                return
        else:
            filename = get_filepath()

        if argv:
            self.usage()
            return

        if filename:
            if not os.path.exists(filename):
                err("{:s} is not found.".format(filename))
                return
            if is_static(filename):
                info("The binary is static build. There is no link_map.")
                return
            try:
                link_map = self.get_linkmap(filename)
            except Exception:
                err("Failed to get link_map.")
                return

        if link_map is None:
            info("link_map is 0.")
            return

        try:
            self.dump_linkmap(link_map)
        except Exception:
            err("Failed to parse.")
        return


@register_command
class DynamicCommand(GenericCommand):
    """Display current status of the _DYNAMIC area."""
    _cmdline_ = "dynamic"
    _syntax_ = "{:s} [-h] [-a DYNAMIC_ADDRESS|-f FILENAME]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} # dump itself\n".format(_cmdline_)
    _example_ += "{:s} -f /lib/x86_64-linux-gnu/libc-2.31.so # dump specified binary\n".format(_cmdline_)
    _example_ += "{:s} -a 0x403de0 # dump specified address".format(_cmdline_)
    _category_ = "Process Information"

    DT_TABLE = {
        0: "DT_NULL",
        1: "DT_NEEDED",
        2: "DT_PLTRELSZ",
        3: "DT_PLTGOT",
        4: "DT_HASH",
        5: "DT_STRTAB",
        6: "DT_SYMTAB",
        7: "DT_RELA",
        8: "DT_RELASZ",
        9: "DT_RELAENT",
        10: "DT_STRSZ",
        11: "DT_SYMENT",
        12: "DT_INIT",
        13: "DT_FINI",
        14: "DT_SONAME",
        15: "DT_RPATH",
        16: "DT_SYMBOLIC",
        17: "DT_REL",
        18: "DT_RELSZ",
        19: "DT_RELENT",
        20: "DT_PLTREL",
        21: "DT_DEBUG",
        22: "DT_TEXTREL",
        23: "DT_JMPREL",
        24: "DT_BIND_NOW",
        25: "DT_INIT_ARRAY",
        26: "DT_FINI_ARRAY",
        27: "DT_INIT_ARRAYSZ",
        28: "DT_FINI_ARRAYSZ",
        29: "DT_RUNPATH",
        30: "DT_FLAGS",
        #32: "DT_ENCODING", # unspecified
        32: "DT_PREINIT_ARRAY",
        33: "DT_PREINIT_ARRAYSZ",
        34: "DT_SYMTAB_SHNDX",
        35: "DT_RELRSZ",
        36: "DT_RELR",
        37: "DT_RELRENT",
        #0x6000000d: "DT_LOOS", # unspecified
        0x6000000e: "DT_SUNW_RTLDINF",
        0x6000000f: "DT_ANDROID_REL",
        0x60000010: "DT_ANDROID_RELSZ",
        0x60000011: "DT_ANDROID_RELA",
        0x60000012: "DT_ANDROID_RELASZ",
        0x6fffe000: "DT_ANDROID_RELR",
        0x6fffe001: "DT_ANDROID_RELRSZ",
        0x6fffe003: "DT_ANDROID_RELRENT",
        0x6fffe005: "DT_ANDROID_RELRCOUNT",
        #0x6ffff000: "DT_HIOS", # unspecified
        #0x6ffffd00: "DT_VALRNGLO", # unspecified
        0x6ffffdf5: "DT_GNU_PRELINKED",
        0x6ffffdf6: "DT_GNU_CONFLICTSZ",
        0x6ffffdf7: "DT_GNU_LIBLISTSZ",
        0x6ffffdf8: "DT_CHECKSUM",
        0x6ffffdf9: "DT_PLTPADSZ",
        0x6ffffdfa: "DT_MOVEENT",
        0x6ffffdfb: "DT_MOVESZ",
        0x6ffffdfc: "DT_FEATURE_1",
        0x6ffffdfd: "DT_POSFLAG_1",
        0x6ffffdfe: "DT_SYMINSZ",
        0x6ffffdff: "DT_SYMINENT",
        #0x6ffffdff: "DT_VALRNGHI", # unspecified
        #0x6ffffe00: "DT_ADDRRNGLO", # unspecified
        0x6ffffef5: "DT_GNU_HASH",
        0x6ffffef6: "DT_TLSDESC_PLT",
        0x6ffffef7: "DT_TLSDESC_GOT",
        0x6ffffef8: "DT_GNU_CONFLICT",
        0x6ffffef9: "DT_GNU_LIBLIST",
        0x6ffffefa: "DT_CONFIG",
        0x6ffffefb: "DT_DEPAUDIT",
        0x6ffffefc: "DT_AUDIT",
        0x6ffffefd: "DT_PLTPAD",
        0x6ffffefe: "DT_MOVETAB",
        0x6ffffeff: "DT_SYMINFO",
        #0x6ffffeff: "DT_ADDRRNGHI", # unspecified
        0x6ffffff0: "DT_VERSYM",
        0x6ffffff9: "DT_RELACOUNT",
        0x6ffffffa: "DT_RELCOUNT",
        0x6ffffffb: "DT_FLAGS_1",
        0x6ffffffc: "DT_VERDEF",
        0x6ffffffd: "DT_VERDEFNUM",
        0x6ffffffe: "DT_VERNEED",
        0x6fffffff: "DT_VERNEEDNUM",
        #0x70000000: "DT_LOPROC", # unspecified
        0x70000001: "DT_SPARC_REGISTER",
        0x7ffffffd: "DT_AUXILIARY",
        0x7ffffffe: "DT_USED",
        0x7fffffff: "DT_FILTER",
        #0x7fffffff: "DT_HIPROC", # unspecified
    }

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_FILENAME)
        return

    def dump_dynamic(self, dynamic):
        current = dynamic
        while True:
            addr = current
            tag = read_int_from_memory(current)
            current += current_arch.ptrsize
            val = read_int_from_memory(current)
            current += current_arch.ptrsize

            if tag not in self.DT_TABLE:
                break

            if is_32bit():
                gef_print("{:#010x}:  {:#010x} {:#010x}  |  tag:{:s}".format(addr, tag, val, self.DT_TABLE[tag]))
            else:
                gef_print("{:#018x}:  {:#018x} {:#018x}  |  tag:{:s}".format(addr, tag, val, self.DT_TABLE[tag]))
        return

    @staticmethod
    def get_dynamic(filename, silent=False):
        if not silent:
            info("filename: {:s}".format(filename))
        elf = Elf(filename)

        phdrs = [phdr for phdr in elf.phdrs if phdr.p_type == Phdr.PT_DYNAMIC]
        if len(phdrs) == 0:
            return None

        if is_pie(filename):
            load_base = get_section_base_address(filename)
            dynamic = phdrs[0].p_vaddr + load_base
        else:
            dynamic = phdrs[0].p_vaddr

        if not silent:
            section = process_lookup_address(dynamic)
            info("_DNYAMIC: {:#x} [{:s}]".format(dynamic, str(section.permission)))
        return dynamic

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        filename = None
        dynamic = None

        if "-a" in argv:
            try:
                idx = argv.index("-a")
                dynamic = int(argv[idx + 1], 0)
                argv = argv[:idx] + argv[idx + 2:]
            except Exception:
                self.usage()
                return
        elif "-f" in argv:
            try:
                idx = argv.index("-f")
                filename = argv[idx + 1]
                argv = argv[:idx] + argv[idx + 2:]
            except Exception:
                self.usage()
                return
        else:
            filename = get_filepath()

        if argv:
            self.usage()
            return

        if filename:
            if not os.path.exists(filename):
                err("{:s} is not found.".format(filename))
                return
            if is_static(filename):
                info("The binary is static build. There is no _DYNAMIC.")
                return
            if get_section_base_address(filename) is None:
                err("{:s} is not loeaded.".format(filename))
                return
            try:
                dynamic = self.get_dynamic(filename)
            except Exception:
                err("Failed to get _DYNAMIC.")
                return

        if dynamic is None:
            info("_DYNAMIC is not found.")
            return

        try:
            self.dump_dynamic(dynamic)
        except Exception:
            err("Failed to parse.")
        return


@register_command
class DestructorDumpCommand(GenericCommand):
    """Display registered destructor functions."""
    _cmdline_ = "dtor-dump"
    _syntax_ = _cmdline_
    _category_ = "Process Information"

    def ror(self, val, bits, arch_bits):
        new_val = (val >> bits) | (val << (arch_bits - bits))
        mask = (1 << arch_bits) - 1
        return new_val & mask

    def decode_function(self, fn):
        if is_x86_64():
            decoded_fn = self.ror(fn, 17, 64) ^ self.cookie
        elif is_x86_32():
            decoded_fn = self.ror(fn, 9, 32) ^ self.cookie
        elif is_arm32() or is_arm64():
            decoded_fn = fn ^ self.cookie
        return decoded_fn

    def perm(self, addr):
        try:
            return "[{:s}]".format(str(lookup_address(addr).section.permission))
        except Exception:
            return "[???]"

    def dump_tls_dtors(self):
        if not self.tls:
            err("TLS is not found")
            return

        if is_x86_64():
            head_p = self.tls - 0x60
        elif is_x86_32():
            head_p = self.tls - 0x3c
        elif is_arm32():
            head_p = self.tls + 0x20
        elif is_arm64():
            head_p = self.tls + 0x40

        current = head = read_int_from_memory(head_p)
        if head:
            fmt = "{:s}: {:#x}{:s}: {:#x}{:s}"
            gef_print(fmt.format("tls_dtor_list", head_p, self.perm(head_p), head, self.perm(head)))
        else:
            fmt = "{:s}: {:#x}{:s}: {:#x}"
            gef_print(fmt.format("tls_dtor_list", head_p, self.perm(head_p), head))

        ptrsize = current_arch.ptrsize

        def read_fns(addr):
            func = read_int_from_memory(current)
            obj = read_int_from_memory(current + ptrsize * 1)
            link_map = read_int_from_memory(current + ptrsize * 2)
            next_ = read_int_from_memory(current + ptrsize * 3)
            return func, obj, link_map, next_

        while current:
            try:
                func, obj, link_map, next_ = read_fns(current)
            except Exception:
                err("Memory access error at {:#x}".format(current))
                break

            decoded_fn = self.decode_function(func)
            sym = get_symbol_string(decoded_fn)
            decoded_fn_s = Color.boldify("{:#x}".format(decoded_fn))

            try:
                read_memory(decoded_fn, 1)
                valid_msg = Color.colorify("valid", "bold green")
            except gdb.MemoryError:
                valid_msg = Color.colorify("invalid", "bold red")

            fmt = "    -> func:     {:#x}{:s}: {:#x} (={:s}{:s}) [{:s}]"
            gef_print(fmt.format(current, self.perm(current), func, decoded_fn_s, sym, valid_msg))
            fmt = "       obj:      {:#x}{:s}: {:#x}"
            gef_print(fmt.format(current + ptrsize * 1, self.perm(current + ptrsize * 1), obj))
            fmt = "       link_map: {:#x}{:s}: {:#x}"
            gef_print(fmt.format(current + ptrsize * 2, self.perm(current + ptrsize * 2), link_map))
            fmt = "       next:     {:#x}{:s}: {:#x}"
            gef_print(fmt.format(current + ptrsize * 3, self.perm(current + ptrsize * 3), next_))
            current = next_
        return

    def dump_exit_funcs(self, name):
        try:
            head_p = parse_address("&" + name)
        except Exception:
            err("Not found symbol ({:s})".format(name))
            return

        current = head = read_int_from_memory(head_p)
        gef_print("{:s}: {:#x}{:s}: {:#x}{:s}".format(name, head_p, self.perm(head_p), head, self.perm(head)))
        if not current:
            return

        ptrsize = current_arch.ptrsize

        next_ = read_int_from_memory(current)
        idx = read_int_from_memory(current + ptrsize)
        current += ptrsize * 2
        gef_print("    -> next:  {:#x}{:s}: {:#x}".format(head + ptrsize * 0, self.perm(head + ptrsize * 0), next_))
        gef_print("       idx:   {:#x}{:s}: {:#x}".format(head + ptrsize * 1, self.perm(head + ptrsize * 1), idx))

        def read_fns(addr):
            flavor = read_int_from_memory(addr)
            fn = read_int_from_memory(addr + ptrsize * 1)
            arg = read_int_from_memory(addr + ptrsize * 2)
            dso_handle = read_int_from_memory(addr + ptrsize * 3)
            return flavor, fn, arg, dso_handle

        fns_size = ptrsize * 4 # flavor, fn, arg, dso_handle

        if is_32bit():
            mask = (1 << 32) - 1
        else:
            mask = (1 << 64) - 1

        for i in range(idx, -1, -1):
            addr = (current + fns_size * i) & mask
            try:
                flavor, fn, arg, dso_handle = read_fns(addr)
            except Exception:
                err("Memory access error at {:#x}".format(addr))
                break
            if fn == 0:
                continue
            decoded_fn = self.decode_function(fn)
            sym = get_symbol_string(decoded_fn)
            decoded_fn_s = Color.boldify("{:#x}".format(decoded_fn))

            try:
                read_memory(decoded_fn, 1)
                valid_msg = Color.colorify("valid", "bold green")
            except gdb.MemoryError:
                valid_msg = Color.colorify("invalid", "bold red")

            fns = "       fns[{:#x}]:{:#x}{:s}:".format(i, addr, self.perm(addr))
            gef_print("{} flavor:{:#x}".format(fns, flavor))
            gef_print("{} func:{:#x} (={:s}{:s}) [{:s}]".format(" " * len(fns), fn, decoded_fn_s, sym, valid_msg))
            gef_print("{} arg:{:#x}".format(" " * len(fns), arg))
            gef_print("{} dso_handle:{:#x}".format(" " * len(fns), dso_handle))
        return

    def yield_linkmap(self):
        link_map = LinkmapCommand.get_linkmap(get_filepath(), silent=True)
        while link_map:
            dic = {}
            dic["load_address"] = read_int_from_memory(link_map)
            name_ptr = read_int_from_memory(link_map + current_arch.ptrsize * 1)
            dic["name"] = dic["name_org"] = read_cstring_from_memory(name_ptr)
            if dic["name_org"] == "":
                dic["name"] = "{:s}".format(get_filepath())
            dic["dynamic"] = read_int_from_memory(link_map + current_arch.ptrsize * 2)
            dic["next"] = read_int_from_memory(link_map + current_arch.ptrsize * 3)
            yield dic
            link_map = dic["next"]

    def dump_sections_not_array(self, section_name):
        if not is_static(get_filepath()):
            for link_map in self.yield_linkmap():
                if not os.path.exists(link_map["name"]):
                    continue
                elf = Elf(link_map["name"])
                try:
                    shdr = [s for s in elf.shdrs if s.sh_name == section_name][0]
                except Exception:
                    continue
                if is_pie(link_map["name"]):
                    addr = shdr.sh_addr + link_map["load_address"]
                else:
                    addr = shdr.sh_addr
                gef_print(link_map["name"])
                sym = get_symbol_string(addr)
                func_s = Color.boldify("{:#x}".format(addr))
                gef_print("    -> {:s}{:s}".format(func_s, sym))
        else:
            elf = Elf(get_filepath())
            try:
                shdr = [s for s in elf.shdrs if s.sh_name == section_name][0]
            except Exception:
                err("Not found {:s} section".format(section_name))
                return
            addr = shdr.sh_addr
            gef_print(get_filepath())
            sym = get_symbol_string(addr)
            func_s = Color.boldify("{:#x}".format(addr))
            gef_print("    -> {:s}{:s}".format(func_s, sym))
        return

    def dump_sections(self, section_name):
        if not is_static(get_filepath()):
            for link_map in self.yield_linkmap():
                if not os.path.exists(link_map["name"]):
                    continue
                elf = Elf(link_map["name"])
                try:
                    shdr = [s for s in elf.shdrs if s.sh_name == section_name][0]
                except Exception:
                    continue
                entries = []
                for i in range(shdr.sh_size // current_arch.ptrsize):
                    if is_pie(link_map["name"]):
                        addr = shdr.sh_addr + link_map["load_address"] + current_arch.ptrsize * i
                    else:
                        addr = shdr.sh_addr + current_arch.ptrsize * i
                    func = read_int_from_memory(addr)
                    if is_32bit() and func in [0, 0xffffffff]:
                        continue
                    if is_64bit() and func in [0, 0xffffffffffffffff]:
                        continue
                    entries.append([addr, func])
                if not entries:
                    continue
                gef_print(link_map["name"])
                for addr, func in entries:
                    sym = get_symbol_string(func)
                    func_s = Color.boldify("{:#x}".format(func))
                    gef_print("    -> {:#x}{:s}: {:s}{:s}".format(addr, self.perm(addr), func_s, sym))
        else:
            elf = Elf(get_filepath())
            try:
                shdr = [s for s in elf.shdrs if s.sh_name == section_name][0]
            except Exception:
                err("Not found {:s} section".format(section_name))
                return
            entries = []
            for i in range(shdr.sh_size // current_arch.ptrsize):
                addr = shdr.sh_addr + current_arch.ptrsize * i
                func = read_int_from_memory(addr)
                if is_32bit() and func in [0, 0xffffffff]:
                    continue
                if is_64bit() and func in [0, 0xffffffffffffffff]:
                    continue
                entries.append([addr, func])
            if not entries:
                err("Not found valid entry")
                return
            gef_print(get_filepath())
            for addr, func in entries:
                sym = get_symbol_string(func)
                func_s = Color.boldify("{:#x}".format(func))
                gef_print("    -> {:#x}{:s}: {:s}{:s}".format(addr, self.perm(addr), func_s, sym))
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64", "ARM32", "ARM64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        # init
        if is_x86_64():
            self.tls = TlsCommand.getfs()
            self.cookie = read_int_from_memory(self.tls + 0x30)
        elif is_x86_32():
            self.tls = TlsCommand.getgs()
            self.cookie = read_int_from_memory(self.tls + 0x18)
        elif is_arm32() or is_arm64():
            if is_arm32():
                try:
                    self.tls = parse_address("(unsigned int)__aeabi_read_tp()")
                except Exception:
                    err("Not found symbol (__aeabi_read_tp)")
                    return
            else:
                try:
                    self.tls = get_register("$TPIDR_EL0")
                except Exception:
                    err("Fail reading $TPIDR_EL0 register")
                    return
            try:
                cookie_ptr = parse_address("&__pointer_chk_guard_local")
            except Exception:
                err("Not found symbol (__pointer_chk_guard_local)")
                return
            self.cookie = read_int_from_memory(cookie_ptr)

        # dump
        gef_print(titlify("tls_dtor_list: registered by __cxa_thread_atexit_impl()"))
        self.dump_tls_dtors()

        gef_print(titlify("__exit_funcs: registered by atexit(), on_exit()"))
        self.dump_exit_funcs("__exit_funcs")

        gef_print(titlify("__quick_exit_funcs: registered by at_quick_exit()"))
        self.dump_exit_funcs("__quick_exit_funcs")

        gef_print(titlify(".fini_array"))
        self.dump_sections(".fini_array")

        gef_print(titlify(".fini"))
        self.dump_sections_not_array(".fini")

        gef_print(titlify(".dtors"))
        self.dump_sections(".dtors")

        gef_print(titlify("__libc_atexit"))
        self.dump_sections("__libc_atexit")
        return


@register_command
class GotCommand(GenericCommand):
    """Display current status of the got/plt inside the process."""
    _cmdline_ = "got"
    _syntax_ = "{:s} [-h] [-f FILE_NAME] [-a LOADED_BASE_ADDRESS] [FILTER, ...] ".format(_cmdline_)
    _example_ = "{:s} read print # filter specified keyword\n".format(_cmdline_)
    _example_ += "{:s} -f /usr/lib/x86_64-linux-gnu/libc.so.6 # target the library's GOT\n".format(_cmdline_)
    _example_ += "{:s} -f /bin/ls -a 0x4000000000 # use specified address, it is useful under qemu".format(_cmdline_)
    _category_ = "Process Information"
    _aliases_ = ["plt"]

    def __init__(self, *args, **kwargs):
        super().__init__(complete=gdb.COMPLETE_FILENAME)
        self.add_setting("function_resolved", "green", "Line color of the got command output if the function has been resolved")
        self.add_setting("function_not_resolved", "yellow", "Line color of the got command output if the function has not been resolved")
        return

    def get_base_address(self):
        @functools.lru_cache()
        def get_base_address_from_vmmap(filename_vmmap):
            vmmap = get_process_maps()
            try:
                return min([x.page_start for x in vmmap if x.path == filename_vmmap])
            except Exception:
                # not found
                return None

        if self.base_address_hint:
            return self.base_address_hint
        # getting vmmap to understand the boundaries of the binary
        # we will use this info to understand if a function has been resolved or not.
        return get_base_address_from_vmmap(self.filename_vmmap)

    def get_jmp_slots(self):
        try:
            cmd = [self.readelf, "--relocs", "--wide", self.filename]
            lines = gef_execute_external(cmd, as_list=True)
        except Exception:
            lines = []

        output = {}
        section_name = None
        reloc_count = 0
        for line in lines:
            # get section
            r = re.findall("Relocation section '(.+?)' ", line)
            if r:
                section_name = r[0]
                continue

            # GOT entry pattern 1
            if "JUMP_SLOT" in line:
                type = "JUMP_SLOT"
                address, _, _, _, name = line.split()[:5]
                address = int(address, 16)
                name = name.split("@")[0]
            # GOT entry pattern 2 (?)
            elif 'GLOB_DAT' in line:
                type = "GLOB_DAT"
                address, _, _, _, name = line.split()[:5]
                address = int(address, 16)
                name = name.split("@")[0]
            # GOT entry pattern 3 (?)
            elif "IRELATIVE" in line:
                type = "IRELATIVE"
                if is_x86_32():
                    address = line.split()[0]
                    address = int(address, 16)
                    name = "*ABS*"
                else:
                    address, _, _, addend = line.split()[:4]
                    address = int(address, 16)
                    name = "*ABS*+{:#x}".format(int(addend, 16))
            # Not GOT entry
            else:
                continue

            # count up reloc_arg
            if section_name in [".rel.plt", ".rela.plt"] and not checksec(self.filename)["Static"]:
                reloc_arg = reloc_count * [1, 8][is_x86_32()]
                reloc_count += 1
            else:
                reloc_arg = None

            # fix address
            if checksec(self.filename)["PIE"]:
                address += self.get_base_address()

            # save
            array = output.get(type, [])
            output[type] = array + [[address, name, section_name, type, reloc_arg]]

        # flatten
        a = output.get("JUMP_SLOT", [])
        b = output.get("IRELATIVE", [])
        c = output.get("GLOB_DAT", [])
        return a + b + c

    def get_plt_addresses(self):
        try:
            cmd = [self.objdump, "-j", ".plt", "-j", ".plt.sec", "-j", ".plt.got", "-d", self.filename]
            lines = gef_execute_external(cmd, as_list=True)
        except Exception:
            lines = []

        output = {}
        for line in lines:
            # get function name
            r = re.findall(r"^([0-9a-f]+) <(.+)@plt>:", line)
            if not r:
                continue
            address, func_name = int(r[0][0], 16), r[0][1]

            # fix addreess
            if checksec(self.filename)["PIE"]:
                address += self.get_base_address()

            # save
            # Since DT_REL (used at i386) has no r_addend, the information of identification does not exist.
            # So there are multiple "*ABS*" entries, keep them in a list.
            array = output.get(func_name, [])
            output[func_name] = array + [address]

        return output

    @functools.lru_cache()
    def get_elf(self):
        return Elf(self.filename)

    def get_plt_range(self):
        # The PLT range is required to determine whether the information in the GOT is resolved or not.
        elf = self.get_elf()
        sections = [x for x in elf.shdrs if x.sh_name in [".plt", ".plt.got", ".plt.sec"]]
        if len(sections) == 0:
            return 0, 0
        plt_begin = min([x.sh_addr for x in sections])
        plt_end = max([x.sh_addr + x.sh_size for x in sections])

        # fix address
        if checksec(self.filename)["PIE"]:
            plt_begin += self.get_base_address()
            plt_end += self.get_base_address()

        return plt_begin, plt_end

    def perm(self, addr):
        try:
            return "[{:s}]".format(str(lookup_address(addr).section.permission))
        except Exception:
            return "[???]"

    def get_section_name(self, addr):
        @functools.lru_cache()
        def get_shdr_range():
            elf = self.get_elf()
            ranges = []
            for shdr in elf.shdrs:
                sh_start = shdr.sh_addr
                sh_end = shdr.sh_addr + shdr.sh_size
                if checksec(self.filename)["PIE"]:
                    sh_start += self.get_base_address()
                    sh_end += self.get_base_address()
                ranges.append([shdr.sh_name, sh_start, sh_end])
            return ranges

        ranges = get_shdr_range()
        for name, start, end in ranges:
            if start <= addr < end:
                return name
        else:
            return "???"

    def get_section_sym(self, addr):
        @functools.lru_cache()
        def get_shdr_range():
            elf = self.get_elf()
            ranges = []
            for shdr in elf.shdrs:
                sh_start = shdr.sh_addr
                sh_end = shdr.sh_addr + shdr.sh_size
                if checksec(self.filename)["PIE"]:
                    sh_start += self.get_base_address()
                    sh_end += self.get_base_address()
                ranges.append([shdr.sh_name, sh_start, sh_end])
            return ranges

        ranges = get_shdr_range()
        for name, start, end in ranges:
            if start <= addr < end:
                return " <{:s}+{:#x}>".format(name, addr - start)
        else:
            return ""

    def print_plt_got(self):
        # retrieve base address
        base_address = self.get_base_address()
        if base_address is None:
            err("Not found {:s} in memory".format(self.filename_vmmap))
            return

        # retrieve jump slots using readelf
        jmpslots = self.get_jmp_slots()

        # retrieve plt address using objdump
        plts = self.get_plt_addresses()

        # retrieve the end of plt from elf parsing
        plt_begin, plt_end = self.get_plt_range()

        # print legend
        gef_print(titlify("{:s}".format(self.filename)))
        fmt = "{:>9s} {:s} {:>14s} @ {:12s} ({:>8s}) {:>9s} {:s} {:>14s} @ {:12s} ({:>8s}) {:s}"
        legend = [
            "TYPE", VERTICAL_LINE,
            "PLT", "Section", "Offset", "reloc_arg", VERTICAL_LINE,
            "GOT", "Section", "Offset", "Symbol -> GOTvalue",
        ]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))

        # link each PLT entries and each GOT entries
        # and create lines for output
        resolved_info = []
        for got_address, name, section_name, type, reloc_arg in jmpslots:
            # resolve PLT from GOT name
            if section_name != ".rel.plt" and name == "*ABS*": # i386 special case
                plt_address = []
            else: # in many other case
                plt_address = plts.get(name, [])
            if plt_address:
                plt_address = plt_address.pop(0)

            # resolve offset from absolute address
            got_offset = got_address - base_address
            if plt_address:
                plt_offset = plt_address - base_address

            # read the address of the function
            try:
                got_value = read_int_from_memory(got_address)
            except gdb.error:
                err("Memory access error")
                return

            # resolve got value's symbol
            if got_value == 0:
                got_value_sym = ""
            elif plt_begin <= got_value < plt_end: # Non-PIE
                got_value_sym = self.get_section_sym(got_value)
            elif plt_begin - base_address <= got_value < plt_end - base_address: # PIE
                got_value_sym = self.get_section_sym(got_value)
            else:
                got_value_sym = get_symbol_string(got_value)

            # different colors if the function has been resolved or not
            if got_value == 0:
                color = self.get_setting("function_resolved") # something is wrong
            elif plt_begin <= got_value < plt_end: # Non-PIE
                color = self.get_setting("function_not_resolved") # function hasn't already been resolved
            elif plt_begin - base_address <= got_value < plt_end - base_address: # PIE
                color = self.get_setting("function_not_resolved") # function hasn't already been resolved
            else:
                color = self.get_setting("function_resolved") # function has already been resolved

            # reloc_arg
            if reloc_arg is None:
                reloc_arg_info = "{:>9s}".format("-")
            else:
                reloc_arg_info = "{:#9x}".format(reloc_arg)

            # make plt info
            if plt_address:
                plt_section = self.get_section_name(plt_address) + self.perm(plt_address)
                plt_info = "{:#14x} @{:13s} ({:#8x}) {:9s}".format(plt_address, plt_section, plt_offset, reloc_arg_info)
            else:
                plt_info = "{:>14s}  {:13s}  {:>8s}  {:9s}".format("Not found", "", "", reloc_arg_info)

            # make got info
            got_section = self.get_section_name(got_address) + self.perm(got_address)
            got_value_c = Color.colorify("{:s} {:s} {:#x}{:s}".format(name, RIGHT_ARROW, got_value, got_value_sym), color)
            got_info = "{:#14x} @{:13s} ({:#8x}) {:s}".format(got_address, got_section, got_offset, got_value_c)

            # make line
            line = "{:>9s} {:s} {:s} {:s} {:s}".format(type, VERTICAL_LINE, plt_info, VERTICAL_LINE, got_info)

            # save
            resolved_info.append([got_address, section_name, line])

        # sort by GOT address
        resolved_info = sorted(resolved_info)

        # print
        prev_section = None
        for got_address, section_name, line in sorted(resolved_info):
            # print section name
            if prev_section != section_name:
                gef_print(titlify(section_name))
            prev_section = section_name
            # if we have a filter let's skip the entries that are not requested
            if self.filter:
                if not any([pattern in line for pattern in self.filter]):
                    continue
            gef_print(line)
        return

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        # setup readelf/objdump
        try:
            self.readelf = which("readelf")
            self.objdump = which("objdump")
        except FileNotFoundError as e:
            err("{}".format(e))
            return

        # get filename
        if "-f" in argv:
            # use specified file
            idx = argv.index("-f")
            self.filename_vmmap = self.filename = argv[idx + 1]
            argv = argv[:idx] + argv[idx + 2:]
        else:
            # use main binary
            self.filename = get_filepath() # /proc/<PID>/root/path/to/binary if another mnt namespace
            self.filename_vmmap = get_filepath(for_vmmap=True)
            if self.filename is None:
                err("Missing info about architecture. Please set: `file /path/to/target_binary`")
                return
        if not os.path.exists(self.filename):
            err("{:s} does not exist".format(self.filename))
            return

        # get base address
        self.base_address_hint = None
        if "-a" in argv:
            idx = argv.index("-a")
            self.base_address_hint = int(argv[idx + 1], 0)
            argv = argv[:idx] + argv[idx + 2:]

        # get the filtering parameter
        self.filter = []
        if argv:
            self.filter = argv

        # doit
        self.print_plt_got()
        return


@register_command
class HighlightCommand(GenericCommand):
    """This command highlights user defined text matches which modifies GEF output universally."""
    _cmdline_ = "highlight"
    _syntax_ = "{:s} (add|remove|list|clear)".format(_cmdline_)
    _category_ = "GEF Maintenance Command"

    def __init__(self):
        super().__init__(prefix=True)
        self.add_setting("regex", False, "Enable regex highlighting")
        return

    def do_invoke(self, argv):
        self.dont_repeat()
        self.usage()
        return


@register_command
class HighlightListCommand(GenericCommand):
    """Show the current highlight table with matches to colors."""
    _cmdline_ = "highlight list"
    _aliases_ = ["highlight ls"]
    _syntax_ = _cmdline_
    _category_ = "GEF Maintenance Command"

    def print_highlight_table(self):
        if not highlight_table:
            err("no matches found")
            return

        left_pad = max(map(len, highlight_table.keys()))
        for match, color in sorted(highlight_table.items()):
            gef_print("{} {} {}".format(Color.colorify(match.ljust(left_pad), color), VERTICAL_LINE, Color.colorify(color, color)))
        return

    def do_invoke(self, argv):
        self.dont_repeat()
        self.print_highlight_table()
        return


@register_command
class HighlightClearCommand(GenericCommand):
    """Clear the highlight table, remove all matches."""
    _cmdline_ = "highlight clear"
    _aliases_ = ["highlight reset"]
    _syntax_ = _cmdline_
    _category_ = "GEF Maintenance Command"

    def do_invoke(self, argv):
        self.dont_repeat()
        highlight_table.clear()
        return


@register_command
class HighlightAddCommand(GenericCommand):
    """Add a match to the highlight table."""
    _cmdline_ = "highlight add"
    _syntax_ = "{:s} MATCH COLOR".format(_cmdline_)
    _aliases_ = ["highlight set"]
    _example_ = "{:s} \"call   rcx\" yellow bold\n".format(_cmdline_)
    _example_ += "use config `gef config highlight.regex true` if need regex"
    _category_ = "GEF Maintenance Command"

    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) < 2:
            self.usage()
            return

        match, color = argv[0], ' '.join(argv[1:])
        highlight_table[match] = color
        return


@register_command
class HighlightRemoveCommand(GenericCommand):
    """Remove a match in the highlight table."""
    _cmdline_ = "highlight remove"
    _syntax_ = "{:s} MATCH".format(_cmdline_)
    _aliases_ = ["highlight del", "highlight unset", "highlight rm"]
    _example_ = "{:s} \"call   rcx\"".format(_cmdline_)
    _category_ = "GEF Maintenance Command"

    def do_invoke(self, argv):
        self.dont_repeat()

        if not argv:
            self.usage()
            return

        highlight_table.pop(argv[0], None)
        return


@register_command
class FormatStringSearchCommand(GenericCommand):
    """Exploitable format-string helper: this command will set up specific breakpoints
    at well-known dangerous functions (printf, snprintf, etc.), and check if the pointer
    holding the format string is writable, and therefore susceptible to format string
    attacks if an attacker can control its content."""
    _cmdline_ = "format-string-helper"
    _syntax_ = _cmdline_
    _aliases_ = ["fmtstr-helper"]
    _category_ = "Debugging Support"

    def do_invoke(self, argv):
        self.dont_repeat()

        dangerous_functions = {
            "printf": 0,
            "sprintf": 1,
            "fprintf": 1,
            "snprintf": 2,
            "vsnprintf": 3,
            "dprintf": 1,
            "vprintf": 1,
            "vfprintf": 2,
            "vdprintf": 2,
            "vsprintf": 2
        }

        enable_redirect_output("/dev/null")

        for func_name, num_arg in dangerous_functions.items():
            FormatStringBreakpoint(func_name, num_arg)

        disable_redirect_output()
        ok("Enabled {:d} FormatStringBreakpoint".format(len(dangerous_functions)))
        return


@register_command
class HeapAnalysisCommand(GenericCommand):
    """Heap vulnerability analysis helper: this command aims to track dynamic heap allocation
    done through malloc()/free() to provide some insights on possible heap vulnerabilities. The
    following vulnerabilities are checked:
    - NULL free
    - Use-after-Free
    - Double Free
    - Heap overlap"""
    _cmdline_ = "heap-analysis-helper"
    _syntax_ = "{:s} [show]".format(_cmdline_)
    _category_ = "Heap"

    def __init__(self, *args, **kwargs):
        super().__init__()
        self.add_setting("check_free_null", False, "Break execution when a free(NULL) is encountered")
        self.add_setting("check_double_free", True, "Break execution when a double free is encountered")
        self.add_setting("check_weird_free", True, "Break execution when free() is called against a non-tracked pointer")
        self.add_setting("check_uaf", True, "Break execution when a possible Use-after-Free condition is found")
        self.add_setting("check_heap_overlap", True, "Break execution when a possible overlap in allocation is found")
        self.bp_malloc = None
        self.bp_calloc = None
        self.bp_free = None
        self.bp_realloc = None
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    @experimental_feature
    def do_invoke(self, argv):
        self.dont_repeat()

        if not argv:
            self.setup()
        elif argv[0] == "show":
            self.dump_tracked_allocations()
        else:
            self.usage()
        return

    def setup(self):
        ok("Tracking malloc() & calloc()")
        self.bp_malloc = TraceMallocBreakpoint("__libc_malloc")
        self.bp_calloc = TraceMallocBreakpoint("__libc_calloc")
        ok("Tracking free()")
        self.bp_free = TraceFreeBreakpoint()
        ok("Tracking realloc()")
        self.bp_realloc = TraceReallocBreakpoint()

        ok("Disabling hardware watchpoints (this may increase the latency)")
        gdb.execute("set can-use-hw-watchpoints 0")

        info("Dynamic breakpoints correctly setup, GEF will break execution if a possible vulnerabity is found.")
        warn("{}: The heap analysis slows down the execution noticeably.".format(
            Color.colorify("Note", "bold underline yellow")))

        # when inferior quits, we need to clean everything for a next execution
        gef_on_exit_hook(self.clean)
        return

    def dump_tracked_allocations(self):
        global __heap_allocated_list__, __heap_freed_list__, __heap_uaf_watchpoints__

        if __heap_allocated_list__:
            ok("Tracked as in-use chunks:")
            for addr, sz in __heap_allocated_list__:
                gef_print("{:#x} = malloc({:d})".format(addr, sz))
        else:
            ok("No malloc() chunk tracked")

        if __heap_freed_list__:
            ok("Tracked as free-ed chunks:")
            for addr, sz in __heap_freed_list__:
                gef_print("free({:#x})".format(addr))
        else:
            ok("No free() chunk tracked")
        return

    def clean(self, event):
        global __heap_allocated_list__, __heap_freed_list__, __heap_uaf_watchpoints__

        ok("{} - Cleaning up".format(Color.colorify("Heap-Analysis", "yellow bold"),))
        for bp in [self.bp_malloc, self.bp_calloc, self.bp_free, self.bp_realloc]:
            if hasattr(bp, "retbp") and bp.retbp:
                try:
                    bp.retbp.delete()
                except RuntimeError:
                    # in some cases, gdb was found failing to correctly remove the retbp
                    # but they can be safely ignored since the debugging session is over
                    pass

            bp.delete()

        for wp in __heap_uaf_watchpoints__:
            wp.delete()

        __heap_allocated_list__ = []
        __heap_freed_list__ = []
        __heap_uaf_watchpoints__ = []

        ok("{} - Re-enabling hardware watchpoints".format(Color.colorify("Heap-Analysis", "yellow bold"),))
        gdb.execute("set can-use-hw-watchpoints 1")

        gef_on_exit_unhook(self.clean)
        return


@register_command
class SyscallSearchCommand(GenericCommand):
    """Search the syscall number"""
    _cmdline_ = "syscall-search"
    _syntax_ = "{:s} [-h] [-v] [-a ARCH] [-m MODE] SYSCALL_NAME_REGEX_SEARCH_PATTERN|SYSCALL_NUM".format(_cmdline_)
    _example_ = "\n"
    _example_ += '{:s} -a X86 -m 64        "^writev?" # amd64\n'.format(_cmdline_)
    _example_ += '{:s} -a X86 -m 32        "^writev?" # i386 on amd64\n'.format(_cmdline_)
    _example_ += '{:s} -a X86 -m N32       "^writev?" # i386 native\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM64            "^writev?" # arm64\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM -m 32        "^writev?" # arm32 on arm64\n'.format(_cmdline_)
    _example_ += '{:s} -a ARM -m N32       "^writev?" # arm32 native\n'.format(_cmdline_)
    _example_ += '{:s} -a MIPS -m MIPS32   "^writev?" # mips32\n'.format(_cmdline_)
    _example_ += '{:s} -a MIPS -m MIPS64   "^writev?" # mips64\n'.format(_cmdline_)
    _example_ += '{:s} -a PPC -m PPC32     "^writev?" # ppc32\n'.format(_cmdline_)
    _example_ += '{:s} -a PPC -m PPC64     "^writev?" # ppc64\n'.format(_cmdline_)
    _example_ += '{:s} -a SPARC -m SPARC32 "^writev?" # sparc32\n'.format(_cmdline_)
    _example_ += '{:s} -a SPARC -m SPARC64 "^writev?" # sparc64'.format(_cmdline_)
    _category_ = "Misc"

    def print_legend(self):
        if self.verbose:
            headers = ["NR", "Name", "Parameter"]
            gef_print(Color.colorify("{:<25} {:<25} {}".format(*headers), get_gef_setting("theme.table_heading")))
        else:
            headers = ["NR", "Name"]
            gef_print(Color.colorify("{:<25} {:<25}".format(*headers), get_gef_setting("theme.table_heading")))
        return

    def print_syscall(self, syscall_table, syscall_num, syscall_name_pattern):
        gef_print(Color.colorify("{:<17}{:s}".format("Syscall-num", "Syscall-name"), get_gef_setting("theme.table_heading")))
        for key, entry in syscall_table.items():
            if key in ["arch", "mode"]:
                continue
            nr = key
            if not re.search(syscall_name_pattern, entry.name):
                continue
            if syscall_num is not None and nr != syscall_num:
                continue
            params = ""
            if self.verbose:
                params = "(" + ', '.join([param.param for param in entry.params]) + ");"
            gef_print("NR={:<#14x}{:s}{:s}".format(nr, Color.boldify(entry.name), params))
        return

    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        self.verbose = False
        if "-v" in argv:
            self.verbose = True
            argv.remove("-v")

        try:
            arch = None
            if "-a" in argv:
                idx = argv.index("-a")
                arch = argv[idx + 1]
                argv = argv[:idx] + argv[idx + 2:]
        except Exception:
            self.usage()
            return

        try:
            mode = None
            if "-m" in argv:
                idx = argv.index("-m")
                mode = argv[idx + 1]
                argv = argv[:idx] + argv[idx + 2:]
        except Exception:
            self.usage()
            return

        syscall_num = None
        syscall_name_pattern = ".*"

        if len(argv) > 0:
            try:
                syscall_num = int(argv[0], 0)
            except ValueError:
                syscall_name_pattern = argv[0]

        try:
            syscall_table = get_syscall_table(arch, mode)
        except Exception:
            self.usage()
            return

        self.print_syscall(syscall_table, syscall_num, syscall_name_pattern)
        return


# System call table (linux-6.0.10)

# [How to make]
# clang-format-14 --style='{BasedOnStyle: Google, ColumnLimit: 1000}' FILENAME | grep ^asmlinkage
#   `!` at the beginning of the line: manually fixed the argument information
#   `#` at the beginning of the line: excluded for reasons such as duplication

# include/linux/syscalls.h
syscall_defs = """
asmlinkage long sys_io_setup(unsigned nr_reqs, aio_context_t __user *ctx);
asmlinkage long sys_io_destroy(aio_context_t ctx);
!asmlinkage long sys_io_submit(aio_context_t ctx_id, long nr, struct iocb __user * __user *iocbpp);
asmlinkage long sys_io_cancel(aio_context_t ctx_id, struct iocb __user *iocb, struct io_event __user *result);
asmlinkage long sys_io_getevents(aio_context_t ctx_id, long min_nr, long nr, struct io_event __user *events, struct __kernel_timespec __user *timeout);
asmlinkage long sys_io_getevents_time32(__u32 ctx_id, __s32 min_nr, __s32 nr, struct io_event __user *events, struct old_timespec32 __user *timeout);
asmlinkage long sys_io_pgetevents(aio_context_t ctx_id, long min_nr, long nr, struct io_event __user *events, struct __kernel_timespec __user *timeout, const struct __aio_sigset *sig);
asmlinkage long sys_io_pgetevents_time32(aio_context_t ctx_id, long min_nr, long nr, struct io_event __user *events, struct old_timespec32 __user *timeout, const struct __aio_sigset *sig);
asmlinkage long sys_io_uring_setup(u32 entries, struct io_uring_params __user *p);
asmlinkage long sys_io_uring_enter(unsigned int fd, u32 to_submit, u32 min_complete, u32 flags, const void __user *argp, size_t argsz);
asmlinkage long sys_io_uring_register(unsigned int fd, unsigned int op, void __user *arg, unsigned int nr_args);
asmlinkage long sys_setxattr(const char __user *path, const char __user *name, const void __user *value, size_t size, int flags);
asmlinkage long sys_lsetxattr(const char __user *path, const char __user *name, const void __user *value, size_t size, int flags);
asmlinkage long sys_fsetxattr(int fd, const char __user *name, const void __user *value, size_t size, int flags);
asmlinkage long sys_getxattr(const char __user *path, const char __user *name, void __user *value, size_t size);
asmlinkage long sys_lgetxattr(const char __user *path, const char __user *name, void __user *value, size_t size);
asmlinkage long sys_fgetxattr(int fd, const char __user *name, void __user *value, size_t size);
asmlinkage long sys_listxattr(const char __user *path, char __user *list, size_t size);
asmlinkage long sys_llistxattr(const char __user *path, char __user *list, size_t size);
asmlinkage long sys_flistxattr(int fd, char __user *list, size_t size);
asmlinkage long sys_removexattr(const char __user *path, const char __user *name);
asmlinkage long sys_lremovexattr(const char __user *path, const char __user *name);
asmlinkage long sys_fremovexattr(int fd, const char __user *name);
asmlinkage long sys_getcwd(char __user *buf, unsigned long size);
asmlinkage long sys_lookup_dcookie(u64 cookie64, char __user *buf, size_t len);
asmlinkage long sys_eventfd2(unsigned int count, int flags);
asmlinkage long sys_epoll_create1(int flags);
asmlinkage long sys_epoll_ctl(int epfd, int op, int fd, struct epoll_event __user *event);
asmlinkage long sys_epoll_pwait(int epfd, struct epoll_event __user *events, int maxevents, int timeout, const sigset_t __user *sigmask, size_t sigsetsize);
asmlinkage long sys_epoll_pwait2(int epfd, struct epoll_event __user *events, int maxevents, const struct __kernel_timespec __user *timeout, const sigset_t __user *sigmask, size_t sigsetsize);
asmlinkage long sys_dup(unsigned int fildes);
asmlinkage long sys_dup3(unsigned int oldfd, unsigned int newfd, int flags);
asmlinkage long sys_fcntl(unsigned int fd, unsigned int cmd, unsigned long arg);
asmlinkage long sys_fcntl64(unsigned int fd, unsigned int cmd, unsigned long arg);
asmlinkage long sys_inotify_init1(int flags);
asmlinkage long sys_inotify_add_watch(int fd, const char __user *path, u32 mask);
asmlinkage long sys_inotify_rm_watch(int fd, __s32 wd);
asmlinkage long sys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg);
asmlinkage long sys_ioprio_set(int which, int who, int ioprio);
asmlinkage long sys_ioprio_get(int which, int who);
asmlinkage long sys_flock(unsigned int fd, unsigned int cmd);
asmlinkage long sys_mknodat(int dfd, const char __user *filename, umode_t mode, unsigned dev);
asmlinkage long sys_mkdirat(int dfd, const char __user *pathname, umode_t mode);
asmlinkage long sys_unlinkat(int dfd, const char __user *pathname, int flag);
asmlinkage long sys_symlinkat(const char __user *oldname, int newdfd, const char __user *newname);
asmlinkage long sys_linkat(int olddfd, const char __user *oldname, int newdfd, const char __user *newname, int flags);
asmlinkage long sys_renameat(int olddfd, const char __user *oldname, int newdfd, const char __user *newname);
asmlinkage long sys_umount(char __user *name, int flags);
asmlinkage long sys_mount(char __user *dev_name, char __user *dir_name, char __user *type, unsigned long flags, void __user *data);
asmlinkage long sys_pivot_root(const char __user *new_root, const char __user *put_old);
asmlinkage long sys_statfs(const char __user *path, struct statfs __user *buf);
asmlinkage long sys_statfs64(const char __user *path, size_t sz, struct statfs64 __user *buf);
asmlinkage long sys_fstatfs(unsigned int fd, struct statfs __user *buf);
asmlinkage long sys_fstatfs64(unsigned int fd, size_t sz, struct statfs64 __user *buf);
asmlinkage long sys_truncate(const char __user *path, long length);
asmlinkage long sys_ftruncate(unsigned int fd, unsigned long length);
asmlinkage long sys_truncate64(const char __user *path, loff_t length);
asmlinkage long sys_ftruncate64(unsigned int fd, loff_t length);
asmlinkage long sys_fallocate(int fd, int mode, loff_t offset, loff_t len);
asmlinkage long sys_faccessat(int dfd, const char __user *filename, int mode);
asmlinkage long sys_faccessat2(int dfd, const char __user *filename, int mode, int flags);
asmlinkage long sys_chdir(const char __user *filename);
asmlinkage long sys_fchdir(unsigned int fd);
asmlinkage long sys_chroot(const char __user *filename);
asmlinkage long sys_fchmod(unsigned int fd, umode_t mode);
asmlinkage long sys_fchmodat(int dfd, const char __user *filename, umode_t mode);
asmlinkage long sys_fchownat(int dfd, const char __user *filename, uid_t user, gid_t group, int flag);
asmlinkage long sys_fchown(unsigned int fd, uid_t user, gid_t group);
asmlinkage long sys_openat(int dfd, const char __user *filename, int flags, umode_t mode);
asmlinkage long sys_openat2(int dfd, const char __user *filename, struct open_how *how, size_t size);
asmlinkage long sys_close(unsigned int fd);
asmlinkage long sys_close_range(unsigned int fd, unsigned int max_fd, unsigned int flags);
asmlinkage long sys_vhangup(void);
asmlinkage long sys_pipe2(int __user *fildes, int flags);
asmlinkage long sys_quotactl(unsigned int cmd, const char __user *special, qid_t id, void __user *addr);
asmlinkage long sys_quotactl_fd(unsigned int fd, unsigned int cmd, qid_t id, void __user *addr);
asmlinkage long sys_getdents64(unsigned int fd, struct linux_dirent64 __user *dirent, unsigned int count);
asmlinkage long sys_llseek(unsigned int fd, unsigned long offset_high, unsigned long offset_low, loff_t __user *result, unsigned int whence);
asmlinkage long sys_lseek(unsigned int fd, off_t offset, unsigned int whence);
asmlinkage long sys_read(unsigned int fd, char __user *buf, size_t count);
asmlinkage long sys_write(unsigned int fd, const char __user *buf, size_t count);
asmlinkage long sys_readv(unsigned long fd, const struct iovec __user *vec, unsigned long vlen);
asmlinkage long sys_writev(unsigned long fd, const struct iovec __user *vec, unsigned long vlen);
asmlinkage long sys_pread64(unsigned int fd, char __user *buf, size_t count, loff_t pos);
asmlinkage long sys_pwrite64(unsigned int fd, const char __user *buf, size_t count, loff_t pos);
asmlinkage long sys_preadv(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h);
asmlinkage long sys_pwritev(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h);
asmlinkage long sys_sendfile64(int out_fd, int in_fd, loff_t __user *offset, size_t count);
!asmlinkage long sys_pselect6(int n, fd_set __user *inp, fd_set __user *outp, fd_set __user *exp, struct __kernel_timespec __user *tsp, void __user *sig);
!asmlinkage long sys_pselect6_time32(int n, fd_set __user *inp, fd_set __user *outp, fd_set __user *exp, struct old_timespec32 __user *tsp, void __user *sig);
!asmlinkage long sys_ppoll(struct pollfd __user *ufds, unsigned int nfds, struct __kernel_timespec __user *tsp, const sigset_t __user *sigmask, size_t sigsetsize);
!asmlinkage long sys_ppoll_time32(struct pollfd __user *ufds, unsigned int nfds, struct old_timespec32 __user *tsp, const sigset_t __user *sigmask, size_t sigsetsize);
asmlinkage long sys_signalfd4(int ufd, sigset_t __user *user_mask, size_t sizemask, int flags);
asmlinkage long sys_vmsplice(int fd, const struct iovec __user *iov, unsigned long nr_segs, unsigned int flags);
asmlinkage long sys_splice(int fd_in, loff_t __user *off_in, int fd_out, loff_t __user *off_out, size_t len, unsigned int flags);
asmlinkage long sys_tee(int fdin, int fdout, size_t len, unsigned int flags);
asmlinkage long sys_readlinkat(int dfd, const char __user *path, char __user *buf, int bufsiz);
asmlinkage long sys_newfstatat(int dfd, const char __user *filename, struct stat __user *statbuf, int flag);
asmlinkage long sys_newfstat(unsigned int fd, struct stat __user *statbuf);
asmlinkage long sys_fstat64(unsigned long fd, struct stat64 __user *statbuf);
asmlinkage long sys_fstatat64(int dfd, const char __user *filename, struct stat64 __user *statbuf, int flag);
asmlinkage long sys_sync(void);
asmlinkage long sys_fsync(unsigned int fd);
asmlinkage long sys_fdatasync(unsigned int fd);
asmlinkage long sys_sync_file_range2(int fd, unsigned int flags, loff_t offset, loff_t nbytes);
asmlinkage long sys_sync_file_range(int fd, loff_t offset, loff_t nbytes, unsigned int flags);
asmlinkage long sys_timerfd_create(int clockid, int flags);
asmlinkage long sys_timerfd_settime(int ufd, int flags, const struct __kernel_itimerspec __user *utmr, struct __kernel_itimerspec __user *otmr);
asmlinkage long sys_timerfd_gettime(int ufd, struct __kernel_itimerspec __user *otmr);
asmlinkage long sys_timerfd_gettime32(int ufd, struct old_itimerspec32 __user *otmr);
asmlinkage long sys_timerfd_settime32(int ufd, int flags, const struct old_itimerspec32 __user *utmr, struct old_itimerspec32 __user *otmr);
asmlinkage long sys_utimensat(int dfd, const char __user *filename, struct __kernel_timespec __user *utimes, int flags);
asmlinkage long sys_utimensat_time32(unsigned int dfd, const char __user *filename, struct old_timespec32 __user *t, int flags);
asmlinkage long sys_acct(const char __user *name);
asmlinkage long sys_capget(cap_user_header_t header, cap_user_data_t dataptr);
asmlinkage long sys_capset(cap_user_header_t header, const cap_user_data_t data);
asmlinkage long sys_personality(unsigned int personality);
asmlinkage long sys_exit(int error_code);
asmlinkage long sys_exit_group(int error_code);
asmlinkage long sys_waitid(int which, pid_t pid, struct siginfo __user *infop, int options, struct rusage __user *ru);
asmlinkage long sys_set_tid_address(int __user *tidptr);
asmlinkage long sys_unshare(unsigned long unshare_flags);
asmlinkage long sys_futex(u32 __user *uaddr, int op, u32 val, const struct __kernel_timespec __user *utime, u32 __user *uaddr2, u32 val3);
asmlinkage long sys_futex_time32(u32 __user *uaddr, int op, u32 val, const struct old_timespec32 __user *utime, u32 __user *uaddr2, u32 val3);
asmlinkage long sys_get_robust_list(int pid, struct robust_list_head __user *__user *head_ptr, size_t __user *len_ptr);
asmlinkage long sys_set_robust_list(struct robust_list_head __user *head, size_t len);
asmlinkage long sys_futex_waitv(struct futex_waitv *waiters, unsigned int nr_futexes, unsigned int flags, struct __kernel_timespec __user *timeout, clockid_t clockid);
asmlinkage long sys_nanosleep(struct __kernel_timespec __user *rqtp, struct __kernel_timespec __user *rmtp);
asmlinkage long sys_nanosleep_time32(struct old_timespec32 __user *rqtp, struct old_timespec32 __user *rmtp);
asmlinkage long sys_getitimer(int which, struct __kernel_old_itimerval __user *value);
asmlinkage long sys_setitimer(int which, struct __kernel_old_itimerval __user *value, struct __kernel_old_itimerval __user *ovalue);
asmlinkage long sys_kexec_load(unsigned long entry, unsigned long nr_segments, struct kexec_segment __user *segments, unsigned long flags);
asmlinkage long sys_init_module(void __user *umod, unsigned long len, const char __user *uargs);
asmlinkage long sys_delete_module(const char __user *name_user, unsigned int flags);
asmlinkage long sys_timer_create(clockid_t which_clock, struct sigevent __user *timer_event_spec, timer_t __user *created_timer_id);
asmlinkage long sys_timer_gettime(timer_t timer_id, struct __kernel_itimerspec __user *setting);
asmlinkage long sys_timer_getoverrun(timer_t timer_id);
asmlinkage long sys_timer_settime(timer_t timer_id, int flags, const struct __kernel_itimerspec __user *new_setting, struct __kernel_itimerspec __user *old_setting);
asmlinkage long sys_timer_delete(timer_t timer_id);
asmlinkage long sys_clock_settime(clockid_t which_clock, const struct __kernel_timespec __user *tp);
asmlinkage long sys_clock_gettime(clockid_t which_clock, struct __kernel_timespec __user *tp);
asmlinkage long sys_clock_getres(clockid_t which_clock, struct __kernel_timespec __user *tp);
asmlinkage long sys_clock_nanosleep(clockid_t which_clock, int flags, const struct __kernel_timespec __user *rqtp, struct __kernel_timespec __user *rmtp);
asmlinkage long sys_timer_gettime32(timer_t timer_id, struct old_itimerspec32 __user *setting);
asmlinkage long sys_timer_settime32(timer_t timer_id, int flags, struct old_itimerspec32 __user *new, struct old_itimerspec32 __user *old);
asmlinkage long sys_clock_settime32(clockid_t which_clock, struct old_timespec32 __user *tp);
asmlinkage long sys_clock_gettime32(clockid_t which_clock, struct old_timespec32 __user *tp);
asmlinkage long sys_clock_getres_time32(clockid_t which_clock, struct old_timespec32 __user *tp);
asmlinkage long sys_clock_nanosleep_time32(clockid_t which_clock, int flags, struct old_timespec32 __user *rqtp, struct old_timespec32 __user *rmtp);
asmlinkage long sys_syslog(int type, char __user *buf, int len);
asmlinkage long sys_ptrace(long request, long pid, unsigned long addr, unsigned long data);
asmlinkage long sys_sched_setparam(pid_t pid, struct sched_param __user *param);
asmlinkage long sys_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param);
asmlinkage long sys_sched_getscheduler(pid_t pid);
asmlinkage long sys_sched_getparam(pid_t pid, struct sched_param __user *param);
asmlinkage long sys_sched_setaffinity(pid_t pid, unsigned int len, unsigned long __user *user_mask_ptr);
asmlinkage long sys_sched_getaffinity(pid_t pid, unsigned int len, unsigned long __user *user_mask_ptr);
asmlinkage long sys_sched_yield(void);
asmlinkage long sys_sched_get_priority_max(int policy);
asmlinkage long sys_sched_get_priority_min(int policy);
asmlinkage long sys_sched_rr_get_interval(pid_t pid, struct __kernel_timespec __user *interval);
asmlinkage long sys_sched_rr_get_interval_time32(pid_t pid, struct old_timespec32 __user *interval);
asmlinkage long sys_restart_syscall(void);
asmlinkage long sys_kill(pid_t pid, int sig);
asmlinkage long sys_tkill(pid_t pid, int sig);
asmlinkage long sys_tgkill(pid_t tgid, pid_t pid, int sig);
asmlinkage long sys_sigaltstack(const struct sigaltstack __user *uss, struct sigaltstack __user *uoss);
asmlinkage long sys_rt_sigsuspend(sigset_t __user *unewset, size_t sigsetsize);
!asmlinkage long sys_rt_sigaction(int sig, const struct sigaction __user *act, struct sigaction __user *oact, size_t sigsetsize);
asmlinkage long sys_rt_sigprocmask(int how, sigset_t __user *set, sigset_t __user *oset, size_t sigsetsize);
asmlinkage long sys_rt_sigpending(sigset_t __user *set, size_t sigsetsize);
asmlinkage long sys_rt_sigtimedwait(const sigset_t __user *uthese, siginfo_t __user *uinfo, const struct __kernel_timespec __user *uts, size_t sigsetsize);
asmlinkage long sys_rt_sigtimedwait_time32(const sigset_t __user *uthese, siginfo_t __user *uinfo, const struct old_timespec32 __user *uts, size_t sigsetsize);
asmlinkage long sys_rt_sigqueueinfo(pid_t pid, int sig, siginfo_t __user *uinfo);
asmlinkage long sys_setpriority(int which, int who, int niceval);
asmlinkage long sys_getpriority(int which, int who);
asmlinkage long sys_reboot(int magic1, int magic2, unsigned int cmd, void __user *arg);
asmlinkage long sys_setregid(gid_t rgid, gid_t egid);
asmlinkage long sys_setgid(gid_t gid);
asmlinkage long sys_setreuid(uid_t ruid, uid_t euid);
asmlinkage long sys_setuid(uid_t uid);
asmlinkage long sys_setresuid(uid_t ruid, uid_t euid, uid_t suid);
asmlinkage long sys_getresuid(uid_t __user *ruid, uid_t __user *euid, uid_t __user *suid);
asmlinkage long sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid);
asmlinkage long sys_getresgid(gid_t __user *rgid, gid_t __user *egid, gid_t __user *sgid);
asmlinkage long sys_setfsuid(uid_t uid);
asmlinkage long sys_setfsgid(gid_t gid);
asmlinkage long sys_times(struct tms __user *tbuf);
asmlinkage long sys_setpgid(pid_t pid, pid_t pgid);
asmlinkage long sys_getpgid(pid_t pid);
asmlinkage long sys_getsid(pid_t pid);
asmlinkage long sys_setsid(void);
asmlinkage long sys_getgroups(int gidsetsize, gid_t __user *grouplist);
asmlinkage long sys_setgroups(int gidsetsize, gid_t __user *grouplist);
asmlinkage long sys_newuname(struct new_utsname __user *name);
asmlinkage long sys_sethostname(char __user *name, int len);
asmlinkage long sys_setdomainname(char __user *name, int len);
asmlinkage long sys_getrlimit(unsigned int resource, struct rlimit __user *rlim);
asmlinkage long sys_setrlimit(unsigned int resource, struct rlimit __user *rlim);
asmlinkage long sys_getrusage(int who, struct rusage __user *ru);
asmlinkage long sys_umask(int mask);
asmlinkage long sys_prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5);
asmlinkage long sys_getcpu(unsigned __user *cpu, unsigned __user *node, struct getcpu_cache __user *cache);
asmlinkage long sys_gettimeofday(struct __kernel_old_timeval __user *tv, struct timezone __user *tz);
asmlinkage long sys_settimeofday(struct __kernel_old_timeval __user *tv, struct timezone __user *tz);
asmlinkage long sys_adjtimex(struct __kernel_timex __user *txc_p);
asmlinkage long sys_adjtimex_time32(struct old_timex32 __user *txc_p);
asmlinkage long sys_getpid(void);
asmlinkage long sys_getppid(void);
asmlinkage long sys_getuid(void);
asmlinkage long sys_geteuid(void);
asmlinkage long sys_getgid(void);
asmlinkage long sys_getegid(void);
asmlinkage long sys_gettid(void);
asmlinkage long sys_sysinfo(struct sysinfo __user *info);
asmlinkage long sys_mq_open(const char __user *name, int oflag, umode_t mode, struct mq_attr __user *attr);
asmlinkage long sys_mq_unlink(const char __user *name);
asmlinkage long sys_mq_timedsend(mqd_t mqdes, const char __user *msg_ptr, size_t msg_len, unsigned int msg_prio, const struct __kernel_timespec __user *abs_timeout);
asmlinkage long sys_mq_timedreceive(mqd_t mqdes, char __user *msg_ptr, size_t msg_len, unsigned int __user *msg_prio, const struct __kernel_timespec __user *abs_timeout);
asmlinkage long sys_mq_notify(mqd_t mqdes, const struct sigevent __user *notification);
asmlinkage long sys_mq_getsetattr(mqd_t mqdes, const struct mq_attr __user *mqstat, struct mq_attr __user *omqstat);
asmlinkage long sys_mq_timedreceive_time32(mqd_t mqdes, char __user *u_msg_ptr, unsigned int msg_len, unsigned int __user *u_msg_prio, const struct old_timespec32 __user *u_abs_timeout);
asmlinkage long sys_mq_timedsend_time32(mqd_t mqdes, const char __user *u_msg_ptr, unsigned int msg_len, unsigned int msg_prio, const struct old_timespec32 __user *u_abs_timeout);
asmlinkage long sys_msgget(key_t key, int msgflg);
asmlinkage long sys_old_msgctl(int msqid, int cmd, struct msqid_ds __user *buf);
asmlinkage long sys_msgctl(int msqid, int cmd, struct msqid_ds __user *buf);
asmlinkage long sys_msgrcv(int msqid, struct msgbuf __user *msgp, size_t msgsz, long msgtyp, int msgflg);
asmlinkage long sys_msgsnd(int msqid, struct msgbuf __user *msgp, size_t msgsz, int msgflg);
asmlinkage long sys_semget(key_t key, int nsems, int semflg);
asmlinkage long sys_semctl(int semid, int semnum, int cmd, unsigned long arg);
asmlinkage long sys_old_semctl(int semid, int semnum, int cmd, unsigned long arg);
asmlinkage long sys_semtimedop(int semid, struct sembuf __user *sops, unsigned nsops, const struct __kernel_timespec __user *timeout);
asmlinkage long sys_semtimedop_time32(int semid, struct sembuf __user *sops, unsigned nsops, const struct old_timespec32 __user *timeout);
asmlinkage long sys_semop(int semid, struct sembuf __user *sops, unsigned nsops);
asmlinkage long sys_shmget(key_t key, size_t size, int flag);
asmlinkage long sys_old_shmctl(int shmid, int cmd, struct shmid_ds __user *buf);
asmlinkage long sys_shmctl(int shmid, int cmd, struct shmid_ds __user *buf);
asmlinkage long sys_shmat(int shmid, char __user *shmaddr, int shmflg);
asmlinkage long sys_shmdt(char __user *shmaddr);
!asmlinkage long sys_socket(int family, int type, int protocol);
!asmlinkage long sys_socketpair(int family, int type, int protocol, int __user *usockvec);
!asmlinkage long sys_bind(int fd, struct sockaddr __user *umyaddr, int addrlen);
!asmlinkage long sys_listen(int fd, int backlog);
!asmlinkage long sys_accept(int fd, struct sockaddr __user *upeer_sockaddr, int __user *upeer_addrlen);
!asmlinkage long sys_connect(int fd, struct sockaddr __user *uservaddr, int addrlen);
!asmlinkage long sys_getsockname(int fd, struct sockaddr __user *usockaddr, int __user *usockaddr_len);
!asmlinkage long sys_getpeername(int fd, struct sockaddr __user *usockaddr, int __user *usockaddr_len);
!asmlinkage long sys_sendto(int fd, void __user *buff, size_t len, unsigned int flags, struct sockaddr __user *addr, int addr_len);
!asmlinkage long sys_recvfrom(int fd, void __user *ubuf, size_t size, unsigned int flags, struct sockaddr __user *addr, int __user *addr_len);
asmlinkage long sys_setsockopt(int fd, int level, int optname, char __user *optval, int optlen);
asmlinkage long sys_getsockopt(int fd, int level, int optname, char __user *optval, int __user *optlen);
!asmlinkage long sys_shutdown(int fd, int how);
asmlinkage long sys_sendmsg(int fd, struct user_msghdr __user *msg, unsigned flags);
asmlinkage long sys_recvmsg(int fd, struct user_msghdr __user *msg, unsigned flags);
asmlinkage long sys_readahead(int fd, loff_t offset, size_t count);
asmlinkage long sys_brk(unsigned long brk);
asmlinkage long sys_munmap(unsigned long addr, size_t len);
asmlinkage long sys_mremap(unsigned long addr, unsigned long old_len, unsigned long new_len, unsigned long flags, unsigned long new_addr);
asmlinkage long sys_add_key(const char __user *_type, const char __user *_description, const void __user *_payload, size_t plen, key_serial_t destringid);
asmlinkage long sys_request_key(const char __user *_type, const char __user *_description, const char __user *_callout_info, key_serial_t destringid);
asmlinkage long sys_keyctl(int cmd, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5);
#asmlinkage long sys_clone(unsigned long, unsigned long, int __user *, unsigned long, int __user *);
#asmlinkage long sys_clone(unsigned long, unsigned long, int, int __user *, int __user *, unsigned long);
#asmlinkage long sys_clone(unsigned long, unsigned long, int __user *, int __user *, unsigned long);
asmlinkage long sys_clone3(struct clone_args __user *uargs, size_t size);
asmlinkage long sys_execve(const char __user *filename, const char __user *const __user *argv, const char __user *const __user *envp);
asmlinkage long sys_fadvise64_64(int fd, loff_t offset, loff_t len, int advice);
asmlinkage long sys_swapon(const char __user *specialfile, int swap_flags);
asmlinkage long sys_swapoff(const char __user *specialfile);
asmlinkage long sys_mprotect(unsigned long start, size_t len, unsigned long prot);
asmlinkage long sys_msync(unsigned long start, size_t len, int flags);
asmlinkage long sys_mlock(unsigned long start, size_t len);
asmlinkage long sys_munlock(unsigned long start, size_t len);
asmlinkage long sys_mlockall(int flags);
asmlinkage long sys_munlockall(void);
asmlinkage long sys_mincore(unsigned long start, size_t len, unsigned char __user *vec);
asmlinkage long sys_madvise(unsigned long start, size_t len, int behavior);
asmlinkage long sys_process_madvise(int pidfd, const struct iovec __user *vec, size_t vlen, int behavior, unsigned int flags);
asmlinkage long sys_process_mrelease(int pidfd, unsigned int flags);
asmlinkage long sys_remap_file_pages(unsigned long start, unsigned long size, unsigned long prot, unsigned long pgoff, unsigned long flags);
asmlinkage long sys_mbind(unsigned long start, unsigned long len, unsigned long mode, const unsigned long __user *nmask, unsigned long maxnode, unsigned flags);
asmlinkage long sys_get_mempolicy(int __user *policy, unsigned long __user *nmask, unsigned long maxnode, unsigned long addr, unsigned long flags);
asmlinkage long sys_set_mempolicy(int mode, const unsigned long __user *nmask, unsigned long maxnode);
asmlinkage long sys_migrate_pages(pid_t pid, unsigned long maxnode, const unsigned long __user *from, const unsigned long __user *to);
asmlinkage long sys_move_pages(pid_t pid, unsigned long nr_pages, const void __user *__user *pages, const int __user *nodes, int __user *status, int flags);
asmlinkage long sys_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t __user *uinfo);
asmlinkage long sys_perf_event_open(struct perf_event_attr __user *attr_uptr, pid_t pid, int cpu, int group_fd, unsigned long flags);
!asmlinkage long sys_accept4(int fd, struct sockaddr __user *upeer_sockaddr, int __user *upeer_addrlen, int flags);
asmlinkage long sys_recvmmsg(int fd, struct mmsghdr __user *msg, unsigned int vlen, unsigned flags, struct __kernel_timespec __user *timeout);
asmlinkage long sys_recvmmsg_time32(int fd, struct mmsghdr __user *msg, unsigned int vlen, unsigned flags, struct old_timespec32 __user *timeout);
asmlinkage long sys_wait4(pid_t pid, int __user *stat_addr, int options, struct rusage __user *ru);
asmlinkage long sys_prlimit64(pid_t pid, unsigned int resource, const struct rlimit64 __user *new_rlim, struct rlimit64 __user *old_rlim);
asmlinkage long sys_fanotify_init(unsigned int flags, unsigned int event_f_flags);
asmlinkage long sys_fanotify_mark(int fanotify_fd, unsigned int flags, u64 mask, int fd, const char __user *pathname);
asmlinkage long sys_name_to_handle_at(int dfd, const char __user *name, struct file_handle __user *handle, int __user *mnt_id, int flag);
asmlinkage long sys_open_by_handle_at(int mountdirfd, struct file_handle __user *handle, int flags);
asmlinkage long sys_clock_adjtime(clockid_t which_clock, struct __kernel_timex __user *tx);
asmlinkage long sys_clock_adjtime32(clockid_t which_clock, struct old_timex32 __user *tx);
asmlinkage long sys_syncfs(int fd);
asmlinkage long sys_setns(int fd, int nstype);
asmlinkage long sys_pidfd_open(pid_t pid, unsigned int flags);
asmlinkage long sys_sendmmsg(int fd, struct mmsghdr __user *msg, unsigned int vlen, unsigned flags);
asmlinkage long sys_process_vm_readv(pid_t pid, const struct iovec __user *lvec, unsigned long liovcnt, const struct iovec __user *rvec, unsigned long riovcnt, unsigned long flags);
asmlinkage long sys_process_vm_writev(pid_t pid, const struct iovec __user *lvec, unsigned long liovcnt, const struct iovec __user *rvec, unsigned long riovcnt, unsigned long flags);
asmlinkage long sys_kcmp(pid_t pid1, pid_t pid2, int type, unsigned long idx1, unsigned long idx2);
asmlinkage long sys_finit_module(int fd, const char __user *uargs, int flags);
asmlinkage long sys_sched_setattr(pid_t pid, struct sched_attr __user *attr, unsigned int flags);
asmlinkage long sys_sched_getattr(pid_t pid, struct sched_attr __user *attr, unsigned int size, unsigned int flags);
asmlinkage long sys_renameat2(int olddfd, const char __user *oldname, int newdfd, const char __user *newname, unsigned int flags);
asmlinkage long sys_seccomp(unsigned int op, unsigned int flags, void __user *uargs);
asmlinkage long sys_getrandom(char __user *buf, size_t count, unsigned int flags);
asmlinkage long sys_memfd_create(const char __user *uname_ptr, unsigned int flags);
asmlinkage long sys_bpf(int cmd, union bpf_attr *attr, unsigned int size);
asmlinkage long sys_execveat(int dfd, const char __user *filename, const char __user *const __user *argv, const char __user *const __user *envp, int flags);
asmlinkage long sys_userfaultfd(int flags);
asmlinkage long sys_membarrier(int cmd, unsigned int flags, int cpu_id);
asmlinkage long sys_mlock2(unsigned long start, size_t len, int flags);
asmlinkage long sys_copy_file_range(int fd_in, loff_t __user *off_in, int fd_out, loff_t __user *off_out, size_t len, unsigned int flags);
asmlinkage long sys_preadv2(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h, rwf_t flags);
asmlinkage long sys_pwritev2(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h, rwf_t flags);
asmlinkage long sys_pkey_mprotect(unsigned long start, size_t len, unsigned long prot, int pkey);
asmlinkage long sys_pkey_alloc(unsigned long flags, unsigned long init_val);
asmlinkage long sys_pkey_free(int pkey);
asmlinkage long sys_statx(int dfd, const char __user *path, unsigned flags, unsigned mask, struct statx __user *buffer);
asmlinkage long sys_rseq(struct rseq __user *rseq, uint32_t rseq_len, int flags, uint32_t sig);
asmlinkage long sys_open_tree(int dfd, const char __user *path, unsigned flags);
asmlinkage long sys_move_mount(int from_dfd, const char __user *from_path, int to_dfd, const char __user *to_path, unsigned int ms_flags);
asmlinkage long sys_mount_setattr(int dfd, const char __user *path, unsigned int flags, struct mount_attr __user *uattr, size_t usize);
asmlinkage long sys_fsopen(const char __user *fs_name, unsigned int flags);
asmlinkage long sys_fsconfig(int fs_fd, unsigned int cmd, const char __user *key, const void __user *value, int aux);
asmlinkage long sys_fsmount(int fs_fd, unsigned int flags, unsigned int ms_flags);
asmlinkage long sys_fspick(int dfd, const char __user *path, unsigned int flags);
asmlinkage long sys_pidfd_send_signal(int pidfd, int sig, siginfo_t __user *info, unsigned int flags);
asmlinkage long sys_pidfd_getfd(int pidfd, int fd, unsigned int flags);
asmlinkage long sys_landlock_create_ruleset(const struct landlock_ruleset_attr __user *attr, size_t size, __u32 flags);
asmlinkage long sys_landlock_add_rule(int ruleset_fd, enum landlock_rule_type rule_type, const void __user *rule_attr, __u32 flags);
asmlinkage long sys_landlock_restrict_self(int ruleset_fd, __u32 flags);
asmlinkage long sys_memfd_secret(unsigned int flags);
asmlinkage long sys_set_mempolicy_home_node(unsigned long start, unsigned long len, unsigned long home_node, unsigned long flags);
asmlinkage long sys_ioperm(unsigned long from, unsigned long num, int on);
asmlinkage long sys_pciconfig_read(unsigned long bus, unsigned long dfn, unsigned long off, unsigned long len, void __user *buf);
asmlinkage long sys_pciconfig_write(unsigned long bus, unsigned long dfn, unsigned long off, unsigned long len, void __user *buf);
asmlinkage long sys_pciconfig_iobase(long which, unsigned long bus, unsigned long devfn);
asmlinkage long sys_spu_run(int fd, __u32 __user *unpc, __u32 __user *ustatus);
asmlinkage long sys_spu_create(const char __user *name, unsigned int flags, umode_t mode, int fd);
asmlinkage long sys_open(const char __user *filename, int flags, umode_t mode);
asmlinkage long sys_link(const char __user *oldname, const char __user *newname);
asmlinkage long sys_unlink(const char __user *pathname);
asmlinkage long sys_mknod(const char __user *filename, umode_t mode, unsigned dev);
asmlinkage long sys_chmod(const char __user *filename, umode_t mode);
asmlinkage long sys_chown(const char __user *filename, uid_t user, gid_t group);
asmlinkage long sys_mkdir(const char __user *pathname, umode_t mode);
asmlinkage long sys_rmdir(const char __user *pathname);
asmlinkage long sys_lchown(const char __user *filename, uid_t user, gid_t group);
asmlinkage long sys_access(const char __user *filename, int mode);
asmlinkage long sys_rename(const char __user *oldname, const char __user *newname);
asmlinkage long sys_symlink(const char __user *old, const char __user *new);
asmlinkage long sys_stat64(const char __user *filename, struct stat64 __user *statbuf);
asmlinkage long sys_lstat64(const char __user *filename, struct stat64 __user *statbuf);
asmlinkage long sys_pipe(int __user *fildes);
asmlinkage long sys_dup2(unsigned int oldfd, unsigned int newfd);
asmlinkage long sys_epoll_create(int size);
asmlinkage long sys_inotify_init(void);
asmlinkage long sys_eventfd(unsigned int count);
asmlinkage long sys_signalfd(int ufd, sigset_t __user *user_mask, size_t sizemask);
asmlinkage long sys_sendfile(int out_fd, int in_fd, off_t __user *offset, size_t count);
asmlinkage long sys_newstat(const char __user *filename, struct stat __user *statbuf);
asmlinkage long sys_newlstat(const char __user *filename, struct stat __user *statbuf);
asmlinkage long sys_fadvise64(int fd, loff_t offset, size_t len, int advice);
asmlinkage long sys_alarm(unsigned int seconds);
asmlinkage long sys_getpgrp(void);
asmlinkage long sys_pause(void);
asmlinkage long sys_time(__kernel_old_time_t __user *tloc);
asmlinkage long sys_time32(old_time32_t __user *tloc);
asmlinkage long sys_utime(char __user *filename, struct utimbuf __user *times);
asmlinkage long sys_utimes(char __user *filename, struct __kernel_old_timeval __user *utimes);
asmlinkage long sys_futimesat(int dfd, const char __user *filename, struct __kernel_old_timeval __user *utimes);
asmlinkage long sys_futimesat_time32(unsigned int dfd, const char __user *filename, struct old_timeval32 __user *t);
asmlinkage long sys_utime32(const char __user *filename, struct old_utimbuf32 __user *t);
asmlinkage long sys_utimes_time32(const char __user *filename, struct old_timeval32 __user *t);
asmlinkage long sys_creat(const char __user *pathname, umode_t mode);
asmlinkage long sys_getdents(unsigned int fd, struct linux_dirent __user *dirent, unsigned int count);
asmlinkage long sys_select(int n, fd_set __user *inp, fd_set __user *outp, fd_set __user *exp, struct __kernel_old_timeval __user *tvp);
asmlinkage long sys_poll(struct pollfd __user *ufds, unsigned int nfds, int timeout);
asmlinkage long sys_epoll_wait(int epfd, struct epoll_event __user *events, int maxevents, int timeout);
asmlinkage long sys_ustat(unsigned dev, struct ustat __user *ubuf);
asmlinkage long sys_vfork(void);
asmlinkage long sys_recv(int, void __user *, size_t, unsigned);
asmlinkage long sys_send(int, void __user *, size_t, unsigned);
asmlinkage long sys_oldumount(char __user *name);
asmlinkage long sys_uselib(const char __user *library);
asmlinkage long sys_sysfs(int option, unsigned long arg1, unsigned long arg2);
asmlinkage long sys_fork(void);
asmlinkage long sys_stime(__kernel_old_time_t __user *tptr);
asmlinkage long sys_stime32(old_time32_t __user *tptr);
asmlinkage long sys_sigpending(old_sigset_t __user *uset);
asmlinkage long sys_sigprocmask(int how, old_sigset_t __user *set, old_sigset_t __user *oset);
asmlinkage long sys_sigsuspend(old_sigset_t mask);
#asmlinkage long sys_sigsuspend(int unused1, int unused2, old_sigset_t mask);
asmlinkage long sys_sigaction(int, const struct old_sigaction __user *, struct old_sigaction __user *);
asmlinkage long sys_sgetmask(void);
asmlinkage long sys_ssetmask(int newmask);
asmlinkage long sys_signal(int sig, __sighandler_t handler);
asmlinkage long sys_nice(int increment);
asmlinkage long sys_kexec_file_load(int kernel_fd, int initrd_fd, unsigned long cmdline_len, const char __user *cmdline_ptr, unsigned long flags);
asmlinkage long sys_waitpid(pid_t pid, int __user *stat_addr, int options);
asmlinkage long sys_chown16(const char __user *filename, old_uid_t user, old_gid_t group);
asmlinkage long sys_lchown16(const char __user *filename, old_uid_t user, old_gid_t group);
asmlinkage long sys_fchown16(unsigned int fd, old_uid_t user, old_gid_t group);
asmlinkage long sys_setregid16(old_gid_t rgid, old_gid_t egid);
asmlinkage long sys_setgid16(old_gid_t gid);
asmlinkage long sys_setreuid16(old_uid_t ruid, old_uid_t euid);
asmlinkage long sys_setuid16(old_uid_t uid);
asmlinkage long sys_setresuid16(old_uid_t ruid, old_uid_t euid, old_uid_t suid);
asmlinkage long sys_getresuid16(old_uid_t __user *ruid, old_uid_t __user *euid, old_uid_t __user *suid);
asmlinkage long sys_setresgid16(old_gid_t rgid, old_gid_t egid, old_gid_t sgid);
asmlinkage long sys_getresgid16(old_gid_t __user *rgid, old_gid_t __user *egid, old_gid_t __user *sgid);
asmlinkage long sys_setfsuid16(old_uid_t uid);
asmlinkage long sys_setfsgid16(old_gid_t gid);
asmlinkage long sys_getgroups16(int gidsetsize, old_gid_t __user *grouplist);
asmlinkage long sys_setgroups16(int gidsetsize, old_gid_t __user *grouplist);
asmlinkage long sys_getuid16(void);
asmlinkage long sys_geteuid16(void);
asmlinkage long sys_getgid16(void);
asmlinkage long sys_getegid16(void);
asmlinkage long sys_socketcall(int call, unsigned long __user *args);
asmlinkage long sys_stat(const char __user *filename, struct __old_kernel_stat __user *statbuf);
asmlinkage long sys_lstat(const char __user *filename, struct __old_kernel_stat __user *statbuf);
asmlinkage long sys_fstat(unsigned int fd, struct __old_kernel_stat __user *statbuf);
asmlinkage long sys_readlink(const char __user *path, char __user *buf, int bufsiz);
asmlinkage long sys_old_select(struct sel_arg_struct __user *arg);
asmlinkage long sys_old_readdir(unsigned int, struct old_linux_dirent __user *, unsigned int);
asmlinkage long sys_gethostname(char __user *name, int len);
asmlinkage long sys_uname(struct old_utsname __user *);
asmlinkage long sys_olduname(struct oldold_utsname __user *);
asmlinkage long sys_old_getrlimit(unsigned int resource, struct rlimit __user *rlim);
asmlinkage long sys_ipc(unsigned int call, int first, unsigned long second, unsigned long third, void __user *ptr, long fifth);
asmlinkage long sys_mmap_pgoff(unsigned long addr, unsigned long len, unsigned long prot, unsigned long flags, unsigned long fd, unsigned long pgoff);
asmlinkage long sys_old_mmap(struct mmap_arg_struct __user *arg);
#asmlinkage long sys_ni_syscall(void);
"""

# include/linux/compat.h
syscall_defs_compat = """
asmlinkage long compat_sys_io_setup(unsigned nr_reqs, u32 __user *ctx32p);
asmlinkage long compat_sys_io_submit(compat_aio_context_t ctx_id, int nr, u32 __user *iocb);
asmlinkage long compat_sys_io_pgetevents(compat_aio_context_t ctx_id, compat_long_t min_nr, compat_long_t nr, struct io_event __user *events, struct old_timespec32 __user *timeout, const struct __compat_aio_sigset __user *usig);
asmlinkage long compat_sys_io_pgetevents_time64(compat_aio_context_t ctx_id, compat_long_t min_nr, compat_long_t nr, struct io_event __user *events, struct __kernel_timespec __user *timeout, const struct __compat_aio_sigset __user *usig);
asmlinkage long compat_sys_lookup_dcookie(u32, u32, char __user *, compat_size_t);
asmlinkage long compat_sys_epoll_pwait(int epfd, struct epoll_event __user *events, int maxevents, int timeout, const compat_sigset_t __user *sigmask, compat_size_t sigsetsize);
asmlinkage long compat_sys_epoll_pwait2(int epfd, struct epoll_event __user *events, int maxevents, const struct __kernel_timespec __user *timeout, const compat_sigset_t __user *sigmask, compat_size_t sigsetsize);
asmlinkage long compat_sys_fcntl(unsigned int fd, unsigned int cmd, compat_ulong_t arg);
asmlinkage long compat_sys_fcntl64(unsigned int fd, unsigned int cmd, compat_ulong_t arg);
asmlinkage long compat_sys_ioctl(unsigned int fd, unsigned int cmd, compat_ulong_t arg);
asmlinkage long compat_sys_statfs(const char __user *pathname, struct compat_statfs __user *buf);
asmlinkage long compat_sys_statfs64(const char __user *pathname, compat_size_t sz, struct compat_statfs64 __user *buf);
asmlinkage long compat_sys_fstatfs(unsigned int fd, struct compat_statfs __user *buf);
asmlinkage long compat_sys_fstatfs64(unsigned int fd, compat_size_t sz, struct compat_statfs64 __user *buf);
asmlinkage long compat_sys_truncate(const char __user *, compat_off_t);
asmlinkage long compat_sys_ftruncate(unsigned int, compat_ulong_t);
asmlinkage long compat_sys_openat(int dfd, const char __user *filename, int flags, umode_t mode);
asmlinkage long compat_sys_getdents(unsigned int fd, struct compat_linux_dirent __user *dirent, unsigned int count);
asmlinkage long compat_sys_lseek(unsigned int, compat_off_t, unsigned int);
asmlinkage ssize_t compat_sys_preadv(compat_ulong_t fd, const struct iovec __user *vec, compat_ulong_t vlen, u32 pos_low, u32 pos_high);
asmlinkage ssize_t compat_sys_pwritev(compat_ulong_t fd, const struct iovec __user *vec, compat_ulong_t vlen, u32 pos_low, u32 pos_high);
asmlinkage long compat_sys_preadv64(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, loff_t pos);
asmlinkage long compat_sys_pwritev64(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, loff_t pos);
asmlinkage long compat_sys_sendfile(int out_fd, int in_fd, compat_off_t __user *offset, compat_size_t count);
asmlinkage long compat_sys_sendfile64(int out_fd, int in_fd, compat_loff_t __user *offset, compat_size_t count);
asmlinkage long compat_sys_pselect6_time32(int n, compat_ulong_t __user *inp, compat_ulong_t __user *outp, compat_ulong_t __user *exp, struct old_timespec32 __user *tsp, void __user *sig);
asmlinkage long compat_sys_pselect6_time64(int n, compat_ulong_t __user *inp, compat_ulong_t __user *outp, compat_ulong_t __user *exp, struct __kernel_timespec __user *tsp, void __user *sig);
asmlinkage long compat_sys_ppoll_time32(struct pollfd __user *ufds, unsigned int nfds, struct old_timespec32 __user *tsp, const compat_sigset_t __user *sigmask, compat_size_t sigsetsize);
asmlinkage long compat_sys_ppoll_time64(struct pollfd __user *ufds, unsigned int nfds, struct __kernel_timespec __user *tsp, const compat_sigset_t __user *sigmask, compat_size_t sigsetsize);
asmlinkage long compat_sys_signalfd4(int ufd, const compat_sigset_t __user *sigmask, compat_size_t sigsetsize, int flags);
asmlinkage long compat_sys_newfstatat(unsigned int dfd, const char __user *filename, struct compat_stat __user *statbuf, int flag);
asmlinkage long compat_sys_newfstat(unsigned int fd, struct compat_stat __user *statbuf);
!asmlinkage long compat_sys_waitid(int which, compat_pid_t pid, struct compat_siginfo __user *waitid, int options, struct compat_rusage __user *uru);
asmlinkage long compat_sys_set_robust_list(struct compat_robust_list_head __user *head, compat_size_t len);
asmlinkage long compat_sys_get_robust_list(int pid, compat_uptr_t __user *head_ptr, compat_size_t __user *len_ptr);
asmlinkage long compat_sys_getitimer(int which, struct old_itimerval32 __user *it);
asmlinkage long compat_sys_setitimer(int which, struct old_itimerval32 __user *in, struct old_itimerval32 __user *out);
!asmlinkage long compat_sys_kexec_load(compat_ulong_t entry, compat_ulong_t nr_segments, struct compat_kexec_segment __user *segments, compat_ulong_t flags);
asmlinkage long compat_sys_timer_create(clockid_t which_clock, struct compat_sigevent __user *timer_event_spec, timer_t __user *created_timer_id);
asmlinkage long compat_sys_ptrace(compat_long_t request, compat_long_t pid, compat_long_t addr, compat_long_t data);
asmlinkage long compat_sys_sched_setaffinity(compat_pid_t pid, unsigned int len, compat_ulong_t __user *user_mask_ptr);
asmlinkage long compat_sys_sched_getaffinity(compat_pid_t pid, unsigned int len, compat_ulong_t __user *user_mask_ptr);
asmlinkage long compat_sys_sigaltstack(const compat_stack_t __user *uss_ptr, compat_stack_t __user *uoss_ptr);
asmlinkage long compat_sys_rt_sigsuspend(compat_sigset_t __user *unewset, compat_size_t sigsetsize);
!asmlinkage long compat_sys_rt_sigaction(int sig, const struct compat_sigaction __user *act, struct compat_sigaction __user *oact, compat_size_t sigsetsize);
asmlinkage long compat_sys_rt_sigprocmask(int how, compat_sigset_t __user *set, compat_sigset_t __user *oset, compat_size_t sigsetsize);
asmlinkage long compat_sys_rt_sigpending(compat_sigset_t __user *uset, compat_size_t sigsetsize);
asmlinkage long compat_sys_rt_sigtimedwait_time32(compat_sigset_t __user *uthese, struct compat_siginfo __user *uinfo, struct old_timespec32 __user *uts, compat_size_t sigsetsize);
asmlinkage long compat_sys_rt_sigtimedwait_time64(compat_sigset_t __user *uthese, struct compat_siginfo __user *uinfo, struct __kernel_timespec __user *uts, compat_size_t sigsetsize);
asmlinkage long compat_sys_rt_sigqueueinfo(compat_pid_t pid, int sig, struct compat_siginfo __user *uinfo);
asmlinkage long compat_sys_times(struct compat_tms __user *tbuf);
asmlinkage long compat_sys_getrlimit(unsigned int resource, struct compat_rlimit __user *rlim);
asmlinkage long compat_sys_setrlimit(unsigned int resource, struct compat_rlimit __user *rlim);
asmlinkage long compat_sys_getrusage(int who, struct compat_rusage __user *ru);
asmlinkage long compat_sys_gettimeofday(struct old_timeval32 __user *tv, struct timezone __user *tz);
asmlinkage long compat_sys_settimeofday(struct old_timeval32 __user *tv, struct timezone __user *tz);
asmlinkage long compat_sys_sysinfo(struct compat_sysinfo __user *info);
asmlinkage long compat_sys_mq_open(const char __user *u_name, int oflag, compat_mode_t mode, struct compat_mq_attr __user *u_attr);
asmlinkage long compat_sys_mq_notify(mqd_t mqdes, const struct compat_sigevent __user *u_notification);
asmlinkage long compat_sys_mq_getsetattr(mqd_t mqdes, const struct compat_mq_attr __user *u_mqstat, struct compat_mq_attr __user *u_omqstat);
asmlinkage long compat_sys_msgctl(int first, int second, void __user *uptr);
asmlinkage long compat_sys_msgrcv(int msqid, compat_uptr_t msgp, compat_ssize_t msgsz, compat_long_t msgtyp, int msgflg);
asmlinkage long compat_sys_msgsnd(int msqid, compat_uptr_t msgp, compat_ssize_t msgsz, int msgflg);
asmlinkage long compat_sys_semctl(int semid, int semnum, int cmd, int arg);
asmlinkage long compat_sys_shmctl(int first, int second, void __user *uptr);
asmlinkage long compat_sys_shmat(int shmid, compat_uptr_t shmaddr, int shmflg);
asmlinkage long compat_sys_recvfrom(int fd, void __user *buf, compat_size_t len, unsigned flags, struct sockaddr __user *addr, int __user *addrlen);
asmlinkage long compat_sys_sendmsg(int fd, struct compat_msghdr __user *msg, unsigned flags);
asmlinkage long compat_sys_recvmsg(int fd, struct compat_msghdr __user *msg, unsigned int flags);
asmlinkage long compat_sys_keyctl(u32 option, u32 arg2, u32 arg3, u32 arg4, u32 arg5);
asmlinkage long compat_sys_execve(const char __user *filename, const compat_uptr_t __user *argv, const compat_uptr_t __user *envp);
asmlinkage long compat_sys_rt_tgsigqueueinfo(compat_pid_t tgid, compat_pid_t pid, int sig, struct compat_siginfo __user *uinfo);
asmlinkage long compat_sys_recvmmsg_time64(int fd, struct compat_mmsghdr __user *mmsg, unsigned vlen, unsigned int flags, struct __kernel_timespec __user *timeout);
asmlinkage long compat_sys_recvmmsg_time32(int fd, struct compat_mmsghdr __user *mmsg, unsigned vlen, unsigned int flags, struct old_timespec32 __user *timeout);
asmlinkage long compat_sys_wait4(compat_pid_t pid, compat_uint_t __user *stat_addr, int options, struct compat_rusage __user *ru);
asmlinkage long compat_sys_fanotify_mark(int, unsigned int, __u32, __u32, int, const char __user *);
asmlinkage long compat_sys_open_by_handle_at(int mountdirfd, struct file_handle __user *handle, int flags);
asmlinkage long compat_sys_sendmmsg(int fd, struct compat_mmsghdr __user *mmsg, unsigned vlen, unsigned int flags);
asmlinkage long compat_sys_execveat(int dfd, const char __user *filename, const compat_uptr_t __user *argv, const compat_uptr_t __user *envp, int flags);
asmlinkage ssize_t compat_sys_preadv2(compat_ulong_t fd, const struct iovec __user *vec, compat_ulong_t vlen, u32 pos_low, u32 pos_high, rwf_t flags);
asmlinkage ssize_t compat_sys_pwritev2(compat_ulong_t fd, const struct iovec __user *vec, compat_ulong_t vlen, u32 pos_low, u32 pos_high, rwf_t flags);
asmlinkage long compat_sys_preadv64v2(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, loff_t pos, rwf_t flags);
asmlinkage long compat_sys_pwritev64v2(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, loff_t pos, rwf_t flags);
asmlinkage long compat_sys_open(const char __user *filename, int flags, umode_t mode);
asmlinkage long compat_sys_signalfd(int ufd, const compat_sigset_t __user *sigmask, compat_size_t sigsetsize);
asmlinkage long compat_sys_newstat(const char __user *filename, struct compat_stat __user *statbuf);
asmlinkage long compat_sys_newlstat(const char __user *filename, struct compat_stat __user *statbuf);
asmlinkage long compat_sys_select(int n, compat_ulong_t __user *inp, compat_ulong_t __user *outp, compat_ulong_t __user *exp, struct old_timeval32 __user *tvp);
asmlinkage long compat_sys_ustat(unsigned dev, struct compat_ustat __user *u32);
asmlinkage long compat_sys_recv(int fd, void __user *buf, compat_size_t len, unsigned flags);
asmlinkage long compat_sys_old_readdir(unsigned int fd, struct compat_old_linux_dirent __user *, unsigned int count);
asmlinkage long compat_sys_old_select(struct compat_sel_arg_struct __user *arg);
asmlinkage long compat_sys_ipc(u32, int, int, u32, compat_uptr_t, u32);
asmlinkage long compat_sys_sigpending(compat_old_sigset_t __user *set);
asmlinkage long compat_sys_sigprocmask(int how, compat_old_sigset_t __user *nset, compat_old_sigset_t __user *oset);
asmlinkage long compat_sys_sigaction(int sig, const struct compat_old_sigaction __user *act, struct compat_old_sigaction __user *oact);
asmlinkage long compat_sys_socketcall(int call, u32 __user *args);
asmlinkage long compat_sys_truncate64(const char __user *pathname, compat_arg_u64(len));
asmlinkage long compat_sys_ftruncate64(unsigned int fd, compat_arg_u64(len));
asmlinkage long compat_sys_fallocate(int fd, int mode, compat_arg_u64(offset), compat_arg_u64(len));
asmlinkage long compat_sys_pread64(unsigned int fd, char __user *buf, size_t count, compat_arg_u64(pos));
asmlinkage long compat_sys_pwrite64(unsigned int fd, const char __user *buf, size_t count, compat_arg_u64(pos));
asmlinkage long compat_sys_sync_file_range(int fd, compat_arg_u64(pos), compat_arg_u64(nbytes), unsigned int flags);
asmlinkage long compat_sys_fadvise64_64(int fd, compat_arg_u64(pos), compat_arg_u64(len), int advice);
asmlinkage long compat_sys_readahead(int fd, compat_arg_u64(offset), size_t count);
"""


def parse_common_syscall_defs():
    sc_defs = [
        syscall_defs,
        syscall_defs_compat,
    ]
    dic = {}
    for defs in sc_defs:
        for line in defs.splitlines():
            if line == "":
                continue
            if line.startswith("#"):
                continue
            m = re.search(r"asmlinkage\s+(?:long|ssize_t)\s+(\S+)\((.+?)\);", line)
            if not m:
                continue
            name, args = m.group(1), m.group(2)
            args = [x.strip() for x in args.split(",")]
            if name in dic:
                err("duplicate: {:s}".format(name))
                raise
            if len(args) == 1 and args[0] == "void":
                dic[name] = []
            else:
                dic[name] = args
    return dic


# x86_64
# - arch/x86/entry/syscalls/syscall_64.tbl
x64_syscall_tbl = """
#
# 64-bit system call numbers and entry vectors
#
# The format is:
# <number> <abi> <name> <entry point>
#
# The __x64_sys_*() stubs are created on-the-fly for sys_*() system calls
#
# The abi is "common", "64" or "x32" for this file.
#
0       common  read                    sys_read
1       common  write                   sys_write
2       common  open                    sys_open
3       common  close                   sys_close
4       common  stat                    sys_newstat
5       common  fstat                   sys_newfstat
6       common  lstat                   sys_newlstat
7       common  poll                    sys_poll
8       common  lseek                   sys_lseek
9       common  mmap                    sys_mmap
10      common  mprotect                sys_mprotect
11      common  munmap                  sys_munmap
12      common  brk                     sys_brk
13      64      rt_sigaction            sys_rt_sigaction
14      common  rt_sigprocmask          sys_rt_sigprocmask
15      64      rt_sigreturn            sys_rt_sigreturn
16      64      ioctl                   sys_ioctl
17      common  pread64                 sys_pread64
18      common  pwrite64                sys_pwrite64
19      64      readv                   sys_readv
20      64      writev                  sys_writev
21      common  access                  sys_access
22      common  pipe                    sys_pipe
23      common  select                  sys_select
24      common  sched_yield             sys_sched_yield
25      common  mremap                  sys_mremap
26      common  msync                   sys_msync
27      common  mincore                 sys_mincore
28      common  madvise                 sys_madvise
29      common  shmget                  sys_shmget
30      common  shmat                   sys_shmat
31      common  shmctl                  sys_shmctl
32      common  dup                     sys_dup
33      common  dup2                    sys_dup2
34      common  pause                   sys_pause
35      common  nanosleep               sys_nanosleep
36      common  getitimer               sys_getitimer
37      common  alarm                   sys_alarm
38      common  setitimer               sys_setitimer
39      common  getpid                  sys_getpid
40      common  sendfile                sys_sendfile64
41      common  socket                  sys_socket
42      common  connect                 sys_connect
43      common  accept                  sys_accept
44      common  sendto                  sys_sendto
45      64      recvfrom                sys_recvfrom
46      64      sendmsg                 sys_sendmsg
47      64      recvmsg                 sys_recvmsg
48      common  shutdown                sys_shutdown
49      common  bind                    sys_bind
50      common  listen                  sys_listen
51      common  getsockname             sys_getsockname
52      common  getpeername             sys_getpeername
53      common  socketpair              sys_socketpair
54      64      setsockopt              sys_setsockopt
55      64      getsockopt              sys_getsockopt
56      common  clone                   sys_clone
57      common  fork                    sys_fork
58      common  vfork                   sys_vfork
59      64      execve                  sys_execve
60      common  exit                    sys_exit
61      common  wait4                   sys_wait4
62      common  kill                    sys_kill
63      common  uname                   sys_newuname
64      common  semget                  sys_semget
65      common  semop                   sys_semop
66      common  semctl                  sys_semctl
67      common  shmdt                   sys_shmdt
68      common  msgget                  sys_msgget
69      common  msgsnd                  sys_msgsnd
70      common  msgrcv                  sys_msgrcv
71      common  msgctl                  sys_msgctl
72      common  fcntl                   sys_fcntl
73      common  flock                   sys_flock
74      common  fsync                   sys_fsync
75      common  fdatasync               sys_fdatasync
76      common  truncate                sys_truncate
77      common  ftruncate               sys_ftruncate
78      common  getdents                sys_getdents
79      common  getcwd                  sys_getcwd
80      common  chdir                   sys_chdir
81      common  fchdir                  sys_fchdir
82      common  rename                  sys_rename
83      common  mkdir                   sys_mkdir
84      common  rmdir                   sys_rmdir
85      common  creat                   sys_creat
86      common  link                    sys_link
87      common  unlink                  sys_unlink
88      common  symlink                 sys_symlink
89      common  readlink                sys_readlink
90      common  chmod                   sys_chmod
91      common  fchmod                  sys_fchmod
92      common  chown                   sys_chown
93      common  fchown                  sys_fchown
94      common  lchown                  sys_lchown
95      common  umask                   sys_umask
96      common  gettimeofday            sys_gettimeofday
97      common  getrlimit               sys_getrlimit
98      common  getrusage               sys_getrusage
99      common  sysinfo                 sys_sysinfo
100     common  times                   sys_times
101     64      ptrace                  sys_ptrace
102     common  getuid                  sys_getuid
103     common  syslog                  sys_syslog
104     common  getgid                  sys_getgid
105     common  setuid                  sys_setuid
106     common  setgid                  sys_setgid
107     common  geteuid                 sys_geteuid
108     common  getegid                 sys_getegid
109     common  setpgid                 sys_setpgid
110     common  getppid                 sys_getppid
111     common  getpgrp                 sys_getpgrp
112     common  setsid                  sys_setsid
113     common  setreuid                sys_setreuid
114     common  setregid                sys_setregid
115     common  getgroups               sys_getgroups
116     common  setgroups               sys_setgroups
117     common  setresuid               sys_setresuid
118     common  getresuid               sys_getresuid
119     common  setresgid               sys_setresgid
120     common  getresgid               sys_getresgid
121     common  getpgid                 sys_getpgid
122     common  setfsuid                sys_setfsuid
123     common  setfsgid                sys_setfsgid
124     common  getsid                  sys_getsid
125     common  capget                  sys_capget
126     common  capset                  sys_capset
127     64      rt_sigpending           sys_rt_sigpending
128     64      rt_sigtimedwait         sys_rt_sigtimedwait
129     64      rt_sigqueueinfo         sys_rt_sigqueueinfo
130     common  rt_sigsuspend           sys_rt_sigsuspend
131     64      sigaltstack             sys_sigaltstack
132     common  utime                   sys_utime
133     common  mknod                   sys_mknod
134     64      uselib
135     common  personality             sys_personality
136     common  ustat                   sys_ustat
137     common  statfs                  sys_statfs
138     common  fstatfs                 sys_fstatfs
139     common  sysfs                   sys_sysfs
140     common  getpriority             sys_getpriority
141     common  setpriority             sys_setpriority
142     common  sched_setparam          sys_sched_setparam
143     common  sched_getparam          sys_sched_getparam
144     common  sched_setscheduler      sys_sched_setscheduler
145     common  sched_getscheduler      sys_sched_getscheduler
146     common  sched_get_priority_max  sys_sched_get_priority_max
147     common  sched_get_priority_min  sys_sched_get_priority_min
148     common  sched_rr_get_interval   sys_sched_rr_get_interval
149     common  mlock                   sys_mlock
150     common  munlock                 sys_munlock
151     common  mlockall                sys_mlockall
152     common  munlockall              sys_munlockall
153     common  vhangup                 sys_vhangup
154     common  modify_ldt              sys_modify_ldt
155     common  pivot_root              sys_pivot_root
156     64      _sysctl                 sys_ni_syscall
157     common  prctl                   sys_prctl
158     common  arch_prctl              sys_arch_prctl
159     common  adjtimex                sys_adjtimex
160     common  setrlimit               sys_setrlimit
161     common  chroot                  sys_chroot
162     common  sync                    sys_sync
163     common  acct                    sys_acct
164     common  settimeofday            sys_settimeofday
165     common  mount                   sys_mount
166     common  umount2                 sys_umount
167     common  swapon                  sys_swapon
168     common  swapoff                 sys_swapoff
169     common  reboot                  sys_reboot
170     common  sethostname             sys_sethostname
171     common  setdomainname           sys_setdomainname
172     common  iopl                    sys_iopl
173     common  ioperm                  sys_ioperm
174     64      create_module
175     common  init_module             sys_init_module
176     common  delete_module           sys_delete_module
177     64      get_kernel_syms
178     64      query_module
179     common  quotactl                sys_quotactl
180     64      nfsservctl
181     common  getpmsg
182     common  putpmsg
183     common  afs_syscall
184     common  tuxcall
185     common  security
186     common  gettid                  sys_gettid
187     common  readahead               sys_readahead
188     common  setxattr                sys_setxattr
189     common  lsetxattr               sys_lsetxattr
190     common  fsetxattr               sys_fsetxattr
191     common  getxattr                sys_getxattr
192     common  lgetxattr               sys_lgetxattr
193     common  fgetxattr               sys_fgetxattr
194     common  listxattr               sys_listxattr
195     common  llistxattr              sys_llistxattr
196     common  flistxattr              sys_flistxattr
197     common  removexattr             sys_removexattr
198     common  lremovexattr            sys_lremovexattr
199     common  fremovexattr            sys_fremovexattr
200     common  tkill                   sys_tkill
201     common  time                    sys_time
202     common  futex                   sys_futex
203     common  sched_setaffinity       sys_sched_setaffinity
204     common  sched_getaffinity       sys_sched_getaffinity
205     64      set_thread_area
206     64      io_setup                sys_io_setup
207     common  io_destroy              sys_io_destroy
208     common  io_getevents            sys_io_getevents
209     64      io_submit               sys_io_submit
210     common  io_cancel               sys_io_cancel
211     64      get_thread_area
212     common  lookup_dcookie          sys_lookup_dcookie
213     common  epoll_create            sys_epoll_create
214     64      epoll_ctl_old
215     64      epoll_wait_old
216     common  remap_file_pages        sys_remap_file_pages
217     common  getdents64              sys_getdents64
218     common  set_tid_address         sys_set_tid_address
219     common  restart_syscall         sys_restart_syscall
220     common  semtimedop              sys_semtimedop
221     common  fadvise64               sys_fadvise64
222     64      timer_create            sys_timer_create
223     common  timer_settime           sys_timer_settime
224     common  timer_gettime           sys_timer_gettime
225     common  timer_getoverrun        sys_timer_getoverrun
226     common  timer_delete            sys_timer_delete
227     common  clock_settime           sys_clock_settime
228     common  clock_gettime           sys_clock_gettime
229     common  clock_getres            sys_clock_getres
230     common  clock_nanosleep         sys_clock_nanosleep
231     common  exit_group              sys_exit_group
232     common  epoll_wait              sys_epoll_wait
233     common  epoll_ctl               sys_epoll_ctl
234     common  tgkill                  sys_tgkill
235     common  utimes                  sys_utimes
236     64      vserver
237     common  mbind                   sys_mbind
238     common  set_mempolicy           sys_set_mempolicy
239     common  get_mempolicy           sys_get_mempolicy
240     common  mq_open                 sys_mq_open
241     common  mq_unlink               sys_mq_unlink
242     common  mq_timedsend            sys_mq_timedsend
243     common  mq_timedreceive         sys_mq_timedreceive
244     64      mq_notify               sys_mq_notify
245     common  mq_getsetattr           sys_mq_getsetattr
246     64      kexec_load              sys_kexec_load
247     64      waitid                  sys_waitid
248     common  add_key                 sys_add_key
249     common  request_key             sys_request_key
250     common  keyctl                  sys_keyctl
251     common  ioprio_set              sys_ioprio_set
252     common  ioprio_get              sys_ioprio_get
253     common  inotify_init            sys_inotify_init
254     common  inotify_add_watch       sys_inotify_add_watch
255     common  inotify_rm_watch        sys_inotify_rm_watch
256     common  migrate_pages           sys_migrate_pages
257     common  openat                  sys_openat
258     common  mkdirat                 sys_mkdirat
259     common  mknodat                 sys_mknodat
260     common  fchownat                sys_fchownat
261     common  futimesat               sys_futimesat
262     common  newfstatat              sys_newfstatat
263     common  unlinkat                sys_unlinkat
264     common  renameat                sys_renameat
265     common  linkat                  sys_linkat
266     common  symlinkat               sys_symlinkat
267     common  readlinkat              sys_readlinkat
268     common  fchmodat                sys_fchmodat
269     common  faccessat               sys_faccessat
270     common  pselect6                sys_pselect6
271     common  ppoll                   sys_ppoll
272     common  unshare                 sys_unshare
273     64      set_robust_list         sys_set_robust_list
274     64      get_robust_list         sys_get_robust_list
275     common  splice                  sys_splice
276     common  tee                     sys_tee
277     common  sync_file_range         sys_sync_file_range
278     64      vmsplice                sys_vmsplice
279     64      move_pages              sys_move_pages
280     common  utimensat               sys_utimensat
281     common  epoll_pwait             sys_epoll_pwait
282     common  signalfd                sys_signalfd
283     common  timerfd_create          sys_timerfd_create
284     common  eventfd                 sys_eventfd
285     common  fallocate               sys_fallocate
286     common  timerfd_settime         sys_timerfd_settime
287     common  timerfd_gettime         sys_timerfd_gettime
288     common  accept4                 sys_accept4
289     common  signalfd4               sys_signalfd4
290     common  eventfd2                sys_eventfd2
291     common  epoll_create1           sys_epoll_create1
292     common  dup3                    sys_dup3
293     common  pipe2                   sys_pipe2
294     common  inotify_init1           sys_inotify_init1
295     64      preadv                  sys_preadv
296     64      pwritev                 sys_pwritev
297     64      rt_tgsigqueueinfo       sys_rt_tgsigqueueinfo
298     common  perf_event_open         sys_perf_event_open
299     64      recvmmsg                sys_recvmmsg
300     common  fanotify_init           sys_fanotify_init
301     common  fanotify_mark           sys_fanotify_mark
302     common  prlimit64               sys_prlimit64
303     common  name_to_handle_at       sys_name_to_handle_at
304     common  open_by_handle_at       sys_open_by_handle_at
305     common  clock_adjtime           sys_clock_adjtime
306     common  syncfs                  sys_syncfs
307     64      sendmmsg                sys_sendmmsg
308     common  setns                   sys_setns
309     common  getcpu                  sys_getcpu
310     64      process_vm_readv        sys_process_vm_readv
311     64      process_vm_writev       sys_process_vm_writev
312     common  kcmp                    sys_kcmp
313     common  finit_module            sys_finit_module
314     common  sched_setattr           sys_sched_setattr
315     common  sched_getattr           sys_sched_getattr
316     common  renameat2               sys_renameat2
317     common  seccomp                 sys_seccomp
318     common  getrandom               sys_getrandom
319     common  memfd_create            sys_memfd_create
320     common  kexec_file_load         sys_kexec_file_load
321     common  bpf                     sys_bpf
322     64      execveat                sys_execveat
323     common  userfaultfd             sys_userfaultfd
324     common  membarrier              sys_membarrier
325     common  mlock2                  sys_mlock2
326     common  copy_file_range         sys_copy_file_range
327     64      preadv2                 sys_preadv2
328     64      pwritev2                sys_pwritev2
329     common  pkey_mprotect           sys_pkey_mprotect
330     common  pkey_alloc              sys_pkey_alloc
331     common  pkey_free               sys_pkey_free
332     common  statx                   sys_statx
333     common  io_pgetevents           sys_io_pgetevents
334     common  rseq                    sys_rseq
# don't use numbers 387 through 423, add new calls after the last
# 'common' entry
424     common  pidfd_send_signal       sys_pidfd_send_signal
425     common  io_uring_setup          sys_io_uring_setup
426     common  io_uring_enter          sys_io_uring_enter
427     common  io_uring_register       sys_io_uring_register
428     common  open_tree               sys_open_tree
429     common  move_mount              sys_move_mount
430     common  fsopen                  sys_fsopen
431     common  fsconfig                sys_fsconfig
432     common  fsmount                 sys_fsmount
433     common  fspick                  sys_fspick
434     common  pidfd_open              sys_pidfd_open
435     common  clone3                  sys_clone3
436     common  close_range             sys_close_range
437     common  openat2                 sys_openat2
438     common  pidfd_getfd             sys_pidfd_getfd
439     common  faccessat2              sys_faccessat2
440     common  process_madvise         sys_process_madvise
441     common  epoll_pwait2            sys_epoll_pwait2
442     common  mount_setattr           sys_mount_setattr
443     common  quotactl_fd             sys_quotactl_fd
444     common  landlock_create_ruleset sys_landlock_create_ruleset
445     common  landlock_add_rule       sys_landlock_add_rule
446     common  landlock_restrict_self  sys_landlock_restrict_self
447     common  memfd_secret            sys_memfd_secret
448     common  process_mrelease        sys_process_mrelease
449     common  futex_waitv             sys_futex_waitv
450     common  set_mempolicy_home_node sys_set_mempolicy_home_node

#
# Due to a historical design error, certain syscalls are numbered differently
# in x32 as compared to native x86_64.  These syscalls have numbers 512-547.
# Do not add new syscalls to this range.  Numbers 548 and above are available
# for non-x32 use.
#
512     x32     rt_sigaction            compat_sys_rt_sigaction
513     x32     rt_sigreturn            compat_sys_x32_rt_sigreturn
514     x32     ioctl                   compat_sys_ioctl
515     x32     readv                   sys_readv
516     x32     writev                  sys_writev
517     x32     recvfrom                compat_sys_recvfrom
518     x32     sendmsg                 compat_sys_sendmsg
519     x32     recvmsg                 compat_sys_recvmsg
520     x32     execve                  compat_sys_execve
521     x32     ptrace                  compat_sys_ptrace
522     x32     rt_sigpending           compat_sys_rt_sigpending
523     x32     rt_sigtimedwait         compat_sys_rt_sigtimedwait_time64
524     x32     rt_sigqueueinfo         compat_sys_rt_sigqueueinfo
525     x32     sigaltstack             compat_sys_sigaltstack
526     x32     timer_create            compat_sys_timer_create
527     x32     mq_notify               compat_sys_mq_notify
528     x32     kexec_load              compat_sys_kexec_load
529     x32     waitid                  compat_sys_waitid
530     x32     set_robust_list         compat_sys_set_robust_list
531     x32     get_robust_list         compat_sys_get_robust_list
532     x32     vmsplice                sys_vmsplice
533     x32     move_pages              sys_move_pages
534     x32     preadv                  compat_sys_preadv64
535     x32     pwritev                 compat_sys_pwritev64
536     x32     rt_tgsigqueueinfo       compat_sys_rt_tgsigqueueinfo
537     x32     recvmmsg                compat_sys_recvmmsg_time64
538     x32     sendmmsg                compat_sys_sendmmsg
539     x32     process_vm_readv        sys_process_vm_readv
540     x32     process_vm_writev       sys_process_vm_writev
541     x32     setsockopt              sys_setsockopt
542     x32     getsockopt              sys_getsockopt
543     x32     io_setup                compat_sys_io_setup
544     x32     io_submit               compat_sys_io_submit
545     x32     execveat                compat_sys_execveat
546     x32     preadv2                 compat_sys_preadv64v2
547     x32     pwritev2                compat_sys_pwritev64v2
# This is the end of the legacy x32 range.  Numbers 548 and above are
# not special and are not to be used for x32-specific syscalls.
"""


# i386 (native / compat(emulated))
# - arch/x86/entry/syscalls/syscall_32.tbl
x86_syscall_tbl = """
#
# 32-bit system call numbers and entry vectors
#
# The format is:
# <number> <abi> <name> <entry point> <compat entry point>
#
# The __ia32_sys and __ia32_compat_sys stubs are created on-the-fly for
# sys_*() system calls and compat_sys_*() compat system calls if
# IA32_EMULATION is defined, and expect struct pt_regs *regs as their only
# parameter.
#
# The abi is always "i386" for this file.
#
0       i386    restart_syscall         sys_restart_syscall
1       i386    exit                    sys_exit
2       i386    fork                    sys_fork
3       i386    read                    sys_read
4       i386    write                   sys_write
5       i386    open                    sys_open                        compat_sys_open
6       i386    close                   sys_close
7       i386    waitpid                 sys_waitpid
8       i386    creat                   sys_creat
9       i386    link                    sys_link
10      i386    unlink                  sys_unlink
11      i386    execve                  sys_execve                      compat_sys_execve
12      i386    chdir                   sys_chdir
13      i386    time                    sys_time32
14      i386    mknod                   sys_mknod
15      i386    chmod                   sys_chmod
16      i386    lchown                  sys_lchown16
17      i386    break
18      i386    oldstat                 sys_stat
19      i386    lseek                   sys_lseek                       compat_sys_lseek
20      i386    getpid                  sys_getpid
21      i386    mount                   sys_mount
22      i386    umount                  sys_oldumount
23      i386    setuid                  sys_setuid16
24      i386    getuid                  sys_getuid16
25      i386    stime                   sys_stime32
26      i386    ptrace                  sys_ptrace                      compat_sys_ptrace
27      i386    alarm                   sys_alarm
28      i386    oldfstat                sys_fstat
29      i386    pause                   sys_pause
30      i386    utime                   sys_utime32
31      i386    stty
32      i386    gtty
33      i386    access                  sys_access
34      i386    nice                    sys_nice
35      i386    ftime
36      i386    sync                    sys_sync
37      i386    kill                    sys_kill
38      i386    rename                  sys_rename
39      i386    mkdir                   sys_mkdir
40      i386    rmdir                   sys_rmdir
41      i386    dup                     sys_dup
42      i386    pipe                    sys_pipe
43      i386    times                   sys_times                       compat_sys_times
44      i386    prof
45      i386    brk                     sys_brk
46      i386    setgid                  sys_setgid16
47      i386    getgid                  sys_getgid16
48      i386    signal                  sys_signal
49      i386    geteuid                 sys_geteuid16
50      i386    getegid                 sys_getegid16
51      i386    acct                    sys_acct
52      i386    umount2                 sys_umount
53      i386    lock
54      i386    ioctl                   sys_ioctl                       compat_sys_ioctl
55      i386    fcntl                   sys_fcntl                       compat_sys_fcntl64
56      i386    mpx
57      i386    setpgid                 sys_setpgid
58      i386    ulimit
59      i386    oldolduname             sys_olduname
60      i386    umask                   sys_umask
61      i386    chroot                  sys_chroot
62      i386    ustat                   sys_ustat                       compat_sys_ustat
63      i386    dup2                    sys_dup2
64      i386    getppid                 sys_getppid
65      i386    getpgrp                 sys_getpgrp
66      i386    setsid                  sys_setsid
67      i386    sigaction               sys_sigaction                   compat_sys_sigaction
68      i386    sgetmask                sys_sgetmask
69      i386    ssetmask                sys_ssetmask
70      i386    setreuid                sys_setreuid16
71      i386    setregid                sys_setregid16
72      i386    sigsuspend              sys_sigsuspend
73      i386    sigpending              sys_sigpending                  compat_sys_sigpending
74      i386    sethostname             sys_sethostname
75      i386    setrlimit               sys_setrlimit                   compat_sys_setrlimit
76      i386    getrlimit               sys_old_getrlimit               compat_sys_old_getrlimit
77      i386    getrusage               sys_getrusage                   compat_sys_getrusage
78      i386    gettimeofday            sys_gettimeofday                compat_sys_gettimeofday
79      i386    settimeofday            sys_settimeofday                compat_sys_settimeofday
80      i386    getgroups               sys_getgroups16
81      i386    setgroups               sys_setgroups16
82      i386    select                  sys_old_select                  compat_sys_old_select
83      i386    symlink                 sys_symlink
84      i386    oldlstat                sys_lstat
85      i386    readlink                sys_readlink
86      i386    uselib                  sys_uselib
87      i386    swapon                  sys_swapon
88      i386    reboot                  sys_reboot
89      i386    readdir                 sys_old_readdir                 compat_sys_old_readdir
90      i386    mmap                    sys_old_mmap                    compat_sys_ia32_mmap
91      i386    munmap                  sys_munmap
92      i386    truncate                sys_truncate                    compat_sys_truncate
93      i386    ftruncate               sys_ftruncate                   compat_sys_ftruncate
94      i386    fchmod                  sys_fchmod
95      i386    fchown                  sys_fchown16
96      i386    getpriority             sys_getpriority
97      i386    setpriority             sys_setpriority
98      i386    profil
99      i386    statfs                  sys_statfs                      compat_sys_statfs
100     i386    fstatfs                 sys_fstatfs                     compat_sys_fstatfs
101     i386    ioperm                  sys_ioperm
102     i386    socketcall              sys_socketcall                  compat_sys_socketcall
103     i386    syslog                  sys_syslog
104     i386    setitimer               sys_setitimer                   compat_sys_setitimer
105     i386    getitimer               sys_getitimer                   compat_sys_getitimer
106     i386    stat                    sys_newstat                     compat_sys_newstat
107     i386    lstat                   sys_newlstat                    compat_sys_newlstat
108     i386    fstat                   sys_newfstat                    compat_sys_newfstat
109     i386    olduname                sys_uname
110     i386    iopl                    sys_iopl
111     i386    vhangup                 sys_vhangup
112     i386    idle
113     i386    vm86old                 sys_vm86old                     sys_ni_syscall
114     i386    wait4                   sys_wait4                       compat_sys_wait4
115     i386    swapoff                 sys_swapoff
116     i386    sysinfo                 sys_sysinfo                     compat_sys_sysinfo
117     i386    ipc                     sys_ipc                         compat_sys_ipc
118     i386    fsync                   sys_fsync
119     i386    sigreturn               sys_sigreturn                   compat_sys_sigreturn
120     i386    clone                   sys_clone                       compat_sys_ia32_clone
121     i386    setdomainname           sys_setdomainname
122     i386    uname                   sys_newuname
123     i386    modify_ldt              sys_modify_ldt
124     i386    adjtimex                sys_adjtimex_time32
125     i386    mprotect                sys_mprotect
126     i386    sigprocmask             sys_sigprocmask                 compat_sys_sigprocmask
127     i386    create_module
128     i386    init_module             sys_init_module
129     i386    delete_module           sys_delete_module
130     i386    get_kernel_syms
131     i386    quotactl                sys_quotactl
132     i386    getpgid                 sys_getpgid
133     i386    fchdir                  sys_fchdir
134     i386    bdflush                 sys_ni_syscall
135     i386    sysfs                   sys_sysfs
136     i386    personality             sys_personality
137     i386    afs_syscall
138     i386    setfsuid                sys_setfsuid16
139     i386    setfsgid                sys_setfsgid16
140     i386    _llseek                 sys_llseek
141     i386    getdents                sys_getdents                    compat_sys_getdents
142     i386    _newselect              sys_select                      compat_sys_select
143     i386    flock                   sys_flock
144     i386    msync                   sys_msync
145     i386    readv                   sys_readv
146     i386    writev                  sys_writev
147     i386    getsid                  sys_getsid
148     i386    fdatasync               sys_fdatasync
149     i386    _sysctl                 sys_ni_syscall
150     i386    mlock                   sys_mlock
151     i386    munlock                 sys_munlock
152     i386    mlockall                sys_mlockall
153     i386    munlockall              sys_munlockall
154     i386    sched_setparam          sys_sched_setparam
155     i386    sched_getparam          sys_sched_getparam
156     i386    sched_setscheduler      sys_sched_setscheduler
157     i386    sched_getscheduler      sys_sched_getscheduler
158     i386    sched_yield             sys_sched_yield
159     i386    sched_get_priority_max  sys_sched_get_priority_max
160     i386    sched_get_priority_min  sys_sched_get_priority_min
161     i386    sched_rr_get_interval   sys_sched_rr_get_interval_time32
162     i386    nanosleep               sys_nanosleep_time32
163     i386    mremap                  sys_mremap
164     i386    setresuid               sys_setresuid16
165     i386    getresuid               sys_getresuid16
166     i386    vm86                    sys_vm86                        sys_ni_syscall
167     i386    query_module
168     i386    poll                    sys_poll
169     i386    nfsservctl
170     i386    setresgid               sys_setresgid16
171     i386    getresgid               sys_getresgid16
172     i386    prctl                   sys_prctl
173     i386    rt_sigreturn            sys_rt_sigreturn                compat_sys_rt_sigreturn
174     i386    rt_sigaction            sys_rt_sigaction                compat_sys_rt_sigaction
175     i386    rt_sigprocmask          sys_rt_sigprocmask              compat_sys_rt_sigprocmask
176     i386    rt_sigpending           sys_rt_sigpending               compat_sys_rt_sigpending
177     i386    rt_sigtimedwait         sys_rt_sigtimedwait_time32      compat_sys_rt_sigtimedwait_time32
178     i386    rt_sigqueueinfo         sys_rt_sigqueueinfo             compat_sys_rt_sigqueueinfo
179     i386    rt_sigsuspend           sys_rt_sigsuspend               compat_sys_rt_sigsuspend
180     i386    pread64                 sys_ia32_pread64
181     i386    pwrite64                sys_ia32_pwrite64
182     i386    chown                   sys_chown16
183     i386    getcwd                  sys_getcwd
184     i386    capget                  sys_capget
185     i386    capset                  sys_capset
186     i386    sigaltstack             sys_sigaltstack                 compat_sys_sigaltstack
187     i386    sendfile                sys_sendfile                    compat_sys_sendfile
188     i386    getpmsg
189     i386    putpmsg
190     i386    vfork                   sys_vfork
191     i386    ugetrlimit              sys_getrlimit                   compat_sys_getrlimit
192     i386    mmap2                   sys_mmap_pgoff
193     i386    truncate64              sys_ia32_truncate64
194     i386    ftruncate64             sys_ia32_ftruncate64
195     i386    stat64                  sys_stat64                      compat_sys_ia32_stat64
196     i386    lstat64                 sys_lstat64                     compat_sys_ia32_lstat64
197     i386    fstat64                 sys_fstat64                     compat_sys_ia32_fstat64
198     i386    lchown32                sys_lchown
199     i386    getuid32                sys_getuid
200     i386    getgid32                sys_getgid
201     i386    geteuid32               sys_geteuid
202     i386    getegid32               sys_getegid
203     i386    setreuid32              sys_setreuid
204     i386    setregid32              sys_setregid
205     i386    getgroups32             sys_getgroups
206     i386    setgroups32             sys_setgroups
207     i386    fchown32                sys_fchown
208     i386    setresuid32             sys_setresuid
209     i386    getresuid32             sys_getresuid
210     i386    setresgid32             sys_setresgid
211     i386    getresgid32             sys_getresgid
212     i386    chown32                 sys_chown
213     i386    setuid32                sys_setuid
214     i386    setgid32                sys_setgid
215     i386    setfsuid32              sys_setfsuid
216     i386    setfsgid32              sys_setfsgid
217     i386    pivot_root              sys_pivot_root
218     i386    mincore                 sys_mincore
219     i386    madvise                 sys_madvise
220     i386    getdents64              sys_getdents64
221     i386    fcntl64                 sys_fcntl64                     compat_sys_fcntl64
# 222 is unused
# 223 is unused
224     i386    gettid                  sys_gettid
225     i386    readahead               sys_ia32_readahead
226     i386    setxattr                sys_setxattr
227     i386    lsetxattr               sys_lsetxattr
228     i386    fsetxattr               sys_fsetxattr
229     i386    getxattr                sys_getxattr
230     i386    lgetxattr               sys_lgetxattr
231     i386    fgetxattr               sys_fgetxattr
232     i386    listxattr               sys_listxattr
233     i386    llistxattr              sys_llistxattr
234     i386    flistxattr              sys_flistxattr
235     i386    removexattr             sys_removexattr
236     i386    lremovexattr            sys_lremovexattr
237     i386    fremovexattr            sys_fremovexattr
238     i386    tkill                   sys_tkill
239     i386    sendfile64              sys_sendfile64
240     i386    futex                   sys_futex_time32
241     i386    sched_setaffinity       sys_sched_setaffinity           compat_sys_sched_setaffinity
242     i386    sched_getaffinity       sys_sched_getaffinity           compat_sys_sched_getaffinity
243     i386    set_thread_area         sys_set_thread_area
244     i386    get_thread_area         sys_get_thread_area
245     i386    io_setup                sys_io_setup                    compat_sys_io_setup
246     i386    io_destroy              sys_io_destroy
247     i386    io_getevents            sys_io_getevents_time32
248     i386    io_submit               sys_io_submit                   compat_sys_io_submit
249     i386    io_cancel               sys_io_cancel
250     i386    fadvise64               sys_ia32_fadvise64
# 251 is available for reuse (was briefly sys_set_zone_reclaim)
252     i386    exit_group              sys_exit_group
253     i386    lookup_dcookie          sys_lookup_dcookie              compat_sys_lookup_dcookie
254     i386    epoll_create            sys_epoll_create
255     i386    epoll_ctl               sys_epoll_ctl
256     i386    epoll_wait              sys_epoll_wait
257     i386    remap_file_pages        sys_remap_file_pages
258     i386    set_tid_address         sys_set_tid_address
259     i386    timer_create            sys_timer_create                compat_sys_timer_create
260     i386    timer_settime           sys_timer_settime32
261     i386    timer_gettime           sys_timer_gettime32
262     i386    timer_getoverrun        sys_timer_getoverrun
263     i386    timer_delete            sys_timer_delete
264     i386    clock_settime           sys_clock_settime32
265     i386    clock_gettime           sys_clock_gettime32
266     i386    clock_getres            sys_clock_getres_time32
267     i386    clock_nanosleep         sys_clock_nanosleep_time32
268     i386    statfs64                sys_statfs64                    compat_sys_statfs64
269     i386    fstatfs64               sys_fstatfs64                   compat_sys_fstatfs64
270     i386    tgkill                  sys_tgkill
271     i386    utimes                  sys_utimes_time32
272     i386    fadvise64_64            sys_ia32_fadvise64_64
273     i386    vserver
274     i386    mbind                   sys_mbind
275     i386    get_mempolicy           sys_get_mempolicy
276     i386    set_mempolicy           sys_set_mempolicy
277     i386    mq_open                 sys_mq_open                     compat_sys_mq_open
278     i386    mq_unlink               sys_mq_unlink
279     i386    mq_timedsend            sys_mq_timedsend_time32
280     i386    mq_timedreceive         sys_mq_timedreceive_time32
281     i386    mq_notify               sys_mq_notify                   compat_sys_mq_notify
282     i386    mq_getsetattr           sys_mq_getsetattr               compat_sys_mq_getsetattr
283     i386    kexec_load              sys_kexec_load                  compat_sys_kexec_load
284     i386    waitid                  sys_waitid                      compat_sys_waitid
# 285 sys_setaltroot
286     i386    add_key                 sys_add_key
287     i386    request_key             sys_request_key
288     i386    keyctl                  sys_keyctl                      compat_sys_keyctl
289     i386    ioprio_set              sys_ioprio_set
290     i386    ioprio_get              sys_ioprio_get
291     i386    inotify_init            sys_inotify_init
292     i386    inotify_add_watch       sys_inotify_add_watch
293     i386    inotify_rm_watch        sys_inotify_rm_watch
294     i386    migrate_pages           sys_migrate_pages
295     i386    openat                  sys_openat                      compat_sys_openat
296     i386    mkdirat                 sys_mkdirat
297     i386    mknodat                 sys_mknodat
298     i386    fchownat                sys_fchownat
299     i386    futimesat               sys_futimesat_time32
300     i386    fstatat64               sys_fstatat64                   compat_sys_ia32_fstatat64
301     i386    unlinkat                sys_unlinkat
302     i386    renameat                sys_renameat
303     i386    linkat                  sys_linkat
304     i386    symlinkat               sys_symlinkat
305     i386    readlinkat              sys_readlinkat
306     i386    fchmodat                sys_fchmodat
307     i386    faccessat               sys_faccessat
308     i386    pselect6                sys_pselect6_time32             compat_sys_pselect6_time32
309     i386    ppoll                   sys_ppoll_time32                compat_sys_ppoll_time32
310     i386    unshare                 sys_unshare
311     i386    set_robust_list         sys_set_robust_list             compat_sys_set_robust_list
312     i386    get_robust_list         sys_get_robust_list             compat_sys_get_robust_list
313     i386    splice                  sys_splice
314     i386    sync_file_range         sys_ia32_sync_file_range
315     i386    tee                     sys_tee
316     i386    vmsplice                sys_vmsplice
317     i386    move_pages              sys_move_pages
318     i386    getcpu                  sys_getcpu
319     i386    epoll_pwait             sys_epoll_pwait
320     i386    utimensat               sys_utimensat_time32
321     i386    signalfd                sys_signalfd                    compat_sys_signalfd
322     i386    timerfd_create          sys_timerfd_create
323     i386    eventfd                 sys_eventfd
324     i386    fallocate               sys_ia32_fallocate
325     i386    timerfd_settime         sys_timerfd_settime32
326     i386    timerfd_gettime         sys_timerfd_gettime32
327     i386    signalfd4               sys_signalfd4                   compat_sys_signalfd4
328     i386    eventfd2                sys_eventfd2
329     i386    epoll_create1           sys_epoll_create1
330     i386    dup3                    sys_dup3
331     i386    pipe2                   sys_pipe2
332     i386    inotify_init1           sys_inotify_init1
333     i386    preadv                  sys_preadv                      compat_sys_preadv
334     i386    pwritev                 sys_pwritev                     compat_sys_pwritev
335     i386    rt_tgsigqueueinfo       sys_rt_tgsigqueueinfo           compat_sys_rt_tgsigqueueinfo
336     i386    perf_event_open         sys_perf_event_open
337     i386    recvmmsg                sys_recvmmsg_time32             compat_sys_recvmmsg_time32
338     i386    fanotify_init           sys_fanotify_init
339     i386    fanotify_mark           sys_fanotify_mark               compat_sys_fanotify_mark
340     i386    prlimit64               sys_prlimit64
341     i386    name_to_handle_at       sys_name_to_handle_at
342     i386    open_by_handle_at       sys_open_by_handle_at           compat_sys_open_by_handle_at
343     i386    clock_adjtime           sys_clock_adjtime32
344     i386    syncfs                  sys_syncfs
345     i386    sendmmsg                sys_sendmmsg                    compat_sys_sendmmsg
346     i386    setns                   sys_setns
347     i386    process_vm_readv        sys_process_vm_readv
348     i386    process_vm_writev       sys_process_vm_writev
349     i386    kcmp                    sys_kcmp
350     i386    finit_module            sys_finit_module
351     i386    sched_setattr           sys_sched_setattr
352     i386    sched_getattr           sys_sched_getattr
353     i386    renameat2               sys_renameat2
354     i386    seccomp                 sys_seccomp
355     i386    getrandom               sys_getrandom
356     i386    memfd_create            sys_memfd_create
357     i386    bpf                     sys_bpf
358     i386    execveat                sys_execveat                    compat_sys_execveat
359     i386    socket                  sys_socket
360     i386    socketpair              sys_socketpair
361     i386    bind                    sys_bind
362     i386    connect                 sys_connect
363     i386    listen                  sys_listen
364     i386    accept4                 sys_accept4
365     i386    getsockopt              sys_getsockopt                  sys_getsockopt
366     i386    setsockopt              sys_setsockopt                  sys_setsockopt
367     i386    getsockname             sys_getsockname
368     i386    getpeername             sys_getpeername
369     i386    sendto                  sys_sendto
370     i386    sendmsg                 sys_sendmsg                     compat_sys_sendmsg
371     i386    recvfrom                sys_recvfrom                    compat_sys_recvfrom
372     i386    recvmsg                 sys_recvmsg                     compat_sys_recvmsg
373     i386    shutdown                sys_shutdown
374     i386    userfaultfd             sys_userfaultfd
375     i386    membarrier              sys_membarrier
376     i386    mlock2                  sys_mlock2
377     i386    copy_file_range         sys_copy_file_range
378     i386    preadv2                 sys_preadv2                     compat_sys_preadv2
379     i386    pwritev2                sys_pwritev2                    compat_sys_pwritev2
380     i386    pkey_mprotect           sys_pkey_mprotect
381     i386    pkey_alloc              sys_pkey_alloc
382     i386    pkey_free               sys_pkey_free
383     i386    statx                   sys_statx
384     i386    arch_prctl              sys_arch_prctl                  compat_sys_arch_prctl
385     i386    io_pgetevents           sys_io_pgetevents_time32        compat_sys_io_pgetevents
386     i386    rseq                    sys_rseq
393     i386    semget                  sys_semget
394     i386    semctl                  sys_semctl                      compat_sys_semctl
395     i386    shmget                  sys_shmget
396     i386    shmctl                  sys_shmctl                      compat_sys_shmctl
397     i386    shmat                   sys_shmat                       compat_sys_shmat
398     i386    shmdt                   sys_shmdt
399     i386    msgget                  sys_msgget
400     i386    msgsnd                  sys_msgsnd                      compat_sys_msgsnd
401     i386    msgrcv                  sys_msgrcv                      compat_sys_msgrcv
402     i386    msgctl                  sys_msgctl                      compat_sys_msgctl
403     i386    clock_gettime64         sys_clock_gettime
404     i386    clock_settime64         sys_clock_settime
405     i386    clock_adjtime64         sys_clock_adjtime
406     i386    clock_getres_time64     sys_clock_getres
407     i386    clock_nanosleep_time64  sys_clock_nanosleep
408     i386    timer_gettime64         sys_timer_gettime
409     i386    timer_settime64         sys_timer_settime
410     i386    timerfd_gettime64       sys_timerfd_gettime
411     i386    timerfd_settime64       sys_timerfd_settime
412     i386    utimensat_time64        sys_utimensat
413     i386    pselect6_time64         sys_pselect6                    compat_sys_pselect6_time64
414     i386    ppoll_time64            sys_ppoll                       compat_sys_ppoll_time64
416     i386    io_pgetevents_time64    sys_io_pgetevents
417     i386    recvmmsg_time64         sys_recvmmsg                    compat_sys_recvmmsg_time64
418     i386    mq_timedsend_time64     sys_mq_timedsend
419     i386    mq_timedreceive_time64  sys_mq_timedreceive
420     i386    semtimedop_time64       sys_semtimedop
421     i386    rt_sigtimedwait_time64  sys_rt_sigtimedwait             compat_sys_rt_sigtimedwait_time64
422     i386    futex_time64            sys_futex
423     i386    sched_rr_get_interval_time64    sys_sched_rr_get_interval
424     i386    pidfd_send_signal       sys_pidfd_send_signal
425     i386    io_uring_setup          sys_io_uring_setup
426     i386    io_uring_enter          sys_io_uring_enter
427     i386    io_uring_register       sys_io_uring_register
428     i386    open_tree               sys_open_tree
429     i386    move_mount              sys_move_mount
430     i386    fsopen                  sys_fsopen
431     i386    fsconfig                sys_fsconfig
432     i386    fsmount                 sys_fsmount
433     i386    fspick                  sys_fspick
434     i386    pidfd_open              sys_pidfd_open
435     i386    clone3                  sys_clone3
436     i386    close_range             sys_close_range
437     i386    openat2                 sys_openat2
438     i386    pidfd_getfd             sys_pidfd_getfd
439     i386    faccessat2              sys_faccessat2
440     i386    process_madvise         sys_process_madvise
441     i386    epoll_pwait2            sys_epoll_pwait2                compat_sys_epoll_pwait2
442     i386    mount_setattr           sys_mount_setattr
443     i386    quotactl_fd             sys_quotactl_fd
444     i386    landlock_create_ruleset sys_landlock_create_ruleset
445     i386    landlock_add_rule       sys_landlock_add_rule
446     i386    landlock_restrict_self  sys_landlock_restrict_self
447     i386    memfd_secret            sys_memfd_secret
448     i386    process_mrelease        sys_process_mrelease
449     i386    futex_waitv             sys_futex_waitv
450     i386    set_mempolicy_home_node         sys_set_mempolicy_home_node
"""


# ARM64
#
# [How to make]
# cd /path/to/linux-6.*/
# gcc -I `pwd`/include/uapi/ -E -D__SYSCALL=SYSCALL arch/arm64/include/uapi/asm/unistd.h | grep ^SYSCALL | sed -e 's/SYSCALL(//;s/[,)]//g' > /tmp/a
# grep -oP "__NR\S+\s+\d+$" include/uapi/asm-generic/unistd.h | grep -v __NR_sync_file_range2 > /tmp/b
# join -2 2 -o 1.1,1.10,2.1,1.2 -e arm64 /tmp/a /tmp/b | sed -e 's/\(__NR_\|__NR3264_\)//g' | column -t
#
arm64_syscall_tbl = """
0    arm64  io_setup                 sys_io_setup
1    arm64  io_destroy               sys_io_destroy
2    arm64  io_submit                sys_io_submit
3    arm64  io_cancel                sys_io_cancel
4    arm64  io_getevents             sys_io_getevents
5    arm64  setxattr                 sys_setxattr
6    arm64  lsetxattr                sys_lsetxattr
7    arm64  fsetxattr                sys_fsetxattr
8    arm64  getxattr                 sys_getxattr
9    arm64  lgetxattr                sys_lgetxattr
10   arm64  fgetxattr                sys_fgetxattr
11   arm64  listxattr                sys_listxattr
12   arm64  llistxattr               sys_llistxattr
13   arm64  flistxattr               sys_flistxattr
14   arm64  removexattr              sys_removexattr
15   arm64  lremovexattr             sys_lremovexattr
16   arm64  fremovexattr             sys_fremovexattr
17   arm64  getcwd                   sys_getcwd
18   arm64  lookup_dcookie           sys_lookup_dcookie
19   arm64  eventfd2                 sys_eventfd2
20   arm64  epoll_create1            sys_epoll_create1
21   arm64  epoll_ctl                sys_epoll_ctl
22   arm64  epoll_pwait              sys_epoll_pwait
23   arm64  dup                      sys_dup
24   arm64  dup3                     sys_dup3
25   arm64  fcntl                    sys_fcntl
26   arm64  inotify_init1            sys_inotify_init1
27   arm64  inotify_add_watch        sys_inotify_add_watch
28   arm64  inotify_rm_watch         sys_inotify_rm_watch
29   arm64  ioctl                    sys_ioctl
30   arm64  ioprio_set               sys_ioprio_set
31   arm64  ioprio_get               sys_ioprio_get
32   arm64  flock                    sys_flock
33   arm64  mknodat                  sys_mknodat
34   arm64  mkdirat                  sys_mkdirat
35   arm64  unlinkat                 sys_unlinkat
36   arm64  symlinkat                sys_symlinkat
37   arm64  linkat                   sys_linkat
38   arm64  renameat                 sys_renameat
39   arm64  umount2                  sys_umount
40   arm64  mount                    sys_mount
41   arm64  pivot_root               sys_pivot_root
42   arm64  nfsservctl               sys_ni_syscall
43   arm64  statfs                   sys_statfs
44   arm64  fstatfs                  sys_fstatfs
45   arm64  truncate                 sys_truncate
46   arm64  ftruncate                sys_ftruncate
47   arm64  fallocate                sys_fallocate
48   arm64  faccessat                sys_faccessat
49   arm64  chdir                    sys_chdir
50   arm64  fchdir                   sys_fchdir
51   arm64  chroot                   sys_chroot
52   arm64  fchmod                   sys_fchmod
53   arm64  fchmodat                 sys_fchmodat
54   arm64  fchownat                 sys_fchownat
55   arm64  fchown                   sys_fchown
56   arm64  openat                   sys_openat
57   arm64  close                    sys_close
58   arm64  vhangup                  sys_vhangup
59   arm64  pipe2                    sys_pipe2
60   arm64  quotactl                 sys_quotactl
61   arm64  getdents64               sys_getdents64
62   arm64  lseek                    sys_lseek
63   arm64  read                     sys_read
64   arm64  write                    sys_write
65   arm64  readv                    sys_readv
66   arm64  writev                   sys_writev
67   arm64  pread64                  sys_pread64
68   arm64  pwrite64                 sys_pwrite64
69   arm64  preadv                   sys_preadv
70   arm64  pwritev                  sys_pwritev
71   arm64  sendfile                 sys_sendfile64
72   arm64  pselect6                 sys_pselect6
73   arm64  ppoll                    sys_ppoll
74   arm64  signalfd4                sys_signalfd4
75   arm64  vmsplice                 sys_vmsplice
76   arm64  splice                   sys_splice
77   arm64  tee                      sys_tee
78   arm64  readlinkat               sys_readlinkat
79   arm64  fstatat                  sys_newfstatat
80   arm64  fstat                    sys_newfstat
81   arm64  sync                     sys_sync
82   arm64  fsync                    sys_fsync
83   arm64  fdatasync                sys_fdatasync
84   arm64  sync_file_range          sys_sync_file_range
85   arm64  timerfd_create           sys_timerfd_create
86   arm64  timerfd_settime          sys_timerfd_settime
87   arm64  timerfd_gettime          sys_timerfd_gettime
88   arm64  utimensat                sys_utimensat
89   arm64  acct                     sys_acct
90   arm64  capget                   sys_capget
91   arm64  capset                   sys_capset
92   arm64  personality              sys_personality
93   arm64  exit                     sys_exit
94   arm64  exit_group               sys_exit_group
95   arm64  waitid                   sys_waitid
96   arm64  set_tid_address          sys_set_tid_address
97   arm64  unshare                  sys_unshare
98   arm64  futex                    sys_futex
99   arm64  set_robust_list          sys_set_robust_list
100  arm64  get_robust_list          sys_get_robust_list
101  arm64  nanosleep                sys_nanosleep
102  arm64  getitimer                sys_getitimer
103  arm64  setitimer                sys_setitimer
104  arm64  kexec_load               sys_kexec_load
105  arm64  init_module              sys_init_module
106  arm64  delete_module            sys_delete_module
107  arm64  timer_create             sys_timer_create
108  arm64  timer_gettime            sys_timer_gettime
109  arm64  timer_getoverrun         sys_timer_getoverrun
110  arm64  timer_settime            sys_timer_settime
111  arm64  timer_delete             sys_timer_delete
112  arm64  clock_settime            sys_clock_settime
113  arm64  clock_gettime            sys_clock_gettime
114  arm64  clock_getres             sys_clock_getres
115  arm64  clock_nanosleep          sys_clock_nanosleep
116  arm64  syslog                   sys_syslog
117  arm64  ptrace                   sys_ptrace
118  arm64  sched_setparam           sys_sched_setparam
119  arm64  sched_setscheduler       sys_sched_setscheduler
120  arm64  sched_getscheduler       sys_sched_getscheduler
121  arm64  sched_getparam           sys_sched_getparam
122  arm64  sched_setaffinity        sys_sched_setaffinity
123  arm64  sched_getaffinity        sys_sched_getaffinity
124  arm64  sched_yield              sys_sched_yield
125  arm64  sched_get_priority_max   sys_sched_get_priority_max
126  arm64  sched_get_priority_min   sys_sched_get_priority_min
127  arm64  sched_rr_get_interval    sys_sched_rr_get_interval
128  arm64  restart_syscall          sys_restart_syscall
129  arm64  kill                     sys_kill
130  arm64  tkill                    sys_tkill
131  arm64  tgkill                   sys_tgkill
132  arm64  sigaltstack              sys_sigaltstack
133  arm64  rt_sigsuspend            sys_rt_sigsuspend
134  arm64  rt_sigaction             sys_rt_sigaction
135  arm64  rt_sigprocmask           sys_rt_sigprocmask
136  arm64  rt_sigpending            sys_rt_sigpending
137  arm64  rt_sigtimedwait          sys_rt_sigtimedwait
138  arm64  rt_sigqueueinfo          sys_rt_sigqueueinfo
139  arm64  rt_sigreturn             sys_rt_sigreturn
140  arm64  setpriority              sys_setpriority
141  arm64  getpriority              sys_getpriority
142  arm64  reboot                   sys_reboot
143  arm64  setregid                 sys_setregid
144  arm64  setgid                   sys_setgid
145  arm64  setreuid                 sys_setreuid
146  arm64  setuid                   sys_setuid
147  arm64  setresuid                sys_setresuid
148  arm64  getresuid                sys_getresuid
149  arm64  setresgid                sys_setresgid
150  arm64  getresgid                sys_getresgid
151  arm64  setfsuid                 sys_setfsuid
152  arm64  setfsgid                 sys_setfsgid
153  arm64  times                    sys_times
154  arm64  setpgid                  sys_setpgid
155  arm64  getpgid                  sys_getpgid
156  arm64  getsid                   sys_getsid
157  arm64  setsid                   sys_setsid
158  arm64  getgroups                sys_getgroups
159  arm64  setgroups                sys_setgroups
160  arm64  uname                    sys_newuname
161  arm64  sethostname              sys_sethostname
162  arm64  setdomainname            sys_setdomainname
163  arm64  getrlimit                sys_getrlimit
164  arm64  setrlimit                sys_setrlimit
165  arm64  getrusage                sys_getrusage
166  arm64  umask                    sys_umask
167  arm64  prctl                    sys_prctl
168  arm64  getcpu                   sys_getcpu
169  arm64  gettimeofday             sys_gettimeofday
170  arm64  settimeofday             sys_settimeofday
171  arm64  adjtimex                 sys_adjtimex
172  arm64  getpid                   sys_getpid
173  arm64  getppid                  sys_getppid
174  arm64  getuid                   sys_getuid
175  arm64  geteuid                  sys_geteuid
176  arm64  getgid                   sys_getgid
177  arm64  getegid                  sys_getegid
178  arm64  gettid                   sys_gettid
179  arm64  sysinfo                  sys_sysinfo
180  arm64  mq_open                  sys_mq_open
181  arm64  mq_unlink                sys_mq_unlink
182  arm64  mq_timedsend             sys_mq_timedsend
183  arm64  mq_timedreceive          sys_mq_timedreceive
184  arm64  mq_notify                sys_mq_notify
185  arm64  mq_getsetattr            sys_mq_getsetattr
186  arm64  msgget                   sys_msgget
187  arm64  msgctl                   sys_msgctl
188  arm64  msgrcv                   sys_msgrcv
189  arm64  msgsnd                   sys_msgsnd
190  arm64  semget                   sys_semget
191  arm64  semctl                   sys_semctl
192  arm64  semtimedop               sys_semtimedop
193  arm64  semop                    sys_semop
194  arm64  shmget                   sys_shmget
195  arm64  shmctl                   sys_shmctl
196  arm64  shmat                    sys_shmat
197  arm64  shmdt                    sys_shmdt
198  arm64  socket                   sys_socket
199  arm64  socketpair               sys_socketpair
200  arm64  bind                     sys_bind
201  arm64  listen                   sys_listen
202  arm64  accept                   sys_accept
203  arm64  connect                  sys_connect
204  arm64  getsockname              sys_getsockname
205  arm64  getpeername              sys_getpeername
206  arm64  sendto                   sys_sendto
207  arm64  recvfrom                 sys_recvfrom
208  arm64  setsockopt               sys_setsockopt
209  arm64  getsockopt               sys_getsockopt
210  arm64  shutdown                 sys_shutdown
211  arm64  sendmsg                  sys_sendmsg
212  arm64  recvmsg                  sys_recvmsg
213  arm64  readahead                sys_readahead
214  arm64  brk                      sys_brk
215  arm64  munmap                   sys_munmap
216  arm64  mremap                   sys_mremap
217  arm64  add_key                  sys_add_key
218  arm64  request_key              sys_request_key
219  arm64  keyctl                   sys_keyctl
220  arm64  clone                    sys_clone
221  arm64  execve                   sys_execve
222  arm64  mmap                     sys_mmap
223  arm64  fadvise64                sys_fadvise64_64
224  arm64  swapon                   sys_swapon
225  arm64  swapoff                  sys_swapoff
226  arm64  mprotect                 sys_mprotect
227  arm64  msync                    sys_msync
228  arm64  mlock                    sys_mlock
229  arm64  munlock                  sys_munlock
230  arm64  mlockall                 sys_mlockall
231  arm64  munlockall               sys_munlockall
232  arm64  mincore                  sys_mincore
233  arm64  madvise                  sys_madvise
234  arm64  remap_file_pages         sys_remap_file_pages
235  arm64  mbind                    sys_mbind
236  arm64  get_mempolicy            sys_get_mempolicy
237  arm64  set_mempolicy            sys_set_mempolicy
238  arm64  migrate_pages            sys_migrate_pages
239  arm64  move_pages               sys_move_pages
240  arm64  rt_tgsigqueueinfo        sys_rt_tgsigqueueinfo
241  arm64  perf_event_open          sys_perf_event_open
242  arm64  accept4                  sys_accept4
243  arm64  recvmmsg                 sys_recvmmsg
260  arm64  wait4                    sys_wait4
261  arm64  prlimit64                sys_prlimit64
262  arm64  fanotify_init            sys_fanotify_init
263  arm64  fanotify_mark            sys_fanotify_mark
264  arm64  name_to_handle_at        sys_name_to_handle_at
265  arm64  open_by_handle_at        sys_open_by_handle_at
266  arm64  clock_adjtime            sys_clock_adjtime
267  arm64  syncfs                   sys_syncfs
268  arm64  setns                    sys_setns
269  arm64  sendmmsg                 sys_sendmmsg
270  arm64  process_vm_readv         sys_process_vm_readv
271  arm64  process_vm_writev        sys_process_vm_writev
272  arm64  kcmp                     sys_kcmp
273  arm64  finit_module             sys_finit_module
274  arm64  sched_setattr            sys_sched_setattr
275  arm64  sched_getattr            sys_sched_getattr
276  arm64  renameat2                sys_renameat2
277  arm64  seccomp                  sys_seccomp
278  arm64  getrandom                sys_getrandom
279  arm64  memfd_create             sys_memfd_create
280  arm64  bpf                      sys_bpf
281  arm64  execveat                 sys_execveat
282  arm64  userfaultfd              sys_userfaultfd
283  arm64  membarrier               sys_membarrier
284  arm64  mlock2                   sys_mlock2
285  arm64  copy_file_range          sys_copy_file_range
286  arm64  preadv2                  sys_preadv2
287  arm64  pwritev2                 sys_pwritev2
288  arm64  pkey_mprotect            sys_pkey_mprotect
289  arm64  pkey_alloc               sys_pkey_alloc
290  arm64  pkey_free                sys_pkey_free
291  arm64  statx                    sys_statx
292  arm64  io_pgetevents            sys_io_pgetevents
293  arm64  rseq                     sys_rseq
294  arm64  kexec_file_load          sys_kexec_file_load
424  arm64  pidfd_send_signal        sys_pidfd_send_signal
425  arm64  io_uring_setup           sys_io_uring_setup
426  arm64  io_uring_enter           sys_io_uring_enter
427  arm64  io_uring_register        sys_io_uring_register
428  arm64  open_tree                sys_open_tree
429  arm64  move_mount               sys_move_mount
430  arm64  fsopen                   sys_fsopen
431  arm64  fsconfig                 sys_fsconfig
432  arm64  fsmount                  sys_fsmount
433  arm64  fspick                   sys_fspick
434  arm64  pidfd_open               sys_pidfd_open
435  arm64  clone3                   sys_clone3
436  arm64  close_range              sys_close_range
437  arm64  openat2                  sys_openat2
438  arm64  pidfd_getfd              sys_pidfd_getfd
439  arm64  faccessat2               sys_faccessat2
440  arm64  process_madvise          sys_process_madvise
441  arm64  epoll_pwait2             sys_epoll_pwait2
442  arm64  mount_setattr            sys_mount_setattr
443  arm64  quotactl_fd              sys_quotactl_fd
444  arm64  landlock_create_ruleset  sys_landlock_create_ruleset
445  arm64  landlock_add_rule        sys_landlock_add_rule
446  arm64  landlock_restrict_self   sys_landlock_restrict_self
447  arm64  memfd_secret             sys_memfd_secret
448  arm64  process_mrelease         sys_process_mrelease
449  arm64  futex_waitv              sys_futex_waitv
450  arm64  set_mempolicy_home_node  sys_set_mempolicy_home_node
"""


# ARM (compat(emulated))
#
# [How to make]
# cd /path/to/linux-6.*/
# gcc -E -D__SYSCALL=SYSCALL arch/arm64/include/asm/unistd32.h | grep ^SYSCALL | sed -e 's/SYSCALL(//;s/[,)]//g' > /tmp/a
# grep -oP "__NR\S+\s+\d+" arch/arm64/include/asm/unistd32.h > /tmp/b
# join -2 2 -o 1.1,1.10,2.1,1.2 -e arm /tmp/a /tmp/b | sed -e 's/__NR_//g' | column -t
#
arm_compat_syscall_tbl = """
0    arm  restart_syscall               sys_restart_syscall
1    arm  exit                          sys_exit
2    arm  fork                          sys_fork
3    arm  read                          sys_read
4    arm  write                         sys_write
5    arm  open                          compat_sys_open
6    arm  close                         sys_close
8    arm  creat                         sys_creat
9    arm  link                          sys_link
10   arm  unlink                        sys_unlink
11   arm  execve                        compat_sys_execve
12   arm  chdir                         sys_chdir
14   arm  mknod                         sys_mknod
15   arm  chmod                         sys_chmod
16   arm  lchown                        sys_lchown16
19   arm  lseek                         compat_sys_lseek
20   arm  getpid                        sys_getpid
21   arm  mount                         sys_mount
23   arm  setuid                        sys_setuid16
24   arm  getuid                        sys_getuid16
26   arm  ptrace                        compat_sys_ptrace
29   arm  pause                         sys_pause
33   arm  access                        sys_access
34   arm  nice                          sys_nice
36   arm  sync                          sys_sync
37   arm  kill                          sys_kill
38   arm  rename                        sys_rename
39   arm  mkdir                         sys_mkdir
40   arm  rmdir                         sys_rmdir
41   arm  dup                           sys_dup
42   arm  pipe                          sys_pipe
43   arm  times                         compat_sys_times
45   arm  brk                           sys_brk
46   arm  setgid                        sys_setgid16
47   arm  getgid                        sys_getgid16
49   arm  geteuid                       sys_geteuid16
50   arm  getegid                       sys_getegid16
51   arm  acct                          sys_acct
52   arm  umount2                       sys_umount
54   arm  ioctl                         compat_sys_ioctl
55   arm  fcntl                         compat_sys_fcntl
57   arm  setpgid                       sys_setpgid
60   arm  umask                         sys_umask
61   arm  chroot                        sys_chroot
62   arm  ustat                         compat_sys_ustat
63   arm  dup2                          sys_dup2
64   arm  getppid                       sys_getppid
65   arm  getpgrp                       sys_getpgrp
66   arm  setsid                        sys_setsid
67   arm  sigaction                     compat_sys_sigaction
70   arm  setreuid                      sys_setreuid16
71   arm  setregid                      sys_setregid16
72   arm  sigsuspend                    sys_sigsuspend
73   arm  sigpending                    compat_sys_sigpending
74   arm  sethostname                   sys_sethostname
75   arm  setrlimit                     compat_sys_setrlimit
77   arm  getrusage                     compat_sys_getrusage
78   arm  gettimeofday                  compat_sys_gettimeofday
79   arm  settimeofday                  compat_sys_settimeofday
80   arm  getgroups                     sys_getgroups16
81   arm  setgroups                     sys_setgroups16
83   arm  symlink                       sys_symlink
85   arm  readlink                      sys_readlink
86   arm  uselib                        sys_uselib
87   arm  swapon                        sys_swapon
88   arm  reboot                        sys_reboot
91   arm  munmap                        sys_munmap
92   arm  truncate                      compat_sys_truncate
93   arm  ftruncate                     compat_sys_ftruncate
94   arm  fchmod                        sys_fchmod
95   arm  fchown                        sys_fchown16
96   arm  getpriority                   sys_getpriority
97   arm  setpriority                   sys_setpriority
99   arm  statfs                        compat_sys_statfs
100  arm  fstatfs                       compat_sys_fstatfs
103  arm  syslog                        sys_syslog
104  arm  setitimer                     compat_sys_setitimer
105  arm  getitimer                     compat_sys_getitimer
106  arm  stat                          compat_sys_newstat
107  arm  lstat                         compat_sys_newlstat
108  arm  fstat                         compat_sys_newfstat
111  arm  vhangup                       sys_vhangup
114  arm  wait4                         compat_sys_wait4
115  arm  swapoff                       sys_swapoff
116  arm  sysinfo                       compat_sys_sysinfo
118  arm  fsync                         sys_fsync
119  arm  sigreturn                     compat_sys_sigreturn
120  arm  clone                         sys_clone
121  arm  setdomainname                 sys_setdomainname
122  arm  uname                         sys_newuname
124  arm  adjtimex                      sys_adjtimex_time32
125  arm  mprotect                      sys_mprotect
126  arm  sigprocmask                   compat_sys_sigprocmask
128  arm  init_module                   sys_init_module
129  arm  delete_module                 sys_delete_module
131  arm  quotactl                      sys_quotactl
132  arm  getpgid                       sys_getpgid
133  arm  fchdir                        sys_fchdir
134  arm  bdflush                       sys_ni_syscall
135  arm  sysfs                         sys_sysfs
136  arm  personality                   sys_personality
138  arm  setfsuid                      sys_setfsuid16
139  arm  setfsgid                      sys_setfsgid16
140  arm  _llseek                       sys_llseek
141  arm  getdents                      compat_sys_getdents
142  arm  _newselect                    compat_sys_select
143  arm  flock                         sys_flock
144  arm  msync                         sys_msync
145  arm  readv                         sys_readv
146  arm  writev                        sys_writev
147  arm  getsid                        sys_getsid
148  arm  fdatasync                     sys_fdatasync
150  arm  mlock                         sys_mlock
151  arm  munlock                       sys_munlock
152  arm  mlockall                      sys_mlockall
153  arm  munlockall                    sys_munlockall
154  arm  sched_setparam                sys_sched_setparam
155  arm  sched_getparam                sys_sched_getparam
156  arm  sched_setscheduler            sys_sched_setscheduler
157  arm  sched_getscheduler            sys_sched_getscheduler
158  arm  sched_yield                   sys_sched_yield
159  arm  sched_get_priority_max        sys_sched_get_priority_max
160  arm  sched_get_priority_min        sys_sched_get_priority_min
161  arm  sched_rr_get_interval         sys_sched_rr_get_interval_time32
162  arm  nanosleep                     sys_nanosleep_time32
163  arm  mremap                        sys_mremap
164  arm  setresuid                     sys_setresuid16
165  arm  getresuid                     sys_getresuid16
168  arm  poll                          sys_poll
169  arm  nfsservctl                    sys_ni_syscall
170  arm  setresgid                     sys_setresgid16
171  arm  getresgid                     sys_getresgid16
172  arm  prctl                         sys_prctl
173  arm  rt_sigreturn                  compat_sys_rt_sigreturn
174  arm  rt_sigaction                  compat_sys_rt_sigaction
175  arm  rt_sigprocmask                compat_sys_rt_sigprocmask
176  arm  rt_sigpending                 compat_sys_rt_sigpending
177  arm  rt_sigtimedwait               compat_sys_rt_sigtimedwait_time32
178  arm  rt_sigqueueinfo               compat_sys_rt_sigqueueinfo
179  arm  rt_sigsuspend                 compat_sys_rt_sigsuspend
180  arm  pread64                       compat_sys_aarch32_pread64
181  arm  pwrite64                      compat_sys_aarch32_pwrite64
182  arm  chown                         sys_chown16
183  arm  getcwd                        sys_getcwd
184  arm  capget                        sys_capget
185  arm  capset                        sys_capset
186  arm  sigaltstack                   compat_sys_sigaltstack
187  arm  sendfile                      compat_sys_sendfile
190  arm  vfork                         sys_vfork
191  arm  ugetrlimit                    compat_sys_getrlimit
192  arm  mmap2                         compat_sys_aarch32_mmap2
193  arm  truncate64                    compat_sys_aarch32_truncate64
194  arm  ftruncate64                   compat_sys_aarch32_ftruncate64
195  arm  stat64                        sys_stat64
196  arm  lstat64                       sys_lstat64
197  arm  fstat64                       sys_fstat64
198  arm  lchown32                      sys_lchown
199  arm  getuid32                      sys_getuid
200  arm  getgid32                      sys_getgid
201  arm  geteuid32                     sys_geteuid
202  arm  getegid32                     sys_getegid
203  arm  setreuid32                    sys_setreuid
204  arm  setregid32                    sys_setregid
205  arm  getgroups32                   sys_getgroups
206  arm  setgroups32                   sys_setgroups
207  arm  fchown32                      sys_fchown
208  arm  setresuid32                   sys_setresuid
209  arm  getresuid32                   sys_getresuid
210  arm  setresgid32                   sys_setresgid
211  arm  getresgid32                   sys_getresgid
212  arm  chown32                       sys_chown
213  arm  setuid32                      sys_setuid
214  arm  setgid32                      sys_setgid
215  arm  setfsuid32                    sys_setfsuid
216  arm  setfsgid32                    sys_setfsgid
217  arm  getdents64                    sys_getdents64
218  arm  pivot_root                    sys_pivot_root
219  arm  mincore                       sys_mincore
220  arm  madvise                       sys_madvise
221  arm  fcntl64                       compat_sys_fcntl64
224  arm  gettid                        sys_gettid
225  arm  readahead                     compat_sys_aarch32_readahead
226  arm  setxattr                      sys_setxattr
227  arm  lsetxattr                     sys_lsetxattr
228  arm  fsetxattr                     sys_fsetxattr
229  arm  getxattr                      sys_getxattr
230  arm  lgetxattr                     sys_lgetxattr
231  arm  fgetxattr                     sys_fgetxattr
232  arm  listxattr                     sys_listxattr
233  arm  llistxattr                    sys_llistxattr
234  arm  flistxattr                    sys_flistxattr
235  arm  removexattr                   sys_removexattr
236  arm  lremovexattr                  sys_lremovexattr
237  arm  fremovexattr                  sys_fremovexattr
238  arm  tkill                         sys_tkill
239  arm  sendfile64                    sys_sendfile64
240  arm  futex                         sys_futex_time32
241  arm  sched_setaffinity             compat_sys_sched_setaffinity
242  arm  sched_getaffinity             compat_sys_sched_getaffinity
243  arm  io_setup                      compat_sys_io_setup
244  arm  io_destroy                    sys_io_destroy
245  arm  io_getevents                  sys_io_getevents_time32
246  arm  io_submit                     compat_sys_io_submit
247  arm  io_cancel                     sys_io_cancel
248  arm  exit_group                    sys_exit_group
249  arm  lookup_dcookie                compat_sys_lookup_dcookie
250  arm  epoll_create                  sys_epoll_create
251  arm  epoll_ctl                     sys_epoll_ctl
252  arm  epoll_wait                    sys_epoll_wait
253  arm  remap_file_pages              sys_remap_file_pages
256  arm  set_tid_address               sys_set_tid_address
257  arm  timer_create                  compat_sys_timer_create
258  arm  timer_settime                 sys_timer_settime32
259  arm  timer_gettime                 sys_timer_gettime32
260  arm  timer_getoverrun              sys_timer_getoverrun
261  arm  timer_delete                  sys_timer_delete
262  arm  clock_settime                 sys_clock_settime32
263  arm  clock_gettime                 sys_clock_gettime32
264  arm  clock_getres                  sys_clock_getres_time32
265  arm  clock_nanosleep               sys_clock_nanosleep_time32
266  arm  statfs64                      compat_sys_aarch32_statfs64
267  arm  fstatfs64                     compat_sys_aarch32_fstatfs64
268  arm  tgkill                        sys_tgkill
269  arm  utimes                        sys_utimes_time32
270  arm  arm_fadvise64_64              compat_sys_aarch32_fadvise64_64
271  arm  pciconfig_iobase              sys_pciconfig_iobase
272  arm  pciconfig_read                sys_pciconfig_read
273  arm  pciconfig_write               sys_pciconfig_write
274  arm  mq_open                       compat_sys_mq_open
275  arm  mq_unlink                     sys_mq_unlink
276  arm  mq_timedsend                  sys_mq_timedsend_time32
277  arm  mq_timedreceive               sys_mq_timedreceive_time32
278  arm  mq_notify                     compat_sys_mq_notify
279  arm  mq_getsetattr                 compat_sys_mq_getsetattr
280  arm  waitid                        compat_sys_waitid
281  arm  socket                        sys_socket
282  arm  bind                          sys_bind
283  arm  connect                       sys_connect
284  arm  listen                        sys_listen
285  arm  accept                        sys_accept
286  arm  getsockname                   sys_getsockname
287  arm  getpeername                   sys_getpeername
288  arm  socketpair                    sys_socketpair
289  arm  send                          sys_send
290  arm  sendto                        sys_sendto
291  arm  recv                          compat_sys_recv
292  arm  recvfrom                      compat_sys_recvfrom
293  arm  shutdown                      sys_shutdown
294  arm  setsockopt                    sys_setsockopt
295  arm  getsockopt                    sys_getsockopt
296  arm  sendmsg                       compat_sys_sendmsg
297  arm  recvmsg                       compat_sys_recvmsg
298  arm  semop                         sys_semop
299  arm  semget                        sys_semget
300  arm  semctl                        compat_sys_old_semctl
301  arm  msgsnd                        compat_sys_msgsnd
302  arm  msgrcv                        compat_sys_msgrcv
303  arm  msgget                        sys_msgget
304  arm  msgctl                        compat_sys_old_msgctl
305  arm  shmat                         compat_sys_shmat
306  arm  shmdt                         sys_shmdt
307  arm  shmget                        sys_shmget
308  arm  shmctl                        compat_sys_old_shmctl
309  arm  add_key                       sys_add_key
310  arm  request_key                   sys_request_key
311  arm  keyctl                        compat_sys_keyctl
312  arm  semtimedop                    sys_semtimedop_time32
313  arm  vserver                       sys_ni_syscall
314  arm  ioprio_set                    sys_ioprio_set
315  arm  ioprio_get                    sys_ioprio_get
316  arm  inotify_init                  sys_inotify_init
317  arm  inotify_add_watch             sys_inotify_add_watch
318  arm  inotify_rm_watch              sys_inotify_rm_watch
319  arm  mbind                         sys_mbind
320  arm  get_mempolicy                 sys_get_mempolicy
321  arm  set_mempolicy                 sys_set_mempolicy
322  arm  openat                        compat_sys_openat
323  arm  mkdirat                       sys_mkdirat
324  arm  mknodat                       sys_mknodat
325  arm  fchownat                      sys_fchownat
326  arm  futimesat                     sys_futimesat_time32
327  arm  fstatat64                     sys_fstatat64
328  arm  unlinkat                      sys_unlinkat
329  arm  renameat                      sys_renameat
330  arm  linkat                        sys_linkat
331  arm  symlinkat                     sys_symlinkat
332  arm  readlinkat                    sys_readlinkat
333  arm  fchmodat                      sys_fchmodat
334  arm  faccessat                     sys_faccessat
335  arm  pselect6                      compat_sys_pselect6_time32
336  arm  ppoll                         compat_sys_ppoll_time32
337  arm  unshare                       sys_unshare
338  arm  set_robust_list               compat_sys_set_robust_list
339  arm  get_robust_list               compat_sys_get_robust_list
340  arm  splice                        sys_splice
341  arm  sync_file_range2              compat_sys_aarch32_sync_file_range2
342  arm  tee                           sys_tee
343  arm  vmsplice                      sys_vmsplice
344  arm  move_pages                    sys_move_pages
345  arm  getcpu                        sys_getcpu
346  arm  epoll_pwait                   compat_sys_epoll_pwait
347  arm  kexec_load                    compat_sys_kexec_load
348  arm  utimensat                     sys_utimensat_time32
349  arm  signalfd                      compat_sys_signalfd
350  arm  timerfd_create                sys_timerfd_create
351  arm  eventfd                       sys_eventfd
352  arm  fallocate                     compat_sys_aarch32_fallocate
353  arm  timerfd_settime               sys_timerfd_settime32
354  arm  timerfd_gettime               sys_timerfd_gettime32
355  arm  signalfd4                     compat_sys_signalfd4
356  arm  eventfd2                      sys_eventfd2
357  arm  epoll_create1                 sys_epoll_create1
358  arm  dup3                          sys_dup3
359  arm  pipe2                         sys_pipe2
360  arm  inotify_init1                 sys_inotify_init1
361  arm  preadv                        compat_sys_preadv
362  arm  pwritev                       compat_sys_pwritev
363  arm  rt_tgsigqueueinfo             compat_sys_rt_tgsigqueueinfo
364  arm  perf_event_open               sys_perf_event_open
365  arm  recvmmsg                      compat_sys_recvmmsg_time32
366  arm  accept4                       sys_accept4
367  arm  fanotify_init                 sys_fanotify_init
368  arm  fanotify_mark                 compat_sys_fanotify_mark
369  arm  prlimit64                     sys_prlimit64
370  arm  name_to_handle_at             sys_name_to_handle_at
371  arm  open_by_handle_at             compat_sys_open_by_handle_at
372  arm  clock_adjtime                 sys_clock_adjtime32
373  arm  syncfs                        sys_syncfs
374  arm  sendmmsg                      compat_sys_sendmmsg
375  arm  setns                         sys_setns
376  arm  process_vm_readv              sys_process_vm_readv
377  arm  process_vm_writev             sys_process_vm_writev
378  arm  kcmp                          sys_kcmp
379  arm  finit_module                  sys_finit_module
380  arm  sched_setattr                 sys_sched_setattr
381  arm  sched_getattr                 sys_sched_getattr
382  arm  renameat2                     sys_renameat2
383  arm  seccomp                       sys_seccomp
384  arm  getrandom                     sys_getrandom
385  arm  memfd_create                  sys_memfd_create
386  arm  bpf                           sys_bpf
387  arm  execveat                      compat_sys_execveat
388  arm  userfaultfd                   sys_userfaultfd
389  arm  membarrier                    sys_membarrier
390  arm  mlock2                        sys_mlock2
391  arm  copy_file_range               sys_copy_file_range
392  arm  preadv2                       compat_sys_preadv2
393  arm  pwritev2                      compat_sys_pwritev2
394  arm  pkey_mprotect                 sys_pkey_mprotect
395  arm  pkey_alloc                    sys_pkey_alloc
396  arm  pkey_free                     sys_pkey_free
397  arm  statx                         sys_statx
398  arm  rseq                          sys_rseq
399  arm  io_pgetevents                 compat_sys_io_pgetevents
400  arm  migrate_pages                 sys_migrate_pages
401  arm  kexec_file_load               sys_kexec_file_load
403  arm  clock_gettime64               sys_clock_gettime
404  arm  clock_settime64               sys_clock_settime
405  arm  clock_adjtime64               sys_clock_adjtime
406  arm  clock_getres_time64           sys_clock_getres
407  arm  clock_nanosleep_time64        sys_clock_nanosleep
408  arm  timer_gettime64               sys_timer_gettime
409  arm  timer_settime64               sys_timer_settime
410  arm  timerfd_gettime64             sys_timerfd_gettime
411  arm  timerfd_settime64             sys_timerfd_settime
412  arm  utimensat_time64              sys_utimensat
413  arm  pselect6_time64               compat_sys_pselect6_time64
414  arm  ppoll_time64                  compat_sys_ppoll_time64
416  arm  io_pgetevents_time64          sys_io_pgetevents
417  arm  recvmmsg_time64               compat_sys_recvmmsg_time64
418  arm  mq_timedsend_time64           sys_mq_timedsend
419  arm  mq_timedreceive_time64        sys_mq_timedreceive
420  arm  semtimedop_time64             sys_semtimedop
421  arm  rt_sigtimedwait_time64        compat_sys_rt_sigtimedwait_time64
422  arm  futex_time64                  sys_futex
423  arm  sched_rr_get_interval_time64  sys_sched_rr_get_interval
424  arm  pidfd_send_signal             sys_pidfd_send_signal
425  arm  io_uring_setup                sys_io_uring_setup
426  arm  io_uring_enter                sys_io_uring_enter
427  arm  io_uring_register             sys_io_uring_register
428  arm  open_tree                     sys_open_tree
429  arm  move_mount                    sys_move_mount
430  arm  fsopen                        sys_fsopen
431  arm  fsconfig                      sys_fsconfig
432  arm  fsmount                       sys_fsmount
433  arm  fspick                        sys_fspick
434  arm  pidfd_open                    sys_pidfd_open
435  arm  clone3                        sys_clone3
436  arm  close_range                   sys_close_range
437  arm  openat2                       sys_openat2
438  arm  pidfd_getfd                   sys_pidfd_getfd
439  arm  faccessat2                    sys_faccessat2
440  arm  process_madvise               sys_process_madvise
441  arm  epoll_pwait2                  compat_sys_epoll_pwait2
442  arm  mount_setattr                 sys_mount_setattr
443  arm  quotactl_fd                   sys_quotactl_fd
444  arm  landlock_create_ruleset       sys_landlock_create_ruleset
445  arm  landlock_add_rule             sys_landlock_add_rule
446  arm  landlock_restrict_self        sys_landlock_restrict_self
448  arm  process_mrelease              sys_process_mrelease
449  arm  futex_waitv                   sys_futex_waitv
450  arm  set_mempolicy_home_node       sys_set_mempolicy_home_node
"""

# ARM (native)
# - arch/arm/tools/syscall.tbl
arm_native_syscall_tbl = """
#
# Linux system call numbers and entry vectors
#
# The format is:
# <num> <abi>   <name>                  [<entry point>                  [<oabi compat entry point>]]
#
# Where abi is:
#  common - for system calls shared between oabi and eabi (may have compat)
#  oabi   - for oabi-only system calls (may have compat)
#  eabi   - for eabi-only system calls
#
# For each syscall number, "common" is mutually exclusive with oabi and eabi
#
0       common  restart_syscall         sys_restart_syscall
1       common  exit                    sys_exit
2       common  fork                    sys_fork
3       common  read                    sys_read
4       common  write                   sys_write
5       common  open                    sys_open
6       common  close                   sys_close
# 7 was sys_waitpid
8       common  creat                   sys_creat
9       common  link                    sys_link
10      common  unlink                  sys_unlink
11      common  execve                  sys_execve
12      common  chdir                   sys_chdir
13      oabi    time                    sys_time32
14      common  mknod                   sys_mknod
15      common  chmod                   sys_chmod
16      common  lchown                  sys_lchown16
# 17 was sys_break
# 18 was sys_stat
19      common  lseek                   sys_lseek
20      common  getpid                  sys_getpid
21      common  mount                   sys_mount
22      oabi    umount                  sys_oldumount
23      common  setuid                  sys_setuid16
24      common  getuid                  sys_getuid16
25      oabi    stime                   sys_stime32
26      common  ptrace                  sys_ptrace
27      oabi    alarm                   sys_alarm
# 28 was sys_fstat
29      common  pause                   sys_pause
30      oabi    utime                   sys_utime32
# 31 was sys_stty
# 32 was sys_gtty
33      common  access                  sys_access
34      common  nice                    sys_nice
# 35 was sys_ftime
36      common  sync                    sys_sync
37      common  kill                    sys_kill
38      common  rename                  sys_rename
39      common  mkdir                   sys_mkdir
40      common  rmdir                   sys_rmdir
41      common  dup                     sys_dup
42      common  pipe                    sys_pipe
43      common  times                   sys_times
# 44 was sys_prof
45      common  brk                     sys_brk
46      common  setgid                  sys_setgid16
47      common  getgid                  sys_getgid16
# 48 was sys_signal
49      common  geteuid                 sys_geteuid16
50      common  getegid                 sys_getegid16
51      common  acct                    sys_acct
52      common  umount2                 sys_umount
# 53 was sys_lock
54      common  ioctl                   sys_ioctl
55      common  fcntl                   sys_fcntl
# 56 was sys_mpx
57      common  setpgid                 sys_setpgid
# 58 was sys_ulimit
# 59 was sys_olduname
60      common  umask                   sys_umask
61      common  chroot                  sys_chroot
62      common  ustat                   sys_ustat
63      common  dup2                    sys_dup2
64      common  getppid                 sys_getppid
65      common  getpgrp                 sys_getpgrp
66      common  setsid                  sys_setsid
67      common  sigaction               sys_sigaction
# 68 was sys_sgetmask
# 69 was sys_ssetmask
70      common  setreuid                sys_setreuid16
71      common  setregid                sys_setregid16
72      common  sigsuspend              sys_sigsuspend
73      common  sigpending              sys_sigpending
74      common  sethostname             sys_sethostname
75      common  setrlimit               sys_setrlimit
# Back compat 2GB limited rlimit
76      oabi    getrlimit               sys_old_getrlimit
77      common  getrusage               sys_getrusage
78      common  gettimeofday            sys_gettimeofday
79      common  settimeofday            sys_settimeofday
80      common  getgroups               sys_getgroups16
81      common  setgroups               sys_setgroups16
82      oabi    select                  sys_old_select
83      common  symlink                 sys_symlink
# 84 was sys_lstat
85      common  readlink                sys_readlink
86      common  uselib                  sys_uselib
87      common  swapon                  sys_swapon
88      common  reboot                  sys_reboot
89      oabi    readdir                 sys_old_readdir
90      oabi    mmap                    sys_old_mmap
91      common  munmap                  sys_munmap
92      common  truncate                sys_truncate
93      common  ftruncate               sys_ftruncate
94      common  fchmod                  sys_fchmod
95      common  fchown                  sys_fchown16
96      common  getpriority             sys_getpriority
97      common  setpriority             sys_setpriority
# 98 was sys_profil
99      common  statfs                  sys_statfs
100     common  fstatfs                 sys_fstatfs
# 101 was sys_ioperm
102     oabi    socketcall              sys_socketcall          sys_oabi_socketcall
103     common  syslog                  sys_syslog
104     common  setitimer               sys_setitimer
105     common  getitimer               sys_getitimer
106     common  stat                    sys_newstat
107     common  lstat                   sys_newlstat
108     common  fstat                   sys_newfstat
# 109 was sys_uname
# 110 was sys_iopl
111     common  vhangup                 sys_vhangup
# 112 was sys_idle
# syscall to call a syscall!
113     oabi    syscall                 sys_syscall
114     common  wait4                   sys_wait4
115     common  swapoff                 sys_swapoff
116     common  sysinfo                 sys_sysinfo
117     oabi    ipc                     sys_ipc                 sys_oabi_ipc
118     common  fsync                   sys_fsync
119     common  sigreturn               sys_sigreturn_wrapper
120     common  clone                   sys_clone
121     common  setdomainname           sys_setdomainname
122     common  uname                   sys_newuname
# 123 was sys_modify_ldt
124     common  adjtimex                sys_adjtimex_time32
125     common  mprotect                sys_mprotect
126     common  sigprocmask             sys_sigprocmask
# 127 was sys_create_module
128     common  init_module             sys_init_module
129     common  delete_module           sys_delete_module
# 130 was sys_get_kernel_syms
131     common  quotactl                sys_quotactl
132     common  getpgid                 sys_getpgid
133     common  fchdir                  sys_fchdir
134     common  bdflush                 sys_ni_syscall
135     common  sysfs                   sys_sysfs
136     common  personality             sys_personality
# 137 was sys_afs_syscall
138     common  setfsuid                sys_setfsuid16
139     common  setfsgid                sys_setfsgid16
140     common  _llseek                 sys_llseek
141     common  getdents                sys_getdents
142     common  _newselect              sys_select
143     common  flock                   sys_flock
144     common  msync                   sys_msync
145     common  readv                   sys_readv
146     common  writev                  sys_writev
147     common  getsid                  sys_getsid
148     common  fdatasync               sys_fdatasync
149     common  _sysctl                 sys_ni_syscall
150     common  mlock                   sys_mlock
151     common  munlock                 sys_munlock
152     common  mlockall                sys_mlockall
153     common  munlockall              sys_munlockall
154     common  sched_setparam          sys_sched_setparam
155     common  sched_getparam          sys_sched_getparam
156     common  sched_setscheduler      sys_sched_setscheduler
157     common  sched_getscheduler      sys_sched_getscheduler
158     common  sched_yield             sys_sched_yield
159     common  sched_get_priority_max  sys_sched_get_priority_max
160     common  sched_get_priority_min  sys_sched_get_priority_min
161     common  sched_rr_get_interval   sys_sched_rr_get_interval_time32
162     common  nanosleep               sys_nanosleep_time32
163     common  mremap                  sys_mremap
164     common  setresuid               sys_setresuid16
165     common  getresuid               sys_getresuid16
# 166 was sys_vm86
# 167 was sys_query_module
168     common  poll                    sys_poll
169     common  nfsservctl
170     common  setresgid               sys_setresgid16
171     common  getresgid               sys_getresgid16
172     common  prctl                   sys_prctl
173     common  rt_sigreturn            sys_rt_sigreturn_wrapper
174     common  rt_sigaction            sys_rt_sigaction
175     common  rt_sigprocmask          sys_rt_sigprocmask
176     common  rt_sigpending           sys_rt_sigpending
177     common  rt_sigtimedwait         sys_rt_sigtimedwait_time32
178     common  rt_sigqueueinfo         sys_rt_sigqueueinfo
179     common  rt_sigsuspend           sys_rt_sigsuspend
180     common  pread64                 sys_pread64             sys_oabi_pread64
181     common  pwrite64                sys_pwrite64            sys_oabi_pwrite64
182     common  chown                   sys_chown16
183     common  getcwd                  sys_getcwd
184     common  capget                  sys_capget
185     common  capset                  sys_capset
186     common  sigaltstack             sys_sigaltstack
187     common  sendfile                sys_sendfile
# 188 reserved
# 189 reserved
190     common  vfork                   sys_vfork
# SuS compliant getrlimit
191     common  ugetrlimit              sys_getrlimit
192     common  mmap2                   sys_mmap2
193     common  truncate64              sys_truncate64          sys_oabi_truncate64
194     common  ftruncate64             sys_ftruncate64         sys_oabi_ftruncate64
195     common  stat64                  sys_stat64              sys_oabi_stat64
196     common  lstat64                 sys_lstat64             sys_oabi_lstat64
197     common  fstat64                 sys_fstat64             sys_oabi_fstat64
198     common  lchown32                sys_lchown
199     common  getuid32                sys_getuid
200     common  getgid32                sys_getgid
201     common  geteuid32               sys_geteuid
202     common  getegid32               sys_getegid
203     common  setreuid32              sys_setreuid
204     common  setregid32              sys_setregid
205     common  getgroups32             sys_getgroups
206     common  setgroups32             sys_setgroups
207     common  fchown32                sys_fchown
208     common  setresuid32             sys_setresuid
209     common  getresuid32             sys_getresuid
210     common  setresgid32             sys_setresgid
211     common  getresgid32             sys_getresgid
212     common  chown32                 sys_chown
213     common  setuid32                sys_setuid
214     common  setgid32                sys_setgid
215     common  setfsuid32              sys_setfsuid
216     common  setfsgid32              sys_setfsgid
217     common  getdents64              sys_getdents64
218     common  pivot_root              sys_pivot_root
219     common  mincore                 sys_mincore
220     common  madvise                 sys_madvise
221     common  fcntl64                 sys_fcntl64             sys_oabi_fcntl64
# 222 for tux
# 223 is unused
224     common  gettid                  sys_gettid
225     common  readahead               sys_readahead           sys_oabi_readahead
226     common  setxattr                sys_setxattr
227     common  lsetxattr               sys_lsetxattr
228     common  fsetxattr               sys_fsetxattr
229     common  getxattr                sys_getxattr
230     common  lgetxattr               sys_lgetxattr
231     common  fgetxattr               sys_fgetxattr
232     common  listxattr               sys_listxattr
233     common  llistxattr              sys_llistxattr
234     common  flistxattr              sys_flistxattr
235     common  removexattr             sys_removexattr
236     common  lremovexattr            sys_lremovexattr
237     common  fremovexattr            sys_fremovexattr
238     common  tkill                   sys_tkill
239     common  sendfile64              sys_sendfile64
240     common  futex                   sys_futex_time32
241     common  sched_setaffinity       sys_sched_setaffinity
242     common  sched_getaffinity       sys_sched_getaffinity
243     common  io_setup                sys_io_setup
244     common  io_destroy              sys_io_destroy
245     common  io_getevents            sys_io_getevents_time32
246     common  io_submit               sys_io_submit
247     common  io_cancel               sys_io_cancel
248     common  exit_group              sys_exit_group
249     common  lookup_dcookie          sys_lookup_dcookie
250     common  epoll_create            sys_epoll_create
251     common  epoll_ctl               sys_epoll_ctl           sys_oabi_epoll_ctl
252     common  epoll_wait              sys_epoll_wait
253     common  remap_file_pages        sys_remap_file_pages
# 254 for set_thread_area
# 255 for get_thread_area
256     common  set_tid_address         sys_set_tid_address
257     common  timer_create            sys_timer_create
258     common  timer_settime           sys_timer_settime32
259     common  timer_gettime           sys_timer_gettime32
260     common  timer_getoverrun        sys_timer_getoverrun
261     common  timer_delete            sys_timer_delete
262     common  clock_settime           sys_clock_settime32
263     common  clock_gettime           sys_clock_gettime32
264     common  clock_getres            sys_clock_getres_time32
265     common  clock_nanosleep         sys_clock_nanosleep_time32
266     common  statfs64                sys_statfs64_wrapper
267     common  fstatfs64               sys_fstatfs64_wrapper
268     common  tgkill                  sys_tgkill
269     common  utimes                  sys_utimes_time32
270     common  arm_fadvise64_64        sys_arm_fadvise64_64
271     common  pciconfig_iobase        sys_pciconfig_iobase
272     common  pciconfig_read          sys_pciconfig_read
273     common  pciconfig_write         sys_pciconfig_write
274     common  mq_open                 sys_mq_open
275     common  mq_unlink               sys_mq_unlink
276     common  mq_timedsend            sys_mq_timedsend_time32
277     common  mq_timedreceive         sys_mq_timedreceive_time32
278     common  mq_notify               sys_mq_notify
279     common  mq_getsetattr           sys_mq_getsetattr
280     common  waitid                  sys_waitid
281     common  socket                  sys_socket
282     common  bind                    sys_bind                sys_oabi_bind
283     common  connect                 sys_connect             sys_oabi_connect
284     common  listen                  sys_listen
285     common  accept                  sys_accept
286     common  getsockname             sys_getsockname
287     common  getpeername             sys_getpeername
288     common  socketpair              sys_socketpair
289     common  send                    sys_send
290     common  sendto                  sys_sendto              sys_oabi_sendto
291     common  recv                    sys_recv
292     common  recvfrom                sys_recvfrom
293     common  shutdown                sys_shutdown
294     common  setsockopt              sys_setsockopt
295     common  getsockopt              sys_getsockopt
296     common  sendmsg                 sys_sendmsg             sys_oabi_sendmsg
297     common  recvmsg                 sys_recvmsg
298     common  semop                   sys_semop               sys_oabi_semop
299     common  semget                  sys_semget
300     common  semctl                  sys_old_semctl
301     common  msgsnd                  sys_msgsnd
302     common  msgrcv                  sys_msgrcv
303     common  msgget                  sys_msgget
304     common  msgctl                  sys_old_msgctl
305     common  shmat                   sys_shmat
306     common  shmdt                   sys_shmdt
307     common  shmget                  sys_shmget
308     common  shmctl                  sys_old_shmctl
309     common  add_key                 sys_add_key
310     common  request_key             sys_request_key
311     common  keyctl                  sys_keyctl
312     common  semtimedop              sys_semtimedop_time32   sys_oabi_semtimedop
313     common  vserver
314     common  ioprio_set              sys_ioprio_set
315     common  ioprio_get              sys_ioprio_get
316     common  inotify_init            sys_inotify_init
317     common  inotify_add_watch       sys_inotify_add_watch
318     common  inotify_rm_watch        sys_inotify_rm_watch
319     common  mbind                   sys_mbind
320     common  get_mempolicy           sys_get_mempolicy
321     common  set_mempolicy           sys_set_mempolicy
322     common  openat                  sys_openat
323     common  mkdirat                 sys_mkdirat
324     common  mknodat                 sys_mknodat
325     common  fchownat                sys_fchownat
326     common  futimesat               sys_futimesat_time32
327     common  fstatat64               sys_fstatat64           sys_oabi_fstatat64
328     common  unlinkat                sys_unlinkat
329     common  renameat                sys_renameat
330     common  linkat                  sys_linkat
331     common  symlinkat               sys_symlinkat
332     common  readlinkat              sys_readlinkat
333     common  fchmodat                sys_fchmodat
334     common  faccessat               sys_faccessat
335     common  pselect6                sys_pselect6_time32
336     common  ppoll                   sys_ppoll_time32
337     common  unshare                 sys_unshare
338     common  set_robust_list         sys_set_robust_list
339     common  get_robust_list         sys_get_robust_list
340     common  splice                  sys_splice
341     common  arm_sync_file_range     sys_sync_file_range2
342     common  tee                     sys_tee
343     common  vmsplice                sys_vmsplice
344     common  move_pages              sys_move_pages
345     common  getcpu                  sys_getcpu
346     common  epoll_pwait             sys_epoll_pwait
347     common  kexec_load              sys_kexec_load
348     common  utimensat               sys_utimensat_time32
349     common  signalfd                sys_signalfd
350     common  timerfd_create          sys_timerfd_create
351     common  eventfd                 sys_eventfd
352     common  fallocate               sys_fallocate
353     common  timerfd_settime         sys_timerfd_settime32
354     common  timerfd_gettime         sys_timerfd_gettime32
355     common  signalfd4               sys_signalfd4
356     common  eventfd2                sys_eventfd2
357     common  epoll_create1           sys_epoll_create1
358     common  dup3                    sys_dup3
359     common  pipe2                   sys_pipe2
360     common  inotify_init1           sys_inotify_init1
361     common  preadv                  sys_preadv
362     common  pwritev                 sys_pwritev
363     common  rt_tgsigqueueinfo       sys_rt_tgsigqueueinfo
364     common  perf_event_open         sys_perf_event_open
365     common  recvmmsg                sys_recvmmsg_time32
366     common  accept4                 sys_accept4
367     common  fanotify_init           sys_fanotify_init
368     common  fanotify_mark           sys_fanotify_mark
369     common  prlimit64               sys_prlimit64
370     common  name_to_handle_at       sys_name_to_handle_at
371     common  open_by_handle_at       sys_open_by_handle_at
372     common  clock_adjtime           sys_clock_adjtime32
373     common  syncfs                  sys_syncfs
374     common  sendmmsg                sys_sendmmsg
375     common  setns                   sys_setns
376     common  process_vm_readv        sys_process_vm_readv
377     common  process_vm_writev       sys_process_vm_writev
378     common  kcmp                    sys_kcmp
379     common  finit_module            sys_finit_module
380     common  sched_setattr           sys_sched_setattr
381     common  sched_getattr           sys_sched_getattr
382     common  renameat2               sys_renameat2
383     common  seccomp                 sys_seccomp
384     common  getrandom               sys_getrandom
385     common  memfd_create            sys_memfd_create
386     common  bpf                     sys_bpf
387     common  execveat                sys_execveat
388     common  userfaultfd             sys_userfaultfd
389     common  membarrier              sys_membarrier
390     common  mlock2                  sys_mlock2
391     common  copy_file_range         sys_copy_file_range
392     common  preadv2                 sys_preadv2
393     common  pwritev2                sys_pwritev2
394     common  pkey_mprotect           sys_pkey_mprotect
395     common  pkey_alloc              sys_pkey_alloc
396     common  pkey_free               sys_pkey_free
397     common  statx                   sys_statx
398     common  rseq                    sys_rseq
399     common  io_pgetevents           sys_io_pgetevents_time32
400     common  migrate_pages           sys_migrate_pages
401     common  kexec_file_load         sys_kexec_file_load
# 402 is unused
403     common  clock_gettime64                 sys_clock_gettime
404     common  clock_settime64                 sys_clock_settime
405     common  clock_adjtime64                 sys_clock_adjtime
406     common  clock_getres_time64             sys_clock_getres
407     common  clock_nanosleep_time64          sys_clock_nanosleep
408     common  timer_gettime64                 sys_timer_gettime
409     common  timer_settime64                 sys_timer_settime
410     common  timerfd_gettime64               sys_timerfd_gettime
411     common  timerfd_settime64               sys_timerfd_settime
412     common  utimensat_time64                sys_utimensat
413     common  pselect6_time64                 sys_pselect6
414     common  ppoll_time64                    sys_ppoll
416     common  io_pgetevents_time64            sys_io_pgetevents
417     common  recvmmsg_time64                 sys_recvmmsg
418     common  mq_timedsend_time64             sys_mq_timedsend
419     common  mq_timedreceive_time64          sys_mq_timedreceive
420     common  semtimedop_time64               sys_semtimedop
421     common  rt_sigtimedwait_time64          sys_rt_sigtimedwait
422     common  futex_time64                    sys_futex
423     common  sched_rr_get_interval_time64    sys_sched_rr_get_interval
424     common  pidfd_send_signal               sys_pidfd_send_signal
425     common  io_uring_setup                  sys_io_uring_setup
426     common  io_uring_enter                  sys_io_uring_enter
427     common  io_uring_register               sys_io_uring_register
428     common  open_tree                       sys_open_tree
429     common  move_mount                      sys_move_mount
430     common  fsopen                          sys_fsopen
431     common  fsconfig                        sys_fsconfig
432     common  fsmount                         sys_fsmount
433     common  fspick                          sys_fspick
434     common  pidfd_open                      sys_pidfd_open
435     common  clone3                          sys_clone3
436     common  close_range                     sys_close_range
437     common  openat2                         sys_openat2
438     common  pidfd_getfd                     sys_pidfd_getfd
439     common  faccessat2                      sys_faccessat2
440     common  process_madvise                 sys_process_madvise
441     common  epoll_pwait2                    sys_epoll_pwait2
442     common  mount_setattr                   sys_mount_setattr
443     common  quotactl_fd                     sys_quotactl_fd
444     common  landlock_create_ruleset         sys_landlock_create_ruleset
445     common  landlock_add_rule               sys_landlock_add_rule
446     common  landlock_restrict_self          sys_landlock_restrict_self
# 447 reserved for memfd_secret
448     common  process_mrelease                sys_process_mrelease
449     common  futex_waitv                     sys_futex_waitv
450     common  set_mempolicy_home_node         sys_set_mempolicy_home_node
"""


# MIPS o32 (backward compatible ABI, present in /lib)
# - arch/mips/kernel/syscalls/syscall_o32.tbl
mips_o32_syscall_tbl = """
# system call numbers and entry vectors for mips
#
# The format is:
# <number> <abi> <name> <entry point> <compat entry point>
#
# The <abi> is always "o32" for this file.
#
0       o32     syscall                         sys_syscall                     sys32_syscall
1       o32     exit                            sys_exit
2       o32     fork                            __sys_fork
3       o32     read                            sys_read
4       o32     write                           sys_write
5       o32     open                            sys_open                        compat_sys_open
6       o32     close                           sys_close
7       o32     waitpid                         sys_waitpid
8       o32     creat                           sys_creat
9       o32     link                            sys_link
10      o32     unlink                          sys_unlink
11      o32     execve                          sys_execve                      compat_sys_execve
12      o32     chdir                           sys_chdir
13      o32     time                            sys_time32
14      o32     mknod                           sys_mknod
15      o32     chmod                           sys_chmod
16      o32     lchown                          sys_lchown
17      o32     break                           sys_ni_syscall
# 18 was sys_stat
18      o32     unused18                        sys_ni_syscall
19      o32     lseek                           sys_lseek
20      o32     getpid                          sys_getpid
21      o32     mount                           sys_mount
22      o32     umount                          sys_oldumount
23      o32     setuid                          sys_setuid
24      o32     getuid                          sys_getuid
25      o32     stime                           sys_stime32
26      o32     ptrace                          sys_ptrace                      compat_sys_ptrace
27      o32     alarm                           sys_alarm
# 28 was sys_fstat
28      o32     unused28                        sys_ni_syscall
29      o32     pause                           sys_pause
30      o32     utime                           sys_utime32
31      o32     stty                            sys_ni_syscall
32      o32     gtty                            sys_ni_syscall
33      o32     access                          sys_access
34      o32     nice                            sys_nice
35      o32     ftime                           sys_ni_syscall
36      o32     sync                            sys_sync
37      o32     kill                            sys_kill
38      o32     rename                          sys_rename
39      o32     mkdir                           sys_mkdir
40      o32     rmdir                           sys_rmdir
41      o32     dup                             sys_dup
42      o32     pipe                            sysm_pipe
43      o32     times                           sys_times                       compat_sys_times
44      o32     prof                            sys_ni_syscall
45      o32     brk                             sys_brk
46      o32     setgid                          sys_setgid
47      o32     getgid                          sys_getgid
48      o32     signal                          sys_ni_syscall
49      o32     geteuid                         sys_geteuid
50      o32     getegid                         sys_getegid
51      o32     acct                            sys_acct
52      o32     umount2                         sys_umount
53      o32     lock                            sys_ni_syscall
54      o32     ioctl                           sys_ioctl                       compat_sys_ioctl
55      o32     fcntl                           sys_fcntl                       compat_sys_fcntl
56      o32     mpx                             sys_ni_syscall
57      o32     setpgid                         sys_setpgid
58      o32     ulimit                          sys_ni_syscall
59      o32     unused59                        sys_olduname
60      o32     umask                           sys_umask
61      o32     chroot                          sys_chroot
62      o32     ustat                           sys_ustat                       compat_sys_ustat
63      o32     dup2                            sys_dup2
64      o32     getppid                         sys_getppid
65      o32     getpgrp                         sys_getpgrp
66      o32     setsid                          sys_setsid
67      o32     sigaction                       sys_sigaction                   sys_32_sigaction
68      o32     sgetmask                        sys_sgetmask
69      o32     ssetmask                        sys_ssetmask
70      o32     setreuid                        sys_setreuid
71      o32     setregid                        sys_setregid
72      o32     sigsuspend                      sys_sigsuspend                  sys32_sigsuspend
73      o32     sigpending                      sys_sigpending                  compat_sys_sigpending
74      o32     sethostname                     sys_sethostname
75      o32     setrlimit                       sys_setrlimit                   compat_sys_setrlimit
76      o32     getrlimit                       sys_getrlimit                   compat_sys_getrlimit
77      o32     getrusage                       sys_getrusage                   compat_sys_getrusage
78      o32     gettimeofday                    sys_gettimeofday                compat_sys_gettimeofday
79      o32     settimeofday                    sys_settimeofday                compat_sys_settimeofday
80      o32     getgroups                       sys_getgroups
81      o32     setgroups                       sys_setgroups
# 82 was old_select
82      o32     reserved82                      sys_ni_syscall
83      o32     symlink                         sys_symlink
# 84 was sys_lstat
84      o32     unused84                        sys_ni_syscall
85      o32     readlink                        sys_readlink
86      o32     uselib                          sys_uselib
87      o32     swapon                          sys_swapon
88      o32     reboot                          sys_reboot
89      o32     readdir                         sys_old_readdir                 compat_sys_old_readdir
90      o32     mmap                            sys_mips_mmap
91      o32     munmap                          sys_munmap
92      o32     truncate                        sys_truncate                    compat_sys_truncate
93      o32     ftruncate                       sys_ftruncate                   compat_sys_ftruncate
94      o32     fchmod                          sys_fchmod
95      o32     fchown                          sys_fchown
96      o32     getpriority                     sys_getpriority
97      o32     setpriority                     sys_setpriority
98      o32     profil                          sys_ni_syscall
99      o32     statfs                          sys_statfs                      compat_sys_statfs
100     o32     fstatfs                         sys_fstatfs                     compat_sys_fstatfs
101     o32     ioperm                          sys_ni_syscall
102     o32     socketcall                      sys_socketcall                  compat_sys_socketcall
103     o32     syslog                          sys_syslog
104     o32     setitimer                       sys_setitimer                   compat_sys_setitimer
105     o32     getitimer                       sys_getitimer                   compat_sys_getitimer
106     o32     stat                            sys_newstat                     compat_sys_newstat
107     o32     lstat                           sys_newlstat                    compat_sys_newlstat
108     o32     fstat                           sys_newfstat                    compat_sys_newfstat
109     o32     unused109                       sys_uname
110     o32     iopl                            sys_ni_syscall
111     o32     vhangup                         sys_vhangup
112     o32     idle                            sys_ni_syscall
113     o32     vm86                            sys_ni_syscall
114     o32     wait4                           sys_wait4                       compat_sys_wait4
115     o32     swapoff                         sys_swapoff
116     o32     sysinfo                         sys_sysinfo                     compat_sys_sysinfo
117     o32     ipc                             sys_ipc                         compat_sys_ipc
118     o32     fsync                           sys_fsync
119     o32     sigreturn                       sys_sigreturn                   sys32_sigreturn
120     o32     clone                           __sys_clone
121     o32     setdomainname                   sys_setdomainname
122     o32     uname                           sys_newuname
123     o32     modify_ldt                      sys_ni_syscall
124     o32     adjtimex                        sys_adjtimex_time32
125     o32     mprotect                        sys_mprotect
126     o32     sigprocmask                     sys_sigprocmask                 compat_sys_sigprocmask
127     o32     create_module                   sys_ni_syscall
128     o32     init_module                     sys_init_module
129     o32     delete_module                   sys_delete_module
130     o32     get_kernel_syms                 sys_ni_syscall
131     o32     quotactl                        sys_quotactl
132     o32     getpgid                         sys_getpgid
133     o32     fchdir                          sys_fchdir
134     o32     bdflush                         sys_ni_syscall
135     o32     sysfs                           sys_sysfs
136     o32     personality                     sys_personality                 sys_32_personality
137     o32     afs_syscall                     sys_ni_syscall
138     o32     setfsuid                        sys_setfsuid
139     o32     setfsgid                        sys_setfsgid
140     o32     _llseek                         sys_llseek                      sys_32_llseek
141     o32     getdents                        sys_getdents                    compat_sys_getdents
142     o32     _newselect                      sys_select                      compat_sys_select
143     o32     flock                           sys_flock
144     o32     msync                           sys_msync
145     o32     readv                           sys_readv
146     o32     writev                          sys_writev
147     o32     cacheflush                      sys_cacheflush
148     o32     cachectl                        sys_cachectl
149     o32     sysmips                         __sys_sysmips
150     o32     unused150                       sys_ni_syscall
151     o32     getsid                          sys_getsid
152     o32     fdatasync                       sys_fdatasync
153     o32     _sysctl                         sys_ni_syscall
154     o32     mlock                           sys_mlock
155     o32     munlock                         sys_munlock
156     o32     mlockall                        sys_mlockall
157     o32     munlockall                      sys_munlockall
158     o32     sched_setparam                  sys_sched_setparam
159     o32     sched_getparam                  sys_sched_getparam
160     o32     sched_setscheduler              sys_sched_setscheduler
161     o32     sched_getscheduler              sys_sched_getscheduler
162     o32     sched_yield                     sys_sched_yield
163     o32     sched_get_priority_max          sys_sched_get_priority_max
164     o32     sched_get_priority_min          sys_sched_get_priority_min
165     o32     sched_rr_get_interval           sys_sched_rr_get_interval_time32
166     o32     nanosleep                       sys_nanosleep_time32
167     o32     mremap                          sys_mremap
168     o32     accept                          sys_accept
169     o32     bind                            sys_bind
170     o32     connect                         sys_connect
171     o32     getpeername                     sys_getpeername
172     o32     getsockname                     sys_getsockname
173     o32     getsockopt                      sys_getsockopt                  sys_getsockopt
174     o32     listen                          sys_listen
175     o32     recv                            sys_recv                        compat_sys_recv
176     o32     recvfrom                        sys_recvfrom                    compat_sys_recvfrom
177     o32     recvmsg                         sys_recvmsg                     compat_sys_recvmsg
178     o32     send                            sys_send
179     o32     sendmsg                         sys_sendmsg                     compat_sys_sendmsg
180     o32     sendto                          sys_sendto
181     o32     setsockopt                      sys_setsockopt                  sys_setsockopt
182     o32     shutdown                        sys_shutdown
183     o32     socket                          sys_socket
184     o32     socketpair                      sys_socketpair
185     o32     setresuid                       sys_setresuid
186     o32     getresuid                       sys_getresuid
187     o32     query_module                    sys_ni_syscall
188     o32     poll                            sys_poll
189     o32     nfsservctl                      sys_ni_syscall
190     o32     setresgid                       sys_setresgid
191     o32     getresgid                       sys_getresgid
192     o32     prctl                           sys_prctl
193     o32     rt_sigreturn                    sys_rt_sigreturn                sys32_rt_sigreturn
194     o32     rt_sigaction                    sys_rt_sigaction                compat_sys_rt_sigaction
195     o32     rt_sigprocmask                  sys_rt_sigprocmask              compat_sys_rt_sigprocmask
196     o32     rt_sigpending                   sys_rt_sigpending               compat_sys_rt_sigpending
197     o32     rt_sigtimedwait                 sys_rt_sigtimedwait_time32      compat_sys_rt_sigtimedwait_time32
198     o32     rt_sigqueueinfo                 sys_rt_sigqueueinfo             compat_sys_rt_sigqueueinfo
199     o32     rt_sigsuspend                   sys_rt_sigsuspend               compat_sys_rt_sigsuspend
200     o32     pread64                         sys_pread64                     sys_32_pread
201     o32     pwrite64                        sys_pwrite64                    sys_32_pwrite
202     o32     chown                           sys_chown
203     o32     getcwd                          sys_getcwd
204     o32     capget                          sys_capget
205     o32     capset                          sys_capset
206     o32     sigaltstack                     sys_sigaltstack                 compat_sys_sigaltstack
207     o32     sendfile                        sys_sendfile                    compat_sys_sendfile
208     o32     getpmsg                         sys_ni_syscall
209     o32     putpmsg                         sys_ni_syscall
210     o32     mmap2                           sys_mips_mmap2
211     o32     truncate64                      sys_truncate64                  sys_32_truncate64
212     o32     ftruncate64                     sys_ftruncate64                 sys_32_ftruncate64
213     o32     stat64                          sys_stat64                      sys_newstat
214     o32     lstat64                         sys_lstat64                     sys_newlstat
215     o32     fstat64                         sys_fstat64                     sys_newfstat
216     o32     pivot_root                      sys_pivot_root
217     o32     mincore                         sys_mincore
218     o32     madvise                         sys_madvise
219     o32     getdents64                      sys_getdents64
220     o32     fcntl64                         sys_fcntl64                     compat_sys_fcntl64
221     o32     reserved221                     sys_ni_syscall
222     o32     gettid                          sys_gettid
223     o32     readahead                       sys_readahead                   sys32_readahead
224     o32     setxattr                        sys_setxattr
225     o32     lsetxattr                       sys_lsetxattr
226     o32     fsetxattr                       sys_fsetxattr
227     o32     getxattr                        sys_getxattr
228     o32     lgetxattr                       sys_lgetxattr
229     o32     fgetxattr                       sys_fgetxattr
230     o32     listxattr                       sys_listxattr
231     o32     llistxattr                      sys_llistxattr
232     o32     flistxattr                      sys_flistxattr
233     o32     removexattr                     sys_removexattr
234     o32     lremovexattr                    sys_lremovexattr
235     o32     fremovexattr                    sys_fremovexattr
236     o32     tkill                           sys_tkill
237     o32     sendfile64                      sys_sendfile64
238     o32     futex                           sys_futex_time32
239     o32     sched_setaffinity               sys_sched_setaffinity           compat_sys_sched_setaffinity
240     o32     sched_getaffinity               sys_sched_getaffinity           compat_sys_sched_getaffinity
241     o32     io_setup                        sys_io_setup                    compat_sys_io_setup
242     o32     io_destroy                      sys_io_destroy
243     o32     io_getevents                    sys_io_getevents_time32
244     o32     io_submit                       sys_io_submit                   compat_sys_io_submit
245     o32     io_cancel                       sys_io_cancel
246     o32     exit_group                      sys_exit_group
247     o32     lookup_dcookie                  sys_lookup_dcookie              compat_sys_lookup_dcookie
248     o32     epoll_create                    sys_epoll_create
249     o32     epoll_ctl                       sys_epoll_ctl
250     o32     epoll_wait                      sys_epoll_wait
251     o32     remap_file_pages                sys_remap_file_pages
252     o32     set_tid_address                 sys_set_tid_address
253     o32     restart_syscall                 sys_restart_syscall
254     o32     fadvise64                       sys_fadvise64_64                sys32_fadvise64_64
255     o32     statfs64                        sys_statfs64                    compat_sys_statfs64
256     o32     fstatfs64                       sys_fstatfs64                   compat_sys_fstatfs64
257     o32     timer_create                    sys_timer_create                compat_sys_timer_create
258     o32     timer_settime                   sys_timer_settime32
259     o32     timer_gettime                   sys_timer_gettime32
260     o32     timer_getoverrun                sys_timer_getoverrun
261     o32     timer_delete                    sys_timer_delete
262     o32     clock_settime                   sys_clock_settime32
263     o32     clock_gettime                   sys_clock_gettime32
264     o32     clock_getres                    sys_clock_getres_time32
265     o32     clock_nanosleep                 sys_clock_nanosleep_time32
266     o32     tgkill                          sys_tgkill
267     o32     utimes                          sys_utimes_time32
268     o32     mbind                           sys_mbind
269     o32     get_mempolicy                   sys_get_mempolicy
270     o32     set_mempolicy                   sys_set_mempolicy
271     o32     mq_open                         sys_mq_open                     compat_sys_mq_open
272     o32     mq_unlink                       sys_mq_unlink
273     o32     mq_timedsend                    sys_mq_timedsend_time32
274     o32     mq_timedreceive                 sys_mq_timedreceive_time32
275     o32     mq_notify                       sys_mq_notify                   compat_sys_mq_notify
276     o32     mq_getsetattr                   sys_mq_getsetattr               compat_sys_mq_getsetattr
277     o32     vserver                         sys_ni_syscall
278     o32     waitid                          sys_waitid                      compat_sys_waitid
# 279 was sys_setaltroot
280     o32     add_key                         sys_add_key
281     o32     request_key                     sys_request_key
282     o32     keyctl                          sys_keyctl                      compat_sys_keyctl
283     o32     set_thread_area                 sys_set_thread_area
284     o32     inotify_init                    sys_inotify_init
285     o32     inotify_add_watch               sys_inotify_add_watch
286     o32     inotify_rm_watch                sys_inotify_rm_watch
287     o32     migrate_pages                   sys_migrate_pages
288     o32     openat                          sys_openat                      compat_sys_openat
289     o32     mkdirat                         sys_mkdirat
290     o32     mknodat                         sys_mknodat
291     o32     fchownat                        sys_fchownat
292     o32     futimesat                       sys_futimesat_time32
293     o32     fstatat64                       sys_fstatat64                   sys_newfstatat
294     o32     unlinkat                        sys_unlinkat
295     o32     renameat                        sys_renameat
296     o32     linkat                          sys_linkat
297     o32     symlinkat                       sys_symlinkat
298     o32     readlinkat                      sys_readlinkat
299     o32     fchmodat                        sys_fchmodat
300     o32     faccessat                       sys_faccessat
301     o32     pselect6                        sys_pselect6_time32             compat_sys_pselect6_time32
302     o32     ppoll                           sys_ppoll_time32                compat_sys_ppoll_time32
303     o32     unshare                         sys_unshare
304     o32     splice                          sys_splice
305     o32     sync_file_range                 sys_sync_file_range             sys32_sync_file_range
306     o32     tee                             sys_tee
307     o32     vmsplice                        sys_vmsplice
308     o32     move_pages                      sys_move_pages
309     o32     set_robust_list                 sys_set_robust_list             compat_sys_set_robust_list
310     o32     get_robust_list                 sys_get_robust_list             compat_sys_get_robust_list
311     o32     kexec_load                      sys_kexec_load                  compat_sys_kexec_load
312     o32     getcpu                          sys_getcpu
313     o32     epoll_pwait                     sys_epoll_pwait                 compat_sys_epoll_pwait
314     o32     ioprio_set                      sys_ioprio_set
315     o32     ioprio_get                      sys_ioprio_get
316     o32     utimensat                       sys_utimensat_time32
317     o32     signalfd                        sys_signalfd                    compat_sys_signalfd
318     o32     timerfd                         sys_ni_syscall
319     o32     eventfd                         sys_eventfd
320     o32     fallocate                       sys_fallocate                   sys32_fallocate
321     o32     timerfd_create                  sys_timerfd_create
322     o32     timerfd_gettime                 sys_timerfd_gettime32
323     o32     timerfd_settime                 sys_timerfd_settime32
324     o32     signalfd4                       sys_signalfd4                   compat_sys_signalfd4
325     o32     eventfd2                        sys_eventfd2
326     o32     epoll_create1                   sys_epoll_create1
327     o32     dup3                            sys_dup3
328     o32     pipe2                           sys_pipe2
329     o32     inotify_init1                   sys_inotify_init1
330     o32     preadv                          sys_preadv                      compat_sys_preadv
331     o32     pwritev                         sys_pwritev                     compat_sys_pwritev
332     o32     rt_tgsigqueueinfo               sys_rt_tgsigqueueinfo           compat_sys_rt_tgsigqueueinfo
333     o32     perf_event_open                 sys_perf_event_open
334     o32     accept4                         sys_accept4
335     o32     recvmmsg                        sys_recvmmsg_time32             compat_sys_recvmmsg_time32
336     o32     fanotify_init                   sys_fanotify_init
337     o32     fanotify_mark                   sys_fanotify_mark               compat_sys_fanotify_mark
338     o32     prlimit64                       sys_prlimit64
339     o32     name_to_handle_at               sys_name_to_handle_at
340     o32     open_by_handle_at               sys_open_by_handle_at           compat_sys_open_by_handle_at
341     o32     clock_adjtime                   sys_clock_adjtime32
342     o32     syncfs                          sys_syncfs
343     o32     sendmmsg                        sys_sendmmsg                    compat_sys_sendmmsg
344     o32     setns                           sys_setns
345     o32     process_vm_readv                sys_process_vm_readv
346     o32     process_vm_writev               sys_process_vm_writev
347     o32     kcmp                            sys_kcmp
348     o32     finit_module                    sys_finit_module
349     o32     sched_setattr                   sys_sched_setattr
350     o32     sched_getattr                   sys_sched_getattr
351     o32     renameat2                       sys_renameat2
352     o32     seccomp                         sys_seccomp
353     o32     getrandom                       sys_getrandom
354     o32     memfd_create                    sys_memfd_create
355     o32     bpf                             sys_bpf
356     o32     execveat                        sys_execveat                    compat_sys_execveat
357     o32     userfaultfd                     sys_userfaultfd
358     o32     membarrier                      sys_membarrier
359     o32     mlock2                          sys_mlock2
360     o32     copy_file_range                 sys_copy_file_range
361     o32     preadv2                         sys_preadv2                     compat_sys_preadv2
362     o32     pwritev2                        sys_pwritev2                    compat_sys_pwritev2
363     o32     pkey_mprotect                   sys_pkey_mprotect
364     o32     pkey_alloc                      sys_pkey_alloc
365     o32     pkey_free                       sys_pkey_free
366     o32     statx                           sys_statx
367     o32     rseq                            sys_rseq
368     o32     io_pgetevents                   sys_io_pgetevents_time32        compat_sys_io_pgetevents
# room for arch specific calls
393     o32     semget                          sys_semget
394     o32     semctl                          sys_semctl                      compat_sys_semctl
395     o32     shmget                          sys_shmget
396     o32     shmctl                          sys_shmctl                      compat_sys_shmctl
397     o32     shmat                           sys_shmat                       compat_sys_shmat
398     o32     shmdt                           sys_shmdt
399     o32     msgget                          sys_msgget
400     o32     msgsnd                          sys_msgsnd                      compat_sys_msgsnd
401     o32     msgrcv                          sys_msgrcv                      compat_sys_msgrcv
402     o32     msgctl                          sys_msgctl                      compat_sys_msgctl
403     o32     clock_gettime64                 sys_clock_gettime               sys_clock_gettime
404     o32     clock_settime64                 sys_clock_settime               sys_clock_settime
405     o32     clock_adjtime64                 sys_clock_adjtime               sys_clock_adjtime
406     o32     clock_getres_time64             sys_clock_getres                sys_clock_getres
407     o32     clock_nanosleep_time64          sys_clock_nanosleep             sys_clock_nanosleep
408     o32     timer_gettime64                 sys_timer_gettime               sys_timer_gettime
409     o32     timer_settime64                 sys_timer_settime               sys_timer_settime
410     o32     timerfd_gettime64               sys_timerfd_gettime             sys_timerfd_gettime
411     o32     timerfd_settime64               sys_timerfd_settime             sys_timerfd_settime
412     o32     utimensat_time64                sys_utimensat                   sys_utimensat
413     o32     pselect6_time64                 sys_pselect6                    compat_sys_pselect6_time64
414     o32     ppoll_time64                    sys_ppoll                       compat_sys_ppoll_time64
416     o32     io_pgetevents_time64            sys_io_pgetevents               sys_io_pgetevents
417     o32     recvmmsg_time64                 sys_recvmmsg                    compat_sys_recvmmsg_time64
418     o32     mq_timedsend_time64             sys_mq_timedsend                sys_mq_timedsend
419     o32     mq_timedreceive_time64          sys_mq_timedreceive             sys_mq_timedreceive
420     o32     semtimedop_time64               sys_semtimedop                  sys_semtimedop
421     o32     rt_sigtimedwait_time64          sys_rt_sigtimedwait             compat_sys_rt_sigtimedwait_time64
422     o32     futex_time64                    sys_futex                       sys_futex
423     o32     sched_rr_get_interval_time64    sys_sched_rr_get_interval       sys_sched_rr_get_interval
424     o32     pidfd_send_signal               sys_pidfd_send_signal
425     o32     io_uring_setup                  sys_io_uring_setup
426     o32     io_uring_enter                  sys_io_uring_enter
427     o32     io_uring_register               sys_io_uring_register
428     o32     open_tree                       sys_open_tree
429     o32     move_mount                      sys_move_mount
430     o32     fsopen                          sys_fsopen
431     o32     fsconfig                        sys_fsconfig
432     o32     fsmount                         sys_fsmount
433     o32     fspick                          sys_fspick
434     o32     pidfd_open                      sys_pidfd_open
435     o32     clone3                          __sys_clone3
436     o32     close_range                     sys_close_range
437     o32     openat2                         sys_openat2
438     o32     pidfd_getfd                     sys_pidfd_getfd
439     o32     faccessat2                      sys_faccessat2
440     o32     process_madvise                 sys_process_madvise
441     o32     epoll_pwait2                    sys_epoll_pwait2                compat_sys_epoll_pwait2
442     o32     mount_setattr                   sys_mount_setattr
443     o32     quotactl_fd                     sys_quotactl_fd
444     o32     landlock_create_ruleset         sys_landlock_create_ruleset
445     o32     landlock_add_rule               sys_landlock_add_rule
446     o32     landlock_restrict_self          sys_landlock_restrict_self
# 447 reserved for memfd_secret
448     o32     process_mrelease                sys_process_mrelease
449     o32     futex_waitv                     sys_futex_waitv
450     o32     set_mempolicy_home_node         sys_set_mempolicy_home_node
"""


# MIPS n32 (default ABI, present in /lib32)
# - arch/mips/kernel/syscalls/syscall_n32.tbl
mips_n32_syscall_tbl = """
# system call numbers and entry vectors for mips
#
# The format is:
# <number> <abi> <name> <entry point> <compat entry point>
#
# The <abi> is always "n32" for this file.
#
0       n32     read                            sys_read
1       n32     write                           sys_write
2       n32     open                            sys_open
3       n32     close                           sys_close
4       n32     stat                            sys_newstat
5       n32     fstat                           sys_newfstat
6       n32     lstat                           sys_newlstat
7       n32     poll                            sys_poll
8       n32     lseek                           sys_lseek
9       n32     mmap                            sys_mips_mmap
10      n32     mprotect                        sys_mprotect
11      n32     munmap                          sys_munmap
12      n32     brk                             sys_brk
13      n32     rt_sigaction                    compat_sys_rt_sigaction
14      n32     rt_sigprocmask                  compat_sys_rt_sigprocmask
15      n32     ioctl                           compat_sys_ioctl
16      n32     pread64                         sys_pread64
17      n32     pwrite64                        sys_pwrite64
18      n32     readv                           sys_readv
19      n32     writev                          sys_writev
20      n32     access                          sys_access
21      n32     pipe                            sysm_pipe
22      n32     _newselect                      compat_sys_select
23      n32     sched_yield                     sys_sched_yield
24      n32     mremap                          sys_mremap
25      n32     msync                           sys_msync
26      n32     mincore                         sys_mincore
27      n32     madvise                         sys_madvise
28      n32     shmget                          sys_shmget
29      n32     shmat                           sys_shmat
30      n32     shmctl                          compat_sys_old_shmctl
31      n32     dup                             sys_dup
32      n32     dup2                            sys_dup2
33      n32     pause                           sys_pause
34      n32     nanosleep                       sys_nanosleep_time32
35      n32     getitimer                       compat_sys_getitimer
36      n32     setitimer                       compat_sys_setitimer
37      n32     alarm                           sys_alarm
38      n32     getpid                          sys_getpid
39      n32     sendfile                        compat_sys_sendfile
40      n32     socket                          sys_socket
41      n32     connect                         sys_connect
42      n32     accept                          sys_accept
43      n32     sendto                          sys_sendto
44      n32     recvfrom                        compat_sys_recvfrom
45      n32     sendmsg                         compat_sys_sendmsg
46      n32     recvmsg                         compat_sys_recvmsg
47      n32     shutdown                        sys_shutdown
48      n32     bind                            sys_bind
49      n32     listen                          sys_listen
50      n32     getsockname                     sys_getsockname
51      n32     getpeername                     sys_getpeername
52      n32     socketpair                      sys_socketpair
53      n32     setsockopt                      sys_setsockopt
54      n32     getsockopt                      sys_getsockopt
55      n32     clone                           __sys_clone
56      n32     fork                            __sys_fork
57      n32     execve                          compat_sys_execve
58      n32     exit                            sys_exit
59      n32     wait4                           compat_sys_wait4
60      n32     kill                            sys_kill
61      n32     uname                           sys_newuname
62      n32     semget                          sys_semget
63      n32     semop                           sys_semop
64      n32     semctl                          compat_sys_old_semctl
65      n32     shmdt                           sys_shmdt
66      n32     msgget                          sys_msgget
67      n32     msgsnd                          compat_sys_msgsnd
68      n32     msgrcv                          compat_sys_msgrcv
69      n32     msgctl                          compat_sys_old_msgctl
70      n32     fcntl                           compat_sys_fcntl
71      n32     flock                           sys_flock
72      n32     fsync                           sys_fsync
73      n32     fdatasync                       sys_fdatasync
74      n32     truncate                        sys_truncate
75      n32     ftruncate                       sys_ftruncate
76      n32     getdents                        compat_sys_getdents
77      n32     getcwd                          sys_getcwd
78      n32     chdir                           sys_chdir
79      n32     fchdir                          sys_fchdir
80      n32     rename                          sys_rename
81      n32     mkdir                           sys_mkdir
82      n32     rmdir                           sys_rmdir
83      n32     creat                           sys_creat
84      n32     link                            sys_link
85      n32     unlink                          sys_unlink
86      n32     symlink                         sys_symlink
87      n32     readlink                        sys_readlink
88      n32     chmod                           sys_chmod
89      n32     fchmod                          sys_fchmod
90      n32     chown                           sys_chown
91      n32     fchown                          sys_fchown
92      n32     lchown                          sys_lchown
93      n32     umask                           sys_umask
94      n32     gettimeofday                    compat_sys_gettimeofday
95      n32     getrlimit                       compat_sys_getrlimit
96      n32     getrusage                       compat_sys_getrusage
97      n32     sysinfo                         compat_sys_sysinfo
98      n32     times                           compat_sys_times
99      n32     ptrace                          compat_sys_ptrace
100     n32     getuid                          sys_getuid
101     n32     syslog                          sys_syslog
102     n32     getgid                          sys_getgid
103     n32     setuid                          sys_setuid
104     n32     setgid                          sys_setgid
105     n32     geteuid                         sys_geteuid
106     n32     getegid                         sys_getegid
107     n32     setpgid                         sys_setpgid
108     n32     getppid                         sys_getppid
109     n32     getpgrp                         sys_getpgrp
110     n32     setsid                          sys_setsid
111     n32     setreuid                        sys_setreuid
112     n32     setregid                        sys_setregid
113     n32     getgroups                       sys_getgroups
114     n32     setgroups                       sys_setgroups
115     n32     setresuid                       sys_setresuid
116     n32     getresuid                       sys_getresuid
117     n32     setresgid                       sys_setresgid
118     n32     getresgid                       sys_getresgid
119     n32     getpgid                         sys_getpgid
120     n32     setfsuid                        sys_setfsuid
121     n32     setfsgid                        sys_setfsgid
122     n32     getsid                          sys_getsid
123     n32     capget                          sys_capget
124     n32     capset                          sys_capset
125     n32     rt_sigpending                   compat_sys_rt_sigpending
126     n32     rt_sigtimedwait                 compat_sys_rt_sigtimedwait_time32
127     n32     rt_sigqueueinfo                 compat_sys_rt_sigqueueinfo
128     n32     rt_sigsuspend                   compat_sys_rt_sigsuspend
129     n32     sigaltstack                     compat_sys_sigaltstack
130     n32     utime                           sys_utime32
131     n32     mknod                           sys_mknod
132     n32     personality                     sys_32_personality
133     n32     ustat                           compat_sys_ustat
134     n32     statfs                          compat_sys_statfs
135     n32     fstatfs                         compat_sys_fstatfs
136     n32     sysfs                           sys_sysfs
137     n32     getpriority                     sys_getpriority
138     n32     setpriority                     sys_setpriority
139     n32     sched_setparam                  sys_sched_setparam
140     n32     sched_getparam                  sys_sched_getparam
141     n32     sched_setscheduler              sys_sched_setscheduler
142     n32     sched_getscheduler              sys_sched_getscheduler
143     n32     sched_get_priority_max          sys_sched_get_priority_max
144     n32     sched_get_priority_min          sys_sched_get_priority_min
145     n32     sched_rr_get_interval           sys_sched_rr_get_interval_time32
146     n32     mlock                           sys_mlock
147     n32     munlock                         sys_munlock
148     n32     mlockall                        sys_mlockall
149     n32     munlockall                      sys_munlockall
150     n32     vhangup                         sys_vhangup
151     n32     pivot_root                      sys_pivot_root
152     n32     _sysctl                         sys_ni_syscall
153     n32     prctl                           sys_prctl
154     n32     adjtimex                        sys_adjtimex_time32
155     n32     setrlimit                       compat_sys_setrlimit
156     n32     chroot                          sys_chroot
157     n32     sync                            sys_sync
158     n32     acct                            sys_acct
159     n32     settimeofday                    compat_sys_settimeofday
160     n32     mount                           sys_mount
161     n32     umount2                         sys_umount
162     n32     swapon                          sys_swapon
163     n32     swapoff                         sys_swapoff
164     n32     reboot                          sys_reboot
165     n32     sethostname                     sys_sethostname
166     n32     setdomainname                   sys_setdomainname
167     n32     create_module                   sys_ni_syscall
168     n32     init_module                     sys_init_module
169     n32     delete_module                   sys_delete_module
170     n32     get_kernel_syms                 sys_ni_syscall
171     n32     query_module                    sys_ni_syscall
172     n32     quotactl                        sys_quotactl
173     n32     nfsservctl                      sys_ni_syscall
174     n32     getpmsg                         sys_ni_syscall
175     n32     putpmsg                         sys_ni_syscall
176     n32     afs_syscall                     sys_ni_syscall
# 177 reserved for security
177     n32     reserved177                     sys_ni_syscall
178     n32     gettid                          sys_gettid
179     n32     readahead                       sys_readahead
180     n32     setxattr                        sys_setxattr
181     n32     lsetxattr                       sys_lsetxattr
182     n32     fsetxattr                       sys_fsetxattr
183     n32     getxattr                        sys_getxattr
184     n32     lgetxattr                       sys_lgetxattr
185     n32     fgetxattr                       sys_fgetxattr
186     n32     listxattr                       sys_listxattr
187     n32     llistxattr                      sys_llistxattr
188     n32     flistxattr                      sys_flistxattr
189     n32     removexattr                     sys_removexattr
190     n32     lremovexattr                    sys_lremovexattr
191     n32     fremovexattr                    sys_fremovexattr
192     n32     tkill                           sys_tkill
193     n32     reserved193                     sys_ni_syscall
194     n32     futex                           sys_futex_time32
195     n32     sched_setaffinity               compat_sys_sched_setaffinity
196     n32     sched_getaffinity               compat_sys_sched_getaffinity
197     n32     cacheflush                      sys_cacheflush
198     n32     cachectl                        sys_cachectl
199     n32     sysmips                         __sys_sysmips
200     n32     io_setup                        compat_sys_io_setup
201     n32     io_destroy                      sys_io_destroy
202     n32     io_getevents                    sys_io_getevents_time32
203     n32     io_submit                       compat_sys_io_submit
204     n32     io_cancel                       sys_io_cancel
205     n32     exit_group                      sys_exit_group
206     n32     lookup_dcookie                  sys_lookup_dcookie
207     n32     epoll_create                    sys_epoll_create
208     n32     epoll_ctl                       sys_epoll_ctl
209     n32     epoll_wait                      sys_epoll_wait
210     n32     remap_file_pages                sys_remap_file_pages
211     n32     rt_sigreturn                    sysn32_rt_sigreturn
212     n32     fcntl64                         compat_sys_fcntl64
213     n32     set_tid_address                 sys_set_tid_address
214     n32     restart_syscall                 sys_restart_syscall
215     n32     semtimedop                      sys_semtimedop_time32
216     n32     fadvise64                       sys_fadvise64_64
217     n32     statfs64                        compat_sys_statfs64
218     n32     fstatfs64                       compat_sys_fstatfs64
219     n32     sendfile64                      sys_sendfile64
220     n32     timer_create                    compat_sys_timer_create
221     n32     timer_settime                   sys_timer_settime32
222     n32     timer_gettime                   sys_timer_gettime32
223     n32     timer_getoverrun                sys_timer_getoverrun
224     n32     timer_delete                    sys_timer_delete
225     n32     clock_settime                   sys_clock_settime32
226     n32     clock_gettime                   sys_clock_gettime32
227     n32     clock_getres                    sys_clock_getres_time32
228     n32     clock_nanosleep                 sys_clock_nanosleep_time32
229     n32     tgkill                          sys_tgkill
230     n32     utimes                          sys_utimes_time32
231     n32     mbind                           sys_mbind
232     n32     get_mempolicy                   sys_get_mempolicy
233     n32     set_mempolicy                   sys_set_mempolicy
234     n32     mq_open                         compat_sys_mq_open
235     n32     mq_unlink                       sys_mq_unlink
236     n32     mq_timedsend                    sys_mq_timedsend_time32
237     n32     mq_timedreceive                 sys_mq_timedreceive_time32
238     n32     mq_notify                       compat_sys_mq_notify
239     n32     mq_getsetattr                   compat_sys_mq_getsetattr
240     n32     vserver                         sys_ni_syscall
241     n32     waitid                          compat_sys_waitid
# 242 was sys_setaltroot
243     n32     add_key                         sys_add_key
244     n32     request_key                     sys_request_key
245     n32     keyctl                          compat_sys_keyctl
246     n32     set_thread_area                 sys_set_thread_area
247     n32     inotify_init                    sys_inotify_init
248     n32     inotify_add_watch               sys_inotify_add_watch
249     n32     inotify_rm_watch                sys_inotify_rm_watch
250     n32     migrate_pages                   sys_migrate_pages
251     n32     openat                          sys_openat
252     n32     mkdirat                         sys_mkdirat
253     n32     mknodat                         sys_mknodat
254     n32     fchownat                        sys_fchownat
255     n32     futimesat                       sys_futimesat_time32
256     n32     newfstatat                      sys_newfstatat
257     n32     unlinkat                        sys_unlinkat
258     n32     renameat                        sys_renameat
259     n32     linkat                          sys_linkat
260     n32     symlinkat                       sys_symlinkat
261     n32     readlinkat                      sys_readlinkat
262     n32     fchmodat                        sys_fchmodat
263     n32     faccessat                       sys_faccessat
264     n32     pselect6                        compat_sys_pselect6_time32
265     n32     ppoll                           compat_sys_ppoll_time32
266     n32     unshare                         sys_unshare
267     n32     splice                          sys_splice
268     n32     sync_file_range                 sys_sync_file_range
269     n32     tee                             sys_tee
270     n32     vmsplice                        sys_vmsplice
271     n32     move_pages                      sys_move_pages
272     n32     set_robust_list                 compat_sys_set_robust_list
273     n32     get_robust_list                 compat_sys_get_robust_list
274     n32     kexec_load                      compat_sys_kexec_load
275     n32     getcpu                          sys_getcpu
276     n32     epoll_pwait                     compat_sys_epoll_pwait
277     n32     ioprio_set                      sys_ioprio_set
278     n32     ioprio_get                      sys_ioprio_get
279     n32     utimensat                       sys_utimensat_time32
280     n32     signalfd                        compat_sys_signalfd
281     n32     timerfd                         sys_ni_syscall
282     n32     eventfd                         sys_eventfd
283     n32     fallocate                       sys_fallocate
284     n32     timerfd_create                  sys_timerfd_create
285     n32     timerfd_gettime                 sys_timerfd_gettime32
286     n32     timerfd_settime                 sys_timerfd_settime32
287     n32     signalfd4                       compat_sys_signalfd4
288     n32     eventfd2                        sys_eventfd2
289     n32     epoll_create1                   sys_epoll_create1
290     n32     dup3                            sys_dup3
291     n32     pipe2                           sys_pipe2
292     n32     inotify_init1                   sys_inotify_init1
293     n32     preadv                          compat_sys_preadv
294     n32     pwritev                         compat_sys_pwritev
295     n32     rt_tgsigqueueinfo               compat_sys_rt_tgsigqueueinfo
296     n32     perf_event_open                 sys_perf_event_open
297     n32     accept4                         sys_accept4
298     n32     recvmmsg                        compat_sys_recvmmsg_time32
299     n32     getdents64                      sys_getdents64
300     n32     fanotify_init                   sys_fanotify_init
301     n32     fanotify_mark                   sys_fanotify_mark
302     n32     prlimit64                       sys_prlimit64
303     n32     name_to_handle_at               sys_name_to_handle_at
304     n32     open_by_handle_at               sys_open_by_handle_at
305     n32     clock_adjtime                   sys_clock_adjtime32
306     n32     syncfs                          sys_syncfs
307     n32     sendmmsg                        compat_sys_sendmmsg
308     n32     setns                           sys_setns
309     n32     process_vm_readv                sys_process_vm_readv
310     n32     process_vm_writev               sys_process_vm_writev
311     n32     kcmp                            sys_kcmp
312     n32     finit_module                    sys_finit_module
313     n32     sched_setattr                   sys_sched_setattr
314     n32     sched_getattr                   sys_sched_getattr
315     n32     renameat2                       sys_renameat2
316     n32     seccomp                         sys_seccomp
317     n32     getrandom                       sys_getrandom
318     n32     memfd_create                    sys_memfd_create
319     n32     bpf                             sys_bpf
320     n32     execveat                        compat_sys_execveat
321     n32     userfaultfd                     sys_userfaultfd
322     n32     membarrier                      sys_membarrier
323     n32     mlock2                          sys_mlock2
324     n32     copy_file_range                 sys_copy_file_range
325     n32     preadv2                         compat_sys_preadv2
326     n32     pwritev2                        compat_sys_pwritev2
327     n32     pkey_mprotect                   sys_pkey_mprotect
328     n32     pkey_alloc                      sys_pkey_alloc
329     n32     pkey_free                       sys_pkey_free
330     n32     statx                           sys_statx
331     n32     rseq                            sys_rseq
332     n32     io_pgetevents                   compat_sys_io_pgetevents
# 333 through 402 are unassigned to sync up with generic numbers
403     n32     clock_gettime64                 sys_clock_gettime
404     n32     clock_settime64                 sys_clock_settime
405     n32     clock_adjtime64                 sys_clock_adjtime
406     n32     clock_getres_time64             sys_clock_getres
407     n32     clock_nanosleep_time64          sys_clock_nanosleep
408     n32     timer_gettime64                 sys_timer_gettime
409     n32     timer_settime64                 sys_timer_settime
410     n32     timerfd_gettime64               sys_timerfd_gettime
411     n32     timerfd_settime64               sys_timerfd_settime
412     n32     utimensat_time64                sys_utimensat
413     n32     pselect6_time64                 compat_sys_pselect6_time64
414     n32     ppoll_time64                    compat_sys_ppoll_time64
416     n32     io_pgetevents_time64            sys_io_pgetevents
417     n32     recvmmsg_time64                 compat_sys_recvmmsg_time64
418     n32     mq_timedsend_time64             sys_mq_timedsend
419     n32     mq_timedreceive_time64          sys_mq_timedreceive
420     n32     semtimedop_time64               sys_semtimedop
421     n32     rt_sigtimedwait_time64          compat_sys_rt_sigtimedwait_time64
422     n32     futex_time64                    sys_futex
423     n32     sched_rr_get_interval_time64    sys_sched_rr_get_interval
424     n32     pidfd_send_signal               sys_pidfd_send_signal
425     n32     io_uring_setup                  sys_io_uring_setup
426     n32     io_uring_enter                  sys_io_uring_enter
427     n32     io_uring_register               sys_io_uring_register
428     n32     open_tree                       sys_open_tree
429     n32     move_mount                      sys_move_mount
430     n32     fsopen                          sys_fsopen
431     n32     fsconfig                        sys_fsconfig
432     n32     fsmount                         sys_fsmount
433     n32     fspick                          sys_fspick
434     n32     pidfd_open                      sys_pidfd_open
435     n32     clone3                          __sys_clone3
436     n32     close_range                     sys_close_range
437     n32     openat2                         sys_openat2
438     n32     pidfd_getfd                     sys_pidfd_getfd
439     n32     faccessat2                      sys_faccessat2
440     n32     process_madvise                 sys_process_madvise
441     n32     epoll_pwait2                    compat_sys_epoll_pwait2
442     n32     mount_setattr                   sys_mount_setattr
443     n32     quotactl_fd                     sys_quotactl_fd
444     n32     landlock_create_ruleset         sys_landlock_create_ruleset
445     n32     landlock_add_rule               sys_landlock_add_rule
446     n32     landlock_restrict_self          sys_landlock_restrict_self
# 447 reserved for memfd_secret
448     n32     process_mrelease                sys_process_mrelease
449     n32     futex_waitv                     sys_futex_waitv
450     n32     set_mempolicy_home_node         sys_set_mempolicy_home_node
"""


# MIPS n64 (for 64-bit ABI, present in /lib64)
# - arch/mips/kernel/syscalls/syscall_n64.tbl
mips_n64_syscall_tbl = """
# system call numbers and entry vectors for mips
#
# The format is:
# <number> <abi> <name> <entry point>
#
# The <abi> is always "n64" for this file.
#
0       n64     read                            sys_read
1       n64     write                           sys_write
2       n64     open                            sys_open
3       n64     close                           sys_close
4       n64     stat                            sys_newstat
5       n64     fstat                           sys_newfstat
6       n64     lstat                           sys_newlstat
7       n64     poll                            sys_poll
8       n64     lseek                           sys_lseek
9       n64     mmap                            sys_mips_mmap
10      n64     mprotect                        sys_mprotect
11      n64     munmap                          sys_munmap
12      n64     brk                             sys_brk
13      n64     rt_sigaction                    sys_rt_sigaction
14      n64     rt_sigprocmask                  sys_rt_sigprocmask
15      n64     ioctl                           sys_ioctl
16      n64     pread64                         sys_pread64
17      n64     pwrite64                        sys_pwrite64
18      n64     readv                           sys_readv
19      n64     writev                          sys_writev
20      n64     access                          sys_access
21      n64     pipe                            sysm_pipe
22      n64     _newselect                      sys_select
23      n64     sched_yield                     sys_sched_yield
24      n64     mremap                          sys_mremap
25      n64     msync                           sys_msync
26      n64     mincore                         sys_mincore
27      n64     madvise                         sys_madvise
28      n64     shmget                          sys_shmget
29      n64     shmat                           sys_shmat
30      n64     shmctl                          sys_old_shmctl
31      n64     dup                             sys_dup
32      n64     dup2                            sys_dup2
33      n64     pause                           sys_pause
34      n64     nanosleep                       sys_nanosleep
35      n64     getitimer                       sys_getitimer
36      n64     setitimer                       sys_setitimer
37      n64     alarm                           sys_alarm
38      n64     getpid                          sys_getpid
39      n64     sendfile                        sys_sendfile64
40      n64     socket                          sys_socket
41      n64     connect                         sys_connect
42      n64     accept                          sys_accept
43      n64     sendto                          sys_sendto
44      n64     recvfrom                        sys_recvfrom
45      n64     sendmsg                         sys_sendmsg
46      n64     recvmsg                         sys_recvmsg
47      n64     shutdown                        sys_shutdown
48      n64     bind                            sys_bind
49      n64     listen                          sys_listen
50      n64     getsockname                     sys_getsockname
51      n64     getpeername                     sys_getpeername
52      n64     socketpair                      sys_socketpair
53      n64     setsockopt                      sys_setsockopt
54      n64     getsockopt                      sys_getsockopt
55      n64     clone                           __sys_clone
56      n64     fork                            __sys_fork
57      n64     execve                          sys_execve
58      n64     exit                            sys_exit
59      n64     wait4                           sys_wait4
60      n64     kill                            sys_kill
61      n64     uname                           sys_newuname
62      n64     semget                          sys_semget
63      n64     semop                           sys_semop
64      n64     semctl                          sys_old_semctl
65      n64     shmdt                           sys_shmdt
66      n64     msgget                          sys_msgget
67      n64     msgsnd                          sys_msgsnd
68      n64     msgrcv                          sys_msgrcv
69      n64     msgctl                          sys_old_msgctl
70      n64     fcntl                           sys_fcntl
71      n64     flock                           sys_flock
72      n64     fsync                           sys_fsync
73      n64     fdatasync                       sys_fdatasync
74      n64     truncate                        sys_truncate
75      n64     ftruncate                       sys_ftruncate
76      n64     getdents                        sys_getdents
77      n64     getcwd                          sys_getcwd
78      n64     chdir                           sys_chdir
79      n64     fchdir                          sys_fchdir
80      n64     rename                          sys_rename
81      n64     mkdir                           sys_mkdir
82      n64     rmdir                           sys_rmdir
83      n64     creat                           sys_creat
84      n64     link                            sys_link
85      n64     unlink                          sys_unlink
86      n64     symlink                         sys_symlink
87      n64     readlink                        sys_readlink
88      n64     chmod                           sys_chmod
89      n64     fchmod                          sys_fchmod
90      n64     chown                           sys_chown
91      n64     fchown                          sys_fchown
92      n64     lchown                          sys_lchown
93      n64     umask                           sys_umask
94      n64     gettimeofday                    sys_gettimeofday
95      n64     getrlimit                       sys_getrlimit
96      n64     getrusage                       sys_getrusage
97      n64     sysinfo                         sys_sysinfo
98      n64     times                           sys_times
99      n64     ptrace                          sys_ptrace
100     n64     getuid                          sys_getuid
101     n64     syslog                          sys_syslog
102     n64     getgid                          sys_getgid
103     n64     setuid                          sys_setuid
104     n64     setgid                          sys_setgid
105     n64     geteuid                         sys_geteuid
106     n64     getegid                         sys_getegid
107     n64     setpgid                         sys_setpgid
108     n64     getppid                         sys_getppid
109     n64     getpgrp                         sys_getpgrp
110     n64     setsid                          sys_setsid
111     n64     setreuid                        sys_setreuid
112     n64     setregid                        sys_setregid
113     n64     getgroups                       sys_getgroups
114     n64     setgroups                       sys_setgroups
115     n64     setresuid                       sys_setresuid
116     n64     getresuid                       sys_getresuid
117     n64     setresgid                       sys_setresgid
118     n64     getresgid                       sys_getresgid
119     n64     getpgid                         sys_getpgid
120     n64     setfsuid                        sys_setfsuid
121     n64     setfsgid                        sys_setfsgid
122     n64     getsid                          sys_getsid
123     n64     capget                          sys_capget
124     n64     capset                          sys_capset
125     n64     rt_sigpending                   sys_rt_sigpending
126     n64     rt_sigtimedwait                 sys_rt_sigtimedwait
127     n64     rt_sigqueueinfo                 sys_rt_sigqueueinfo
128     n64     rt_sigsuspend                   sys_rt_sigsuspend
129     n64     sigaltstack                     sys_sigaltstack
130     n64     utime                           sys_utime
131     n64     mknod                           sys_mknod
132     n64     personality                     sys_personality
133     n64     ustat                           sys_ustat
134     n64     statfs                          sys_statfs
135     n64     fstatfs                         sys_fstatfs
136     n64     sysfs                           sys_sysfs
137     n64     getpriority                     sys_getpriority
138     n64     setpriority                     sys_setpriority
139     n64     sched_setparam                  sys_sched_setparam
140     n64     sched_getparam                  sys_sched_getparam
141     n64     sched_setscheduler              sys_sched_setscheduler
142     n64     sched_getscheduler              sys_sched_getscheduler
143     n64     sched_get_priority_max          sys_sched_get_priority_max
144     n64     sched_get_priority_min          sys_sched_get_priority_min
145     n64     sched_rr_get_interval           sys_sched_rr_get_interval
146     n64     mlock                           sys_mlock
147     n64     munlock                         sys_munlock
148     n64     mlockall                        sys_mlockall
149     n64     munlockall                      sys_munlockall
150     n64     vhangup                         sys_vhangup
151     n64     pivot_root                      sys_pivot_root
152     n64     _sysctl                         sys_ni_syscall
153     n64     prctl                           sys_prctl
154     n64     adjtimex                        sys_adjtimex
155     n64     setrlimit                       sys_setrlimit
156     n64     chroot                          sys_chroot
157     n64     sync                            sys_sync
158     n64     acct                            sys_acct
159     n64     settimeofday                    sys_settimeofday
160     n64     mount                           sys_mount
161     n64     umount2                         sys_umount
162     n64     swapon                          sys_swapon
163     n64     swapoff                         sys_swapoff
164     n64     reboot                          sys_reboot
165     n64     sethostname                     sys_sethostname
166     n64     setdomainname                   sys_setdomainname
167     n64     create_module                   sys_ni_syscall
168     n64     init_module                     sys_init_module
169     n64     delete_module                   sys_delete_module
170     n64     get_kernel_syms                 sys_ni_syscall
171     n64     query_module                    sys_ni_syscall
172     n64     quotactl                        sys_quotactl
173     n64     nfsservctl                      sys_ni_syscall
174     n64     getpmsg                         sys_ni_syscall
175     n64     putpmsg                         sys_ni_syscall
176     n64     afs_syscall                     sys_ni_syscall
# 177 reserved for security
177     n64     reserved177                     sys_ni_syscall
178     n64     gettid                          sys_gettid
179     n64     readahead                       sys_readahead
180     n64     setxattr                        sys_setxattr
181     n64     lsetxattr                       sys_lsetxattr
182     n64     fsetxattr                       sys_fsetxattr
183     n64     getxattr                        sys_getxattr
184     n64     lgetxattr                       sys_lgetxattr
185     n64     fgetxattr                       sys_fgetxattr
186     n64     listxattr                       sys_listxattr
187     n64     llistxattr                      sys_llistxattr
188     n64     flistxattr                      sys_flistxattr
189     n64     removexattr                     sys_removexattr
190     n64     lremovexattr                    sys_lremovexattr
191     n64     fremovexattr                    sys_fremovexattr
192     n64     tkill                           sys_tkill
193     n64     reserved193                     sys_ni_syscall
194     n64     futex                           sys_futex
195     n64     sched_setaffinity               sys_sched_setaffinity
196     n64     sched_getaffinity               sys_sched_getaffinity
197     n64     cacheflush                      sys_cacheflush
198     n64     cachectl                        sys_cachectl
199     n64     sysmips                         __sys_sysmips
200     n64     io_setup                        sys_io_setup
201     n64     io_destroy                      sys_io_destroy
202     n64     io_getevents                    sys_io_getevents
203     n64     io_submit                       sys_io_submit
204     n64     io_cancel                       sys_io_cancel
205     n64     exit_group                      sys_exit_group
206     n64     lookup_dcookie                  sys_lookup_dcookie
207     n64     epoll_create                    sys_epoll_create
208     n64     epoll_ctl                       sys_epoll_ctl
209     n64     epoll_wait                      sys_epoll_wait
210     n64     remap_file_pages                sys_remap_file_pages
211     n64     rt_sigreturn                    sys_rt_sigreturn
212     n64     set_tid_address                 sys_set_tid_address
213     n64     restart_syscall                 sys_restart_syscall
214     n64     semtimedop                      sys_semtimedop
215     n64     fadvise64                       sys_fadvise64_64
216     n64     timer_create                    sys_timer_create
217     n64     timer_settime                   sys_timer_settime
218     n64     timer_gettime                   sys_timer_gettime
219     n64     timer_getoverrun                sys_timer_getoverrun
220     n64     timer_delete                    sys_timer_delete
221     n64     clock_settime                   sys_clock_settime
222     n64     clock_gettime                   sys_clock_gettime
223     n64     clock_getres                    sys_clock_getres
224     n64     clock_nanosleep                 sys_clock_nanosleep
225     n64     tgkill                          sys_tgkill
226     n64     utimes                          sys_utimes
227     n64     mbind                           sys_mbind
228     n64     get_mempolicy                   sys_get_mempolicy
229     n64     set_mempolicy                   sys_set_mempolicy
230     n64     mq_open                         sys_mq_open
231     n64     mq_unlink                       sys_mq_unlink
232     n64     mq_timedsend                    sys_mq_timedsend
233     n64     mq_timedreceive                 sys_mq_timedreceive
234     n64     mq_notify                       sys_mq_notify
235     n64     mq_getsetattr                   sys_mq_getsetattr
236     n64     vserver                         sys_ni_syscall
237     n64     waitid                          sys_waitid
# 238 was sys_setaltroot
239     n64     add_key                         sys_add_key
240     n64     request_key                     sys_request_key
241     n64     keyctl                          sys_keyctl
242     n64     set_thread_area                 sys_set_thread_area
243     n64     inotify_init                    sys_inotify_init
244     n64     inotify_add_watch               sys_inotify_add_watch
245     n64     inotify_rm_watch                sys_inotify_rm_watch
246     n64     migrate_pages                   sys_migrate_pages
247     n64     openat                          sys_openat
248     n64     mkdirat                         sys_mkdirat
249     n64     mknodat                         sys_mknodat
250     n64     fchownat                        sys_fchownat
251     n64     futimesat                       sys_futimesat
252     n64     newfstatat                      sys_newfstatat
253     n64     unlinkat                        sys_unlinkat
254     n64     renameat                        sys_renameat
255     n64     linkat                          sys_linkat
256     n64     symlinkat                       sys_symlinkat
257     n64     readlinkat                      sys_readlinkat
258     n64     fchmodat                        sys_fchmodat
259     n64     faccessat                       sys_faccessat
260     n64     pselect6                        sys_pselect6
261     n64     ppoll                           sys_ppoll
262     n64     unshare                         sys_unshare
263     n64     splice                          sys_splice
264     n64     sync_file_range                 sys_sync_file_range
265     n64     tee                             sys_tee
266     n64     vmsplice                        sys_vmsplice
267     n64     move_pages                      sys_move_pages
268     n64     set_robust_list                 sys_set_robust_list
269     n64     get_robust_list                 sys_get_robust_list
270     n64     kexec_load                      sys_kexec_load
271     n64     getcpu                          sys_getcpu
272     n64     epoll_pwait                     sys_epoll_pwait
273     n64     ioprio_set                      sys_ioprio_set
274     n64     ioprio_get                      sys_ioprio_get
275     n64     utimensat                       sys_utimensat
276     n64     signalfd                        sys_signalfd
277     n64     timerfd                         sys_ni_syscall
278     n64     eventfd                         sys_eventfd
279     n64     fallocate                       sys_fallocate
280     n64     timerfd_create                  sys_timerfd_create
281     n64     timerfd_gettime                 sys_timerfd_gettime
282     n64     timerfd_settime                 sys_timerfd_settime
283     n64     signalfd4                       sys_signalfd4
284     n64     eventfd2                        sys_eventfd2
285     n64     epoll_create1                   sys_epoll_create1
286     n64     dup3                            sys_dup3
287     n64     pipe2                           sys_pipe2
288     n64     inotify_init1                   sys_inotify_init1
289     n64     preadv                          sys_preadv
290     n64     pwritev                         sys_pwritev
291     n64     rt_tgsigqueueinfo               sys_rt_tgsigqueueinfo
292     n64     perf_event_open                 sys_perf_event_open
293     n64     accept4                         sys_accept4
294     n64     recvmmsg                        sys_recvmmsg
295     n64     fanotify_init                   sys_fanotify_init
296     n64     fanotify_mark                   sys_fanotify_mark
297     n64     prlimit64                       sys_prlimit64
298     n64     name_to_handle_at               sys_name_to_handle_at
299     n64     open_by_handle_at               sys_open_by_handle_at
300     n64     clock_adjtime                   sys_clock_adjtime
301     n64     syncfs                          sys_syncfs
302     n64     sendmmsg                        sys_sendmmsg
303     n64     setns                           sys_setns
304     n64     process_vm_readv                sys_process_vm_readv
305     n64     process_vm_writev               sys_process_vm_writev
306     n64     kcmp                            sys_kcmp
307     n64     finit_module                    sys_finit_module
308     n64     getdents64                      sys_getdents64
309     n64     sched_setattr                   sys_sched_setattr
310     n64     sched_getattr                   sys_sched_getattr
311     n64     renameat2                       sys_renameat2
312     n64     seccomp                         sys_seccomp
313     n64     getrandom                       sys_getrandom
314     n64     memfd_create                    sys_memfd_create
315     n64     bpf                             sys_bpf
316     n64     execveat                        sys_execveat
317     n64     userfaultfd                     sys_userfaultfd
318     n64     membarrier                      sys_membarrier
319     n64     mlock2                          sys_mlock2
320     n64     copy_file_range                 sys_copy_file_range
321     n64     preadv2                         sys_preadv2
322     n64     pwritev2                        sys_pwritev2
323     n64     pkey_mprotect                   sys_pkey_mprotect
324     n64     pkey_alloc                      sys_pkey_alloc
325     n64     pkey_free                       sys_pkey_free
326     n64     statx                           sys_statx
327     n64     rseq                            sys_rseq
328     n64     io_pgetevents                   sys_io_pgetevents
# 329 through 423 are reserved to sync up with other architectures
424     n64     pidfd_send_signal               sys_pidfd_send_signal
425     n64     io_uring_setup                  sys_io_uring_setup
426     n64     io_uring_enter                  sys_io_uring_enter
427     n64     io_uring_register               sys_io_uring_register
428     n64     open_tree                       sys_open_tree
429     n64     move_mount                      sys_move_mount
430     n64     fsopen                          sys_fsopen
431     n64     fsconfig                        sys_fsconfig
432     n64     fsmount                         sys_fsmount
433     n64     fspick                          sys_fspick
434     n64     pidfd_open                      sys_pidfd_open
435     n64     clone3                          __sys_clone3
436     n64     close_range                     sys_close_range
437     n64     openat2                         sys_openat2
438     n64     pidfd_getfd                     sys_pidfd_getfd
439     n64     faccessat2                      sys_faccessat2
440     n64     process_madvise                 sys_process_madvise
441     n64     epoll_pwait2                    sys_epoll_pwait2
442     n64     mount_setattr                   sys_mount_setattr
443     n64     quotactl_fd                     sys_quotactl_fd
444     n64     landlock_create_ruleset         sys_landlock_create_ruleset
445     n64     landlock_add_rule               sys_landlock_add_rule
446     n64     landlock_restrict_self          sys_landlock_restrict_self
# 447 reserved for memfd_secret
448     n64     process_mrelease                sys_process_mrelease
449     n64     futex_waitv                     sys_futex_waitv
450     common  set_mempolicy_home_node         sys_set_mempolicy_home_node
"""


# PowerPC
# - arch/powerpc/kernel/syscalls/syscall.tbl
ppc_syscall_tbl = """
# system call numbers and entry vectors for powerpc
#
# The format is:
# <number> <abi> <name> <entry point> <compat entry point>
#
# The <abi> can be common, spu, nospu, 64, or 32 for this file.
#
0       nospu   restart_syscall                 sys_restart_syscall
1       nospu   exit                            sys_exit
2       nospu   fork                            sys_fork
3       common  read                            sys_read
4       common  write                           sys_write
5       common  open                            sys_open                        compat_sys_open
6       common  close                           sys_close
7       common  waitpid                         sys_waitpid
8       common  creat                           sys_creat
9       common  link                            sys_link
10      common  unlink                          sys_unlink
11      nospu   execve                          sys_execve                      compat_sys_execve
12      common  chdir                           sys_chdir
13      32      time                            sys_time32
13      64      time                            sys_time
13      spu     time                            sys_time
14      common  mknod                           sys_mknod
15      common  chmod                           sys_chmod
16      common  lchown                          sys_lchown
17      common  break                           sys_ni_syscall
18      32      oldstat                         sys_stat                        sys_ni_syscall
18      64      oldstat                         sys_ni_syscall
18      spu     oldstat                         sys_ni_syscall
19      common  lseek                           sys_lseek                       compat_sys_lseek
20      common  getpid                          sys_getpid
21      nospu   mount                           sys_mount
22      32      umount                          sys_oldumount
22      64      umount                          sys_ni_syscall
22      spu     umount                          sys_ni_syscall
23      common  setuid                          sys_setuid
24      common  getuid                          sys_getuid
25      32      stime                           sys_stime32
25      64      stime                           sys_stime
25      spu     stime                           sys_stime
26      nospu   ptrace                          sys_ptrace                      compat_sys_ptrace
27      common  alarm                           sys_alarm
28      32      oldfstat                        sys_fstat                       sys_ni_syscall
28      64      oldfstat                        sys_ni_syscall
28      spu     oldfstat                        sys_ni_syscall
29      nospu   pause                           sys_pause
30      32      utime                           sys_utime32
30      64      utime                           sys_utime
31      common  stty                            sys_ni_syscall
32      common  gtty                            sys_ni_syscall
33      common  access                          sys_access
34      common  nice                            sys_nice
35      common  ftime                           sys_ni_syscall
36      common  sync                            sys_sync
37      common  kill                            sys_kill
38      common  rename                          sys_rename
39      common  mkdir                           sys_mkdir
40      common  rmdir                           sys_rmdir
41      common  dup                             sys_dup
42      common  pipe                            sys_pipe
43      common  times                           sys_times                       compat_sys_times
44      common  prof                            sys_ni_syscall
45      common  brk                             sys_brk
46      common  setgid                          sys_setgid
47      common  getgid                          sys_getgid
48      nospu   signal                          sys_signal
49      common  geteuid                         sys_geteuid
50      common  getegid                         sys_getegid
51      nospu   acct                            sys_acct
52      nospu   umount2                         sys_umount
53      common  lock                            sys_ni_syscall
54      common  ioctl                           sys_ioctl                       compat_sys_ioctl
55      common  fcntl                           sys_fcntl                       compat_sys_fcntl
56      common  mpx                             sys_ni_syscall
57      common  setpgid                         sys_setpgid
58      common  ulimit                          sys_ni_syscall
59      32      oldolduname                     sys_olduname
59      64      oldolduname                     sys_ni_syscall
59      spu     oldolduname                     sys_ni_syscall
60      common  umask                           sys_umask
61      common  chroot                          sys_chroot
62      nospu   ustat                           sys_ustat                       compat_sys_ustat
63      common  dup2                            sys_dup2
64      common  getppid                         sys_getppid
65      common  getpgrp                         sys_getpgrp
66      common  setsid                          sys_setsid
67      32      sigaction                       sys_sigaction                   compat_sys_sigaction
67      64      sigaction                       sys_ni_syscall
67      spu     sigaction                       sys_ni_syscall
68      common  sgetmask                        sys_sgetmask
69      common  ssetmask                        sys_ssetmask
70      common  setreuid                        sys_setreuid
71      common  setregid                        sys_setregid
72      32      sigsuspend                      sys_sigsuspend
72      64      sigsuspend                      sys_ni_syscall
72      spu     sigsuspend                      sys_ni_syscall
73      32      sigpending                      sys_sigpending                  compat_sys_sigpending
73      64      sigpending                      sys_ni_syscall
73      spu     sigpending                      sys_ni_syscall
74      common  sethostname                     sys_sethostname
75      common  setrlimit                       sys_setrlimit                   compat_sys_setrlimit
76      32      getrlimit                       sys_old_getrlimit               compat_sys_old_getrlimit
76      64      getrlimit                       sys_ni_syscall
76      spu     getrlimit                       sys_ni_syscall
77      common  getrusage                       sys_getrusage                   compat_sys_getrusage
78      common  gettimeofday                    sys_gettimeofday                compat_sys_gettimeofday
79      common  settimeofday                    sys_settimeofday                compat_sys_settimeofday
80      common  getgroups                       sys_getgroups
81      common  setgroups                       sys_setgroups
82      32      select                          ppc_select                      sys_ni_syscall
82      64      select                          sys_ni_syscall
82      spu     select                          sys_ni_syscall
83      common  symlink                         sys_symlink
84      32      oldlstat                        sys_lstat                       sys_ni_syscall
84      64      oldlstat                        sys_ni_syscall
84      spu     oldlstat                        sys_ni_syscall
85      common  readlink                        sys_readlink
86      nospu   uselib                          sys_uselib
87      nospu   swapon                          sys_swapon
88      nospu   reboot                          sys_reboot
89      32      readdir                         sys_old_readdir                 compat_sys_old_readdir
89      64      readdir                         sys_ni_syscall
89      spu     readdir                         sys_ni_syscall
90      common  mmap                            sys_mmap
91      common  munmap                          sys_munmap
92      common  truncate                        sys_truncate                    compat_sys_truncate
93      common  ftruncate                       sys_ftruncate                   compat_sys_ftruncate
94      common  fchmod                          sys_fchmod
95      common  fchown                          sys_fchown
96      common  getpriority                     sys_getpriority
97      common  setpriority                     sys_setpriority
98      common  profil                          sys_ni_syscall
99      nospu   statfs                          sys_statfs                      compat_sys_statfs
100     nospu   fstatfs                         sys_fstatfs                     compat_sys_fstatfs
101     common  ioperm                          sys_ni_syscall
102     common  socketcall                      sys_socketcall                  compat_sys_socketcall
103     common  syslog                          sys_syslog
104     common  setitimer                       sys_setitimer                   compat_sys_setitimer
105     common  getitimer                       sys_getitimer                   compat_sys_getitimer
106     common  stat                            sys_newstat                     compat_sys_newstat
107     common  lstat                           sys_newlstat                    compat_sys_newlstat
108     common  fstat                           sys_newfstat                    compat_sys_newfstat
109     32      olduname                        sys_uname
109     64      olduname                        sys_ni_syscall
109     spu     olduname                        sys_ni_syscall
110     common  iopl                            sys_ni_syscall
111     common  vhangup                         sys_vhangup
112     common  idle                            sys_ni_syscall
113     common  vm86                            sys_ni_syscall
114     common  wait4                           sys_wait4                       compat_sys_wait4
115     nospu   swapoff                         sys_swapoff
116     common  sysinfo                         sys_sysinfo                     compat_sys_sysinfo
117     nospu   ipc                             sys_ipc                         compat_sys_ipc
118     common  fsync                           sys_fsync
119     32      sigreturn                       sys_sigreturn                   compat_sys_sigreturn
119     64      sigreturn                       sys_ni_syscall
119     spu     sigreturn                       sys_ni_syscall
120     nospu   clone                           sys_clone
121     common  setdomainname                   sys_setdomainname
122     common  uname                           sys_newuname
123     common  modify_ldt                      sys_ni_syscall
124     32      adjtimex                        sys_adjtimex_time32
124     64      adjtimex                        sys_adjtimex
124     spu     adjtimex                        sys_adjtimex
125     common  mprotect                        sys_mprotect
126     32      sigprocmask                     sys_sigprocmask                 compat_sys_sigprocmask
126     64      sigprocmask                     sys_ni_syscall
126     spu     sigprocmask                     sys_ni_syscall
127     common  create_module                   sys_ni_syscall
128     nospu   init_module                     sys_init_module
129     nospu   delete_module                   sys_delete_module
130     common  get_kernel_syms                 sys_ni_syscall
131     nospu   quotactl                        sys_quotactl
132     common  getpgid                         sys_getpgid
133     common  fchdir                          sys_fchdir
134     common  bdflush                         sys_ni_syscall
135     common  sysfs                           sys_sysfs
136     32      personality                     sys_personality                 ppc64_personality
136     64      personality                     ppc64_personality
136     spu     personality                     ppc64_personality
137     common  afs_syscall                     sys_ni_syscall
138     common  setfsuid                        sys_setfsuid
139     common  setfsgid                        sys_setfsgid
140     common  _llseek                         sys_llseek
141     common  getdents                        sys_getdents                    compat_sys_getdents
142     common  _newselect                      sys_select                      compat_sys_select
143     common  flock                           sys_flock
144     common  msync                           sys_msync
145     common  readv                           sys_readv
146     common  writev                          sys_writev
147     common  getsid                          sys_getsid
148     common  fdatasync                       sys_fdatasync
149     nospu   _sysctl                         sys_ni_syscall
150     common  mlock                           sys_mlock
151     common  munlock                         sys_munlock
152     common  mlockall                        sys_mlockall
153     common  munlockall                      sys_munlockall
154     common  sched_setparam                  sys_sched_setparam
155     common  sched_getparam                  sys_sched_getparam
156     common  sched_setscheduler              sys_sched_setscheduler
157     common  sched_getscheduler              sys_sched_getscheduler
158     common  sched_yield                     sys_sched_yield
159     common  sched_get_priority_max          sys_sched_get_priority_max
160     common  sched_get_priority_min          sys_sched_get_priority_min
161     32      sched_rr_get_interval           sys_sched_rr_get_interval_time32
161     64      sched_rr_get_interval           sys_sched_rr_get_interval
161     spu     sched_rr_get_interval           sys_sched_rr_get_interval
162     32      nanosleep                       sys_nanosleep_time32
162     64      nanosleep                       sys_nanosleep
162     spu     nanosleep                       sys_nanosleep
163     common  mremap                          sys_mremap
164     common  setresuid                       sys_setresuid
165     common  getresuid                       sys_getresuid
166     common  query_module                    sys_ni_syscall
167     common  poll                            sys_poll
168     common  nfsservctl                      sys_ni_syscall
169     common  setresgid                       sys_setresgid
170     common  getresgid                       sys_getresgid
171     common  prctl                           sys_prctl
172     nospu   rt_sigreturn                    sys_rt_sigreturn                compat_sys_rt_sigreturn
173     nospu   rt_sigaction                    sys_rt_sigaction                compat_sys_rt_sigaction
174     nospu   rt_sigprocmask                  sys_rt_sigprocmask              compat_sys_rt_sigprocmask
175     nospu   rt_sigpending                   sys_rt_sigpending               compat_sys_rt_sigpending
176     32      rt_sigtimedwait                 sys_rt_sigtimedwait_time32      compat_sys_rt_sigtimedwait_time32
176     64      rt_sigtimedwait                 sys_rt_sigtimedwait
177     nospu   rt_sigqueueinfo                 sys_rt_sigqueueinfo             compat_sys_rt_sigqueueinfo
178     nospu   rt_sigsuspend                   sys_rt_sigsuspend               compat_sys_rt_sigsuspend
179     common  pread64                         sys_pread64                     compat_sys_pread64
180     common  pwrite64                        sys_pwrite64                    compat_sys_pwrite64
181     common  chown                           sys_chown
182     common  getcwd                          sys_getcwd
183     common  capget                          sys_capget
184     common  capset                          sys_capset
185     nospu   sigaltstack                     sys_sigaltstack                 compat_sys_sigaltstack
186     32      sendfile                        sys_sendfile                    compat_sys_sendfile
186     64      sendfile                        sys_sendfile64
186     spu     sendfile                        sys_sendfile64
187     common  getpmsg                         sys_ni_syscall
188     common  putpmsg                         sys_ni_syscall
189     nospu   vfork                           sys_vfork
190     common  ugetrlimit                      sys_getrlimit                   compat_sys_getrlimit
191     common  readahead                       sys_readahead                   compat_sys_readahead
192     32      mmap2                           sys_mmap2                       compat_sys_mmap2
193     32      truncate64                      sys_truncate64                  compat_sys_truncate64
194     32      ftruncate64                     sys_ftruncate64                 compat_sys_ftruncate64
195     32      stat64                          sys_stat64
196     32      lstat64                         sys_lstat64
197     32      fstat64                         sys_fstat64
198     nospu   pciconfig_read                  sys_pciconfig_read
199     nospu   pciconfig_write                 sys_pciconfig_write
200     nospu   pciconfig_iobase                sys_pciconfig_iobase
201     common  multiplexer                     sys_ni_syscall
202     common  getdents64                      sys_getdents64
203     common  pivot_root                      sys_pivot_root
204     32      fcntl64                         sys_fcntl64                     compat_sys_fcntl64
205     common  madvise                         sys_madvise
206     common  mincore                         sys_mincore
207     common  gettid                          sys_gettid
208     common  tkill                           sys_tkill
209     common  setxattr                        sys_setxattr
210     common  lsetxattr                       sys_lsetxattr
211     common  fsetxattr                       sys_fsetxattr
212     common  getxattr                        sys_getxattr
213     common  lgetxattr                       sys_lgetxattr
214     common  fgetxattr                       sys_fgetxattr
215     common  listxattr                       sys_listxattr
216     common  llistxattr                      sys_llistxattr
217     common  flistxattr                      sys_flistxattr
218     common  removexattr                     sys_removexattr
219     common  lremovexattr                    sys_lremovexattr
220     common  fremovexattr                    sys_fremovexattr
221     32      futex                           sys_futex_time32
221     64      futex                           sys_futex
221     spu     futex                           sys_futex
222     common  sched_setaffinity               sys_sched_setaffinity           compat_sys_sched_setaffinity
223     common  sched_getaffinity               sys_sched_getaffinity           compat_sys_sched_getaffinity
# 224 unused
225     common  tuxcall                         sys_ni_syscall
226     32      sendfile64                      sys_sendfile64                  compat_sys_sendfile64
227     common  io_setup                        sys_io_setup                    compat_sys_io_setup
228     common  io_destroy                      sys_io_destroy
229     32      io_getevents                    sys_io_getevents_time32
229     64      io_getevents                    sys_io_getevents
229     spu     io_getevents                    sys_io_getevents
230     common  io_submit                       sys_io_submit                   compat_sys_io_submit
231     common  io_cancel                       sys_io_cancel
232     nospu   set_tid_address                 sys_set_tid_address
233     common  fadvise64                       sys_fadvise64                   ppc32_fadvise64
234     nospu   exit_group                      sys_exit_group
235     nospu   lookup_dcookie                  sys_lookup_dcookie              compat_sys_lookup_dcookie
236     common  epoll_create                    sys_epoll_create
237     common  epoll_ctl                       sys_epoll_ctl
238     common  epoll_wait                      sys_epoll_wait
239     common  remap_file_pages                sys_remap_file_pages
240     common  timer_create                    sys_timer_create                compat_sys_timer_create
241     32      timer_settime                   sys_timer_settime32
241     64      timer_settime                   sys_timer_settime
241     spu     timer_settime                   sys_timer_settime
242     32      timer_gettime                   sys_timer_gettime32
242     64      timer_gettime                   sys_timer_gettime
242     spu     timer_gettime                   sys_timer_gettime
243     common  timer_getoverrun                sys_timer_getoverrun
244     common  timer_delete                    sys_timer_delete
245     32      clock_settime                   sys_clock_settime32
245     64      clock_settime                   sys_clock_settime
245     spu     clock_settime                   sys_clock_settime
246     32      clock_gettime                   sys_clock_gettime32
246     64      clock_gettime                   sys_clock_gettime
246     spu     clock_gettime                   sys_clock_gettime
247     32      clock_getres                    sys_clock_getres_time32
247     64      clock_getres                    sys_clock_getres
247     spu     clock_getres                    sys_clock_getres
248     32      clock_nanosleep                 sys_clock_nanosleep_time32
248     64      clock_nanosleep                 sys_clock_nanosleep
248     spu     clock_nanosleep                 sys_clock_nanosleep
249     nospu   swapcontext                     sys_swapcontext                 compat_sys_swapcontext
250     common  tgkill                          sys_tgkill
251     32      utimes                          sys_utimes_time32
251     64      utimes                          sys_utimes
251     spu     utimes                          sys_utimes
252     common  statfs64                        sys_statfs64                    compat_sys_statfs64
253     common  fstatfs64                       sys_fstatfs64                   compat_sys_fstatfs64
254     32      fadvise64_64                    ppc_fadvise64_64
254     spu     fadvise64_64                    sys_ni_syscall
255     common  rtas                            sys_rtas
256     32      sys_debug_setcontext            sys_debug_setcontext            sys_ni_syscall
256     64      sys_debug_setcontext            sys_ni_syscall
256     spu     sys_debug_setcontext            sys_ni_syscall
# 257 reserved for vserver
258     nospu   migrate_pages                   sys_migrate_pages
259     nospu   mbind                           sys_mbind
260     nospu   get_mempolicy                   sys_get_mempolicy
261     nospu   set_mempolicy                   sys_set_mempolicy
262     nospu   mq_open                         sys_mq_open                     compat_sys_mq_open
263     nospu   mq_unlink                       sys_mq_unlink
264     32      mq_timedsend                    sys_mq_timedsend_time32
264     64      mq_timedsend                    sys_mq_timedsend
265     32      mq_timedreceive                 sys_mq_timedreceive_time32
265     64      mq_timedreceive                 sys_mq_timedreceive
266     nospu   mq_notify                       sys_mq_notify                   compat_sys_mq_notify
267     nospu   mq_getsetattr                   sys_mq_getsetattr               compat_sys_mq_getsetattr
268     nospu   kexec_load                      sys_kexec_load                  compat_sys_kexec_load
269     nospu   add_key                         sys_add_key
270     nospu   request_key                     sys_request_key
271     nospu   keyctl                          sys_keyctl                      compat_sys_keyctl
272     nospu   waitid                          sys_waitid                      compat_sys_waitid
273     nospu   ioprio_set                      sys_ioprio_set
274     nospu   ioprio_get                      sys_ioprio_get
275     nospu   inotify_init                    sys_inotify_init
276     nospu   inotify_add_watch               sys_inotify_add_watch
277     nospu   inotify_rm_watch                sys_inotify_rm_watch
278     nospu   spu_run                         sys_spu_run
279     nospu   spu_create                      sys_spu_create
280     32      pselect6                        sys_pselect6_time32             compat_sys_pselect6_time32
280     64      pselect6                        sys_pselect6
281     32      ppoll                           sys_ppoll_time32                compat_sys_ppoll_time32
281     64      ppoll                           sys_ppoll
282     common  unshare                         sys_unshare
283     common  splice                          sys_splice
284     common  tee                             sys_tee
285     common  vmsplice                        sys_vmsplice
286     common  openat                          sys_openat                      compat_sys_openat
287     common  mkdirat                         sys_mkdirat
288     common  mknodat                         sys_mknodat
289     common  fchownat                        sys_fchownat
290     32      futimesat                       sys_futimesat_time32
290     64      futimesat                       sys_futimesat
290     spu     utimesat                        sys_futimesat
291     32      fstatat64                       sys_fstatat64
291     64      newfstatat                      sys_newfstatat
291     spu     newfstatat                      sys_newfstatat
292     common  unlinkat                        sys_unlinkat
293     common  renameat                        sys_renameat
294     common  linkat                          sys_linkat
295     common  symlinkat                       sys_symlinkat
296     common  readlinkat                      sys_readlinkat
297     common  fchmodat                        sys_fchmodat
298     common  faccessat                       sys_faccessat
299     common  get_robust_list                 sys_get_robust_list             compat_sys_get_robust_list
300     common  set_robust_list                 sys_set_robust_list             compat_sys_set_robust_list
301     common  move_pages                      sys_move_pages
302     common  getcpu                          sys_getcpu
303     nospu   epoll_pwait                     sys_epoll_pwait                 compat_sys_epoll_pwait
304     32      utimensat                       sys_utimensat_time32
304     64      utimensat                       sys_utimensat
304     spu     utimensat                       sys_utimensat
305     common  signalfd                        sys_signalfd                    compat_sys_signalfd
306     common  timerfd_create                  sys_timerfd_create
307     common  eventfd                         sys_eventfd
308     common  sync_file_range2                sys_sync_file_range2            compat_sys_sync_file_range2
309     nospu   fallocate                       sys_fallocate                   compat_sys_fallocate
310     nospu   subpage_prot                    sys_subpage_prot
311     32      timerfd_settime                 sys_timerfd_settime32
311     64      timerfd_settime                 sys_timerfd_settime
311     spu     timerfd_settime                 sys_timerfd_settime
312     32      timerfd_gettime                 sys_timerfd_gettime32
312     64      timerfd_gettime                 sys_timerfd_gettime
312     spu     timerfd_gettime                 sys_timerfd_gettime
313     common  signalfd4                       sys_signalfd4                   compat_sys_signalfd4
314     common  eventfd2                        sys_eventfd2
315     common  epoll_create1                   sys_epoll_create1
316     common  dup3                            sys_dup3
317     common  pipe2                           sys_pipe2
318     nospu   inotify_init1                   sys_inotify_init1
319     common  perf_event_open                 sys_perf_event_open
320     common  preadv                          sys_preadv                      compat_sys_preadv
321     common  pwritev                         sys_pwritev                     compat_sys_pwritev
322     nospu   rt_tgsigqueueinfo               sys_rt_tgsigqueueinfo           compat_sys_rt_tgsigqueueinfo
323     nospu   fanotify_init                   sys_fanotify_init
324     nospu   fanotify_mark                   sys_fanotify_mark               compat_sys_fanotify_mark
325     common  prlimit64                       sys_prlimit64
326     common  socket                          sys_socket
327     common  bind                            sys_bind
328     common  connect                         sys_connect
329     common  listen                          sys_listen
330     common  accept                          sys_accept
331     common  getsockname                     sys_getsockname
332     common  getpeername                     sys_getpeername
333     common  socketpair                      sys_socketpair
334     common  send                            sys_send
335     common  sendto                          sys_sendto
336     common  recv                            sys_recv                        compat_sys_recv
337     common  recvfrom                        sys_recvfrom                    compat_sys_recvfrom
338     common  shutdown                        sys_shutdown
339     common  setsockopt                      sys_setsockopt                  sys_setsockopt
340     common  getsockopt                      sys_getsockopt                  sys_getsockopt
341     common  sendmsg                         sys_sendmsg                     compat_sys_sendmsg
342     common  recvmsg                         sys_recvmsg                     compat_sys_recvmsg
343     32      recvmmsg                        sys_recvmmsg_time32             compat_sys_recvmmsg_time32
343     64      recvmmsg                        sys_recvmmsg
343     spu     recvmmsg                        sys_recvmmsg
344     common  accept4                         sys_accept4
345     common  name_to_handle_at               sys_name_to_handle_at
346     common  open_by_handle_at               sys_open_by_handle_at           compat_sys_open_by_handle_at
347     32      clock_adjtime                   sys_clock_adjtime32
347     64      clock_adjtime                   sys_clock_adjtime
347     spu     clock_adjtime                   sys_clock_adjtime
348     common  syncfs                          sys_syncfs
349     common  sendmmsg                        sys_sendmmsg                    compat_sys_sendmmsg
350     common  setns                           sys_setns
351     nospu   process_vm_readv                sys_process_vm_readv
352     nospu   process_vm_writev               sys_process_vm_writev
353     nospu   finit_module                    sys_finit_module
354     nospu   kcmp                            sys_kcmp
355     common  sched_setattr                   sys_sched_setattr
356     common  sched_getattr                   sys_sched_getattr
357     common  renameat2                       sys_renameat2
358     common  seccomp                         sys_seccomp
359     common  getrandom                       sys_getrandom
360     common  memfd_create                    sys_memfd_create
361     common  bpf                             sys_bpf
362     nospu   execveat                        sys_execveat                    compat_sys_execveat
363     32      switch_endian                   sys_ni_syscall
363     64      switch_endian                   sys_switch_endian
363     spu     switch_endian                   sys_ni_syscall
364     common  userfaultfd                     sys_userfaultfd
365     common  membarrier                      sys_membarrier
# 366-377 originally left for IPC, now unused
378     nospu   mlock2                          sys_mlock2
379     nospu   copy_file_range                 sys_copy_file_range
380     common  preadv2                         sys_preadv2                     compat_sys_preadv2
381     common  pwritev2                        sys_pwritev2                    compat_sys_pwritev2
382     nospu   kexec_file_load                 sys_kexec_file_load
383     nospu   statx                           sys_statx
384     nospu   pkey_alloc                      sys_pkey_alloc
385     nospu   pkey_free                       sys_pkey_free
386     nospu   pkey_mprotect                   sys_pkey_mprotect
387     nospu   rseq                            sys_rseq
388     32      io_pgetevents                   sys_io_pgetevents_time32        compat_sys_io_pgetevents
388     64      io_pgetevents                   sys_io_pgetevents
# room for arch specific syscalls
392     64      semtimedop                      sys_semtimedop
393     common  semget                          sys_semget
394     common  semctl                          sys_semctl                      compat_sys_semctl
395     common  shmget                          sys_shmget
396     common  shmctl                          sys_shmctl                      compat_sys_shmctl
397     common  shmat                           sys_shmat                       compat_sys_shmat
398     common  shmdt                           sys_shmdt
399     common  msgget                          sys_msgget
400     common  msgsnd                          sys_msgsnd                      compat_sys_msgsnd
401     common  msgrcv                          sys_msgrcv                      compat_sys_msgrcv
402     common  msgctl                          sys_msgctl                      compat_sys_msgctl
403     32      clock_gettime64                 sys_clock_gettime               sys_clock_gettime
404     32      clock_settime64                 sys_clock_settime               sys_clock_settime
405     32      clock_adjtime64                 sys_clock_adjtime               sys_clock_adjtime
406     32      clock_getres_time64             sys_clock_getres                sys_clock_getres
407     32      clock_nanosleep_time64          sys_clock_nanosleep             sys_clock_nanosleep
408     32      timer_gettime64                 sys_timer_gettime               sys_timer_gettime
409     32      timer_settime64                 sys_timer_settime               sys_timer_settime
410     32      timerfd_gettime64               sys_timerfd_gettime             sys_timerfd_gettime
411     32      timerfd_settime64               sys_timerfd_settime             sys_timerfd_settime
412     32      utimensat_time64                sys_utimensat                   sys_utimensat
413     32      pselect6_time64                 sys_pselect6                    compat_sys_pselect6_time64
414     32      ppoll_time64                    sys_ppoll                       compat_sys_ppoll_time64
416     32      io_pgetevents_time64            sys_io_pgetevents               sys_io_pgetevents
417     32      recvmmsg_time64                 sys_recvmmsg                    compat_sys_recvmmsg_time64
418     32      mq_timedsend_time64             sys_mq_timedsend                sys_mq_timedsend
419     32      mq_timedreceive_time64          sys_mq_timedreceive             sys_mq_timedreceive
420     32      semtimedop_time64               sys_semtimedop                  sys_semtimedop
421     32      rt_sigtimedwait_time64          sys_rt_sigtimedwait             compat_sys_rt_sigtimedwait_time64
422     32      futex_time64                    sys_futex                       sys_futex
423     32      sched_rr_get_interval_time64    sys_sched_rr_get_interval       sys_sched_rr_get_interval
424     common  pidfd_send_signal               sys_pidfd_send_signal
425     common  io_uring_setup                  sys_io_uring_setup
426     common  io_uring_enter                  sys_io_uring_enter
427     common  io_uring_register               sys_io_uring_register
428     common  open_tree                       sys_open_tree
429     common  move_mount                      sys_move_mount
430     common  fsopen                          sys_fsopen
431     common  fsconfig                        sys_fsconfig
432     common  fsmount                         sys_fsmount
433     common  fspick                          sys_fspick
434     common  pidfd_open                      sys_pidfd_open
435     nospu   clone3                          sys_clone3
436     common  close_range                     sys_close_range
437     common  openat2                         sys_openat2
438     common  pidfd_getfd                     sys_pidfd_getfd
439     common  faccessat2                      sys_faccessat2
440     common  process_madvise                 sys_process_madvise
441     common  epoll_pwait2                    sys_epoll_pwait2                compat_sys_epoll_pwait2
442     common  mount_setattr                   sys_mount_setattr
443     common  quotactl_fd                     sys_quotactl_fd
444     common  landlock_create_ruleset         sys_landlock_create_ruleset
445     common  landlock_add_rule               sys_landlock_add_rule
446     common  landlock_restrict_self          sys_landlock_restrict_self
# 447 reserved for memfd_secret
448     common  process_mrelease                sys_process_mrelease
449     common  futex_waitv                     sys_futex_waitv
450     nospu   set_mempolicy_home_node         sys_set_mempolicy_home_node
"""


# SPARC
# - arch/sparc/kernel/syscalls/syscall.tbl
sparc_syscall_tbl = """
# system call numbers and entry vectors for sparc
#
# The format is:
# <number> <abi> <name> <entry point> <compat entry point>
#
# The <abi> can be common, 64, or 32 for this file.
#
0       common  restart_syscall         sys_restart_syscall
1       32      exit                    sys_exit                        sparc_exit
1       64      exit                    sparc_exit
2       common  fork                    sys_fork
3       common  read                    sys_read
4       common  write                   sys_write
5       common  open                    sys_open                        compat_sys_open
6       common  close                   sys_close
7       common  wait4                   sys_wait4                       compat_sys_wait4
8       common  creat                   sys_creat
9       common  link                    sys_link
10      common  unlink                  sys_unlink
11      32      execv                   sunos_execv
11      64      execv                   sys_nis_syscall
12      common  chdir                   sys_chdir
13      32      chown                   sys_chown16
13      64      chown                   sys_chown
14      common  mknod                   sys_mknod
15      common  chmod                   sys_chmod
16      32      lchown                  sys_lchown16
16      64      lchown                  sys_lchown
17      common  brk                     sys_brk
18      common  perfctr                 sys_nis_syscall
19      common  lseek                   sys_lseek                       compat_sys_lseek
20      common  getpid                  sys_getpid
21      common  capget                  sys_capget
22      common  capset                  sys_capset
23      32      setuid                  sys_setuid16
23      64      setuid                  sys_setuid
24      32      getuid                  sys_getuid16
24      64      getuid                  sys_getuid
25      common  vmsplice                sys_vmsplice
26      common  ptrace                  sys_ptrace                      compat_sys_ptrace
27      common  alarm                   sys_alarm
28      common  sigaltstack             sys_sigaltstack                 compat_sys_sigaltstack
29      32      pause                   sys_pause
29      64      pause                   sys_nis_syscall
30      32      utime                   sys_utime32
30      64      utime                   sys_utime
31      32      lchown32                sys_lchown
32      32      fchown32                sys_fchown
33      common  access                  sys_access
34      common  nice                    sys_nice
35      32      chown32                 sys_chown
36      common  sync                    sys_sync
37      common  kill                    sys_kill
38      common  stat                    sys_newstat                     compat_sys_newstat
39      32      sendfile                sys_sendfile                    compat_sys_sendfile
39      64      sendfile                sys_sendfile64
40      common  lstat                   sys_newlstat                    compat_sys_newlstat
41      common  dup                     sys_dup
42      common  pipe                    sys_sparc_pipe
43      common  times                   sys_times                       compat_sys_times
44      32      getuid32                sys_getuid
45      common  umount2                 sys_umount
46      32      setgid                  sys_setgid16
46      64      setgid                  sys_setgid
47      32      getgid                  sys_getgid16
47      64      getgid                  sys_getgid
48      common  signal                  sys_signal
49      32      geteuid                 sys_geteuid16
49      64      geteuid                 sys_geteuid
50      32      getegid                 sys_getegid16
50      64      getegid                 sys_getegid
51      common  acct                    sys_acct
52      64      memory_ordering         sys_memory_ordering
53      32      getgid32                sys_getgid
54      common  ioctl                   sys_ioctl                       compat_sys_ioctl
55      common  reboot                  sys_reboot
56      32      mmap2                   sys_mmap2                       sys32_mmap2
57      common  symlink                 sys_symlink
58      common  readlink                sys_readlink
59      32      execve                  sys_execve                      sys32_execve
59      64      execve                  sys64_execve
60      common  umask                   sys_umask
61      common  chroot                  sys_chroot
62      common  fstat                   sys_newfstat                    compat_sys_newfstat
63      common  fstat64                 sys_fstat64                     compat_sys_fstat64
64      common  getpagesize             sys_getpagesize
65      common  msync                   sys_msync
66      common  vfork                   sys_vfork
67      common  pread64                 sys_pread64                     compat_sys_pread64
68      common  pwrite64                sys_pwrite64                    compat_sys_pwrite64
69      32      geteuid32               sys_geteuid
70      32      getegid32               sys_getegid
71      common  mmap                    sys_mmap
72      32      setreuid32              sys_setreuid
73      32      munmap                  sys_munmap
73      64      munmap                  sys_64_munmap
74      common  mprotect                sys_mprotect
75      common  madvise                 sys_madvise
76      common  vhangup                 sys_vhangup
77      32      truncate64              sys_truncate64                  compat_sys_truncate64
78      common  mincore                 sys_mincore
79      32      getgroups               sys_getgroups16
79      64      getgroups               sys_getgroups
80      32      setgroups               sys_setgroups16
80      64      setgroups               sys_setgroups
81      common  getpgrp                 sys_getpgrp
82      32      setgroups32             sys_setgroups
83      common  setitimer               sys_setitimer                   compat_sys_setitimer
84      32      ftruncate64             sys_ftruncate64                 compat_sys_ftruncate64
85      common  swapon                  sys_swapon
86      common  getitimer               sys_getitimer                   compat_sys_getitimer
87      32      setuid32                sys_setuid
88      common  sethostname             sys_sethostname
89      32      setgid32                sys_setgid
90      common  dup2                    sys_dup2
91      32      setfsuid32              sys_setfsuid
92      common  fcntl                   sys_fcntl                       compat_sys_fcntl
93      common  select                  sys_select
94      32      setfsgid32              sys_setfsgid
95      common  fsync                   sys_fsync
96      common  setpriority             sys_setpriority
97      common  socket                  sys_socket
98      common  connect                 sys_connect
99      common  accept                  sys_accept
100     common  getpriority             sys_getpriority
101     common  rt_sigreturn            sys_rt_sigreturn                sys32_rt_sigreturn
102     common  rt_sigaction            sys_rt_sigaction                compat_sys_rt_sigaction
103     common  rt_sigprocmask          sys_rt_sigprocmask              compat_sys_rt_sigprocmask
104     common  rt_sigpending           sys_rt_sigpending               compat_sys_rt_sigpending
105     32      rt_sigtimedwait         sys_rt_sigtimedwait_time32      compat_sys_rt_sigtimedwait_time32
105     64      rt_sigtimedwait         sys_rt_sigtimedwait
106     common  rt_sigqueueinfo         sys_rt_sigqueueinfo             compat_sys_rt_sigqueueinfo
107     common  rt_sigsuspend           sys_rt_sigsuspend               compat_sys_rt_sigsuspend
108     32      setresuid32             sys_setresuid
108     64      setresuid               sys_setresuid
109     32      getresuid32             sys_getresuid
109     64      getresuid               sys_getresuid
110     32      setresgid32             sys_setresgid
110     64      setresgid               sys_setresgid
111     32      getresgid32             sys_getresgid
111     64      getresgid               sys_getresgid
112     32      setregid32              sys_setregid
113     common  recvmsg                 sys_recvmsg                     compat_sys_recvmsg
114     common  sendmsg                 sys_sendmsg                     compat_sys_sendmsg
115     32      getgroups32             sys_getgroups
116     common  gettimeofday            sys_gettimeofday                compat_sys_gettimeofday
117     common  getrusage               sys_getrusage                   compat_sys_getrusage
118     common  getsockopt              sys_getsockopt                  sys_getsockopt
119     common  getcwd                  sys_getcwd
120     common  readv                   sys_readv
121     common  writev                  sys_writev
122     common  settimeofday            sys_settimeofday                compat_sys_settimeofday
123     32      fchown                  sys_fchown16
123     64      fchown                  sys_fchown
124     common  fchmod                  sys_fchmod
125     common  recvfrom                sys_recvfrom
126     32      setreuid                sys_setreuid16
126     64      setreuid                sys_setreuid
127     32      setregid                sys_setregid16
127     64      setregid                sys_setregid
128     common  rename                  sys_rename
129     common  truncate                sys_truncate                    compat_sys_truncate
130     common  ftruncate               sys_ftruncate                   compat_sys_ftruncate
131     common  flock                   sys_flock
132     common  lstat64                 sys_lstat64                     compat_sys_lstat64
133     common  sendto                  sys_sendto
134     common  shutdown                sys_shutdown
135     common  socketpair              sys_socketpair
136     common  mkdir                   sys_mkdir
137     common  rmdir                   sys_rmdir
138     32      utimes                  sys_utimes_time32
138     64      utimes                  sys_utimes
139     common  stat64                  sys_stat64                      compat_sys_stat64
140     common  sendfile64              sys_sendfile64
141     common  getpeername             sys_getpeername
142     32      futex                   sys_futex_time32
142     64      futex                   sys_futex
143     common  gettid                  sys_gettid
144     common  getrlimit               sys_getrlimit                   compat_sys_getrlimit
145     common  setrlimit               sys_setrlimit                   compat_sys_setrlimit
146     common  pivot_root              sys_pivot_root
147     common  prctl                   sys_prctl
148     common  pciconfig_read          sys_pciconfig_read
149     common  pciconfig_write         sys_pciconfig_write
150     common  getsockname             sys_getsockname
151     common  inotify_init            sys_inotify_init
152     common  inotify_add_watch       sys_inotify_add_watch
153     common  poll                    sys_poll
154     common  getdents64              sys_getdents64
155     32      fcntl64                 sys_fcntl64                     compat_sys_fcntl64
156     common  inotify_rm_watch        sys_inotify_rm_watch
157     common  statfs                  sys_statfs                      compat_sys_statfs
158     common  fstatfs                 sys_fstatfs                     compat_sys_fstatfs
159     common  umount                  sys_oldumount
160     common  sched_set_affinity      sys_sched_setaffinity           compat_sys_sched_setaffinity
161     common  sched_get_affinity      sys_sched_getaffinity           compat_sys_sched_getaffinity
162     common  getdomainname           sys_getdomainname
163     common  setdomainname           sys_setdomainname
164     64      utrap_install           sys_utrap_install
165     common  quotactl                sys_quotactl
166     common  set_tid_address         sys_set_tid_address
167     common  mount                   sys_mount
168     common  ustat                   sys_ustat                       compat_sys_ustat
169     common  setxattr                sys_setxattr
170     common  lsetxattr               sys_lsetxattr
171     common  fsetxattr               sys_fsetxattr
172     common  getxattr                sys_getxattr
173     common  lgetxattr               sys_lgetxattr
174     common  getdents                sys_getdents                    compat_sys_getdents
175     common  setsid                  sys_setsid
176     common  fchdir                  sys_fchdir
177     common  fgetxattr               sys_fgetxattr
178     common  listxattr               sys_listxattr
179     common  llistxattr              sys_llistxattr
180     common  flistxattr              sys_flistxattr
181     common  removexattr             sys_removexattr
182     common  lremovexattr            sys_lremovexattr
183     32      sigpending              sys_sigpending                  compat_sys_sigpending
183     64      sigpending              sys_nis_syscall
184     common  query_module            sys_ni_syscall
185     common  setpgid                 sys_setpgid
186     common  fremovexattr            sys_fremovexattr
187     common  tkill                   sys_tkill
188     32      exit_group              sys_exit_group                  sparc_exit_group
188     64      exit_group              sparc_exit_group
189     common  uname                   sys_newuname
190     common  init_module             sys_init_module
191     32      personality             sys_personality                 sys_sparc64_personality
191     64      personality             sys_sparc64_personality
192     32      remap_file_pages        sys_sparc_remap_file_pages      sys_remap_file_pages
192     64      remap_file_pages        sys_remap_file_pages
193     common  epoll_create            sys_epoll_create
194     common  epoll_ctl               sys_epoll_ctl
195     common  epoll_wait              sys_epoll_wait
196     common  ioprio_set              sys_ioprio_set
197     common  getppid                 sys_getppid
198     32      sigaction               sys_sparc_sigaction             compat_sys_sparc_sigaction
198     64      sigaction               sys_nis_syscall
199     common  sgetmask                sys_sgetmask
200     common  ssetmask                sys_ssetmask
201     32      sigsuspend              sys_sigsuspend
201     64      sigsuspend              sys_nis_syscall
202     common  oldlstat                sys_newlstat                    compat_sys_newlstat
203     common  uselib                  sys_uselib
204     32      readdir                 sys_old_readdir                 compat_sys_old_readdir
204     64      readdir                 sys_nis_syscall
205     common  readahead               sys_readahead                   compat_sys_readahead
206     common  socketcall              sys_socketcall                  sys32_socketcall
207     common  syslog                  sys_syslog
208     common  lookup_dcookie          sys_lookup_dcookie              compat_sys_lookup_dcookie
209     common  fadvise64               sys_fadvise64                   compat_sys_fadvise64
210     common  fadvise64_64            sys_fadvise64_64                compat_sys_fadvise64_64
211     common  tgkill                  sys_tgkill
212     common  waitpid                 sys_waitpid
213     common  swapoff                 sys_swapoff
214     common  sysinfo                 sys_sysinfo                     compat_sys_sysinfo
215     32      ipc                     sys_ipc                         compat_sys_ipc
215     64      ipc                     sys_sparc_ipc
216     32      sigreturn               sys_sigreturn                   sys32_sigreturn
216     64      sigreturn               sys_nis_syscall
217     common  clone                   sys_clone
218     common  ioprio_get              sys_ioprio_get
219     32      adjtimex                sys_adjtimex_time32
219     64      adjtimex                sys_sparc_adjtimex
220     32      sigprocmask             sys_sigprocmask                 compat_sys_sigprocmask
220     64      sigprocmask             sys_nis_syscall
221     common  create_module           sys_ni_syscall
222     common  delete_module           sys_delete_module
223     common  get_kernel_syms         sys_ni_syscall
224     common  getpgid                 sys_getpgid
225     common  bdflush                 sys_ni_syscall
226     common  sysfs                   sys_sysfs
227     common  afs_syscall             sys_nis_syscall
228     common  setfsuid                sys_setfsuid16
229     common  setfsgid                sys_setfsgid16
230     common  _newselect              sys_select                      compat_sys_select
231     32      time                    sys_time32
232     common  splice                  sys_splice
233     32      stime                   sys_stime32
233     64      stime                   sys_stime
234     common  statfs64                sys_statfs64                    compat_sys_statfs64
235     common  fstatfs64               sys_fstatfs64                   compat_sys_fstatfs64
236     common  _llseek                 sys_llseek
237     common  mlock                   sys_mlock
238     common  munlock                 sys_munlock
239     common  mlockall                sys_mlockall
240     common  munlockall              sys_munlockall
241     common  sched_setparam          sys_sched_setparam
242     common  sched_getparam          sys_sched_getparam
243     common  sched_setscheduler      sys_sched_setscheduler
244     common  sched_getscheduler      sys_sched_getscheduler
245     common  sched_yield             sys_sched_yield
246     common  sched_get_priority_max  sys_sched_get_priority_max
247     common  sched_get_priority_min  sys_sched_get_priority_min
248     32      sched_rr_get_interval   sys_sched_rr_get_interval_time32
248     64      sched_rr_get_interval   sys_sched_rr_get_interval
249     32      nanosleep               sys_nanosleep_time32
249     64      nanosleep               sys_nanosleep
250     32      mremap                  sys_mremap
250     64      mremap                  sys_64_mremap
251     common  _sysctl                 sys_ni_syscall
252     common  getsid                  sys_getsid
253     common  fdatasync               sys_fdatasync
254     32      nfsservctl              sys_ni_syscall                  sys_nis_syscall
254     64      nfsservctl              sys_nis_syscall
255     common  sync_file_range         sys_sync_file_range             compat_sys_sync_file_range
256     32      clock_settime           sys_clock_settime32
256     64      clock_settime           sys_clock_settime
257     32      clock_gettime           sys_clock_gettime32
257     64      clock_gettime           sys_clock_gettime
258     32      clock_getres            sys_clock_getres_time32
258     64      clock_getres            sys_clock_getres
259     32      clock_nanosleep         sys_clock_nanosleep_time32
259     64      clock_nanosleep         sys_clock_nanosleep
260     common  sched_getaffinity       sys_sched_getaffinity           compat_sys_sched_getaffinity
261     common  sched_setaffinity       sys_sched_setaffinity           compat_sys_sched_setaffinity
262     32      timer_settime           sys_timer_settime32
262     64      timer_settime           sys_timer_settime
263     32      timer_gettime           sys_timer_gettime32
263     64      timer_gettime           sys_timer_gettime
264     common  timer_getoverrun        sys_timer_getoverrun
265     common  timer_delete            sys_timer_delete
266     common  timer_create            sys_timer_create                compat_sys_timer_create
# 267 was vserver
267     common  vserver                 sys_nis_syscall
268     common  io_setup                sys_io_setup                    compat_sys_io_setup
269     common  io_destroy              sys_io_destroy
270     common  io_submit               sys_io_submit                   compat_sys_io_submit
271     common  io_cancel               sys_io_cancel
272     32      io_getevents            sys_io_getevents_time32
272     64      io_getevents            sys_io_getevents
273     common  mq_open                 sys_mq_open                     compat_sys_mq_open
274     common  mq_unlink               sys_mq_unlink
275     32      mq_timedsend            sys_mq_timedsend_time32
275     64      mq_timedsend            sys_mq_timedsend
276     32      mq_timedreceive         sys_mq_timedreceive_time32
276     64      mq_timedreceive         sys_mq_timedreceive
277     common  mq_notify               sys_mq_notify                   compat_sys_mq_notify
278     common  mq_getsetattr           sys_mq_getsetattr               compat_sys_mq_getsetattr
279     common  waitid                  sys_waitid                      compat_sys_waitid
280     common  tee                     sys_tee
281     common  add_key                 sys_add_key
282     common  request_key             sys_request_key
283     common  keyctl                  sys_keyctl                      compat_sys_keyctl
284     common  openat                  sys_openat                      compat_sys_openat
285     common  mkdirat                 sys_mkdirat
286     common  mknodat                 sys_mknodat
287     common  fchownat                sys_fchownat
288     32      futimesat               sys_futimesat_time32
288     64      futimesat               sys_futimesat
289     common  fstatat64               sys_fstatat64                   compat_sys_fstatat64
290     common  unlinkat                sys_unlinkat
291     common  renameat                sys_renameat
292     common  linkat                  sys_linkat
293     common  symlinkat               sys_symlinkat
294     common  readlinkat              sys_readlinkat
295     common  fchmodat                sys_fchmodat
296     common  faccessat               sys_faccessat
297     32      pselect6                sys_pselect6_time32             compat_sys_pselect6_time32
297     64      pselect6                sys_pselect6
298     32      ppoll                   sys_ppoll_time32                compat_sys_ppoll_time32
298     64      ppoll                   sys_ppoll
299     common  unshare                 sys_unshare
300     common  set_robust_list         sys_set_robust_list             compat_sys_set_robust_list
301     common  get_robust_list         sys_get_robust_list             compat_sys_get_robust_list
302     common  migrate_pages           sys_migrate_pages
303     common  mbind                   sys_mbind
304     common  get_mempolicy           sys_get_mempolicy
305     common  set_mempolicy           sys_set_mempolicy
306     common  kexec_load              sys_kexec_load                  compat_sys_kexec_load
307     common  move_pages              sys_move_pages
308     common  getcpu                  sys_getcpu
309     common  epoll_pwait             sys_epoll_pwait                 compat_sys_epoll_pwait
310     32      utimensat               sys_utimensat_time32
310     64      utimensat               sys_utimensat
311     common  signalfd                sys_signalfd                    compat_sys_signalfd
312     common  timerfd_create          sys_timerfd_create
313     common  eventfd                 sys_eventfd
314     common  fallocate               sys_fallocate                   compat_sys_fallocate
315     32      timerfd_settime         sys_timerfd_settime32
315     64      timerfd_settime         sys_timerfd_settime
316     32      timerfd_gettime         sys_timerfd_gettime32
316     64      timerfd_gettime         sys_timerfd_gettime
317     common  signalfd4               sys_signalfd4                   compat_sys_signalfd4
318     common  eventfd2                sys_eventfd2
319     common  epoll_create1           sys_epoll_create1
320     common  dup3                    sys_dup3
321     common  pipe2                   sys_pipe2
322     common  inotify_init1           sys_inotify_init1
323     common  accept4                 sys_accept4
324     common  preadv                  sys_preadv                      compat_sys_preadv
325     common  pwritev                 sys_pwritev                     compat_sys_pwritev
326     common  rt_tgsigqueueinfo       sys_rt_tgsigqueueinfo           compat_sys_rt_tgsigqueueinfo
327     common  perf_event_open         sys_perf_event_open
328     32      recvmmsg                sys_recvmmsg_time32             compat_sys_recvmmsg_time32
328     64      recvmmsg                sys_recvmmsg
329     common  fanotify_init           sys_fanotify_init
330     common  fanotify_mark           sys_fanotify_mark               compat_sys_fanotify_mark
331     common  prlimit64               sys_prlimit64
332     common  name_to_handle_at       sys_name_to_handle_at
333     common  open_by_handle_at       sys_open_by_handle_at           compat_sys_open_by_handle_at
334     32      clock_adjtime           sys_clock_adjtime32
334     64      clock_adjtime           sys_sparc_clock_adjtime
335     common  syncfs                  sys_syncfs
336     common  sendmmsg                sys_sendmmsg                    compat_sys_sendmmsg
337     common  setns                   sys_setns
338     common  process_vm_readv        sys_process_vm_readv
339     common  process_vm_writev       sys_process_vm_writev
340     32      kern_features           sys_ni_syscall                  sys_kern_features
340     64      kern_features           sys_kern_features
341     common  kcmp                    sys_kcmp
342     common  finit_module            sys_finit_module
343     common  sched_setattr           sys_sched_setattr
344     common  sched_getattr           sys_sched_getattr
345     common  renameat2               sys_renameat2
346     common  seccomp                 sys_seccomp
347     common  getrandom               sys_getrandom
348     common  memfd_create            sys_memfd_create
349     common  bpf                     sys_bpf
350     32      execveat                sys_execveat                    sys32_execveat
350     64      execveat                sys64_execveat
351     common  membarrier              sys_membarrier
352     common  userfaultfd             sys_userfaultfd
353     common  bind                    sys_bind
354     common  listen                  sys_listen
355     common  setsockopt              sys_setsockopt                  sys_setsockopt
356     common  mlock2                  sys_mlock2
357     common  copy_file_range         sys_copy_file_range
358     common  preadv2                 sys_preadv2                     compat_sys_preadv2
359     common  pwritev2                sys_pwritev2                    compat_sys_pwritev2
360     common  statx                   sys_statx
361     32      io_pgetevents           sys_io_pgetevents_time32        compat_sys_io_pgetevents
361     64      io_pgetevents           sys_io_pgetevents
362     common  pkey_mprotect           sys_pkey_mprotect
363     common  pkey_alloc              sys_pkey_alloc
364     common  pkey_free               sys_pkey_free
365     common  rseq                    sys_rseq
# room for arch specific syscalls
392     64      semtimedop                      sys_semtimedop
393     common  semget                  sys_semget
394     common  semctl                  sys_semctl                      compat_sys_semctl
395     common  shmget                  sys_shmget
396     common  shmctl                  sys_shmctl                      compat_sys_shmctl
397     common  shmat                   sys_shmat                       compat_sys_shmat
398     common  shmdt                   sys_shmdt
399     common  msgget                  sys_msgget
400     common  msgsnd                  sys_msgsnd                      compat_sys_msgsnd
401     common  msgrcv                  sys_msgrcv                      compat_sys_msgrcv
402     common  msgctl                  sys_msgctl                      compat_sys_msgctl
403     32      clock_gettime64                 sys_clock_gettime               sys_clock_gettime
404     32      clock_settime64                 sys_clock_settime               sys_clock_settime
405     32      clock_adjtime64                 sys_clock_adjtime               sys_clock_adjtime
406     32      clock_getres_time64             sys_clock_getres                sys_clock_getres
407     32      clock_nanosleep_time64          sys_clock_nanosleep             sys_clock_nanosleep
408     32      timer_gettime64                 sys_timer_gettime               sys_timer_gettime
409     32      timer_settime64                 sys_timer_settime               sys_timer_settime
410     32      timerfd_gettime64               sys_timerfd_gettime             sys_timerfd_gettime
411     32      timerfd_settime64               sys_timerfd_settime             sys_timerfd_settime
412     32      utimensat_time64                sys_utimensat                   sys_utimensat
413     32      pselect6_time64                 sys_pselect6                    compat_sys_pselect6_time64
414     32      ppoll_time64                    sys_ppoll                       compat_sys_ppoll_time64
416     32      io_pgetevents_time64            sys_io_pgetevents               sys_io_pgetevents
417     32      recvmmsg_time64                 sys_recvmmsg                    compat_sys_recvmmsg_time64
418     32      mq_timedsend_time64             sys_mq_timedsend                sys_mq_timedsend
419     32      mq_timedreceive_time64          sys_mq_timedreceive             sys_mq_timedreceive
420     32      semtimedop_time64               sys_semtimedop                  sys_semtimedop
421     32      rt_sigtimedwait_time64          sys_rt_sigtimedwait             compat_sys_rt_sigtimedwait_time64
422     32      futex_time64                    sys_futex                       sys_futex
423     32      sched_rr_get_interval_time64    sys_sched_rr_get_interval       sys_sched_rr_get_interval
424     common  pidfd_send_signal               sys_pidfd_send_signal
425     common  io_uring_setup                  sys_io_uring_setup
426     common  io_uring_enter                  sys_io_uring_enter
427     common  io_uring_register               sys_io_uring_register
428     common  open_tree                       sys_open_tree
429     common  move_mount                      sys_move_mount
430     common  fsopen                          sys_fsopen
431     common  fsconfig                        sys_fsconfig
432     common  fsmount                         sys_fsmount
433     common  fspick                          sys_fspick
434     common  pidfd_open                      sys_pidfd_open
# 435 reserved for clone3
436     common  close_range                     sys_close_range
437     common  openat2                 sys_openat2
438     common  pidfd_getfd                     sys_pidfd_getfd
439     common  faccessat2                      sys_faccessat2
440     common  process_madvise                 sys_process_madvise
441     common  epoll_pwait2                    sys_epoll_pwait2                compat_sys_epoll_pwait2
442     common  mount_setattr                   sys_mount_setattr
443     common  quotactl_fd                     sys_quotactl_fd
444     common  landlock_create_ruleset         sys_landlock_create_ruleset
445     common  landlock_add_rule               sys_landlock_add_rule
446     common  landlock_restrict_self          sys_landlock_restrict_self
# 447 reserved for memfd_secret
448     common  process_mrelease                sys_process_mrelease
449     common  futex_waitv                     sys_futex_waitv
450     common  set_mempolicy_home_node         sys_set_mempolicy_home_node
"""


def parse_syscall_table_defs(table_defs):
    table = []
    for line in table_defs.splitlines():
        if line == "":
            continue
        if line.startswith("#"):
            continue
        entry = line.split()
        if len(entry) == 3: # it is unimplemented
            continue
        entry[0] = int(entry[0])
        table.append(entry)
    return table


# ARM/ARM64 OP-TEE (at secure world)
# - core/include/tee/tee_svc.h
# - core/include/tee/tee_svc_cryp.h
# - core/include/tee/tee_svc_storage.h
# - core/include/tee/svc_cache.h
arm_OPTEE_syscall_list = [
    [0x00, 'syscall_sys_return', ['unsigned long ret']],
    [0x01, 'syscall_log', ['const void *buf', 'size_t len']],
    [0x02, 'syscall_panic', ['unsigned long code']],
    [0x03, 'syscall_get_property', ['unsigned long prop_set', 'unsigned long index', 'void *name', 'uint32_t *name_len', 'void *buf', 'uint32_t *blen', 'uint32_t *prop_type']],
    [0x04, 'syscall_get_property_name_to_index', ['unsigned long prop_set', 'void *name', 'unsigned long name_len', 'uint32_t *index']],
    [0x05, 'syscall_open_ta_session', ['const TEE_UUID *dest', 'unsigned long cancel_req_to', 'struct utee_params *params', 'uint32_t *sess', 'uint32_t *ret_orig']],
    [0x06, 'syscall_close_ta_session', ['unsigned long sess']],
    [0x07, 'syscall_invoke_ta_command', ['unsigned long sess', 'unsigned long cancel_req_to', 'unsigned long cmd_id', 'struct utee_params *params', 'uint32_t *ret_orig']],
    [0x08, 'syscall_check_access_rights', ['unsigned long flags', 'const void *buf', 'size_t len']],
    [0x09, 'syscall_get_cancellation_flag', ['uint32_t *cancel', ]],
    [0x0a, 'syscall_unmask_cancellation', ['uint32_t *old_mask']],
    [0x0b, 'syscall_mask_cancellation', ['uint32_t *old_mask']],
    [0x0c, 'syscall_wait', ['unsigned long timeout']],
    [0x0d, 'syscall_get_time', ['unsigned long cat', 'TEE_Time *time']],
    [0x0e, 'syscall_set_ta_time', ['const TEE_Time *time']],
    [0x0f, 'syscall_cryp_state_alloc', ['unsigned long algo', 'unsigned long op_mode', 'unsigned long key1', 'unsigned long key2', 'uint32_t *state']],
    [0x10, 'syscall_cryp_state_copy', ['unsigned long dst', 'unsigned long src']],
    [0x11, 'syscall_cryp_state_free', ['unsigned long state']],
    [0x12, 'syscall_hash_init', ['unsigned long state', 'const void *iv', 'size_t iv_len']],
    [0x13, 'syscall_hash_update', ['unsigned long state', 'const void *chunk', 'size_t chunk_size']],
    [0x14, 'syscall_hash_final', ['unsigned long state', 'const void *chunk', 'size_t chunk_size', 'void *hash', 'uint64_t *hash_len']],
    [0x15, 'syscall_cipher_init', ['unsigned long state', 'const void *iv', 'size_t iv_len']],
    [0x16, 'syscall_cipher_update', ['unsigned long state', 'const void *src', 'size_t src_len', 'void *dest', 'uint64_t *dest_len']],
    [0x17, 'syscall_cipher_final', ['unsigned long state', 'const void *src', 'size_t src_len', 'void *dest', 'uint64_t *dest_len']],
    [0x18, 'syscall_cryp_obj_get_info', ['unsigned long obj', 'TEE_ObjectInfo *info']],
    [0x19, 'syscall_cryp_obj_restrict_usage', ['unsigned long obj', 'unsigned long usage']],
    [0x1a, 'syscall_cryp_obj_get_attr', ['unsigned long obj', 'unsigned long attr_id', 'void *buffer', 'uint64_t *size']],
    [0x1b, 'syscall_cryp_obj_alloc', ['unsigned long obj_type', 'unsigned long max_key_size', 'uint32_t *obj']],
    [0x1c, 'syscall_cryp_obj_close', ['unsigned long obj']],
    [0x1d, 'syscall_cryp_obj_reset', ['unsigned long obj']],
    [0x1e, 'syscall_cryp_obj_populate', ['unsigned long obj', 'struct utee_attribute *attrs', 'unsigned long attr_count']],
    [0x1f, 'syscall_cryp_obj_copy', ['unsigned long dst_obj', 'unsigned long src_obj']],
    [0x20, 'syscall_cryp_derive_key', ['unsigned long state', 'const struct utee_attribute *params', 'unsigned long param_count', 'unsigned long derived_key']],
    [0x21, 'syscall_cryp_random_number_generate', ['void *buf', 'size_t blen']],
    [0x22, 'syscall_authenc_init', ['unsigned long state', 'const void *nonce', 'size_t nonce_len', 'size_t tag_len', 'size_t aad_len', 'size_t payload_len']],
    [0x23, 'syscall_authenc_update_aad', ['unsigned long state', 'const void *aad_data', 'size_t aad_data_len']],
    [0x24, 'syscall_authenc_update_payload', ['unsigned long state', 'const void *src_data', 'size_t src_len', 'void *dest_data', 'uint64_t *dest_len']],
    [0x25, 'syscall_authenc_enc_final', ['unsigned long state', 'const void *src_data', 'size_t src_len', 'void *dest_data', 'uint64_t *dest_len', 'void *tag', 'uint64_t *tag_len']],
    [0x26, 'syscall_authenc_dec_final', ['unsigned long state', 'const void *src_data', 'size_t src_len', 'void *dest_data', 'uint64_t *dest_len', 'const void *tag', 'uint64_t *tag_len']],
    [0x27, 'syscall_asymm_operate', ['unsigned long state', 'const struct utee_attribute *usr_params', 'size_t num_params', 'const void *src_data', 'size_t src_len', 'void *dest_data', 'uint64_t *dest_len']],
    [0x28, 'syscall_asymm_verify', ['unsigned long state', 'const struct utee_attribute *usr_params', 'size_t num_params', 'const void *data', 'size_t data_len', 'const void *sig', 'size_t sig_len']],
    [0x29, 'syscall_storage_obj_open', ['unsigned long storage_id', 'void *object_id', 'size_t object_id_len', 'unsigned long flags', 'uint32_t *obj']],
    [0x2a, 'syscall_storage_obj_create', ['unsigned long storage_id', 'void *object_id', 'size_t object_id_len', 'unsigned long flags', 'unsigned long attr', 'void *data', 'size_t len', 'uint32_t *obj']],
    [0x2b, 'syscall_storage_obj_del', ['unsigned long obj']],
    [0x2c, 'syscall_storage_obj_rename', ['unsigned long obj', 'void *object_id', 'size_t object_id_len']],
    [0x2d, 'syscall_storage_alloc_enum', ['uint32_t *obj_enum']],
    [0x2e, 'syscall_storage_free_enum', ['nsigned long obj_enum']],
    [0x2f, 'syscall_storage_reset_enum', ['unsigned long obj_enum']],
    [0x30, 'syscall_storage_start_enum', ['unsigned long obj_enum', 'unsigned long storage_id']],
    [0x31, 'syscall_storage_next_enum', ['unsigned long obj_enum', 'TEE_ObjectInfo *info', 'void *obj_id', 'uint64_t *len']],
    [0x32, 'syscall_storage_obj_read', ['unsigned long obj', 'void *data', 'size_t len', 'uint64_t *count']],
    [0x33, 'syscall_storage_obj_write', ['unsigned long obj', 'void *data', 'size_t len']],
    [0x34, 'syscall_storage_obj_trunc', ['unsigned long obj, size_t len']],
    [0x35, 'syscall_storage_obj_seek', ['unsigned long obj', 'int32_t offset', 'unsigned long whence']],
    [0x36, 'syscall_obj_generate_key', ['unsigned long obj', 'unsigned long key_size', 'const struct utee_attribute *params', 'unsigned long param_count']],
    [0x37, 'syscall_not_supported', []],
    [0x38, 'syscall_not_supported', []],
    [0x39, 'syscall_not_supported', []],
    [0x3a, 'syscall_not_supported', []],
    [0x3b, 'syscall_not_supported', []],
    [0x3c, 'syscall_not_supported', []],
    [0x3d, 'syscall_not_supported', []],
    [0x3e, 'syscall_not_supported', []],
    [0x3f, 'syscall_not_supported', []],
    [0x40, 'syscall_not_supported', []],
    [0x41, 'syscall_not_supported', []],
    [0x42, 'syscall_not_supported', []],
    [0x43, 'syscall_not_supported', []],
    [0x44, 'syscall_not_supported', []],
    [0x45, 'syscall_not_supported', []],
    [0x46, 'syscall_cache_operation', ['void *va, size_t len', 'unsigned long op']],
]


# ARM/ARM64 OP-TEE ldelf (at secure world)
# - core/include/tee/tee_svc.h
# - core/include/kernel/ldelf_syscalls.h
arm_ldelf_syscall_list = [
    [0x00, 'syscall_sys_return', ['unsigned long ret']],
    [0x01, 'syscall_log', ['const void *buf', 'size_t len']],
    [0x02, 'syscall_panic', ['unsigned long code']],
    [0x03, 'ldelf_syscall_map_zi', ['vaddr_t *va', 'size_t num_bytes', 'size_t pad_begin', 'size_t pad_end', 'unsigned long flags']],
    [0x04, 'ldelf_syscall_unmap', ['vaddr_t va', 'size_t num_bytes']],
    [0x05, 'ldelf_syscall_open_bin', ['const TEE_UUID *uuid', 'size_t uuid_size', 'uint32_t *handle']],
    [0x06, 'ldelf_syscall_close_bin', ['unsigned long handle']],
    [0x07, 'ldelf_syscall_map_bin', ['vaddr_t *va', 'size_t num_bytes', 'unsigned long handle', 'size_t offs_bytes', 'size_t pad_begin', 'size_t pad_end', 'unsigned long flags']],
    [0x08, 'ldelf_syscall_copy_from_bin', ['void *dst', 'size_t offs', 'size_t num_bytes', 'unsigned long handle']],
    [0x09, 'ldelf_syscall_set_prot', ['unsigned long va', 'size_t num_bytes', 'unsigned long flags']],
    [0x0a, 'ldelf_syscall_remap', ['unsigned long old_va', 'addr_t *new_va', 'size_t num_bytes', 'size_t pad_begin', 'size_t pad_end']],
    [0x0b, 'ldelf_syscall_gen_rnd_num', ['void *buf', 'size_t num_bytes']],
]


# This cache is not cleared when reset_cache() is run.
cached_syscall_table = {}


def get_syscall_table(arch=None, mode=None):

    def is_emulated32():
        if is_qemu_usermode():
            return True

        if is_qemu_system():
            # corner case (ex: using qemu-system-x86_64, but process is executed as 32bit mode)
            # is not able to be detected
            return True

        for m in get_process_maps():
            # native x86:
            # 0xbffdf000 0xc0000000 0x021000 0x000000 rw- [stack]
            # emulated x86 on x86_64
            # 0xfffdd000 0xffffe000 0x021000 0x000000 rw- [stack]
            # native arm:
            # 0xbefdf000 0xbf000000 0x021000 0x000000 rw- [stack]
            # emulated arm on aarch64
            # 0xfffcf000 0xffff0000 0x021000 0x000000 rw- [stack]
            if m.path == "[stack]":
                return (m.page_start >> 28) == 0xf
        else:
            return False # by default it considers on native

    def is_secure():
        scr = get_register("$SCR" if is_arm32() else "$SCR_EL3")
        if scr is None:
            return False
        return (scr & 0b1) == 0

    if arch is None and mode is None :
        if is_x86_64():
            arch, mode = "X86", "64"
        elif is_x86_32():
            arch, mode = "X86", ["N32", "32"][is_emulated32()]
        elif is_arm64():
            arch, mode = "ARM64", [None, "S"][is_secure()]
        elif is_arm32():
            arch, mode = "ARM", [["N32", "32"][is_emulated32()], "S"][is_secure()]
        elif is_mips32():
            arch, mode = "MIPS", "MIPS32"
        elif is_mips64():
            arch, mode = "MIPS", "MIPS64"
        elif is_ppc32():
            arch, mode = "PPC", "PPC32"
        elif is_ppc64():
            arch, mode = "PPC", "PPC64"
        elif is_sparc32():
            arch, mode = "SPARC", "SPARC32"
        elif is_sparc64():
            arch, mode = "SPARC", "SPARC64"
        else:
            raise

    global cached_syscall_table
    if (arch, mode) in cached_syscall_table:
        return cached_syscall_table[arch, mode]

    if arch == "X86" and mode == "64":
        register_list = ["$rdi", "$rsi", "$rdx", "$r10", "$r8", "$r9"]
        #syscall_register = "$rax"
        #retval_register_list = ["$rax"]

        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(x64_syscall_tbl)
        arch_specific_dic = {
            'sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp',
                'int __user *parent_tidptr', 'int __user *child_tidptr', 'unsigned long tls',
            ], # kernel/fork.c
            'sys_modify_ldt': [
                'int func', 'void __user *ptr', 'unsigned long bytecount',
            ], # arch/x86/kernel/ldt.c
            'sys_arch_prctl': [
                'int option', 'unsigned long arg2',
            ], # arch/x86/kernel/process_64.c
            'sys_iopl': [
                'unsigned int level',
            ], # arch/x86/kernel/ioport.c
            'compat_sys_x32_rt_sigreturn': [], # arch/x86/kernel/signal.c
            'sys_mmap': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'unsigned long off',
            ], # arch/x86/kernel/sys_x86_64.c
            'sys_rt_sigreturn': [], # arch/x86/kernel/signal.c
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry
            if abi not in ["common", "64", "x32"]:
                continue
            # special case
            if func in arch_specific_dic:
                if abi in ["common", "64"]:
                    syscall_list.append([nr, name, arch_specific_dic[func]])
                if abi in ["common", "x32"]:
                    syscall_list.append([nr + 0x40000000, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            if abi in ["common", "64"]:
                syscall_list.append([nr, name, sc_def[func]])
            if abi in ["common", "x32"]:
                syscall_list.append([nr + 0x40000000, name, sc_def[func]])

    elif arch == "X86" and mode == "32":
        register_list = ["$ebx", "$ecx", "$edx", "$esi", "$edi", "$ebp"]
        #syscall_register = "$eax"
        #retval_register_list = ["$eax"]

        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(x86_syscall_tbl)
        arch_specific_dic = {
            'compat_sys_sigreturn': [], # arch/x86/ia32/ia32_signal.c
            'compat_sys_rt_sigreturn': [], # arch/x86/ia32/ia32_signal.c
            'compat_sys_old_getrlimit': [
                'unsigned int resource', 'struct compat_rlimit *rlim',
            ], # kernel/sys.c
            'compat_sys_ia32_mmap': [
                'struct mmap_arg_struct32 __user *arg',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_iopl': [
                'unsigned int level',
            ], # arch/x86/kernel/ioport.c
            'compat_sys_ia32_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int __user *parent_tidptr',
                'unsigned long tls_val', 'int __user *child_tidptr',
            ], # arch/x86/kernel/sys_ia32.c (CONFIG_CLONE_BACKWARDS)
            'sys_modify_ldt': [
                'int func', 'void __user *ptr', 'unsigned long bytecount',
            ], # arch/x86/kernel/ldt.c
            'sys_ia32_pread64': [
                'unsigned int fd', 'char __user *ubuf', 'u32 count', 'u32 poslo', 'u32 poshi',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_ia32_pwrite64': [
                'unsigned int fd', 'const char __user *ubuf', 'u32 count', 'u32 poslo', 'u32 poshi',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_ia32_truncate64': [
                'const char __user *filename', 'unsigned long offset_low', 'unsigned long offset_high',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_ia32_ftruncate64': [
                'unsigned int fd', 'unsigned long offset_low', 'unsigned long offset_high',
            ], # arch/x86/kernel/sys_ia32.c
            'compat_sys_ia32_stat64': [
                'const char __user *filename', 'struct stat64 __user *statbuf',
            ], # arch/x86/kernel/sys_ia32.c
            'compat_sys_ia32_lstat64': [
                'const char __user *filename', 'struct stat64 __user *statbuf',
            ], # arch/x86/kernel/sys_ia32.c
            'compat_sys_ia32_fstat64': [
                'unsigned long fd', 'struct stat64 __user *statbuf',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_ia32_readahead': [
                'int fd', 'unsigned int off_lo', 'unsigned int off_high', 'size_t count',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_set_thread_area': [
                'struct user_desc __user * u_info',
            ], # arch/x86/kernel/tls.c
            'sys_get_thread_area': [
                'struct user_desc __user * u_info',
            ], # arch/x86/kernel/tls.c
            'sys_ia32_fadvise64': [
                'int fd', 'unsigned int offset_lo', 'unsigned int offset_hi', 'size_t len', 'int advice',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_ia32_fadvise64_64': [
                'int fd', '__u32 offset_low', '__u32 offset_high', '__u32 len_low', '__u32 len_high', 'int advice',
            ], # arch/x86/kernel/sys_ia32.c
            'compat_sys_ia32_fstatat64': [
                'unsigned int dfd', 'const char __user *filename', 'struct stat64 __user *statbuf', 'int flag',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_ia32_sync_file_range': [
                'int fd', 'unsigned int off_low', 'unsigned int off_hi', 'unsigned int n_low',
                'unsigned int n_hi', 'unsigned int flags',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_ia32_fallocate': [
                'int fd', 'int mode', 'unsigned int offset_lo', 'unsigned int offset_hi',
                'unsigned int len_lo', 'unsigned int len_hi',
            ], # arch/x86/kernel/sys_ia32.c
            'compat_sys_arch_prctl': [
                'int option', 'unsigned long arg2',
            ], # arch/x86/kernel/process_64.c
        }

        syscall_list = []
        for entry in tbl:
            if len(entry) == 5:
                nr, abi, name, _, func = entry # use compat
            else:
                nr, abi, name, func = entry
            if abi != "i386":
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

    elif arch == "X86" and mode == "N32":
        register_list = ["$ebx", "$ecx", "$edx", "$esi", "$edi", "$ebp"]
        #syscall_register = "$eax"
        #retval_register_list = ["$eax"]

        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(x86_syscall_tbl)
        arch_specific_dic = {
            'sys_iopl': [
                'unsigned int level',
            ], # arch/x86/kernel/ioport.c
            'sys_vm86old': [
                'struct vm86_struct __user *user_vm86',
            ], # arch/x86/kernel/vm86_32.c
            'sys_sigreturn': [], # arch/x86/kernel/signal.c
            'sys_rt_sigreturn': [], # arch/x86/kernel/signal.c
            'sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int __user *parent_tidptr',
                'unsigned long tls', 'int *child_tidptr',
            ], # kernel/fork.c (CONFIG_CLONE_BACKWARDS)
            'sys_modify_ldt': [
                'int func', 'void __user *ptr', 'unsigned long bytecount',
            ], # arch/x86/kernel/ldt.c
            'sys_vm86': [
                'unsigned long cmd', 'unsigned long arg',
            ], # arch/x86/kernel/vm86_32.c
            'sys_ia32_pread64': [
                'unsigned int fd', 'char __user *ubuf', 'u32 count', 'u32 poslo', 'u32 poshi',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_ia32_pwrite64': [
                'unsigned int fd', 'const char __user *ubuf', 'u32 count', 'u32 poslo', 'u32 poshi',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_ia32_truncate64': [
                'const char __user *filename', 'unsigned long offset_low', 'unsigned long offset_high',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_ia32_ftruncate64': [
                'unsigned int fd', 'unsigned long offset_low', 'unsigned long offset_high',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_ia32_readahead': [
                'int fd', 'unsigned int off_lo', 'unsigned int off_high', 'size_t count',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_set_thread_area': [
                'struct user_desc __user * u_info',
            ], # arch/x86/kernel/tls.c
            'sys_get_thread_area': [
                'struct user_desc __user * u_info',
            ], # arch/x86/kernel/tls.c
            'sys_ia32_fadvise64': [
                'int fd', 'unsigned int offset_lo', 'unsigned int offset_hi', 'size_t len', 'int advice',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_ia32_fadvise64_64': [
                'int fd', '__u32 offset_low', '__u32 offset_high', '__u32 len_low', '__u32 len_high', 'int advice',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_ia32_sync_file_range': [
                'int fd', 'unsigned int off_low', 'unsigned int off_hi', 'unsigned int n_low',
                'unsigned int n_hi', 'unsigned int flags',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_ia32_fallocate': [
                'int fd', 'int mode', 'unsigned int offset_lo', 'unsigned int offset_hi',
                'unsigned int len_lo', 'unsigned int len_hi',
            ], # arch/x86/kernel/sys_ia32.c
            'sys_arch_prctl': [
                'int option', 'unsigned long arg2',
            ], # arch/x86/kernel/process_32.c
        }

        syscall_list = []
        for entry in tbl:
            if len(entry) == 5:
                nr, abi, name, func, _ = entry # dont use compat
            else:
                nr, abi, name, func = entry
            if abi != "i386":
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

    elif arch == "ARM64":
        register_list = ["$x0", "$x1", "$x2", "$x3", "$x4", "$x5"]
        #syscall_register = "$x8"
        #retval_register_list = ["$x0", "$x1"]

        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(arm64_syscall_tbl)
        arch_specific_dic = {
            'sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int __user *parent_tidptr',
                'unsigned long tls', 'int __user *child_tidptr',
            ], # kernel/fork.c (CONFIG_CLONE_BACKWARDS)
            'sys_rt_sigreturn': [], # arch/arm64/kernel/signal.c
            'sys_mmap': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'unsigned long off',
            ], # arch/arm64/kernel/sys.c
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry
            if abi != "arm64":
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

    elif arch == "ARM" and mode == "32": # support EABI only
        register_list = ["$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6"]
        #syscall_register = "$r7"
        #retval_register_list = ["$r0", "$r1"]

        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(arm_compat_syscall_tbl)
        arch_specific_dic = {
            'sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int __user *parent_tidptr',
                'unsigned long tls', 'int __user *child_tidptr',
            ], # kernel/fork.c (CONFIG_CLONE_BACKWARDS)
            'compat_sys_aarch32_pread64': [
                'unsigned int fd', 'char *buf', 'size_t count', 'u32 __pad', 'arg_u32p(pos)',
            ], # arch/arm64/kernel/sys32.c
            'compat_sys_aarch32_pwrite64': [
                'unsigned int fd', 'const char *buf', 'size_t count', 'u32 __pad', 'arg_u32p(pos)',
            ], # arch/arm64/kernel/sys32.c
            'compat_sys_aarch32_mmap2': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'unsigned long off_4k',
            ], # arch/arm64/kernel/sys32.c
            'compat_sys_aarch32_truncate64': [
                'const char *path', 'u32 __pad', 'arg_u32p(length)',
            ], # arch/arm64/kernel/sys32.c
            'compat_sys_aarch32_ftruncate64': [
                'unsigned int fd', 'u32 __pad', 'arg_u32p(length)',
            ], # arch/arm64/kernel/sys32.c
            'compat_sys_aarch32_readahead': [
                'int fd', 'u32 __pad', 'arg_u32(offset)', 'size_t count',
            ], # arch/arm64/kernel/sys32.c
            'compat_sys_aarch32_statfs64': [
                'const char *pathname', 'compat_size_t sz', 'struct compat_statfs64 *buf',
            ], # arch/arm64/kernel/sys32.c
            'compat_sys_aarch32_fstatfs64': [
                'unsigned int fd', 'compat_size_t sz', 'struct compat_statfs64 *buf',
            ], # arch/arm64/kernel/sys32.c
            'compat_sys_aarch32_fadvise64_64': [
                'int fd', 'int advice', 'arg_u32p(offset)', 'arg_u32p(len)',
            ], # arch/arm64/kernel/sys32.c
            'compat_sys_aarch32_sync_file_range2': [
                'int fd', 'unsigned int flags', 'arg_u32p(offset)', 'arg_u32p(nbytes)',
            ], # arch/arm64/kernel/sys32.c
            'compat_sys_aarch32_fallocate': [
                'int fd', 'int mode', 'arg_u32p(offset)', 'arg_u32p(len)',
            ], # arch/arm64/kernel/sys32.c
            'compat_sys_old_semctl': [
                'int semid', 'int semnum', 'int cmd', 'int arg',
            ], # ipc/sem.c
            'compat_sys_old_msgctl': [
                'int msqid', 'int cmd', 'void *uptr',
            ], # ipc/msg.c
            'compat_sys_old_shmctl': [
                'int shmid', 'int cmd', 'void *uptr',
            ], # ipc/shm.c
            'compat_sys_sigreturn': [], # arch/arm64/kernel/signal32.c
            'compat_sys_rt_sigreturn': [], # arch/arm64/kernel/signal32.c
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry
            if abi != "arm":
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

        arch_specific_extra = [
            [0xf0002, 'cacheflush', [
                'unsigned long start', 'unsigned long end', 'int flags',
            ]], # arch/arm64/kernel/sys_compat.c
            [0xf0005, 'set_tls', [
                'unsigned long val',
            ]], # arch/arm64/kernel/sys_compat.c
        ]
        syscall_list += arch_specific_extra

    elif arch == "ARM" and mode == "N32": # support EABI only
        register_list = ["$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6"]
        #syscall_register = "$r7"
        #retval_register_list = ["$r0", "$r1"]

        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(arm_native_syscall_tbl)
        arch_specific_dic = {
            'sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int __user *parent_tidptr',
                'unsigned long tls', 'int __user *child_tidptr',
            ], # kernel/fork.c (CONFIG_CLONE_BACKWARDS)
            'sys_mmap2': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'unsigned long pgoff',
            ], # include/asm-generic/syscalls.h
            'sys_sigreturn_wrapper': [], # arch/arm/kernel/entry-common.S
            'sys_rt_sigreturn_wrapper': [], # arch/arm/kernel/entry-common.S
            'sys_statfs64_wrapper': [
                'const char __user *path', 'size_t sz', 'struct statfs64 __user *buf',
            ], # arch/arm/kernel/entry-common.S
            'sys_fstatfs64_wrapper': [
                'unsigned int fd', 'size_t sz', 'struct statfs64 __user *buf',
            ], # arch/arm/kernel/entry-common.S
            'sys_arm_fadvise64_64': [
                'int fd', 'int advice', 'loff_t offset', 'loff_t len',
            ] # arch/arm/kernel/sys_arm.c
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry[:4] # dont use OABI
            if abi not in ["common", "eabi"]:
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

        arch_specific_extra = [
            [0xf0001, 'breakpoint', []], # arch/arm/kernel/traps.c
            [0xf0002, 'cacheflush', [
                'unsigned long start', 'unsigned long end', 'int flags',
            ]], # arch/arm/kernel/traps.c
            [0xf0003, 'usr26', []], # arch/arm/kernel/traps.c
            [0xf0004, 'usr32', []], # arch/arm/kernel/traps.c
            [0xf0005, 'set_tls', [
                'unsigned long val',
            ]], # arch/arm/kernel/traps.c
            [0xf0006, 'get_tls', []], # arch/arm/kernel/traps.c
        ]
        syscall_list += arch_specific_extra

    elif arch in ["ARM64", "ARM"] and mode == "S":
        if arch == "ARM64":
            register_list = ["$x0", "$x1", "$x2", "$x3", "$x4", "$x5", "$x6"]
            #syscall_register = "$x8"
            #retval_register_list = ["$x0", "$x1"]
        else:
            register_list = ["$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6"]
            #syscall_register = "$r7"
            #retval_register_list = ["$r0", "$r1"]
        syscall_list = arm_OPTEE_syscall_list.copy()

    elif arch == "MIPS" and mode == "MIPS32":
        o32_register_list = ["$a0", "$a1", "$a2", "$a3", "$sp+0x10", "$sp+0x14", "$sp+0x18", "$sp+0x1c"]
        n32_register_list = ["$a0", "$a1", "$a2", "$a3", "$a4", "$a5"]
        #syscall_register = "$v0"
        #retval_register_list = ["$v0", "$v1"]

        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(mips_o32_syscall_tbl)
        tbl += parse_syscall_table_defs(mips_n32_syscall_tbl)
        arch_specific_dic = {
            # o32
            'sys_syscall': ['...', ], #
            '__sys_fork': [], #
            'sys_rt_sigreturn': [], # arch/mips/kernel/signal.c
            'sysm_pipe': [], # arch/mips/kernel/syscall.c
            'sys_mips_mmap': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'off_t offset',
            ], # arch/mips/kernel/syscall.c
            'sys_sigreturn': [], #
            '__sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int __user *parent_tidptr',
                'unsigned long tls', 'int __user *child_tidptr',
            ], # kernel/fork.c (CONFIG_CLONE_BACKWARDS)
            'sys_cacheflush': [
                'unsigned long addr', 'unsigned long bytes', 'unsigned int cache',
            ], # arch/mips/mm/cache.c
            'sys_cachectl': [
                'char *addr', 'int nbytes', 'int op',
            ], # arch/mips/kernel/syscall.c
            '__sys_sysmips': [
                'long cmd', 'long arg1', 'long arg2',
            ], # arch/mips/kernel/syscall.c
            'sys_mips_mmap2': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'unsigned long pgoff',
            ], # arch/mips/kernel/syscall.c
            'sys_set_thread_area': [
                'unsigned long addr',
            ], # arch/mips/kernel/syscall.c
            '__sys_clone3': [
                'struct clone_args __user *uargs', 'size_t size',
            ], #
            'sys_sigsuspend': [
                'sigset_t __user *uset',
            ], # arch/mips/kernel/signal.c
            'sys_sigaction': [
                'int sig2', 'const struct sigaction __user *act', 'struct sigaction __user *oact',
            ], # arch/mips/kernel/signal.c
            # n32
            'compat_sys_old_shmctl': [
                'int shmid', 'int cmd', 'void *uptr',
            ], # ipc/shm.c
            'compat_sys_old_semctl': [
                'int semid', 'int semnum', 'int cmd', 'int arg',
            ], # ipc/sem.c
            'compat_sys_old_msgctl': [
                'int msqid', 'int cmd', 'void *uptr',
            ], # ipc/msg.c
            'sys_32_personality': [
                'unsigned long personality',
            ], # arch/mips/kernel/linux32.c
            'sysn32_rt_sigreturn': [], # arch/mips/kernel/signal_n32.c
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry[:4] # dont use compat
            if abi not in ["o32", "n32"]:
                continue
            if abi == "o32":
                nr += 4000 # arch/mips/include/asm/unistd.h
            elif abi == "n32":
                nr += 6000 # arch/mips/include/asm/unistd.h
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

    elif arch == "MIPS" and mode == "MIPS64":
        register_list = ["$a0", "$a1", "$a2", "$a3", "$a4", "$a5"]
        #syscall_register = "$v0"
        #retval_register_list = ["$v0", "$v1"]

        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(mips_n64_syscall_tbl)
        arch_specific_dic = {
            'sys_mips_mmap': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'off_t offset',
            ], # arch/mips/kernel/syscall.c
            'sysm_pipe': [], # arch/mips/kernel/syscall.c
            '__sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int __user *parent_tidptr',
                'unsigned long tls', 'int __user *child_tidptr',
            ], # kernel/fork.c (CONFIG_CLONE_BACKWARDS)
            '__sys_fork': [], #
            'sys_rt_sigreturn': [], # arch/mips/kernel/signal.c
            'sys_cacheflush': [
                'unsigned long addr', 'unsigned long bytes', 'unsigned int cache',
            ], # arch/mips/mm/cache.c
            'sys_cachectl': [
                'char *addr', 'int nbytes', 'int op',
            ], # arch/mips/kernel/syscall.c
            '__sys_sysmips': [
                'long cmd', 'long arg1', 'long arg2',
            ], # arch/mips/kernel/syscall.c
            'sys_set_thread_area': [
                'unsigned long addr',
            ], # arch/mips/kernel/syscall.c
            '__sys_clone3': [
                'struct clone_args __user *uargs', 'size_t size',
            ], #
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry[:4] # dont use compat
            if abi != "n64":
                continue
            nr += 5000 # arch/mips/include/asm/unistd.h
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

    elif arch == "PPC" and mode == "PPC32":
        register_list = ["$r3", "$r4", "$r5", "$r6", "$r7", "$r8", "$r9"]
        #syscall_register = "$r0"
        #retval_register_list = ["$r3"]

        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(ppc_syscall_tbl)
        arch_specific_dic = {
            'ppc_select': [
                'int n', 'fd_set __user *inp', 'fd_set __user *outp', 'fd_set __user *exp',
                'struct __kernel_old_timeval __user *tvp',
            ], # arch/poerpc/kernel/syscalls.c
            'sys_sigreturn': [], # arch/powerpc/kernel/signal_32.c
            'sys_rt_sigreturn': [], # arch/powerpc/kernel/signal_32.c
            'sys_mmap': [
                'unsigned long addr', 'size_t len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'off_t offset',
            ], # arch/powerpc/kernel/syscalls.c
            'sys_mmap2': [
                'unsigned long addr', 'size_t len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'unsigned long pgoff',
            ], # arch/powerpc/kernel/syscalls.c
            'sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int __user *parent_tidptr',
                'unsigned long tls', 'int __user *child_tidptr',
            ], # kernel/fork.c (CONFIG_CLONE_BACKWARDS)
            'sys_swapcontext': [
                'struct ucontext __user *old_ctx', 'struct ucontext __user *new_ctx', 'long ctx_size',
            ], # arch/powerpc/kernel/signal_32.c
            'ppc_fadvise64_64': [
                'int fd', 'int advice', 'u32 offset_high', 'u32 offset_low', 'u32 len_high', 'u32 len_low',
            ], # arch/poerpc/kernel/syscalls.c
            'sys_rtas': [
                'struct rtas_args __user *uargs',
            ], # arch/powerpc/include/asm/syscalls.h
            'sys_debug_setcontext': [
                'struct ucontext __user *ctx', 'int ndbg', 'struct sig_dbg_op __user *dbg',
            ], # arch/powerpc/kernel/signal_32.c
            'sys_subpage_prot': [
                'unsigned long addr', 'unsigned long len', 'u32 __user *map',
            ], # arch/powerpc/mm/book3s64/subpage_prot.c
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry[:4] # dont use compat
            if abi not in ["common", "32", "nospu"]:
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

    elif arch == "PPC" and mode == "PPC64":
        register_list = ["$r3", "$r4", "$r5", "$r6", "$r7", "$r8"]
        #syscall_register = "$r0"
        #retval_register_list = ["$r3"]

        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(ppc_syscall_tbl)
        arch_specific_dic = {
            'sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp', 'int __user *parent_tidptr',
                'unsigned long tls', 'int __user *child_tidptr',
            ], # kernel/fork.c (CONFIG_CLONE_BACKWARDS)
            'sys_rt_sigreturn': [], # arch/powerpc/kernel/signal_64.c
            'sys_mmap': [
                'unsigned long addr', 'size_t len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'off_t offset',
            ], # arch/powerpc/kernel/syscalls.c
            'sys_mmap2': [
                'unsigned long addr', 'size_t len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'unsigned long pgoff',
            ], # arch/powerpc/kernel/syscalls.c
            'ppc64_personality': [
                'unsigned long personality',
            ], # arch/powerpc/kernel/syscalls.c
            'sys_swapcontext': [
                'struct ucontext __user *old_ctx', 'struct ucontext __user *new_ctx', 'long ctx_size',
            ], # arch/powerpc/kernel/signal_64.c
            'sys_rtas': [
                'struct rtas_args __user *uargs',
            ], # arch/powerpc/include/asm/syscalls.h
            'sys_subpage_prot': [
                'unsigned long addr', 'unsigned long len', 'u32 __user *map',
            ], # arch/powerpc/mm/book3s64/subpage_prot.c
            'sys_switch_endian': [], # arch/powerpc/kernel/syscalls.c
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry[:4] # dont use compat
            if abi not in ["common", "64", "nospu"]:
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func == 'sys_ni_syscall':
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

    elif arch == "SPARC" and mode == "SPARC32":
        register_list = ["$o0", "$o1", "$o2", "$o3", "$o4", "$o5"]
        #syscall_register = "$g1"
        #retval_register_list = ["$o0", "$o1"]

        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(sparc_syscall_tbl)
        arch_specific_dic = {
            'sys_mmap': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'unsigned long off'
            ], # arch/sparc/kernel/sys_sparc_32.c
            'sys_mmap2': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'unsigned long pgoff'
            ], # arch/sparc/kernel/sys_sparc_32.c
            'sunos_execv': [
                'const char __user *filename', 'const char __user *const __user *argv',
                'const char __user *const __user *envp',
            ], # arch/sparc/kernel/entry.S
            'sys_sparc_pipe': [], # arch/sparc/kernel/sys_sparc_32.c
            'sys_getpagesize': [], # arch/sparc/kernel/sys_sparc_32.c
            'sys_getdomainname': [
                'char __user *name', 'int len'
            ], # arch/sparc/kernel/sys_sparc_32.c
            'sys_sparc_remap_file_pages': [
                'unsigned long start', 'unsigned long size', 'unsigned long prot',
                'unsigned long pgoff', 'unsigned long flags',
            ], # kernel/sys_sparc_32.c
            'sys_sparc_sigaction': [
                'int, sig', 'struct old_sigaction __user *act', 'struct old_sigaction __user *oact',
            ], # arch/sparc/kernel/sys_sparc_32.c
            'sys_sigreturn': [
                "struct pt_regs *regs",
            ], # arch/sparc/kernel/signal_32.c
            'sys_rt_sigreturn': [
                "struct pt_regs *regs",
            ], # arch/sparc/kernel/signal_32.c
            'sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp',
                'int __user *parent_tidptr', 'int __user *child_tidptr', 'unsigned long tls',
            ], # kernel/fork.c
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry[:4] # dont use compat
            if abi not in ["common", "32"]:
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func in ['sys_ni_syscall', 'sys_nis_syscall']:
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

    elif arch == "SPARC" and mode == "SPARC64":
        register_list = ["$o0", "$o1", "$o2", "$o3", "$o4", "$o5"]
        #syscall_register = "$g1"
        #retval_register_list = ["$o0", "$o1"]

        sc_def = parse_common_syscall_defs()
        tbl = parse_syscall_table_defs(sparc_syscall_tbl)
        arch_specific_dic = {
            'sparc_exit': [
                'int error_code',
            ], # arch/sparc/kernel/syscalls.S
            'sys_sparc_pipe': [], # arch/sparc/kernel/sys_sparc_64.c
            'sys_memory_ordering': [
                'unsigned long model',
            ], # arch/sparc/kernel/sys_sparc_64.c
            'sys64_execve': [
                'const char __user *filename', 'const char __user *const __user *argv',
                'const char __user *const __user *envp',
            ], # arch/sparc/kernel/syscalls.S
            'sys_getpagesize': [], # arch/sparc/kernel/sys_sparc_64.c
            'sys_64_munmap': [
                'unsigned long addr', 'size_t len',
            ], # arch/sparc/kernel/sys_sparc_64.c
            'sys_getdomainname': [
                'char __user *name', 'int len'
            ], # arch/sparc/kernel/sys_sparc_64.c
            'sys_utrap_install': [
                'utrap_entry_t type', 'utrap_handler_t new_p', 'utrap_handler_t new_d',
                'utrap_handler_t __user * old_p', 'utrap_handler_t __user *old_d',
            ], # arch/sparc/kernel/sys_sparc_64.c
            'sparc_exit_group': [
                'int error_code',
            ], # arch/sparc/kernel/syscalls.S
            'sys_sparc64_personality': [
                'unsigned long personality',
            ], # arch/sparc/kernel/sys_sparc_64.c
            'sys_sparc_ipc': [
                'unsigned int call', 'int first', 'unsigned long second',
                'unsigned long third', 'void __user *ptr', 'long fifth',
            ], # arch/sparc/kernel/sys_sparc_64.c
            'sys_clone': [
                'unsigned long clone_flags', 'unsigned long newsp',
                'int __user *parent_tidptr', 'int __user *child_tidptr', 'unsigned long tls',
            ], # kernel/fork.c
            'sys_sparc_adjtimex': [
                'struct __kernel_timex __user *txc_p',
            ], # arch/sparc/kernel/sys_sparc_64.c
            'sys_mmap': [
                'unsigned long addr', 'unsigned long len', 'unsigned long prot',
                'unsigned long flags', 'unsigned long fd', 'unsigned long off'
            ], # arch/sparc/kernel/sys_sparc_64.c
            'sys_64_mremap': [
                'unsigned long addr', 'unsigned long old_len', 'unsigned long new_len',
                'unsigned long flags', 'unsigned long new_addr',
            ], # arch/sparc/kernel/sys_sparc_64.c
            'sys_sparc_clock_adjtime': [
                'const clockid_t which_clock', 'struct __kernel_timex __user *txc_p',
            ], # arch/sparc/kernel/sys_sparc_64.c
            'sys_kern_features': [], # arch/sparc/kernel/sys_sparc_64.c
            'sys64_execveat': [
                'int dfd', 'const char __user *filename', 'const char __user *const __user *argv',
                'const char __user *const __user *envp', 'int flags',
            ] ,# arch/sparc/kernel/syscalls.S
            'sys_rt_sigreturn': [
                "struct pt_regs *regs",
            ], # arch/sparc/kernel/signal_64.c
        }

        syscall_list = []
        for entry in tbl:
            nr, abi, name, func = entry[:4] # dont use compat
            if abi not in ["common", "64"]:
                continue
            # special case
            if func in arch_specific_dic:
                syscall_list.append([nr, name, arch_specific_dic[func]])
                continue
            # common case
            if func in ['sys_ni_syscall', 'sys_nis_syscall']:
                continue
            if func not in sc_def:
                err("Not found: {:s}".format(func))
                raise
            syscall_list.append([nr, name, sc_def[func]])

    else:
        raise

    # common process
    if mode == "S":
        mode_str = "Secure-World"
    elif mode == "N32":
        mode_str = "Native-32"
    elif mode == "32":
        mode_str = "Emulated-32"
    else:
        mode_str = mode
    syscall_table = {"arch": arch, "mode": mode_str}

    syscall_list = sorted(syscall_list, key=lambda x: x[0])
    Entry = collections.namedtuple('Entry', 'name params')
    Param = collections.namedtuple('Param', 'reg param')
    for nr, name, args in syscall_list:
        if arch == "MIPS" and mode == "MIPS32":
            if nr >= 6000:
                args = list(zip(n32_register_list[:len(args)], args))
            else:
                args = list(zip(o32_register_list[:len(args)], args))
        else:
            args = list(zip(register_list[:len(args)], args))
        syscall_table[nr] = Entry(name, [Param(*p) for p in args])

    cached_syscall_table[arch, mode] = syscall_table
    return syscall_table


@register_command
class SyscallArgsCommand(GenericCommand):
    """Gets the syscall name and arguments based on the register values in the current state."""
    _cmdline_ = "syscall-args"
    _syntax_ = "{:s} [-h] [SYSCALL_NUM]".format(_cmdline_)
    _category_ = "Debugging Support"

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        try:
            syscall_table = get_syscall_table()
        except Exception:
            warn("This command cannot work under this architecture.")
            return

        if len(argv) == 1:
            reg_value = int(argv[0], 0)
        else:
            reg_value = get_register(current_arch.syscall_register)
        if reg_value not in syscall_table:
            warn("There is no system call for {:#x}".format(reg_value))
            return
        syscall_entry = syscall_table[reg_value]

        values = []
        for param in syscall_entry.params:
            if "+" not in param.reg:
                values.append(get_register(param.reg))
            else:
                _reg, _off = param.reg.split("+") # like `$sp + 0x10`
                values.append(read_int_from_memory(get_register(_reg) + int(_off, 0)))

        parameters = [s.param for s in syscall_entry.params]
        registers = [s.reg for s in syscall_entry.params]

        info("Detected syscall (arch:{:s}, mode:{:s})".format(syscall_table["arch"], syscall_table["mode"]))
        gef_print("    " + Color.colorify("{}({})".format(syscall_entry.name, ", ".join(parameters)), "bold yellow"))

        headers = ["Parameter", "Register", "Value"]
        info(Color.colorify("{:<20} {:<20} {}".format(*headers), get_gef_setting("theme.table_heading")))
        gef_print("    {:<20} {:<20} {:#x}".format("_NR", current_arch.syscall_register, reg_value))

        param_names = [re.split(r" |\*", p)[-1] for p in parameters]
        for name, register, value in zip(param_names, registers, values):
            line = "    {:<20} {:<20} ".format(name, register)
            line += to_string_dereference_from(value)
            gef_print(line)
        return


@functools.lru_cache()
def get_section_base_address(name):
    if name is None:
        return None
    section = process_lookup_path(name)
    if section:
        return section.page_start
    # Fail, retry with real path
    section = process_lookup_path(os.path.realpath(name))
    if section:
        return section.page_start
    return None


def get_section_base_address_by_list(names):
    for name in names:
        page_start = get_section_base_address(name)
        if page_start is not None:
            return page_start
    return None


@functools.lru_cache()
def get_zone_base_address(name):
    zone = file_lookup_name_path(name, get_filepath(for_vmmap=True))
    if zone:
        return zone.zone_start
    return None


@register_command
class SmartCppFunctionNameCommand(GenericCommand):
    """Toggle the setting of `config context.smart_cpp_function_name`"""
    _cmdline_ = "smart-cpp-function-name"
    _syntax_ = "{:s}".format(_cmdline_)
    _category_ = "Misc"

    def do_invoke(self, argv):
        self.dont_repeat()
        setting = gdb.execute("gef config context.smart_cpp_function_name", to_string=True)
        if "False" in setting:
            gdb.execute("gef config context.smart_cpp_function_name true", to_string=True)
        else:
            gdb.execute("gef config context.smart_cpp_function_name false", to_string=True)
        return


@register_command
class FollowCommand(GenericCommand):
    """View/modify the follow-fork-mode setting of GDB. By default, GDB will follow parent when it starts the process.
    This command allows to change that setting."""
    _cmdline_ = "follow"
    _syntax_ = "{:s} (child|parent)".format(_cmdline_)
    _category_ = "Misc"

    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        argc = len(argv)

        if argc == 0:
            ret = gdb.execute("show follow-fork-mode", to_string=True)
            i = ret.find("\"child\"")
            if i >= 0:
                msg = "follow " + Color.redify("Child")
            else:
                msg = "follow " + Color.redify("Parent")
            gef_print(msg)
            return

        elif argc == 1:
            if argv[0] == "child":
                info("Follow child")
                gdb.execute("set follow-fork-mode child")
                return
            elif argv[0] == "parent":
                info("Follow parent")
                gdb.execute("set follow-fork-mode parent")
                return
            warn("Invalid command")
        self.usage()
        return


@register_command
class CodebaseCommand(GenericCommand):
    """Show code base address."""
    _cmdline_ = "codebase"
    _syntax_ = _cmdline_
    _category_ = "Process Information"

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        codebase = get_section_base_address(get_filepath(for_vmmap=True))
        if codebase is None:
            codebase = get_section_base_address(get_path_from_info_proc())
        if codebase is None:
            gef_print("codebase not found")
            return
        gef_print(titlify("Code base"))
        gdb.execute(f"set $codebase = {codebase}")
        gef_print(f"$codebase = {codebase:#x}")

        if is_pie(get_filepath()):
            gdb.execute(f"set $piebase = {codebase}")
            gef_print(f"$piebase = {codebase:#x}")
        return


@register_command
class HeapbaseCommand(GenericCommand):
    """Show heap base address."""
    _cmdline_ = "heapbase"
    _syntax_ = _cmdline_
    _category_ = "Process Information"

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        heap = HeapBaseFunction.heap_base()
        if heap is None:
            gef_print("heap not found")
            return

        gef_print(titlify("Heap base"))
        gdb.execute(f"set $heapbase = {heap}")
        gef_print(f"$heapbase = {heap:#x}")
        return


@register_command
class LibcCommand(GenericCommand):
    """Show `libc.so` base address."""
    _cmdline_ = "libc"
    _syntax_ = _cmdline_
    _category_ = "Process Information"

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        libc = get_section_base_address_by_list(("libc-2.", "libc.so.6"))
        if libc is None:
            err("libc is not found")
            return
        gef_print(titlify("libc info"))
        gdb.execute(f"set $libc = {libc}")
        gef_print(f"$libc = {libc:#x}")

        libc = process_lookup_path(("libc-2.", "libc.so.6"))
        if not os.path.exists(libc.path):
            return

        gef_print("path:\t" + libc.path)
        data = open(libc.path, "rb").read()

        gef_print("sha512:\t" + hashlib.sha512(data).hexdigest())
        gef_print("sha256:\t" + hashlib.sha256(data).hexdigest())
        gef_print("sha1:\t" + hashlib.sha1(data).hexdigest())
        gef_print("md5:\t" + hashlib.md5(data).hexdigest())

        try:
            strings = which("strings")
        except IOError:
            err("Missing `strings`")
            return
        result = gef_execute_external([strings, "-a", libc.path], as_list=True)
        version = [line for line in result if line.startswith("GNU C Library")]
        gef_print("ver:\t" + version[0])
        return


@register_command
class LdCommand(GenericCommand):
    """Show `ld.so` base address."""
    _cmdline_ = "ld"
    _syntax_ = _cmdline_
    _category_ = "Process Information"

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        ld = get_section_base_address_by_list(("ld-2.", "ld-linux-"))
        if ld is None:
            gef_print("ld not found")
            return
        gef_print(titlify("ld info"))
        gdb.execute(f"set $ld = {ld}")
        gef_print(f"$ld = {ld:#x}")

        ld = process_lookup_path(("ld-2.", "ld-linux-"))
        if not os.path.exists(ld.path):
            return

        gef_print("path:\t" + ld.path)
        data = open(ld.path, "rb").read()
        gef_print("sha512:\t" + hashlib.sha512(data).hexdigest())
        gef_print("sha256:\t" + hashlib.sha256(data).hexdigest())
        gef_print("sha1:\t" + hashlib.sha1(data).hexdigest())
        gef_print("md5:\t" + hashlib.md5(data).hexdigest())
        return


@register_command
class MagicCommand(GenericCommand):
    """Show Magic addresses / offsets."""
    _cmdline_ = "magic"
    _syntax_ = "{:s} [-h] [--fj] [FILTER]".format(_cmdline_)
    _example_ = "{:s}\n".format(_cmdline_)
    _example_ += "{:s} --fj    # print _IO_xxx_jumps functions\n".format(_cmdline_)
    _example_ += "{:s} system  # filtering by keyword (grep)".format(_cmdline_)
    _category_ = "Exploit Development"

    def should_be_print(self, sym):
        if not self.filter:
            return True

        for filt in self.filter:
            if filt in sym:
                return True
        return False

    def resolve_and_print(self, sym, base):
        def get_permission(addr):
            maps = get_process_maps()
            for m in maps:
                if m.page_start <= addr and addr < m.page_end:
                    return str(m.permission)
            return "???"

        if not self.should_be_print(sym):
            return

        try:
            addr = int(gdb.parse_and_eval(f"&{sym}"))
            perm = get_permission(addr)
            if is_ascii_string(addr):
                val = read_ascii_string(addr)
                gef_print(f"{sym:42s}: {addr:#18x} [{perm:3s}] ({base:#18x} + {addr - base:#10x}) -> {val:>18s}")
            else:
                val = read_int_from_memory(addr)
                val_sym = get_symbol_string(val)
                gef_print(f"{sym:42s}: {addr:#18x} [{perm:3s}] ({base:#18x} + {addr - base:#10x}) -> {val:#18x}{val_sym}")
        except Exception:
            gef_print(f"{sym:42s}: {'Not found':>18s}")
        return

    def print_file_jumps_func(self, sym):
        if not self.should_be_print(sym):
            return

        if not self.print_file_jumps:
            return

        try:
            vtable = int(gdb.parse_and_eval(f"&{sym}"))
        except Exception:
            return

        gdb.execute("telescope {:#x} 22".format(vtable))
        return

    def magic(self):
        codebase = get_section_base_address(get_filepath(for_vmmap=True))
        libc = get_section_base_address_by_list(("libc-2.", "libc.so.6"))
        ld = get_section_base_address_by_list(("ld-2.", "ld-linux-", "ld-linux.so.2"))
        if libc is None or ld is None:
            gef_print("libc/ld not found")
            return

        gef_print(titlify("Legend"))
        msg = f"{'symbol':42s}: {'addr':>18s} {'perm':5s} ({'base':>18s} + {'offset':>10s}) -> {'val':>18s}"
        gef_print(Color.colorify(msg, get_gef_setting("theme.table_heading")))

        gef_print(titlify("Heap"))
        self.resolve_and_print("main_arena", libc)
        self.resolve_and_print("mp_", libc)
        self.resolve_and_print("__malloc_hook", libc)
        self.resolve_and_print("__free_hook", libc)
        self.resolve_and_print("__realloc_hook", libc)
        self.resolve_and_print("__memalign_hook", libc)
        self.resolve_and_print("__after_morecore_hook", libc)
        self.resolve_and_print("_dl_open_hook", libc)
        self.resolve_and_print("global_max_fast", libc)
        self.resolve_and_print("malloc", libc)
        self.resolve_and_print("free", libc)
        self.resolve_and_print("calloc", libc)
        self.resolve_and_print("realloc", libc)
        gef_print(titlify("I/O"))
        self.resolve_and_print("*stdin", libc)
        self.resolve_and_print("*stdout", libc)
        self.resolve_and_print("*stderr", libc)
        self.resolve_and_print("_IO_list_all", libc)
        self.resolve_and_print("_IO_file_jumps", libc)
        self.print_file_jumps_func("_IO_file_jumps")
        self.resolve_and_print("_IO_file_jumps_mmap", libc)
        self.print_file_jumps_func("_IO_file_jumps_mmap")
        self.resolve_and_print("_IO_file_jumps_maybe_mmap", libc)
        self.print_file_jumps_func("_IO_file_jumps_maybe_mmap")
        self.resolve_and_print("_IO_wfile_jumps", libc)
        self.print_file_jumps_func("_IO_wfile_jumps")
        self.resolve_and_print("_IO_wfile_jumps_mmap", libc)
        self.print_file_jumps_func("_IO_wfile_jumps_mmap")
        self.resolve_and_print("_IO_wfile_jumps_maybe_mmap", libc)
        self.print_file_jumps_func("_IO_wfile_jumps_maybe_mmap")
        self.resolve_and_print("_IO_old_file_jumps", libc)
        self.print_file_jumps_func("_IO_old_file_jumps")
        self.resolve_and_print("_IO_mem_jumps", libc)
        self.print_file_jumps_func("_IO_mem_jumps")
        self.resolve_and_print("_IO_wmem_jumps", libc)
        self.print_file_jumps_func("_IO_wmem_jumps")
        self.resolve_and_print("_IO_str_jumps", libc)
        self.print_file_jumps_func("_IO_str_jumps")
        self.resolve_and_print("_IO_strn_jumps", libc)
        self.print_file_jumps_func("_IO_strn_jumps")
        self.resolve_and_print("_IO_str_chk_jumps", libc)
        self.print_file_jumps_func("_IO_str_chk_jumps")
        self.resolve_and_print("_IO_wstr_jumps", libc)
        self.print_file_jumps_func("_IO_wstr_jumps")
        self.resolve_and_print("_IO_wstrn_jumps", libc)
        self.print_file_jumps_func("_IO_wstrn_jumps")
        self.resolve_and_print("_IO_streambuf_jumps", libc)
        self.print_file_jumps_func("_IO_streambuf_jumps")
        self.resolve_and_print("_IO_proc_jumps", libc)
        self.print_file_jumps_func("_IO_proc_jumps")
        self.resolve_and_print("_IO_old_proc_jumps", libc)
        self.print_file_jumps_func("_IO_old_proc_jumps")
        self.resolve_and_print("_IO_helper_jumps", libc)
        self.print_file_jumps_func("_IO_helper_jumps")
        self.resolve_and_print("_IO_cookie_jumps", libc)
        self.print_file_jumps_func("_IO_cookie_jumps")
        self.resolve_and_print("_IO_obstack_jumps", libc)
        self.print_file_jumps_func("_IO_obstack_jumps")
        self.resolve_and_print("open", libc)
        self.resolve_and_print("read", libc)
        self.resolve_and_print("write", libc)
        self.resolve_and_print("dup", libc)
        self.resolve_and_print("dup2", libc)
        self.resolve_and_print("dup3", libc)
        self.resolve_and_print("puts", libc)
        self.resolve_and_print("gets", libc)
        self.resolve_and_print("fputs", libc)
        self.resolve_and_print("fgets", libc)
        self.resolve_and_print("printf", libc)
        self.resolve_and_print("fprintf", libc)
        self.resolve_and_print("dprintf", libc)
        self.resolve_and_print("sprintf", libc)
        self.resolve_and_print("snprintf", libc)
        self.resolve_and_print("__printf_chk", libc)
        self.resolve_and_print("__fprintf_chk", libc)
        self.resolve_and_print("__dprintf_chk", libc)
        self.resolve_and_print("__sprintf_chk", libc)
        self.resolve_and_print("__snprintf_chk", libc)
        self.resolve_and_print("__printf_function_table", libc)
        self.resolve_and_print("__printf_arginfo_table", libc)
        self.resolve_and_print("scanf", libc)
        self.resolve_and_print("fscanf", libc)
        self.resolve_and_print("sscanf", libc)
        gef_print(titlify("Process"))
        self.resolve_and_print("system", libc)
        self.resolve_and_print("do_system", libc)
        self.resolve_and_print("execve", libc)
        self.resolve_and_print("setcontext", libc)
        self.resolve_and_print("__libc_start_main", libc)
        self.resolve_and_print("syscall", libc)
        self.resolve_and_print("ptrace", libc)
        self.resolve_and_print("prctl", libc)
        gef_print(titlify("Memory"))
        self.resolve_and_print("mmap", libc)
        self.resolve_and_print("munmap", libc)
        self.resolve_and_print("mremap", libc)
        self.resolve_and_print("mprotect", libc)
        gef_print(titlify("Stack"))
        self.resolve_and_print("__libc_argv", libc)
        self.resolve_and_print("__environ", libc)
        gef_print(titlify("Destructor"))
        self.resolve_and_print("_rtld_global->_dl_rtld_lock_recursive", ld)
        self.resolve_and_print("_rtld_global->_dl_rtld_unlock_recursive", ld)
        gef_print(titlify("Unwind"))
        self.resolve_and_print("'DW.ref.__gxx_personality_v0'", codebase)
        return

    def resolve_and_print_kernel(self, sym, base, maps, external_func=None):
        def get_permission(addr, maps):
            for vaddr, size, perm in maps:
                if vaddr <= addr and addr < vaddr + size:
                    return perm
            return "???"

        if not self.should_be_print(sym):
            return

        try:
            if external_func:
                addr = external_func()
            else:
                if isinstance(sym, str):
                    addr = get_ksymaddr(sym)
                    if addr is None:
                        raise # goto Not found/recognized
                elif isinstance(sym, list):
                    for s in sym:
                        addr = get_ksymaddr(s)
                        if addr:
                            sym = s
                            break
                    else: # Not found
                        sym = sym[0]
                        raise # goto Not found/recognized
            perm = get_permission(addr, maps)
            if is_ascii_string(addr):
                val = read_ascii_string(addr)
                gef_print(f"{sym:42s}: {addr:#18x} [{perm:3s}] ({base:#18x} + {addr - base:#10x}) -> {val:>18s}")
            else:
                val = read_int_from_memory(addr)
                gef_print(f"{sym:42s}: {addr:#18x} [{perm:3s}] ({base:#18x} + {addr - base:#10x}) -> {val:#18x}")
        except Exception:
            gef_print(f"{sym:42s}: {'Not found/recognized':>18s}")
        return

    def magic_kernel(self):
        info("Wait for memory scan")

        dic = KernelbaseCommand.get_kernel_base()
        maps = dic["maps"]
        kbase = dic["kbase"]
        kbase_size = dic["kbase_size"]
        if maps is None or kbase is None or kbase_size is None:
            return
        gef_print("{:42s}: {:#x} ({:#x} bytes)".format("kernel_base", kbase, kbase_size))

        gef_print(titlify("Legend"))
        msg = f"{'symbol':42s}: {'addr':>18s} {'perm':5s} ({'base':>18s} + {'offset':>10s}) -> {'val':>18s}"
        gef_print(Color.colorify(msg, get_gef_setting("theme.table_heading")))

        gef_print(titlify("Credential"))
        self.resolve_and_print_kernel("commit_creds", kbase, maps)
        self.resolve_and_print_kernel("prepare_kernel_cred", kbase, maps)
        self.resolve_and_print_kernel("init_cred", kbase, maps, KernelAddressHeuristicFinder.get_init_cred)
        self.resolve_and_print_kernel(["sys_setuid", "__sys_setuid"], kbase, maps)
        self.resolve_and_print_kernel("init_task", kbase, maps, KernelAddressHeuristicFinder.get_init_task)
        gef_print(titlify("Usermode helper"))
        self.resolve_and_print_kernel("call_usermodehelper", kbase, maps)
        self.resolve_and_print_kernel("run_cmd", kbase, maps)
        self.resolve_and_print_kernel("modprobe_path", kbase, maps, KernelAddressHeuristicFinder.get_modprobe_path)
        self.resolve_and_print_kernel("orderly_poweroff", kbase, maps)
        self.resolve_and_print_kernel("poweroff_cmd", kbase, maps, KernelAddressHeuristicFinder.get_poweroff_cmd)
        self.resolve_and_print_kernel("orderly_reboot", kbase, maps)
        self.resolve_and_print_kernel("reboot_cmd", kbase, maps, KernelAddressHeuristicFinder.get_reboot_cmd)
        self.resolve_and_print_kernel("core_pattern", kbase, maps, KernelAddressHeuristicFinder.get_core_pattern)
        gef_print(titlify("ROP finalizer"))
        if is_x86():
            self.resolve_and_print_kernel("swapgs_restore_regs_and_return_to_usermode", kbase, maps)
        self.resolve_and_print_kernel("msleep", kbase, maps)
        gef_print(titlify("Memory protection modifier"))
        if is_x86():
            self.resolve_and_print_kernel("native_write_cr0", kbase, maps)
            self.resolve_and_print_kernel("native_write_cr4", kbase, maps)
        self.resolve_and_print_kernel("set_memory_rw", kbase, maps)
        self.resolve_and_print_kernel("set_memory_x", kbase, maps)
        gef_print(titlify("Memory patcher"))
        self.resolve_and_print_kernel("text_poke", kbase, maps)
        self.resolve_and_print_kernel("memcpy", kbase, maps)
        self.resolve_and_print_kernel("_copy_to_user", kbase, maps)
        self.resolve_and_print_kernel("_copy_from_user", kbase, maps)
        if is_arm64():
            self.resolve_and_print_kernel("__arch_copy_to_user", kbase, maps)
            self.resolve_and_print_kernel("__arch_copy_from_user", kbase, maps)
        gef_print(titlify("Memory remapper"))
        self.resolve_and_print_kernel(["ioremap", "__ioremap"], kbase, maps)
        self.resolve_and_print_kernel(["iounmap", "__iounmap"], kbase, maps)
        self.resolve_and_print_kernel("phys_base", kbase, maps)
        gef_print(titlify("Automatically called function pointer"))
        self.resolve_and_print_kernel("kvm_clock", kbase, maps)
        self.resolve_and_print_kernel("clocksource_tsc", kbase, maps)
        gef_print(titlify("Function pointer table"))
        self.resolve_and_print_kernel("ptmx_fops", kbase, maps)
        self.resolve_and_print_kernel("perf_fops", kbase, maps)
        self.resolve_and_print_kernel("capability_hooks", kbase, maps)
        self.resolve_and_print_kernel("n_tty_ops", kbase, maps, KernelAddressHeuristicFinder.get_n_tty_ops)
        gef_print(titlify("Function pointer table array"))
        self.resolve_and_print_kernel("tty_ldiscs", kbase, maps, KernelAddressHeuristicFinder.get_tty_ldiscs)
        gef_print(titlify("SLUB"))
        self.resolve_and_print_kernel("__kmalloc", kbase, maps)
        self.resolve_and_print_kernel("kzalloc", kbase, maps)
        self.resolve_and_print_kernel("kfree", kbase, maps)
        self.resolve_and_print_kernel("kzfree", kbase, maps)
        self.resolve_and_print_kernel("slab_caches", kbase, maps, KernelAddressHeuristicFinder.get_slab_caches)
        gef_print(titlify("Dynamic resolver"))
        self.resolve_and_print_kernel("kallsyms_lookup_name", kbase, maps)
        gef_print(titlify("vDSO"))
        if is_x86():
            self.resolve_and_print_kernel("vdso_image_64", kbase, maps)
            self.resolve_and_print_kernel("vdso_image_32", kbase, maps)
            self.resolve_and_print_kernel("vdso_image_x32", kbase, maps)
        elif is_arm64():
            self.resolve_and_print_kernel("vdso_info", kbase, maps, KernelAddressHeuristicFinder.get_vdso_info)
        elif is_arm32():
            self.resolve_and_print_kernel("vdso_start", kbase, maps)
        gef_print(titlify("Others"))
        self.resolve_and_print_kernel("do_fchmodat", kbase, maps)
        self.resolve_and_print_kernel("mmap_min_addr", kbase, maps, KernelAddressHeuristicFinder.get_mmap_min_addr)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        if "--fj" in argv:
            argv.remove("--fj")
            self.print_file_jumps = True
        else:
            self.print_file_jumps = False

        self.filter = argv

        if is_qemu_system():
            self.magic_kernel()
        else:
            self.magic()
        return


@register_command
class OneGadgetCommand(GenericCommand):
    """Exec `one_gadget`."""
    _cmdline_ = "onegadget"
    _syntax_ = _cmdline_
    _category_ = "Exploit Development"

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        libc = process_lookup_path(("libc-2.", "libc.so.6"))
        if libc is None:
            err("libc is not found")
            return

        try:
            one_gadget = which("one_gadget")
            gef_print(titlify(f"{one_gadget} '{libc.path}' -l 1"))
            os.system(f"{one_gadget} '{libc.path}' -l 1")
        except Exception:
            err("Missing `one_gadget`, install with: `gem install one_gadget`.")
        return


@register_command
class SeccompCommand(GenericCommand):
    """Exec `seccomp-tools`."""
    _cmdline_ = "seccomp"
    _syntax_ = _cmdline_
    _category_ = "Exploit Development"

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        path = get_filepath()
        try:
            seccomp = which("seccomp-tools")
            gef_print(titlify(f"{seccomp} dump '{path}'"))
            os.system(f"{seccomp} dump '{path}'")
        except Exception:
            err("Missing `seccomp-tools`, install with: `gem install seccomp-tools`.")
        return


@register_command
class SysregCommand(GenericCommand):
    """Pretty-print system registers (not general parpose) from `info regiser`"""
    _cmdline_ = "sysreg"
    _syntax_ = "{:s} [-h] [FILTER[, FILTER, ...]]".format(_cmdline_)
    _category_ = "Show/Modify Register"

    def get_non_generic_regs(self, filt):
        res = gdb.execute("info register", to_string=True)
        res = res.strip()
        regs = {}
        for line in res.splitlines():
            m = re.match(r"(\S+)\s*(0x\S+)\s+(0x\S+|\[.+\])", line)
            if not m:
                continue
            regname, regvalue = m.group(1), m.group(2)
            if filt and not any([f.lower() in regname.lower() for f in filt]):
                continue
            regs[regname] = int(regvalue, 16)
        regs = list(filter(lambda x: "$" + x[0] not in current_arch.all_registers, sorted(regs.items())))
        return regs # [[regname, regvalue], ...]

    def print_sysreg_compact(self, filt):
        regs = self.get_non_generic_regs(filt)
        if regs:
            gef_print(titlify("System registers"))
        else:
            gef_print("Not found non generic regs")
            return
        COLUMN = 3
        length = len(regs)
        length_of_each_bank = (length + COLUMN - 1) // COLUMN
        for i in range(length_of_each_bank):
            out = []
            for j in range(COLUMN):
                if len(regs) > i + j * length_of_each_bank:
                    if is_32bit():
                        msg = "{:16s} = {:#10x}".format(*regs[i + j * length_of_each_bank])
                    else:
                        msg = "{:25s} = {:#18x}".format(*regs[i + j * length_of_each_bank])
                    if regs[i + j * length_of_each_bank][1] > 0:
                        msg = Color.boldify(msg)
                    out.append(msg)
                else:
                    out.append("")
            gef_print("  |  ".join(out))
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        self.print_sysreg_compact(argv)
        return


@register_command
class MmxSetCommand(GenericCommand):
    """Simply set the value to mm."""
    _cmdline_ = "mmxset"
    _syntax_ = "{:s} $mm0=0x1122334455667788".format(_cmdline_)
    _category_ = "Show/Modify Register"

    def get_state(self, code_len):
        d = {}
        d["pc"] = get_register("$pc")
        d["code"] = read_memory(d["pc"], code_len)
        if is_x86_64():
            d["rax"] = get_register("$rax")
        else:
            d["eax"] = get_register("$eax")
        return d

    def revert_state(self, d):
        write_memory(d["pc"], d["code"], len(d["code"]))
        gdb.execute("set $pc = {:#x}".format(d["pc"]), to_string=True)
        if is_x86_64():
            gdb.execute("set $rax = {:#x}".format(d["rax"]), to_string=True)
        else:
            gdb.execute("set $eax = {:#x}".format(d["eax"]), to_string=True)
        return

    def close_stdout(self):
        self.stdout = 1
        self.stdout_bak = os.dup(self.stdout)
        f = open("/dev/null")
        os.dup2(f.fileno(), self.stdout)
        f.close()
        return

    def revert_stdout(self):
        os.dup2(self.stdout_bak, self.stdout)
        os.close(self.stdout_bak)
        return

    def execute_movq_mm(self, value, reg):
        REG_CODE = {
            "$mm0": b"\x0f\x6f\x00",
            "$mm1": b"\x0f\x6f\x08",
            "$mm2": b"\x0f\x6f\x10",
            "$mm3": b"\x0f\x6f\x08",
            "$mm4": b"\x0f\x6f\x20",
            "$mm5": b"\x0f\x6f\x28",
            "$mm6": b"\x0f\x6f\x30",
            "$mm7": b"\x0f\x6f\x38",
        }
        code = b"\xeb\xfe" + REG_CODE[reg] + p64(value) # inf-loop (to stop another thread); movq mm0, [rax]; db value
        gef_on_stop_unhook(hook_stop_handler)
        d = self.get_state(len(code))
        write_memory(d["pc"], code, len(code))
        if is_x86_64():
            gdb.execute("set $rax = {:#x}".format(d["pc"] + 5), to_string=True) # points to p64(value)
        else:
            gdb.execute("set $eax = {:#x}".format(d["pc"] + 5), to_string=True) # points to p64(value)
        gdb.execute("set $pc = {:#x}".format(d["pc"] + 2), to_string=True) # skip "\xeb\xfe"
        self.close_stdout()
        gdb.execute("stepi", to_string=True)
        self.revert_stdout()
        self.revert_state(d)
        gef_on_stop_hook(hook_stop_handler)
        return

    @only_if_gdb_running
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        # arg parse
        try:
            reg, value = ''.join(argv).split("=")
            value = int(value, 0)
        except Exception:
            self.usage()
            return

        # check register is valid or not
        if reg not in ["$mm{:d}".format(i) for i in range(8)]:
            err("Invalid register name")
            return

        # modify
        self.execute_movq_mm(value, reg)
        return


@register_command
class MmxCommand(GenericCommand):
    """Show MMX registers."""
    _cmdline_ = "mmx"
    _syntax_ = _cmdline_
    _category_ = "Show/Modify Register"

    def print_mmx(self):
        gef_print(titlify("MMX Register (from fpu register)"))
        regs = []

        for i in range(8):
            regname = "$st{:d}".format(i)
            result = gdb.execute(f"info registers $st{i}", to_string=True)
            r = re.findall(r"\(raw (0x[0-9a-f]+)\)", result)
            if r:
                reg = int(r[0], 16) & 0xffffffffffffffff
                regs.append(reg)

        fstat = get_register("$fstat")
        top_of_stack = (fstat >> 11) & 0b111
        regs = regs[-top_of_stack:] + regs[:-top_of_stack] # need rotate. because mmx0 != st(0)

        fmt = "{:5s}: {:s}"
        legend = ["Name", "64-bit hex"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        red = lambda x: Color.colorify("{:4s}".format(x), "red bold")
        for i in range(len(regs)):
            regname = "$mm{:d}".format(i)
            reghex = ""
            for j in range(8):
                c = (regs[i] >> (8 * j)) & 0xff
                reghex += chr(c) if 0x20 <= c < 0x7f else '.'
            gef_print("{:s} : {:#018x}  |  {:s}".format(red(regname), regs[i], reghex))
        return

    @only_if_gdb_running
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, argv):
        self.dont_repeat()
        self.print_mmx()
        return


@register_command
class XmmSetCommand(GenericCommand):
    """Simply set the value to xmm / ymm."""
    _cmdline_ = "xmmset"
    _syntax_ = "{:s} $ymm0=0x11223344556677889900aabbccddeeff9876543210".format(_cmdline_)
    _category_ = "Show/Modify Register"

    @only_if_gdb_running
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        # arg parse
        try:
            reg, value = ''.join(argv).split("=")
            value = int(value, 0)
        except Exception:
            self.usage()
            return

        # check register is valid or not
        try:
            gdb.execute(f"info register {reg}", to_string=True)
        except Exception:
            err("Invalid register name")
            return

        # modify
        if "$xmm" in reg:
            for i in range(2):
                v = (value >> (64 * i)) & ((1 << 64) - 1)
                gdb.execute(f"set {reg}.v2_int64[{i}]={v:#x}", to_string=True)
        elif "$ymm" in reg:
            for i in range(4):
                v = (value >> (64 * i)) & ((1 << 64) - 1)
                gdb.execute(f"set {reg}.v4_int64[{i}]={v:#x}", to_string=True)
        else:
            err("Unsupported")
        return


@register_command
class SseCommand(GenericCommand):
    """Show SSE registers."""
    _cmdline_ = "sse"
    _syntax_ = "{:s} [-h] [-v]".format(_cmdline_)
    _aliases_ = ["xmm"]
    _category_ = "Show/Modify Register"

    def print_sse(self):
        gef_print(titlify("SSE Data Register"))

        # xmm0-15
        regs = []
        for i in range(16 if is_x86_64() else 8):
            result = gdb.execute(f"info registers $xmm{i}", to_string=True)
            r = re.findall(r"uint128 = (0x[0-9a-f]+)", result)
            if r:
                reg = int(r[0], 16)
                regs.append(reg)
        fmt = "{:7s}: {:s}"
        legend = ["Name", "128-bit hex"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        red = lambda x: Color.colorify("{:4s}".format(x), "red bold")
        for i in range(len(regs)):
            if i == 8:
                gef_print("* xmm8-15 are introduced by AVX")
            reghex = ""
            for j in range(16):
                c = (regs[i] >> (8 * j)) & 0xff
                reghex += chr(c) if 0x20 <= c < 0x7f else '.'
            regname = "$xmm{:<2d}".format(i)
            gef_print("{:s} : {:#034x}  |  {:s}".format(red(regname), regs[i], reghex))
        return

    def print_sse_other(self):
        # mxcsr
        gef_print(titlify("MXCSR (MXCSR Control and Status Register)"))
        bit_info = [
            [15, "FZ", "Flush To Zero", ""],
            [[13, 14], "RC", "Rounding Control", "00: Round To Nearest, 01: Round Negative, 10: Round Positive, 11: Round To Zero"],
            [12, "PM", "Precision Exception Mask", ""],
            [11, "UM", "Underflow Exception Mask", ""],
            [10, "OM", "Overflow Exception Mask", ""],
            [9, "ZM", "Zero Divide Exception Mask", ""],
            [8, "DM", "Denormalized Opernad Exception Mask", ""],
            [7, "IM", "Invalid Operation Exception Mask", ""],
            [6, "DAZ", "Use as 0.0 if input data is denormalized", ""],
            [5, "PE", "Precision Exception", ""],
            [4, "UE", "Underflow Exception", ""],
            [3, "OE", "Overflow Exception", ""],
            [2, "ZE", "Zero Divide Exception", ""],
            [1, "DE", "Denormalized Operand Exception", ""],
            [0, "IE", "Invalid Operation Exception", ""],
        ]
        reg = int(gdb.execute("info registers $mxcsr", to_string=True).split()[1], 16)
        PrintBitInfo("$mxcsr", 32, None, bit_info).print(reg)
        return

    @only_if_gdb_running
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        self.print_sse()
        if "-v" in argv:
            self.print_sse_other()
        else:
            info("for $mxcsr flags description, use `-v`")
        return


@register_command
class AvxCommand(GenericCommand):
    """Show AVX registers."""
    _cmdline_ = "avx"
    _syntax_ = _cmdline_
    _aliases_ = ["ymm"]
    _category_ = "Show/Modify Register"

    def print_avx(self):
        regs = []
        for i in range(16 if is_x86_64() else 8):
            try:
                result = gdb.execute(f"info registers $ymm{i}", to_string=True)
            except Exception:
                continue
            result = result.replace("\n", "")
            r = re.findall(r"v2_int128 = \{.*?\[0x0\] = (0x[0-9a-f]+),.*?\[0x1\] = (0x[0-9a-f]+).*?\}", result)
            if r:
                reg = (int(r[0][1], 16) << 128) + int(r[0][0], 16)
                regs.append(reg)
        if regs:
            gef_print(titlify("AVX Register"))
            fmt = "{:7s}: {:s}"
            legend = ["Name", "256-bit hex"]
            gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
            red = lambda x: Color.colorify("{:4s}".format(x), "red bold")
            for i in range(len(regs)):
                regname = "$ymm{:<2d}".format(i)
                reghex = ""
                for j in range(32):
                    c = (regs[i] >> (8 * j)) & 0xff
                    reghex += chr(c) if 0x20 <= c < 0x7f else '.'
                gef_print("{:s} : {:#066x}  |  {:s}".format(red(regname), regs[i], reghex))
        else:
            err("Not found avx registers")
        return

    @only_if_gdb_running
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, argv):
        self.dont_repeat()
        self.print_avx()
        return


@register_command
class FpuCommand(GenericCommand):
    """Show fpu registers.(x86/x64:x57-fpu, ARM/ARM64:vfp-d16)"""
    _cmdline_ = "fpu"
    _syntax_ = "{:s} [-h] [-v]".format(_cmdline_)
    _category_ = "Show/Modify Register"

    def f2u(self, a):
        u = lambda a: struct.unpack("<I", a)[0]
        pf = lambda a: struct.pack("<f", a)
        return u(pf(a))

    def u2f(self, a):
        p = lambda a: struct.pack("<I", a & 0xffffffff)
        uf = lambda a: struct.unpack("<f", a)[0]
        return uf(p(a))

    def d2u(self, a):
        uQ = lambda a: struct.unpack("<Q", a)[0]
        pd = lambda a: struct.pack("<d", a)
        return uQ(pd(a))

    def u2d(self, a):
        pQ = lambda a: struct.pack("<Q", a & 0xffffffffffffffff)
        ud = lambda a: struct.unpack("<d", a)[0]
        return ud(pQ(a))

    def d2u80(self, a):
        value = ctypes.c_longdouble(a)
        BYTES = ctypes.POINTER(ctypes.c_byte * 10)
        ptr = ctypes.cast(ctypes.addressof(value), BYTES)
        x = ["{:02x}".format(int(x) & 0xff) for x in ptr[0][::-1]]
        return int(''.join(x), 16)

    def bits_split(self, x, bits=32):
        # 0xaaaabbbb -> 0xaaaa_bbbb
        out = ""
        for i in range(bits):
            if x & (1 << i):
                out = "1" + out
            else:
                out = "0" + out
            if i % 4 == 3:
                out = "_" + out
        return "0b" + out[1:]

    def print_fpu_arm(self):
        red = lambda x: Color.colorify("{:4s}".format(x), "red bold")

        # s0-s31, d0-d31, q0-q15
        gef_print(titlify("FPU/NEON Data Register"))
        fmt = "{:4s}: {:15s} {:10s} | {:4s}: {:28s} {:18s} | {:4s} {:34s}"
        legend = ["Name", "Value", "32-bit hex", "Name", "Value", "64-bit hex", "Name", "128-bit hex"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        for i in range(32):
            regname1 = "$s{:d}".format(i)
            regname2 = "$d{:d}".format(i)
            regname3 = "$q{:d}".format(i)
            if is_32bit():
                reg1 = self.f2u(float(gdb.execute("p {}".format(regname1), to_string=True).split()[2]))
                reg2 = int(gdb.execute("p {}.u64".format(regname2), to_string=True).split()[2], 16)
                try:
                    reg3h = int(gdb.execute("p {}.u64[0]".format(regname3), to_string=True).split()[2], 16)
                    reg3l = int(gdb.execute("p {}.u64[1]".format(regname3), to_string=True).split()[2], 16)
                    reg3 = (reg3h << 64) + reg3l
                except Exception:
                    reg3 = None
            else:
                reg1 = int(gdb.execute("p {}.u".format(regname1), to_string=True).split()[2], 16)
                reg2 = int(gdb.execute("p {}.u".format(regname2), to_string=True).split()[2], 16)
                try:
                    reg3 = int(gdb.execute("p {}.u".format(regname3), to_string=True).split()[2], 16)
                except Exception:
                    reg3 = None

            fmt1 = "{:s}: {:15s} {:<#10x}".format(red(regname1), "{:<+.8e}".format(self.u2f(reg1)), reg1)
            fmt2 = "{:s}: {:28s} {:<#18x}".format(red(regname2), "{:<+.20e}".format(self.u2d(reg2)), reg2)
            if reg3 is None:
                fmt3 = "{:s}: {:s}".format(red(regname3), "Access denied")
            else:
                fmt3 = "{:s}: {:<#34x}".format(red(regname3), reg3)
            gef_print("{:s} | {:s} | {:s}".format(fmt1, fmt2, fmt3))
        return

    def print_fpu_x86(self):
        red = lambda x: Color.colorify("{:4s}".format(x), "red bold")

        # st0-7
        gef_print(titlify("FPU Data Register"))
        fmt = "{:9s} : {:27s}\t{:24s} {:18s} {:10s}"
        legend = ["Name", "Value", "80-bit hex(TWORD/XWORD)", "64-bit hex(QWORD)", "32-bit Hex(DWORD)"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))

        fstat = get_register("$fstat")
        top_of_stack = (fstat >> 11) & 0b111
        regs = ["mm{:d}".format(i) for i in range(8)]
        regs = regs[top_of_stack:] + regs[:top_of_stack] # need rotate. because mmx0 != st(0)

        for i in range(8):
            regname = "$st{:d}".format(i)
            result = gdb.execute("info registers {}".format(regname), to_string=True)
            if "invalid" in result:
                r = re.findall(r"\(raw (0x[0-9a-f]+)\)", result)
                u80 = int(r[0], 16)
                u64 = 0xfff8000000000000 # nan
                u32 = 0xffc00000 # nan
                gef_print("{:4s}({:3s}) : {:<27s}\t{:<#24x} {:<#18x} {:<#10x}".format(red(regname), regs[i], "<invalid>", u80, u64, u32))
            else:
                reg = float(result.split()[1])
                u80 = self.d2u80(reg)
                u64 = self.d2u(reg)
                u32 = self.f2u(reg)
                gef_print("{:4s}({:3s}) : {:<+.20e}\t{:<#24x} {:<#18x} {:<#10x}".format(red(regname), regs[i], reg, u80, u64, u32))
        info('XWORD: Real register value; Used at "fstp xword ptr [rax]".')
        info('QWORD: Used at "fst/fstp qword ptr [rax]".')
        info('DWORD: Used at "fst/fstp dword ptr [rax]".')
        return

    def print_fpu_arm_other(self):
        # fpscr
        gef_print(titlify("FPSCR (Floating-Point Status and Control Register)"))
        bit_info = [
            [31, "N", "Negative condition flag", ""],
            [30, "Z", "Zero condition flag", ""],
            [29, "C", "Carry condition flag", ""],
            [28, "V", "Overflow condition flag", ""],
            [27, "QC", "Cumulative saturation bit", ""],
            [26, "AHP", "Alternative Half-Precision Control", ""],
            [25, "DN", "Default NaN mode Control", ""],
            [24, "FZ", "Flush-to-zero mode Control", ""],
            [[22, 23], "RMode", "Rounding Control", "00: Round To Nearest, 01: Round Positive, 10: Round Negative, 11: Round To Zero"],
            [[20, 21], "Stride", "", "IMPLEMENTATION DEFINED"],
            [19, "FZ16", "Flush-to-zero mode Control", "When FEAT_FP16 is implemented"],
            [[16, 17, 18], "Len", "", "IMPLEMENTATION DEFINED"],
            [15, "IDE", "Input Denormal floating-point Exception trap enable", ""],
            [12, "IXE", "Inexact floating-point Exception trap enable", ""],
            [11, "UFE", "Underflow floating-point Exception trap enable", ""],
            [10, "OFE", "Overflow floating-point Exception trap enable", ""],
            [9, "DZE", "Divide by Zero floating-point Exception trap enable", ""],
            [8, "IOE", "Invalid Operation floating-point Exception trap enable", ""],
            [7, "IDC", "Input Denormal Cumulative floating-point exception bit", ""],
            [4, "IXC", "Inexact Cumulative floating-point exception bit", ""],
            [3, "UFC", "Underflow Cumulative floating-point exception bit", ""],
            [2, "OFC", "Overflow Cumulative floating-point exception bit", ""],
            [1, "DZC", "Divide by Zero Cumulative floating-point exception bit", ""],
            [0, "IOC", "Invalid Operation Cumulative floating-point exception bit", ""],
        ]
        reg = int(gdb.execute("info registers $fpscr", to_string=True).split()[1], 16)
        PrintBitInfo("$fpscr", 32, None, bit_info).print(reg)

        # fpsid
        gef_print(titlify("FPSID (Floating-Point System ID Register)"))
        bit_info = [
            [list(range(24, 32)), "Implementer", "Implementer code", ""],
            [23, "SW", "Software bit", "Implementation of floating point instructions, 0:HW, 1:SW"],
            [list(range(16, 23)), "Subarchitecture", "Subarchitecture version number", ""],
            [list(range(8, 16)), "PartNum", "Part number", "IMPLEMENTATION DEFINED"],
            [[4, 5, 6, 7], "Variant", "Variant number", "IMPLEMENTATION DEFINED"],
            [[0, 1, 2, 3], "Revision", "Revisino number", "IMPLEMENTATION DEFINED"],
        ]
        impl = {
            0x00: "Reserved for software use",
            0xc0: "Ampere Computing",
            0x41: "Arm Limited",
            0x42: "Broadcom Corporation",
            0x43: "Cavium Inc.",
            0x44: "Digital Equipment Corporation",
            0x46: "Fujitsu Ltd.",
            0x49: "Infineon Technologies AG",
            0x4d: "Motorola or Freescale Semiconductor Inc.",
            0x4e: "NVIDIA Corporation",
            0x50: "Applied Micro Circuits Corporation",
            0x51: "Qualcomm Inc.",
            0x56: "Marvell International Ltd.",
            0x69: "Intel Corporation",
        }
        reg = int(gdb.execute("info registers $fpsid", to_string=True).split()[1], 16)
        PrintBitInfo("$fpsid", 32, None, bit_info).print(reg)
        gef_print("Implementer code")
        for k, v in impl.items():
            gef_print("  {:#02x}: {:s}".format(k, v))

        # fpexc
        gef_print(titlify("FPEXC (Floating-Point Exception Control Register)"))
        bit_info = [
            [31, "EX", "Exception bit", ""],
            [30, "EN", "Enables access to the Advanced SIMD and floating-point functionality from all Exception levels", ""],
            [29, "DEX", "Defined synchronous exception on floating-point execution", ""],
            [28, "FP2V", "FPINST2 instruction valid bit", ""],
            [27, "VV", "VECITR valid bit", ""],
            [26, "TFV", "Trapped Fault Valid bit", ""],
            [[8, 9, 10], "VECITR", "Vector iteration count", ""],
            [7, "IDF", "Input Denormal trapped exception bit", ""],
            [4, "IXF", "Inexact trapped exception bit", ""],
            [3, "UFF", "Underflow trapped exception bit", ""],
            [2, "OFF", "Overflow trapped exception bit", ""],
            [1, "DZF", "Divide by Zero trapped exception bit", ""],
            [0, "IOF", "Invalid Operation trapped exception bit", ""],
        ]
        reg = int(gdb.execute("info registers $fpexc", to_string=True).split()[1], 16)
        PrintBitInfo("$fpexc", 32, None, bit_info).print(reg)
        return

    def print_fpu_arm64_other(self):
        # fpcr
        gef_print(titlify("FPCR (Floating-Point Control Register)"))
        bit_info = [
            [26, "AHP", "Alternative Half-Precision Control", ""],
            [25, "DN", "Default NaN mode Control", ""],
            [24, "FZ", "Flush-to-zero mode Control", ""],
            [[22, 23], "RMode", "Rounding Control", "00: Round To Nearest, 01: Round Positive, 10: Round Negative, 11: Round To Zero"],
            [[20, 21], "Stride", "", "Unused"],
            [19, "FZ16", "Flush-to-zero mode Control", "When FEAT_FP16 is implemented"],
            [[16, 17, 18], "Len", "", "Unused"],
            [15, "IDE", "Input Denormal floating-point Exception trap enable", ""],
            [12, "IXE", "Inexact floating-point Exception trap enable", ""],
            [11, "UFE", "Underflow floating-point Exception trap enable", ""],
            [10, "OFE", "Overflow floating-point Exception trap enable", ""],
            [9, "DZE", "Divide by Zero floating-point Exception trap enable", ""],
            [8, "IOE", "Invalid Operation floating-point Exception trap enable", ""],
        ]
        reg = int(gdb.execute("info registers $fpcr", to_string=True).split()[1], 16)
        PrintBitInfo("$fpcr", 32, None, bit_info).print(reg)

        # fpsr
        gef_print(titlify("FPCR (Floating-Point Status Register)"))
        bit_info = [
            [31, "N", "", "Unused, see $cpsr"],
            [30, "Z", "", "Unused, see $cpsr"],
            [29, "C", "", "Unused, see $cpsr"],
            [28, "V", "", "Unused, see $cpsr"],
            [27, "QC", "Cumulative saturation bit", ""],
            [7, "IDC", "Input Denormal Cumulative floating-point exception bit", ""],
            [4, "IXC", "Inexact Cumulative floating-point exception bit", ""],
            [3, "UFC", "Underflow Cumulative floating-point exception bit", ""],
            [2, "OFC", "Overflow Cumulative floating-point exception bit", ""],
            [1, "DZC", "Divide by Zero Cumulative floating-point exception bit", ""],
            [0, "IOC", "Invalid Operation Cumulative floating-point exception bit", ""],
        ]
        reg = int(gdb.execute("info registers $fpsr", to_string=True).split()[1], 16)
        PrintBitInfo("$fpsr", 32, None, bit_info).print(reg)
        return

    def print_fpu_x86_other(self):
        # fctrl
        gef_print(titlify("FCTRL (x87 FPU Control Word)"))
        bit_info = [
            [12, "X", "Infinity Control", ""],
            [[10, 11], "RC", "Rounding Control", "00: Round To Nearest, 01: Round Negative, 10: Round Positive, 11: Round To Zero"],
            [[8, 9], "PC", "Precision Control", "00: Signle Precison, 01: Reserved, 10: Double Precision, 11: Double-Extended Precision"],
            [5, "PM", "Precision Exception Mask", ""],
            [4, "UM", "Underflow Exception Mask", ""],
            [3, "OM", "Overflow Exception Mask", ""],
            [2, "ZM", "Zero Divide Exception Mask", ""],
            [1, "DM", "Denormalized Opernd Exception Mask", ""],
            [0, "IM", "Invalid Operation Exception Mask", ""],
        ]
        reg = int(gdb.execute("info registers $fctrl", to_string=True).split()[1], 16)
        PrintBitInfo("$fctrl", 16, None, bit_info).print(reg)

        # fstat
        gef_print(titlify("FSTAT (x87 FPU Status Word)"))
        bit_info = [
            [15, "B", "FPU Busy", ""],
            [14, "C3", "Condition Code", ""],
            [[11, 12, 13], "TOP", "Top of Stack Pointer", ""],
            [10, "C2", "Condition Code", ""],
            [9, "C1", "Condition Code", ""],
            [8, "C0", "Condition Code", ""],
            [7, "ES", "Exception Summary Status", ""],
            [6, "SF", "Stack Fault", ""],
            [5, "PE", "Precision Exception", ""],
            [4, "UE", "Underflow Exception", ""],
            [3, "OE", "Overflow Exception", ""],
            [2, "ZE", "Zero Divide Exception", ""],
            [1, "DE", "Denormalized Operand Exception", ""],
            [0, "IE", "Invalid Operation Exception", ""],
        ]
        reg = int(gdb.execute("info registers $fstat", to_string=True).split()[1], 16)
        PrintBitInfo("$fstat", 16, None, bit_info).print(reg)

        # ftag
        gef_print(titlify("FTAG (x87 FPU Tag Word)"))
        bit_info = [
            [[14, 15], "TAG(7)", "Reg7 Tag", "00: Valid, 01: Zero, 10: Invalid/Nan/Inf/Denormal, 11: Blank"],
            [[12, 13], "TAG(6)", "Reg6 Tag", "00: Valid, 01: Zero, 10: Invalid/Nan/Inf/Denormal, 11: Blank"],
            [[10, 11], "TAG(5)", "Reg5 Tag", "00: Valid, 01: Zero, 10: Invalid/Nan/Inf/Denormal, 11: Blank"],
            [[8, 9], "TAG(4)", "Reg4 Tag", "00: Valid, 01: Zero, 10: Invalid/Nan/Inf/Denormal, 11: Blank"],
            [[6, 7], "TAG(3)", "Reg3 Tag", "00: Valid, 01: Zero, 10: Invalid/Nan/Inf/Denormal, 11: Blank"],
            [[4, 5], "TAG(2)", "Reg2 Tag", "00: Valid, 01: Zero, 10: Invalid/Nan/Inf/Denormal, 11: Blank"],
            [[2, 3], "TAG(1)", "Reg1 Tag", "00: Valid, 01: Zero, 10: Invalid/Nan/Inf/Denormal, 11: Blank"],
            [[0, 1], "TAG(0)", "Reg0 Tag", "00: Valid, 01: Zero, 10: Invalid/Nan/Inf/Denormal, 11: Blank"],
        ]
        reg = int(gdb.execute("info registers $ftag", to_string=True).split()[1], 16)
        PrintBitInfo("$ftag", 16, None, bit_info).print(reg)

        # $fiseg, $fioff
        gef_print(titlify("FCS:FIP (x87 FPU Last Instruction Pointer)"))
        reg = int(gdb.execute("info registers $fiseg", to_string=True).split()[1], 16)
        reg = int(gdb.execute("info registers $fioff", to_string=True).split()[1], 16)
        PrintBitInfo("$fiseg(FCS)", 16, None, bit_info=[]).print(reg, split=False)
        PrintBitInfo("$fioff(FIP)", 32, None, bit_info=[]).print(reg, split=False)

        # $foseg, $fooff
        gef_print(titlify("FDS:FDP (x87 FPU Last Data(Operand) Pointer)"))
        reg = int(gdb.execute("info registers $foseg", to_string=True).split()[1], 16)
        reg = int(gdb.execute("info registers $fooff", to_string=True).split()[1], 16)
        PrintBitInfo("$foseg(FDS)", 16, None, bit_info=[]).print(reg, split=False)
        PrintBitInfo("$fooff(FDP)", 32, None, bit_info=[]).print(reg, split=False)

        # $fop
        gef_print(titlify("FOP (x87 FPU Last Instruction Opcode)"))
        reg = int(gdb.execute("info registers $fop", to_string=True).split()[1], 16)
        PrintBitInfo("$fop", 11, None, bit_info=[]).print(reg, split=False)
        return

    @only_if_gdb_running
    @only_if_specific_arch(arch=["x86_32", "x86_64", "ARM32", "ARM64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        if is_x86():
            self.print_fpu_x86()
        elif is_arm32() or is_arm64():
            self.print_fpu_arm()

        if "-v" in argv:
            if is_x86():
                self.print_fpu_x86_other()
            elif is_arm32():
                self.print_fpu_arm_other()
            elif is_arm64():
                self.print_fpu_arm64_other()
        else:
            info("for fpu other register's flags description, use `-v`")
        return


@register_command
class ErrnoCommand(GenericCommand):
    """Converts errno (or argument) to its string representation."""
    _cmdline_ = "errno"
    _syntax_ = "{:s} [errno] [all]".format(_cmdline_)
    _category_ = "Process Information"

    # /usr/include/asm-generic/errno.h
    ERRNO_DICT = {
        0   : ["-",               "No error"],
        1   : ["EPERM",           "Operation not permitted"],
        2   : ["ENOENT",          "No such file or directory"],
        3   : ["ESRCH",           "No such process"],
        4   : ["EINTR",           "Interrupted system call"],
        5   : ["EIO",             "I/O error"],
        6   : ["ENXIO",           "No such device or address"],
        7   : ["E2BIG",           "Argument list too long"],
        8   : ["ENOEXEC",         "Exec format error"],
        9   : ["EBADF",           "Bad file number"],
        10  : ["ECHILD",          "No child processes"],
        11  : ["EAGAIN",          "Try again"],
        12  : ["ENOMEM",          "Out of memory"],
        13  : ["EACCES",          "Permission denied"],
        14  : ["EFAULT",          "Bad address"],
        15  : ["ENOTBLK",         "Block device required"],
        16  : ["EBUSY",           "Device or resource busy"],
        17  : ["EEXIST",          "File exists"],
        18  : ["EXDEV",           "Cross-device link"],
        19  : ["ENODEV",          "No such device"],
        20  : ["ENOTDIR",         "Not a directory"],
        21  : ["EISDIR",          "Is a directory"],
        22  : ["EINVAL",          "Invalid argument"],
        23  : ["ENFILE",          "File table overflow"],
        24  : ["EMFILE",          "Too many open files"],
        25  : ["ENOTTY",          "Not a typewriter"],
        26  : ["ETXTBSY",         "Text file busy"],
        27  : ["EFBIG",           "File too large"],
        28  : ["ENOSPC",          "No space left on device"],
        29  : ["ESPIPE",          "Illegal seek"],
        30  : ["EROFS",           "Read-only file system"],
        31  : ["EMLINK",          "Too many links"],
        32  : ["EPIPE",           "Broken pipe"],
        33  : ["EDOM",            "Math argument out of domain of func"],
        34  : ["ERANGE",          "Math result not representable"],
        35  : ["EDEADLK",         "Resource deadlock would occur"],
        36  : ["ENAMETOOLONG",    "File name too long"],
        37  : ["ENOLCK",          "No record locks available"],
        38  : ["ENOSYS",          "Invalid system call number"],
        39  : ["ENOTEMPTY",       "Directory not empty"],
        40  : ["ELOOP",           "Too many symbolic links encountered"],
        42  : ["ENOMSG",          "No message of desired type"],
        43  : ["EIDRM",           "Identifier removed"],
        44  : ["ECHRNG",          "Channel number out of range"],
        45  : ["EL2NSYNC",        "Level 2 not synchronized"],
        46  : ["EL3HLT",          "Level 3 halted"],
        47  : ["EL3RST",          "Level 3 reset"],
        48  : ["ELNRNG",          "Link number out of range"],
        49  : ["EUNATCH",         "Protocol driver not attached"],
        50  : ["ENOCSI",          "No CSI structure available"],
        51  : ["EL2HLT",          "Level 2 halted"],
        52  : ["EBADE",           "Invalid exchange"],
        53  : ["EBADR",           "Invalid request descriptor"],
        54  : ["EXFULL",          "Exchange full"],
        55  : ["ENOANO",          "No anode"],
        56  : ["EBADRQC",         "Invalid request code"],
        57  : ["EBADSLT",         "Invalid slot"],
        59  : ["EBFONT",          "Bad font file format"],
        60  : ["ENOSTR",          "Device not a stream"],
        61  : ["ENODATA",         "No data available"],
        62  : ["ETIME",           "Timer expired"],
        63  : ["ENOSR",           "Out of streams resources"],
        64  : ["ENONET",          "Machine is not on the network"],
        65  : ["ENOPKG",          "Package not installed"],
        66  : ["EREMOTE",         "Object is remote"],
        67  : ["ENOLINK",         "Link has been severed"],
        68  : ["EADV",            "Advertise error"],
        69  : ["ESRMNT",          "Srmount error"],
        70  : ["ECOMM",           "Communication error on send"],
        71  : ["EPROTO",          "Protocol error"],
        72  : ["EMULTIHOP",       "Multihop attempted"],
        73  : ["EDOTDOT",         "RFS specific error"],
        74  : ["EBADMSG",         "Not a data message"],
        75  : ["EOVERFLOW",       "Value too large for defined data type"],
        76  : ["ENOTUNIQ",        "Name not unique on network"],
        77  : ["EBADFD",          "File descriptor in bad state"],
        78  : ["EREMCHG",         "Remote address changed"],
        79  : ["ELIBACC",         "Can not access a needed shared library"],
        80  : ["ELIBBAD",         "Accessing a corrupted shared library"],
        81  : ["ELIBSCN",         ".lib section in a.out corrupted"],
        82  : ["ELIBMAX",         "Attempting to link in too many shared libraries"],
        83  : ["ELIBEXEC",        "Cannot exec a shared library directly"],
        84  : ["EILSEQ",          "Illegal byte sequence"],
        85  : ["ERESTART",        "Interrupted system call should be restarted"],
        86  : ["ESTRPIPE",        "Streams pipe error"],
        87  : ["EUSERS",          "Too many users"],
        88  : ["ENOTSOCK",        "Socket operation on non-socket"],
        89  : ["EDESTADDRREQ",    "Destination address required"],
        90  : ["EMSGSIZE",        "Message too long"],
        91  : ["EPROTOTYPE",      "Protocol wrong type for socket"],
        92  : ["ENOPROTOOPT",     "Protocol not available"],
        93  : ["EPROTONOSUPPORT", "Protocol not supported"],
        94  : ["ESOCKTNOSUPPORT", "Socket type not supported"],
        95  : ["EOPNOTSUPP",      "Operation not supported on transport endpoint"],
        96  : ["EPFNOSUPPORT",    "Protocol family not supported"],
        97  : ["EAFNOSUPPORT",    "Address family not supported by protocol"],
        98  : ["EADDRINUSE",      "Address already in use"],
        99  : ["EADDRNOTAVAIL",   "Cannot assign requested address"],
        100 : ["ENETDOWN",        "Network is down"],
        101 : ["ENETUNREACH",     "Network is unreachable"],
        102 : ["ENETRESET",       "Network dropped connection because of reset"],
        103 : ["ECONNABORTED",    "Software caused connection abort"],
        104 : ["ECONNRESET",      "Connection reset by peer"],
        105 : ["ENOBUFS",         "No buffer space available"],
        106 : ["EISCONN",         "Transport endpoint is already connected"],
        107 : ["ENOTCONN",        "Transport endpoint is not connected"],
        108 : ["ESHUTDOWN",       "Cannot send after transport endpoint shutdown"],
        109 : ["ETOOMANYREFS",    "Too many references: cannot splice"],
        110 : ["ETIMEDOUT",       "Connection timed out"],
        111 : ["ECONNREFUSED",    "Connection refused"],
        112 : ["EHOSTDOWN",       "Host is down"],
        113 : ["EHOSTUNREACH",    "No route to host"],
        114 : ["EALREADY",        "Operation already in progress"],
        115 : ["EINPROGRESS",     "Operation now in progress"],
        116 : ["ESTALE",          "Stale file handle"],
        117 : ["EUCLEAN",         "Structure needs cleaning"],
        118 : ["ENOTNAM",         "Not a XENIX named type file"],
        119 : ["ENAVAIL",         "No XENIX semaphores available"],
        120 : ["EISNAM",          "Is a named type file"],
        121 : ["EREMOTEIO",       "Remote I/O error"],
        122 : ["EDQUOT",          "Quota exceeded"],
        123 : ["ENOMEDIUM",       "No medium found"],
        124 : ["EMEDIUMTYPE",     "Wrong medium type"],
        125 : ["ECANCELED",       "Operation Canceled"],
        126 : ["ENOKEY",          "Required key not available"],
        127 : ["EKEYEXPIRED",     "Key has expired"],
        128 : ["EKEYREVOKED",     "Key has been revoked"],
        129 : ["EKEYREJECTED",    "Key was rejected by service"],
        130 : ["EOWNERDEAD",      "Owner died"],
        131 : ["ENOTRECOVERABLE", "State not recoverable"],
        132 : ["ERFKILL",         "Operation not possible due to RF-kill"],
        133 : ["EHWPOISON",       "Memory page has hardware error"],
    }

    def do_invoke(self, argv):
        self.dont_repeat()

        if "all" in argv:
            for val, es in sorted(self.ERRNO_DICT.items()):
                gef_print("{:3d} (={:#4x}): {:<15s}: \"{:s}\"".format(val, val, es[0], es[1]))
            return

        try:
            if len(argv) == 0:
                if is_alive():
                    val = parse_address("*__errno_location()")
                else:
                    warn("No debugging session active")
                    return
            else:
                val = int(argv[0], 0)
        except Exception:
            self.usage()
            return

        if val > 0xffff:
            if current_arch and current_arch.ptrsize == 4:
                val = struct.unpack("<i", struct.pack("<I", val))[0]
            elif current_arch and current_arch.ptrsize == 8:
                val = struct.unpack("<q", struct.pack("<Q", val))[0]
            elif current_arch is None:
                val = struct.unpack("<q", struct.pack("<Q", val))[0]
            else:
                err("not support this pointer size.")
                return

        if val < 0:
            val = -val

        if val in self.ERRNO_DICT:
            es = self.ERRNO_DICT[val]
            gef_print("{:3d} (={:#4x}): {:<15s}: \"{:s}\"".format(val, val, es[0], es[1]))
        else:
            err("not found value in ERRNO_DICT (1~{:d})".format(len(self.ERRNO_DICT)))
        return


@register_command
class ExtractHeapAddrCommand(GenericCommand):
    """Extract heap address from protected `fd` pointer of single linked-list. This will be introduced from glibc 2.32."""
    _cmdline_ = "extract-heap-addr"
    _syntax_ = "{:s} [-h] VALUE|--source".format(_cmdline_)
    _example_ = "{:s} 0x000055500000C7F9".format(_cmdline_)
    _category_ = "Heap"

    def reveal(self, fd):
        # https://smallkirby.hatenablog.com/entry/safeunlinking
        L = fd >> 36
        for i in range(3):
            temp = (fd >> (36 - (i + 1) * 8)) & 0xff
            element = ((L >> 4) ^ temp) & 0xff
            L = (L << 8) + element
        return L << 12

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if not argv:
            self.usage()
            return

        if "-h" in argv:
            self.usage()
            return

        if "--source" in argv:
            s = inspect.getsource(self.reveal).rstrip()
            gef_print(s)
            return

        ptr = int(argv[0], 16)
        extracted_ptr = self.reveal(ptr)
        gef_print("Protected fd pointer: {:#x} -> Extracted heap address: {:#x} (=fd & ~0xfff)".format(ptr, extracted_ptr))
        return


@register_command
class U2dCommand(GenericCommand):
    """Translate type (unsigned long <-> double/float)."""
    _cmdline_ = "u2d"
    _syntax_ = "{:s} [-h] [HEX_VALUE|DOUBLE_VALUE]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} 0xdeadbeef\n".format(_cmdline_)
    _example_ += "{:s} 0.12345\n".format(_cmdline_)
    _example_ += "{:s} 1.2345e-1\n".format(_cmdline_)
    _example_ += " * only ~64bit supported (Unsupported 80bit, 128bit)"
    _category_ = "Misc"

    def f2u(self, x):
        u = lambda a: struct.unpack("<I", a)[0]
        pf = lambda a: struct.pack("<f", a)
        return u(pf(x))

    def u2f(self, x):
        p = lambda a: struct.pack("<I", a & 0xffffffff)
        uf = lambda a: struct.unpack("<f", a)[0]
        return uf(p(x))

    def d2u(self, x):
        uQ = lambda a: struct.unpack("<Q", a)[0]
        pd = lambda a: struct.pack("<d", a)
        return uQ(pd(x))

    def u2d(self, x):
        pQ = lambda a: struct.pack("<Q", a & 0xffffffffffffffff)
        ud = lambda a: struct.unpack("<d", a)[0]
        return ud(pQ(x))

    def translate_from_float(self, n):
        gef_print(titlify("double -> unsigned long long"))
        gef_print(Color.cyanify("double -> ull (reinterpret_cast)"))
        gef_print("  {:.20e} ---> {:#018x}".format(n, self.d2u(n)))
        gef_print(titlify("float -> float"))
        gef_print(Color.cyanify("float -> uint (reinterpret_cast)"))
        gef_print("  {:.20e} ---> {:#010x}".format(n, self.f2u(n)))
        return

    def translate_from_int(self, n):
        n &= 0xffffffffffffffff
        gef_print(titlify("unsigned long long <-> double"))
        gef_print(Color.cyanify("ull -> double (reinterpret_cast)"))
        gef_print("  {:#018x} ---> {:.20e}".format(n, self.u2d(n)))
        gef_print(Color.cyanify("ull -> double -> ull (static_cast)"))
        gef_print("  {:#018x} ---> {:#018x} ---> {:#018x}".format(n, self.d2u(float(n)), int(self.u2d(self.d2u(float(n))))))
        gef_print(Color.cyanify("double -> ull (reinterpret_cast)"))
        gef_print("  {:#018x} ---> {:#018x}".format(n, int(self.u2d(n))))

        n &= 0xffffffff
        gef_print(titlify("unsigned int <-> float"))
        gef_print(Color.cyanify("uint -> float (reinterpret_cast)"))
        gef_print("  {:#010x} ---> {:.20e}".format(n, self.u2f(n)))
        gef_print(Color.cyanify("uint -> float -> uint (static_cast)"))
        gef_print("  {:#010x} ---> {:#010x} ---> {:#010x}".format(n, self.f2u(float(n)), int(self.u2f(self.f2u(float(n))))))
        gef_print(Color.cyanify("float -> uint (reinterpret_cast)"))
        gef_print("  {:#010x} ---> {:#010x}".format(n, int(self.u2f(n))))
        return

    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) == 0:
            self.usage()
            return

        if "-h" in argv:
            self.usage()
            return

        try:
            if "." in argv[0]:
                n = float(argv[0])
                self.translate_from_float(n)
            else:
                n = int(argv[0], 0)
                self.translate_from_int(n)
        except Exception:
            self.usage()
        return


@register_command
class PackCommand(GenericCommand):
    """Translate integer -> string."""
    _cmdline_ = "pack"
    _syntax_ = "{:s} [-h] VALUE".format(_cmdline_)
    _example_ = "{:s} 0xdeadbeef".format(_cmdline_)
    _category_ = "Misc"

    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) == 0:
            self.usage()
            return

        if "-h" in argv:
            self.usage()
            return

        try:
            value = int(argv[0], 0)
        except Exception:
            self.usage()
            return
        gef_print("pack8:   {}".format(p8(value & 0xff)))
        gef_print("pack16:  {}".format(p16(value & 0xffff)))
        gef_print("pack32:  {}".format(p32(value & 0xffffffff)))
        gef_print("pack64:  {}".format(p64(value & 0xffffffffffffffff)))
        low = value & 0xffffffffffffffff
        high = (value >> 64) & 0xffffffffffffffff
        val128 = p64(low) + p64(high)
        gef_print("pack128: {}".format(val128))

        gef_print("pack8-hex:   {}".format(p8(value & 0xff).hex()))
        gef_print("pack16-hex:  {}".format(p16(value & 0xffff).hex()))
        gef_print("pack32-hex:  {}".format(p32(value & 0xffffffff).hex()))
        gef_print("pack64-hex:  {}".format(p64(value & 0xffffffffffffffff).hex()))
        gef_print("pack128-hex: {}".format(val128.hex()))
        return


@register_command
class UnpackCommand(GenericCommand):
    """Translate string -> integer"""
    _cmdline_ = "unpack"
    _syntax_ = '{:s} [-h] "double-escaped string"'.format(_cmdline_)
    _example_ = '{:s} "\\\\x41\\\\x42\\\\x43\\\\x44"'.format(_cmdline_)
    _category_ = "Misc"

    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) == 0:
            self.usage()
            return

        if "-h" in argv:
            self.usage()
            return

        try:
            value = codecs.escape_decode(argv[0])[0] + b"\0" * 16
        except binascii.Error:
            gef_print("Could not decode '\\xXX' encoded string \"{}\"".format(argv[0]))
            return
        gef_print("unpack8:   {:#04x}".format(u8(value[:1])))
        gef_print("unpack16:  {:#06x}".format(u16(value[:2])))
        gef_print("unpack32:  {:#010x}".format(u32(value[:4])))
        gef_print("unpack64:  {:#018x}".format(u64(value[:8])))
        low, high = value[:8], value[8:16]
        gef_print("unpack128: {:#034x}".format((u64(high) << 64) | u64(low)))
        return


@register_command
class TohexCommand(GenericCommand):
    """Translate bytes -> hex"""
    _cmdline_ = "tohex"
    _syntax_ = '{:s} [-h] "double-escaped string"'.format(_cmdline_)
    _example_ = '{:s} "\\\\x41\\\\x42\\\\x43\\\\x44"'.format(_cmdline_)
    _category_ = "Misc"

    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) == 0:
            self.usage()
            return

        if "-h" in argv:
            self.usage()
            return

        try:
            value = codecs.escape_decode(argv[0])[0]
        except binascii.Error:
            gef_print("Could not decode '\\xXX' encoded string \"{}\"".format(argv[0]))
            return

        gef_print(binascii.hexlify(value))
        return


@register_command
class UnhexCommand(GenericCommand):
    """Translate hex -> bytes"""
    _cmdline_ = "unhex"
    _syntax_ = '{:s} [-h] "hex string"'.format(_cmdline_)
    _example_ = "{:s} 41414242 43434444".format(_cmdline_)
    _category_ = "Misc"

    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) == 0:
            self.usage()
            return

        if "-h" in argv:
            self.usage()
            return

        code = argv[0].replace(" ", "")
        try:
            value = binascii.unhexlify(code)
        except binascii.Error:
            gef_print("Could not unhexlify")
            return

        gef_print(value)
        return


@register_command
class ByteswapCommand(GenericCommand):
    """Translate endian (little-endian <-> big-endian)."""
    _cmdline_ = "byteswap"
    _syntax_ = "{:s} [-h] VALUE".format(_cmdline_)
    _example_ = "{:s} 0xdeadbeef".format(_cmdline_)
    _category_ = "Misc"

    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) == 0:
            self.usage()
            return

        if "-h" in argv:
            self.usage()
            return

        try:
            x = int(argv[0], 0)
        except Exception:
            self.usage()
            return

        p = lambda a: struct.pack("<I", a & 0xffffffff)
        ube = lambda a: struct.unpack(">I", a)[0]
        pQ = lambda a: struct.pack("<Q", a & 0xffffffffffffffff)
        uQbe = lambda a: struct.unpack(">Q", a)[0]
        converted32 = ube(p(x))
        converted64 = uQbe(pQ(x))

        gef_print("{:#x} -> 64bit byteswap -> {:#x}".format(x, converted64))
        gef_print("{:#x} -> 32bit byteswap -> {:#x}".format(x & 0xffffffff, converted32))
        return


@register_command
class VersionCommand(GenericCommand):
    """Display GEF version info."""
    _cmdline_ = "version"
    _syntax_ = "{:s}".format(_cmdline_)
    _example_ = "{:s}".format(_cmdline_)
    _category_ = "GEF Maintenance Command"

    def gef_version(self):
        gef_fpath = os.path.abspath(os.path.realpath(os.path.expanduser(inspect.stack()[0][1])))
        gef_dir = os.path.dirname(gef_fpath)
        gef_hash = hashlib.sha1(open(gef_fpath, "rb").read()).hexdigest()

        if os.access("{}/.git".format(gef_dir), os.X_OK):
            ver = subprocess.check_output('git log --format="%H" -n 1 HEAD', cwd=gef_dir, shell=True).decode("utf8").strip()
            extra = "dirty" if len(subprocess.check_output('git ls-files -m', cwd=gef_dir, shell=True).decode("utf8").strip()) else "clean"
            return "rev:{} (Git - {}) SHA1: {}".format(ver, extra, gef_hash)
        else:
            return "(Standalone) SHA1:{}".format(gef_hash)

    def gdb_version(self):
        try:
            return gdb.VERSION # GDB >= 8.1 (or earlier?)
        except AttributeError:
            return gdb.execute('show version', to_string=True).split('\n')[0]

    def python_version(self):
        return sys.version.replace('\n', ' ')

    def capstone_version(self):
        try:
            capstone = sys.modules['capstone']
            return '.'.join(map(str, capstone.cs_version()))
        except KeyError:
            return 'not found'

    def keystone_version(self):
        try:
            keystone = sys.modules['keystone']
            return '.'.join(map(str, keystone.ks_version()))
        except KeyError:
            return 'not found'

    def unicorn_version(self):
        try:
            unicorn = sys.modules['unicorn']
            return unicorn.__version__
        except KeyError:
            return 'not found'

    def ropper_version(self):
        try:
            ropper = sys.modules['ropper']
            return '.'.join(map(str, ropper.VERSION))
        except KeyError:
            return 'not found'

    def readelf_version(self):
        try:
            command = which("readelf")
            res = gef_execute_external([command, "-v"], as_list=True)
            return res[0]
        except IOError:
            return 'not found'

    def objdump_version(self):
        try:
            command = which("objdump")
            res = gef_execute_external([command, "-v"], as_list=True)
            return res[0]
        except IOError:
            return 'not found'

    def seccomp_tools_version(self):
        try:
            command = which("seccomp-tools")
            res = gef_execute_external([command, "--version"], as_list=True)
            return res[0]
        except IOError:
            return 'not found'

    def one_gadget_version(self):
        try:
            command = which("one_gadget")
            res = gef_execute_external([command, "--version"], as_list=True)
            return res[0]
        except IOError:
            return 'not found'

    def qemu_version(self):
        return gdb.execute('monitor info version', to_string=True).strip()

    def kernel_version(self):
        try:
            command = which("uname")
            res = gef_execute_external([command, "-a"], as_list=True)
            return res[0]
        except IOError:
            return 'not found'

    def do_invoke(self, argv):
        self.dont_repeat()

        gef_print("Kernel:        \t{:s}".format(self.kernel_version()))
        gef_print("GEF:           \t{:s}".format(self.gef_version()))
        gef_print("Gdb:           \t{:s}".format(self.gdb_version()))
        gef_print("Python:        \t{:s}".format(self.python_version()))
        gef_print("Capstone:      \t{:s}".format(self.capstone_version()))
        gef_print("Keystone:      \t{:s}".format(self.keystone_version()))
        gef_print("Unicorn:       \t{:s}".format(self.unicorn_version()))
        gef_print("Ropper:        \t{:s}".format(self.ropper_version()))
        gef_print("readelf:       \t{:s}".format(self.readelf_version()))
        gef_print("objdump:       \t{:s}".format(self.objdump_version()))
        gef_print("seccomp-tools: \t{:s}".format(self.seccomp_tools_version()))
        gef_print("one_gadget:    \t{:s}".format(self.one_gadget_version()))

        if is_qemu_system():
            gef_print("qemu:          \t{:s}".format(self.qemu_version()))
        return


class KernelAddressHeuristicFinder:
    """A class that heuristically finds a specific symbol in the kernel."""

    @staticmethod
    def get_saved_command_line():
        # plan 1
        cmdline_proc_show = get_ksymaddr("cmdline_proc_show")
        if cmdline_proc_show:
            res = gdb.execute("x/10i {:#x}".format(cmdline_proc_show), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"QWORD PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"DWORD PTR ds:(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"ldr\s+\S+,\s*\[\S+,\s*#(\d+)\]", line)
                        if m:
                            return base + int(m.group(1), 0)
            elif is_arm32():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"movw.*;\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"movt.*;\s*(0x\S+)", line)
                        if m:
                            return base + (int(m.group(1), 16) << 16)
        return None

    @staticmethod
    def get_init_task():
        # plan 1 (directly)
        init_task = get_ksymaddr("init_task")
        if init_task:
            return init_task

        # plan 2 (available v2.6.29.3 or later)
        chroot_fs_refs = get_ksymaddr("chroot_fs_refs")
        if chroot_fs_refs:
            res = gdb.execute("x/30i {:#x}".format(chroot_fs_refs), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"QWORD PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"ds:(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                count = 0
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                        if m:
                            addr = base + int(m.group(1), 16) # add 1 time
                            if count == 1:
                                return addr # 2nd pair of (adrp + add) is target
                            else:
                                base = None
                                count += 1
            elif is_arm32():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"movw.*;\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"movt.*;\s*(0x\S+)", line)
                        if m:
                            return base + (int(m.group(1), 16) << 16)
        return None

    @staticmethod
    def get_init_cred():
        # plan 1 (directly)
        init_cred = get_ksymaddr("init_cred")
        if init_cred:
            return init_cred

    @staticmethod
    def get_modules():
        # plan 1 (directly)
        modules = get_ksymaddr("modules")
        if modules:
            return modules

        # plan 2 (available v3.7.5 or later)
        find_module_all = get_ksymaddr("find_module_all")
        if find_module_all:
            res = gdb.execute("x/20i {:#x}".format(find_module_all), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"QWORD PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"ds:(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                bases = {}
                add1time = {}
                for line in res.splitlines():
                    m = re.search(r"adrp\s+(\S+),\s*(0x\S+)", line)
                    if m:
                        reg = m.group(1)
                        base = int(m.group(2), 16)
                        bases[reg] = base
                        continue
                    m = re.search(r"add\s+(\S+),\s*(\S+),\s*#(0x\w+)", line)
                    if m:
                        dstreg = m.group(1)
                        srcreg = m.group(2)
                        v = int(m.group(3), 16)
                        if srcreg in bases:
                            add1time[dstreg] = bases[srcreg] + v
                            continue
                    m = re.search(r"ldr\s+\S+,\s*\[(\S+),\s*#(\d+)\]", line)
                    if m:
                        srcreg = m.group(1)
                        v = int(m.group(2), 0)
                        if srcreg in add1time:
                            return add1time[srcreg] + v
            elif is_arm32():
                bases = {}
                add1time = {}
                for line in res.splitlines():
                    m = re.search(r"movw\s+(\S+),.+;\s*(0x\S+)", line)
                    if m:
                        reg = m.group(1)
                        base = int(m.group(2), 16)
                        bases[reg] = base
                        continue
                    m = re.search(r"movt\s+(\S+),.+;\s*(0x\S+)", line)
                    if m:
                        reg = m.group(1)
                        v = int(m.group(2), 16) << 16
                        if reg in bases:
                            add1time[reg] = bases[reg] + v
                            continue
                    m = re.search(r"ldr\s+\S+,\s*\[(\S+),\s*#(\d+)\]", line)
                    if m:
                        reg = m.group(1)
                        v = int(m.group(2), 0)
                        if reg in add1time:
                            return add1time[reg] + v
        return None

    @staticmethod
    def get_chrdevs():
        # plan 1 (directly)
        chrdevs = get_ksymaddr("chrdevs")
        if chrdevs:
            return chrdevs

        # plan 2
        chrdev_show = get_ksymaddr("chrdev_show")
        if chrdev_show:
            res = gdb.execute("x/30i {:#x}".format(chrdev_show), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"QWORD PTR \[.*\*8([-+]0x\S+)\]", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"\[.*\*4([+-]0x\S+)\]", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                count = 0
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                        if m:
                            addr = base + int(m.group(1), 16) # add 1 time
                            if count == 1:
                                return addr # 2nd pair of (adrp + add) is target
                            else:
                                base = None
                                count += 1
            elif is_arm32():
                bases = {}
                add1time = {}
                for line in res.splitlines():
                    m = re.search(r"movw\s+(\S+),.+;\s*(0x\S+)", line)
                    if m:
                        reg = m.group(1)
                        base = int(m.group(2), 16)
                        bases[reg] = base
                        continue
                    m = re.search(r"movt\s+(\S+),.+;\s*(0x\S+)", line)
                    if m:
                        reg = m.group(1)
                        v = int(m.group(2), 16) << 16
                        if reg in bases:
                            add1time[reg] = bases[reg] + v
                            continue
                    m = re.search(r"ldr\s+\S+,\s*\[(\S+),.*#\d+\]", line)
                    if m:
                        reg = m.group(1)
                        if reg in add1time:
                            return add1time[reg]
            return None

    @staticmethod
    def get_cdev_map():
        # plan 1 (directly)
        cdev_map = get_ksymaddr("cdev_map")
        if cdev_map:
            return cdev_map

        # plan 2
        cdev_del = get_ksymaddr("cdev_del")
        if cdev_del:
            res = gdb.execute("x/30i {:#x}".format(cdev_del), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"QWORD PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"ds:(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"ldr\s+\S+,\s*\[\S+,\s*#(\d+)\]", line)
                        if m:
                            return base + int(m.group(1), 0)
            elif is_arm32():
                bases = {}
                add1time = {}
                for line in res.splitlines():
                    m = re.search(r"movw\s+(\S+),.+;\s*(0x\S+)", line)
                    if m:
                        reg = m.group(1)
                        base = int(m.group(2), 16)
                        bases[reg] = base
                        continue
                    m = re.search(r"movt\s+(\S+),.+;\s*(0x\S+)", line)
                    if m:
                        reg = m.group(1)
                        v = int(m.group(2), 16) << 16
                        if reg in bases:
                            add1time[reg] = bases[reg] + v
                            continue
                    m = re.search(r"ldr\s+\S+,\s*\[(\S+),\s*#(\d+)\]", line)
                    if m:
                        reg = m.group(1)
                        v = int(m.group(2), 0)
                        if reg in add1time:
                            return add1time[reg] + v
        return None

    @staticmethod
    def get_sys_call_table_x64():
        # plan 1 (directly)
        if is_x86_64():
            sys_call_table = get_ksymaddr("sys_call_table")
        else:
            return None
        if sys_call_table:
            return sys_call_table

        # plan 2 (available v4.6-rc1 or later)
        do_syscall_64 = get_ksymaddr("do_syscall_64")
        if do_syscall_64:
            res = gdb.execute("x/30i {:#x}".format(do_syscall_64), to_string=True)
            for line in res.splitlines():
                m = re.search(r"[DQ]WORD PTR \[.*\*8([-+]0x\S+)\]", line)
                if m:
                    v = int(m.group(1), 16) & 0xffffffffffffffff
                    if v != 0:
                        return v
        return None

    @staticmethod
    def get_sys_call_table_x32():
        # plan 1 (directly)
        if is_x86_64():
            sys_call_table = get_ksymaddr("x32_sys_call_table")
        else:
            return None
        if sys_call_table:
            return sys_call_table

        # plan 2 (available v4.6-rc1 or later)
        do_syscall_64 = get_ksymaddr("do_syscall_64")
        if do_syscall_64:
            count = 0
            res = gdb.execute("x/30i {:#x}".format(do_syscall_64), to_string=True)
            for line in res.splitlines():
                m = re.search(r"[DQ]WORD PTR \[.*\*8([-+]0x\S+)\]", line)
                if m and count == 0:
                    count += 1
                    continue
                elif m and count == 1:
                    v = int(m.group(1), 16) & 0xffffffffffffffff
                    if v != 0:
                        return v
        return None

    @staticmethod
    def get_sys_call_table_x86():
        # plan 1 (directly)
        if is_x86_64():
            sys_call_table = get_ksymaddr("ia32_sys_call_table")
        elif is_x86_32():
            sys_call_table = get_ksymaddr("sys_call_table")
        else:
            return None
        if sys_call_table:
            return sys_call_table

        # plan 2 (available v4.6-rc1 or later)
        do_int80_syscall_32 = get_ksymaddr("do_int80_syscall_32")
        if do_int80_syscall_32:
            res = gdb.execute("x/20i {:#x}".format(do_int80_syscall_32), to_string=True)
            for line in res.splitlines():
                if is_x86_32():
                    m = re.search(r"\[eax\*4([+-]0x\S+)\]", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
                if is_x86_64():
                    m = re.search(r"\[rax\*8([+-]0x\S+)\]", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
        return None

    @staticmethod
    def get_sys_call_table_arm32():
        # plan 1 (directly)
        if is_arm32():
            sys_call_table = get_ksymaddr("sys_call_table")
        else:
            return None
        if sys_call_table:
            return sys_call_table

        # plan 2 is nothing
        # because `sys_call_table` symbol is embeded in .text area
        # I couldn't come up with the detection logic.
        return None

    @staticmethod
    def get_sys_call_table_arm64():
        # plan 1 (directly)
        if is_arm64():
            sys_call_table = get_ksymaddr("sys_call_table")
        else:
            return None
        if sys_call_table:
            return sys_call_table

        # plan 2 (available v3.7-rc1 or later)
        el0_svc = get_ksymaddr("do_el0_svc") or get_ksymaddr("el0_svc")
        if el0_svc:
            res = gdb.execute("x/20i {:#x}".format(el0_svc), to_string=True)
            base = None
            for line in res.splitlines():
                if base is None:
                    m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                    if m:
                        base = int(m.group(1), 16)
                else:
                    m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                    if m:
                        return base + int(m.group(1), 16)
        return None

    @staticmethod
    def get_sys_call_table_arm64_compat():
        # plan 1 (directly)
        if is_arm64():
            sys_call_table = get_ksymaddr("compat_sys_call_table")
        else:
            return None
        if sys_call_table:
            return sys_call_table

        # plan 2 (available v3.7-rc1 or later)
        el0_svc_compat = get_ksymaddr("do_el0_svc_compat") or get_ksymaddr("el0_svc_compat")
        if el0_svc_compat:
            res = gdb.execute("x/20i {:#x}".format(el0_svc_compat), to_string=True)
            base = None
            for line in res.splitlines():
                if base is None:
                    m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                    if m:
                        base = int(m.group(1), 16)
                else:
                    m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                    if m:
                        return base + int(m.group(1), 16)
        return None

    @staticmethod
    def get_per_cpu_offset():
        # plan 1 (directly)
        __per_cpu_offset = get_ksymaddr("__per_cpu_offset")
        if __per_cpu_offset:
            return __per_cpu_offset

        # plan 2
        nr_iowait_cpu = get_ksymaddr("nr_iowait_cpu")
        if nr_iowait_cpu:
            res = gdb.execute("x/10i {:#x}".format(nr_iowait_cpu), to_string=True)
            if is_x86():
                # pattern 1
                for line in res.splitlines():
                    m = re.search(r"add.*[DQ]WORD PTR \[.*([-+]0x\S+)\]", line)
                    if m:
                        if is_64bit():
                            v = int(m.group(1), 16) & 0xffffffffffffffff
                            if v != 0:
                                return v
                        else:
                            v = int(m.group(1), 16) & 0xffffffff
                            if v != 0:
                                return v
                # pattern 2
                for line in res.splitlines():
                    m = re.search(r"DWORD PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                        if m:
                            return base + int(m.group(1), 16)
            elif is_arm32():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"movw.*;\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"movt.*;\s*(0x\S+)", line)
                        if m:
                            return base + (int(m.group(1), 16) << 16)
        return None

    @staticmethod
    def get_slab_caches():
        # plan 1 (directly)
        slab_caches = get_ksymaddr("slab_caches")
        if slab_caches:
            return slab_caches

        # plan 2 (available v4.9-rc1 or later)
        slub_cpu_dead = get_ksymaddr("slub_cpu_dead")
        if slub_cpu_dead:
            res = gdb.execute("x/20i {:#x}".format(slub_cpu_dead), to_string=True)
            if is_x86():
                count = 0
                for line in res.splitlines():
                    m = re.search(r"(?:# |,)(0x\S{8,})", line)
                    if not m:
                        continue
                    if count == 1:
                        return int(m.group(1), 16)
                    count += 1
            elif is_arm64():
                count = 0
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                        if m:
                            addr = base + int(m.group(1), 16) # add 1 time
                            if count == 1:
                                return addr # 2nd pair of (adrp + add) is target
                            else:
                                base = None
                                count += 1
            elif is_arm32():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"movw.*;\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"movt.*;\s*(0x\S+)", line)
                        if m:
                            return base + (int(m.group(1), 16) << 16)

        # plan 3 (available v4.10.17 or before)
        memcg_update_all_caches = get_ksymaddr("memcg_update_all_caches")
        if memcg_update_all_caches:
            res = gdb.execute("x/20i {:#x}".format(memcg_update_all_caches), to_string=True)
            if is_x86():
                for line in res.splitlines():
                    m = re.search(r"(?:# |,)(0x\S{8,})", line)
                    if m:
                        if is_64bit():
                            return int(m.group(1), 16) & 0xffffffffffffffff
                        else:
                            return int(m.group(1), 16) & 0xffffffff
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                        if m:
                            return base + int(m.group(1), 16)
            elif is_arm32():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"movw.*;\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"movt.*;\s*(0x\S+)", line)
                        if m:
                            return base + (int(m.group(1), 16) << 16)
        return None

    @staticmethod
    def get_modprobe_path():
        # plan 1 (directly)
        modprobe_path = get_ksymaddr("modprobe_path")
        if modprobe_path:
            return modprobe_path

        # plan 2 (available v3.11-rc1 or later)
        request_module = get_ksymaddr("__request_module")
        if request_module:
            res = gdb.execute("x/30i {:#x}".format(request_module), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"BYTE PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"BYTE PTR ds:(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"ldrb\s+\S+,\s*\[\S+,\s*#(\d+)\]", line)
                        if m:
                            return base + int(m.group(1), 0)
            elif is_arm32():
                addr = 0
                for line in res.splitlines():
                    m = re.search(r"movw.*;\s*(0x\S+)", line)
                    if m:
                        addr_high = addr & 0xffff0000
                        addr = addr_high | int(m.group(1), 16)
                        continue
                    m = re.search(r"movt.*;\s*(0x\S+)", line)
                    if m:
                        addr_low = addr & 0xffff
                        addr = (int(m.group(1), 16) << 16) | addr_low
                        continue
                    if "ldrb" in line:
                        return addr
        return None

    @staticmethod
    def get_poweroff_cmd():
        # plan 1 (directly)
        poweroff_cmd = get_ksymaddr("poweroff_cmd")
        if poweroff_cmd:
            return poweroff_cmd

        # plan 2 (available v4.1-rc1 or later)
        poweroff_work_func = get_ksymaddr("poweroff_work_func")
        if poweroff_work_func:
            res = gdb.execute("x/20i {:#x}".format(poweroff_work_func), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"mov\s+rdi\s*,\s*(0x\w+)", line) # search run_cmd
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
                for line in res.splitlines():
                    m = re.search(r"mov\s+rsi\s*,\s*(0x\w+)", line) # search argv_split
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"mov\s+e[a-d]x\s*,\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                bases = {}
                add1time = {}
                for line in res.splitlines():
                    m = re.search(r"adrp\s+(\S+),\s*(0x\S+)", line)
                    if m:
                        reg = m.group(1)
                        base = int(m.group(2), 16)
                        bases[reg] = base
                        continue
                    m = re.search(r"add\s+(\S+),\s*(\S+),\s*#(0x\w+)", line)
                    if m:
                        dstreg = m.group(1)
                        srcreg = m.group(2)
                        v = int(m.group(3), 16)
                        if srcreg in add1time:
                            return add1time[srcreg] + v
                        if srcreg in bases:
                            add1time[dstreg] = bases[srcreg] + v
                            continue
            elif is_arm32():
                addr = 0
                for line in res.splitlines():
                    m = re.search(r"ldr.*;\s*(0x\S+)", line)
                    if m:
                        addr = int(m.group(1), 16)
                        try:
                            return read_int_from_memory(addr)
                        except Exception:
                            pass
        return None

    @staticmethod
    def get_reboot_cmd():
        # plan 1 (directly)
        reboot_cmd = get_ksymaddr("reboot_cmd")
        if reboot_cmd:
            return reboot_cmd

        # plan 2 (available v4.1-rc1 or later)
        reboot_work_func = get_ksymaddr("reboot_work_func")
        if reboot_work_func:
            res = gdb.execute("x/10i {:#x}".format(reboot_work_func), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"mov\s+rdi\s*,\s*(0x\w+)", line) # search run_cmd
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
                for line in res.splitlines():
                    m = re.search(r"mov\s+rsi\s*,\s*(0x\w+)", line) # search argv_split
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"mov\s+e[a-d]x\s*,\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                        if m:
                            return base + int(m.group(1), 16)
            elif is_arm32():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"movw.*;\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"movt.*;\s*(0x\S+)", line)
                        if m:
                            return base + (int(m.group(1), 16) << 16)
        return None

    @staticmethod
    def get_core_pattern():
        # plan 1 (directly)
        core_pattern = get_ksymaddr("core_pattern")
        if core_pattern:
            return core_pattern

        # plan 2 (available v3.6-rc1 or later)
        validate_coredump_safety = get_ksymaddr("validate_coredump_safety.part.0")
        if validate_coredump_safety:
            res = gdb.execute("x/10i {:#x}".format(validate_coredump_safety), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"BYTE PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"BYTE PTR ds:(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"ldrb\s+\S+,\s*\[\S+,\s*#(\d+)\]", line)
                        if m:
                            return base + int(m.group(1), 0)
            elif is_arm32():
                addr = 0
                for line in res.splitlines():
                    m = re.search(r"movw.*;\s*(0x\S+)", line)
                    if m:
                        addr_high = addr & 0xffff0000
                        addr = addr_high | int(m.group(1), 16)
                        continue
                    m = re.search(r"movt.*;\s*(0x\S+)", line)
                    if m:
                        addr_low = addr & 0xffff
                        addr = (int(m.group(1), 16) << 16) | addr_low
                        continue
                    if "ldrb" in line:
                        return addr

        # plan 3 (available v3.6-rc1 or later)
        proc_dostring_coredump = get_ksymaddr("proc_dostring_coredump")
        if proc_dostring_coredump:
            res = gdb.execute("x/50i {:#x}".format(proc_dostring_coredump), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"BYTE PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"BYTE PTR ds:(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                    if m:
                        base = int(m.group(1), 16)
                        continue
                    if base:
                        m = re.search(r"ldrb\s+\S+,\s*\[\S+,\s*#(\d+)\]", line)
                        if m:
                            return base + int(m.group(1), 0)
            elif is_arm32():
                addr = 0
                for line in res.splitlines():
                    m = re.search(r"movw.*;\s*(0x\S+)", line)
                    if m:
                        addr_high = addr & 0xffff0000
                        addr = addr_high | int(m.group(1), 16)
                        continue
                    m = re.search(r"movt.*;\s*(0x\S+)", line)
                    if m:
                        addr_low = addr & 0xffff
                        addr = (int(m.group(1), 16) << 16) | addr_low
                        continue
                    if "ldrb" in line:
                        return addr
        return None

    @staticmethod
    def get_n_tty_ops():
        # plan 1 (directly)
        n_tty_ops = get_ksymaddr("n_tty_ops")
        if n_tty_ops:
            return n_tty_ops

        # plan 2 (available v4.6-rc1 or later)
        n_tty_inherit_ops = get_ksymaddr("n_tty_inherit_ops")
        if n_tty_inherit_ops:
            res = gdb.execute("x/20i {:#x}".format(n_tty_inherit_ops), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"mov\s+r\S+,\s*(0x\S+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r",\s*DWORD PTR \[.*([+-]0x\S+)\]", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
                for line in res.splitlines():
                    m = re.search(r"mov\s+\S+,\s*(0x[0-9a-f]{8})", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                        if m:
                            return base + int(m.group(1), 0)
            elif is_arm32():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"movw.*;\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"movt.*;\s*(0x\S+)", line)
                        if m:
                            return base + (int(m.group(1), 16) << 16)
        return None

    @staticmethod
    def get_tty_ldiscs():
        # plan 1 (directly)
        tty_ldiscs = get_ksymaddr("tty_ldiscs")
        if tty_ldiscs:
            return tty_ldiscs

        # plan 2 (available v2.6.37-rc2 or later)
        tty_register_ldisc = get_ksymaddr("tty_register_ldisc")
        if tty_register_ldisc:
            res = gdb.execute("x/20i {:#x}".format(tty_register_ldisc), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"QWORD PTR \[.*\*8([-+]0x\S+)\]", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"DWORD PTR \[.*\*4([+-]0x\S+)\]", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                        if m:
                            return base + int(m.group(1), 0) + 8
            elif is_arm32():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"movw.*;\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"movt.*;\s*(0x\S+)", line)
                        if m:
                            return base + (int(m.group(1), 16) << 16) + 4
        return None

    @staticmethod
    def get_mmap_min_addr():
        # plan 1 (directly)
        mmap_min_addr = get_ksymaddr("mmap_min_addr")
        if mmap_min_addr:
            return mmap_min_addr

        # plan 2 (available v4.19.27 or later)
        expand_downwards = get_ksymaddr("expand_downwards")
        if expand_downwards:
            res = gdb.execute("x/20i {:#x}".format(expand_downwards), to_string=True)
            if is_x86_64():
                for line in res.splitlines():
                    m = re.search(r"QWORD PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffffffffffff
                        if v != 0:
                            return v
            elif is_x86_32():
                for line in res.splitlines():
                    m = re.search(r"ds:(0x\w+)", line)
                    if m:
                        v = int(m.group(1), 16) & 0xffffffff
                        if v != 0:
                            return v
            elif is_arm64():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"ldr\s+\S+,\s*\[\S+,\s*#(\d+)\]", line)
                        if m:
                            return base + int(m.group(1), 0)
            elif is_arm32():
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"movw.*;\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"movt.*;\s*(0x\S+)", line)
                        if m:
                            return base + (int(m.group(1), 16) << 16)
        return None

    @staticmethod
    def get_vdso_info():
        # plan 1 (directly)
        vdso_info = get_ksymaddr("vdso_info")
        if vdso_info:
            return vdso_info

        # plan 2 (available v5.3-rc1 or later)
        if is_arm64():
            vdso_init = get_ksymaddr("__vdso_init")
            if vdso_init:
                res = gdb.execute("x/20i {:#x}".format(vdso_init), to_string=True)
                base = None
                for line in res.splitlines():
                    if base is None:
                        m = re.search(r"adrp\s+\S+,\s*(0x\S+)", line)
                        if m:
                            base = int(m.group(1), 16)
                    else:
                        m = re.search(r"add\s+\S+,\s*\S+,\s*#(0x\S+)", line)
                        if m:
                            return base + int(m.group(1), 0)
        return None


@register_command
class KernelbaseCommand(GenericCommand):
    """Show kernel base address."""
    _cmdline_ = "kbase"
    _syntax_ = _cmdline_
    _category_ = "Qemu-system Cooperation"

    @staticmethod
    @functools.lru_cache()
    def get_maps():
        maps = []
        res = get_maps_by_pagewalk("pagewalk -q --simple")
        res = sorted(set(res.splitlines()))
        res = list(filter(lambda line: line.endswith("]"), res))
        res = list(filter(lambda line: "[+]" not in line, res))
        res = list(filter(lambda line: "*" not in line, res))

        if is_x86():
            for line in res:
                line = line.split()
                if line[6] != "KERN":
                    continue
                vaddr = int(line[0].split("-")[0], 16)
                size = int(line[2], 16)
                perm = line[5][1:] # [xxx
                maps.append([vaddr, size, perm])

        elif is_arm32():
            for line in res:
                line = line.split()
                if line[5] != "[PL0/---":
                    continue
                vaddr = int(line[0].split("-")[0], 16)
                size = int(line[2], 16)
                perm = line[6][4:7] # PL1/xxx
                maps.append([vaddr, size, perm])

        elif is_arm64():
            for line in res:
                line = line.split()
                if line[5] != "[EL0/---":
                    continue
                vaddr = int(line[0].split("-")[0], 16)
                size = int(line[2], 16)
                perm = line[6][4:7] # EL1/xxx
                maps.append([vaddr, size, perm])

        if maps == []:
            if is_x86():
                warn("Make sure you are in ring0 (=kernel mode)")
            elif is_arm32():
                warn("Make sure you are in supervisor mode (=kernel mode)")
                warn("Make sure qemu 3.x or higher")
            elif is_arm64():
                warn("Make sure you are in EL1 (=kernel mode)")
                warn("Make sure qemu 3.x or higher")
            return None
        else:
            return maps

    @staticmethod
    def get_kernel_base():
        dic = {
            "maps": KernelbaseCommand.get_maps(),
            "kbase": None,
            "kbase_size": None,
            "krobase": None,
            "krobase_size": None,
            "krwbase": None,
            "krwbase_size": None,
        }

        # maps is not found, so fast return
        if dic["maps"] is None:
            return dic

        # search kbase
        for i, (vaddr, size, perm) in enumerate(dic["maps"]):
            if perm == "R-X" and size >= 0x100000:
                dic["kbase"] = vaddr
                dic["kbase_size"] = size
                maps_after_kbase = dic["maps"][i + 1:]
                break
        else:
            # not found, maybe old kernel
            for i, (vaddr, size, perm) in enumerate(dic["maps"]):
                if perm == "RWX" and size >= 0x100000:
                    dic["kbase"] = vaddr
                    dic["kbase_size"] = size
                    maps_after_kbase = dic["maps"][i + 1:]
                    break
            else:
                # Not found, so fast return
                return dic

        # search kernel RO base - logic 1
        for i, (vaddr, size, perm) in enumerate(maps_after_kbase):
            if perm == "R--":
                if dic["krobase"] is None:
                    if size > 0x1000: # ignore ranges that are too small
                        dic["krobase"] = vaddr
                        dic["krobase_size"] = size
                        maps_after_krobase = maps_after_kbase[i + 1:]
                elif dic["krobase"] + dic["krobase_size"] == vaddr:
                    dic["krobase_size"] += size # merge contiguous region
                    maps_after_krobase = maps_after_kbase[i + 1:]
                else:
                    break

        # search kernel RO base - logic 2
        if dic["krobase"] is None:
            # maybe old kernel (no-NX)
            # Detected kbase(R-X) range already includes rodata, so use heuristic search
            #    [  .text  ] <- maybe .text is larger than 0x3000 (it fails in certain cases if 0x2000)
            #    [  .text  ]
            #    [  .text  ]
            #    [  .text  ] <- end of this area has [0x00, 0x00, 0x00, ...]
            #    [  .rodata  ]
            #    [  .rodata  ]
            #    [  .rodata  ]
            start = dic["kbase"] + gef_getpagesize() * 3
            end = dic["kbase"] + dic["kbase_size"]
            for addr in range(start, end, gef_getpagesize()):
                data = read_memory(addr - 0x20, 0x20)
                if data == b"\0" * 0x20:
                    dic["krobase"] = addr
                    dic["krobase_size"] = end - dic["krobase"]
                    dic["kbase_size"] -= dic["krobase_size"]
                    maps_after_krobase = maps_after_kbase
                    break
            else:
                return dic

        # search kernel RW base
        def search_perm(target_perm):
            rw = None
            for vaddr, size, perm in maps_after_krobase:
                if perm == target_perm:
                    if rw is None:
                        if size > 0x1000:
                            rw = [vaddr, size]
                    elif rw[0] + rw[1] == vaddr:
                        rw = [rw[0], rw[1] + size] # merge contiguous region
            return rw

        res = search_perm("RW-")
        if res:
            dic["krwbase"] = res[0]
            dic["krwbase_size"] = res[1]
        else:
            res = search_perm("RWX") # old x86/arm kernel
            if res:
                dic["krwbase"] = res[0]
                dic["krwbase_size"] = res[1]
            else:
                # Not found
                pass

        return dic

    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        # resolve kbase, krobase
        info("Wait for memory scan")
        dic = self.get_kernel_base()
        if None in dic.values():
            err("Failed to resolve")
            return
        gef_print(titlify("Kernel base (heuristic)"))
        gef_print("kernel text:   {:#x} ({:#x} bytes)".format(dic["kbase"], dic["kbase_size"]))
        gef_print("kernel rodata: {:#x} ({:#x} bytes)".format(dic["krobase"], dic["krobase_size"]))
        gef_print("kernel data:   {:#x} ({:#x} bytes)".format(dic["krwbase"], dic["krwbase_size"]))
        return


@register_command
class KernelVersionCommand(GenericCommand):
    """Display kernel version string under qemu-system."""
    _cmdline_ = "kversion"
    _syntax_ = "{:s}".format(_cmdline_)
    _example_ = "{:s}".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    def kernel_version(self):
        info("Wait for memory scan")
        dic = KernelbaseCommand.get_kernel_base()
        if None in dic.values():
            err("Failed to resolve")
            return None

        # resolve area
        area = []
        for addr in dic["maps"]:
            if addr[0] < dic["kbase"]:
                continue
            if addr[0] >= dic["krwbase"]:
                continue
            area.append([addr[0], addr[0] + addr[1]])
        if area == []:
            return None

        for start, end in area:
            try:
                data = read_memory(start, end - start)
            except gdb.MemoryError:
                continue
            data = ''.join([chr(x) for x in data])
            r = re.findall(r"(Linux version (?:\d+\.[\d.]*\d)[ -~]+)", data)
            if not r:
                continue
            kernel_version_string = r[0]
            idx = data.find(kernel_version_string)
            return start + idx, kernel_version_string
        return None

    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        ret = self.kernel_version()
        if ret is None:
            err("Parse failed")
            return
        addr, kernel_version_string = ret
        gef_print(titlify("Kernel version (heuristic)"))
        gef_print("{:#x}: {:s}".format(addr, kernel_version_string))
        return


@register_command
class KernelCmdlineCommand(GenericCommand):
    """Display kernel cmdline string under qemu-system."""
    _cmdline_ = "kcmdline"
    _syntax_ = "{:s}".format(_cmdline_)
    _example_ = "{:s}".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    def kernel_cmdline(self):
        saved_command_line = KernelAddressHeuristicFinder.get_saved_command_line()
        if saved_command_line is None:
            return None
        try:
            ptr = read_int_from_memory(saved_command_line)
            cmdline = read_cstring_from_memory(ptr)
            return ptr, cmdline
        except Exception:
            return None

    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        info("Wait for memory scan")

        ret = self.kernel_cmdline()
        if ret is None:
            err("Parse failed")
            return
        addr, kernel_cmdline_string = ret
        gef_print(titlify("Kernel cmdline (heuristic)"))
        gef_print("{:#x}: '{:s}'".format(addr, kernel_cmdline_string))
        return


@register_command
class KernelTaskCommand(GenericCommand):
    """Display process list under qemu-system."""
    _cmdline_ = "ktask"
    _syntax_ = "{:s}".format(_cmdline_)
    _example_ = "{:s}".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    def get_task_list(self):
        init_task = KernelAddressHeuristicFinder.get_init_task()
        if init_task is None:
            err("Not found symbol")
            return None
        gef_print(titlify("Kernel tasks (heuristic)"))
        info("init_task: {:#x}".format(init_task))

        # search init_task->tasks
        for i in range(0x200):
            offset_tasks = i * current_arch.ptrsize
            pos = init_task + offset_tasks
            value_list = [pos]
            # validating candidate offset
            while True:
                # read check
                try:
                    pos = read_int_from_memory(pos)
                except Exception: # memory read error
                    found = False
                    break
                # list validate
                if pos in value_list[1:]: # incomplete infinity loop detected
                    found = False
                    break
                if pos == value_list[0] and len(value_list) == 1: # self reference
                    found = False
                    break
                if pos == value_list[0] and len(value_list) > 1: # maybe link list
                    found = True
                    break
                value_list.append(pos)
            if found:
                info("offsetof(task_struct, tasks): {:#x}".format(offset_tasks))
                info("Number of tasks: {:d}".format(len(value_list)))
                return [x - offset_tasks for x in value_list]
        err("Not found init_task->tasks")
        return None

    def get_offset_comm(self, task_addrs):
        for i in range(0x300):
            offset_comm = i * current_arch.ptrsize
            valid = True
            for task in task_addrs:
                if not is_ascii_string(task + offset_comm):
                    valid = False
                    break
                s = read_cstring_from_memory(task + offset_comm)
                if s == "swapper/0": # Very common name, so for speeding up, we assume that offset is found
                    break
                if len(s) < 2:
                    valid = False
                    break
            if valid:
                info("offsetof(task_struct, comm): {:#x}".format(offset_comm))
                return offset_comm
        err("Not found task->comm[TASK_CMM_LEN]")
        return None

    def get_offset_cred(self, task_addrs, offset_comm):
        """
        struct task_struct {
        ...
            const struct cred __rcu        *real_cred;    // These may point to the same address
            const struct cred __rcu        *cred;         // These may point to the same address
        #ifdef CONFIG_KEYS
            struct key                     *cached_requested_key;
        #endif
            char                           comm[TASK_COMM_LEN];
        """
        # backward search from `comm`
        for i in range(0x100):
            offset_cred = offset_comm - ((i + 1) * current_arch.ptrsize)
            for task in task_addrs:
                val1 = read_int_from_memory(task + offset_cred)
                val2 = read_int_from_memory(task + offset_cred - current_arch.ptrsize)
                if val1 == val2 and val1 != 0:
                    info("offsetof(task_struct, cred): {:#x}".format(offset_cred))
                    return offset_cred
        err("Not found task->cred")
        return None

    def get_offset_uid(self, init_task_cred_ptr):
        """
        struct cred {
            atomic_t    usage;
        #ifdef CONFIG_DEBUG_CREDENTIALS
            atomic_t    subscribers;    /* number of processes subscribed */
            void        *put_addr;
            unsigned    magic;
        #endif
            kuid_t        uid;         /* real UID of the task */
            kgid_t        gid;         /* real GID of the task */
            kuid_t        suid;        /* saved UID of the task */
            kgid_t        sgid;        /* saved GID of the task */
            kuid_t        euid;        /* effective UID of the task */
            kgid_t        egid;        /* effective GID of the task */
            kuid_t        fsuid;       /* UID for VFS ops */
            kgid_t        fsgid;       /* GID for VFS ops */
            unsigned    securebits;    /* SUID-less security management */
            kernel_cap_t    cap_inheritable; /* caps our children can inherit */
            kernel_cap_t    cap_permitted;    /* caps we're permitted */

        [Example x64]
            0xffffffff820460c0:     0x0000000000000004      0x0000000000000000
            0xffffffff820460d0:     0x0000000000000000      0x0000000000000000
            0xffffffff820460e0:     0x0000000000000000      0x0000000000000000
            0xffffffff820460f0:     0x0000003fffffffff      0x0000003fffffffff
            0xffffffff82046100:     0x0000003fffffffff      0x0000000000000000
            0xffffffff82046110:     0x0000000000000000      0x0000000000000000
        """
        init_task_cred = read_int_from_memory(init_task_cred_ptr)
        uid_gid_size = 4 * 8 # uid_t:4byte. len([uid,gid,suid,sgid,euid,egid,fsuid,fsgid]) == 8
        offset_uid = 4
        ret = read_memory(init_task_cred + offset_uid, uid_gid_size)
        if ret == b"\0" * uid_gid_size:
            pass
        else:
            offset_uid += 4 + current_arch.ptrsize + 4
        info("offsetof(cred, uid): {:#x}".format(offset_uid))
        return offset_uid

    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        info("Wait for memory scan")

        task_addrs = self.get_task_list()
        if task_addrs is None:
            return

        offset_comm = self.get_offset_comm(task_addrs)
        if offset_comm is None:
            return

        offset_cred = self.get_offset_cred(task_addrs, offset_comm)
        if offset_cred is None:
            return

        offset_uid = self.get_offset_uid(task_addrs[0] + offset_cred)
        if offset_uid is None:
            return

        ids_str = ','.join(["uid", "gid", "suid", "sgid", "euid", "egid", "fsuid", "fsgid"])
        fmt = "{:<18s}: {:<16s} {:<18s} [{}]"
        legend = ["task", "task->comm", "task->cred", ids_str]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        for task in task_addrs:
            comm_string = read_cstring_from_memory(task + offset_comm)
            cred = read_int_from_memory(task + offset_cred)
            uids = [u32(read_memory(cred + offset_uid + j * 4, 4)) for j in range(8)]
            gef_print("{:#018x}: {:<16s} {:#018x} {}".format(task, comm_string, cred, uids))
        return


@register_command
class KernelModuleCommand(GenericCommand):
    """Display module list under qemu-system."""
    _cmdline_ = "kmod"
    _syntax_ = "{:s}".format(_cmdline_)
    _example_ = "{:s}".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    def get_modules_list(self):
        modules = KernelAddressHeuristicFinder.get_modules()
        if modules is None:
            err("Not found symbol")
            return None
        gef_print(titlify("Kernel modules (heuristic)"))
        info("modules: {:#x}".format(modules))

        module_addrs = []
        current = modules
        while True:
            addr = read_int_from_memory(current)
            if addr == modules:
                break
            module_addrs.append(addr)
            current = addr
        return module_addrs

    def get_offset_name(self, module_addrs):
        for i in range(0x100):
            offset_name = i * current_arch.ptrsize
            valid = True
            for module in module_addrs:
                if not is_ascii_string(module + offset_name):
                    valid = False
                    break
                s = read_cstring_from_memory(module + offset_name)
                if len(s) < 2:
                    valid = False
                    break
            if valid:
                info("offsetof(module, name): {:#x}".format(offset_name))
                return offset_name
        err("Not found module->name[MODULE_NAME_LEN]]")
        return None

    def get_offset_layout(self, module_addrs):
        """
            struct module {
                enum module_state state;
                /* Member of list of modules */
                struct list_head list;
                /* Unique handle for this module */
                char name[MODULE_NAME_LEN];
            #ifdef CONFIG_STACKTRACE_BUILD_ID
                /* Module build ID */
                unsigned char build_id[BUILD_ID_SIZE_MAX];
            #endif
                /* Sysfs stuff. */
                struct module_kobject mkobj;
                struct module_attribute *modinfo_attrs;
                const char *version;
                const char *srcversion;
                struct kobject *holders_dir;
                /* Exported symbols */
                const struct kernel_symbol *syms;
                const s32 *crcs;
                unsigned int num_syms;
            #ifdef CONFIG_CFI_CLANG
                cfi_check_fn cfi_check;
            #endif
                /* Kernel parameters. */
            #ifdef CONFIG_SYSFS
                struct mutex param_lock;
            #endif
                struct kernel_param *kp;
                unsigned int num_kp;
                /* GPL-only exported symbols. */
                unsigned int num_gpl_syms;
                const struct kernel_symbol *gpl_syms;
                const s32 *gpl_crcs;
                bool using_gplonly_symbols;
            #ifdef CONFIG_MODULE_SIG
                /* Signature was verified. */
                bool sig_ok;
            #endif
                bool async_probe_requested;
                /* Exception table */
                unsigned int num_exentries;
                struct exception_table_entry *extable;
                /* Startup function. */
                int (*init)(void);
                /* Core layout: rbtree is accessed frequently, so keep together. */
                struct module_layout core_layout __module_layout_align;
                struct module_layout init_layout;
                ...
        }

        struct module_layout {
            /* The actual code + data. */
            void *base;
            /* Total size. */
            unsigned int size;
            /* The size of the executable code.  */
            unsigned int text_size;
            /* Size of RO section of the module (text+rodata) */
            unsigned int ro_size;
            /* Size of RO after init section */
            unsigned int ro_after_init_size;
        #ifdef CONFIG_MODULES_TREE_LOOKUP
            struct mod_tree_node mtn;
        #endif
        };

        [Example arm32]
            gef> x/128xw 0x00000000bf22b084
            0xbf22b084:     0xbf1bb044      0xc1696530      0x00006773      0x00000000
            0xbf22b094:     0x00000000      0x00000000      0x00000000      0x00000000
            0xbf22b0a4:     0x00000000      0x00000000      0x00000000      0x00000000
            0xbf22b0b4:     0x00000000      0x00000000      0x00000000      0x00000000
            0xbf22b0c4:     0x00000000      0xc1ec2d00      0xc1a11d80      0xbf1bb08c
            0xbf22b0d4:     0xc1a11d8c      0xc1a11d80      0xc1628e38      0xc8e0b2c0
            0xbf22b0e4:     0x00000003      0x00000007      0xbf22b080      0x00000000
            0xbf22b0f4:     0xc8d4f380      0x00000000      0xc1e47400      0xc8f6d900
            0xbf22b104:     0xc8f6d080      0xc8004300      0x00000000      0x00000000
            0xbf22b114:     0x00000000      0x00000000      0x00000000      0x00000000
            0xbf22b124:     0xbf22b124      0xbf22b124      0xbf22a990      0x00000003
            0xbf22b134:     0x00000000      0x00000000      0x00000000      0x00000001
            0xbf22b144:     0x00000000      0x00000000      0x00000000      0x00000000
            0xbf22b154:     0x00000000      0xbf17e000      0x00000000      0x00000000
            0xbf22b164:     0x00000000      0x00000000      0x00000000      0x00000000
            0xbf22b174:     0x00000000      0x00000000      0x00000000      0xbf225000 <- init_layout.base
            0xbf22b184:     0x00008000      0x00005000      0x00006000      0x00006000
        """
        for i in range(300):
            offset_layout = i * current_arch.ptrsize
            valid = True
            for module in module_addrs:
                # base align check
                cand_base = read_int_from_memory(module + offset_layout)
                if cand_base == 0 or cand_base & 0xfff:
                    valid = False
                    break
                # size align check
                cand_size = u32(read_memory(module + offset_layout + current_arch.ptrsize + 4 * 0, 4))
                if cand_size == 0 or cand_size & 0xfff:
                    valid = False
                    break
                # text_size align check
                cand_text_size = u32(read_memory(module + offset_layout + current_arch.ptrsize + 4 * 1, 4))
                if cand_text_size == 0 or cand_text_size & 0xfff:
                    valid = False
                    break
                # ro_size align check
                cand_ro_size = u32(read_memory(module + offset_layout + current_arch.ptrsize + 4 * 2, 4))
                if cand_ro_size == 0 or cand_ro_size & 0xfff:
                    valid = False
                    break
                # ro_after_init_size align check
                cand_ro_after_init_size = u32(read_memory(module + offset_layout + current_arch.ptrsize + 4 * 3, 4))
                if cand_ro_after_init_size == 0 or cand_ro_after_init_size & 0xfff:
                    valid = False
                    break
            if valid:
                info("offsetof(module, init_layout): {:#x}".format(offset_layout))
                return offset_layout
        err("Not found module->init_layout")
        return None

    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        info("Wait for memory scan")

        module_addrs = self.get_modules_list()
        if module_addrs is None:
            return

        offset_name = self.get_offset_name(module_addrs)
        if offset_name is None:
            return

        offset_layout = self.get_offset_layout(module_addrs)
        if offset_layout is None:
            return

        fmt = "{:<18s}: {:<18s} {:<18s} {:<18s}"
        legend = ["module", "module->name", "base", "size"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        for module in module_addrs:
            name_string = read_cstring_from_memory(module + offset_name)
            base = read_int_from_memory(module + offset_layout)
            size = u32(read_memory(module + offset_layout + 4, 4))
            gef_print("{:#018x}: {:<18s} {:#018x} {:#018x}".format(module, name_string, base, size))
        return


@register_command
class KernelCharacterDevicesCommand(GenericCommand):
    """Display character device list under qemu-system."""
    _cmdline_ = "kcdev"
    _syntax_ = "{:s}".format(_cmdline_)
    _example_ = "{:s}".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    # character device is managed at chrdevs[] and cdev_map.
    # we use each of them for getting structure information.

    def get_chrdev_list(self): # [chrdev, chrdev, chrdev, ...]
        """
        #define CHRDEV_MAJOR_HASH_SIZE 255
        static struct char_device_struct {
            struct char_device_struct *next;
            unsigned int major;
            unsigned int baseminor;
            int minorct;
            char name[64];
            struct cdev *cdev;		/* will die */
        } *chrdevs[CHRDEV_MAJOR_HASH_SIZE];
        """
        chrdevs = KernelAddressHeuristicFinder.get_chrdevs()
        if chrdevs is None:
            err("Not found symbol")
            return None
        gef_print(titlify("Kernel character devices (heuristic)"))
        info("chrdevs: {:#x}".format(chrdevs))

        chrdev_addrs = []
        for i in range(255):
            addr = read_int_from_memory(chrdevs + i * current_arch.ptrsize)
            while addr and addr not in chrdev_addrs:
                chrdev_addrs.append(addr)
                addr = read_int_from_memory(addr)
        return chrdev_addrs

    def get_cdev_list(self): # [[cdev, major, minor], [...] ...]
        """
        struct kobj_map {
            struct probe {
                struct probe *next;
                dev_t dev;
                unsigned long range;
                struct module *owner;
                kobj_probe_t *get;
                int (*lock)(dev_t, void *);
                void *data;                  // -> cdev
            } *probes[255];
            struct mutex *lock;
        };
        static struct kobj_map *cdev_map;

        struct cdev {
            struct kobject kobj;
            struct module *owner;
            const struct file_operations *ops;
            struct list_head list;
            dev_t dev;
            unsigned int count;
        } __randomize_layout;

        struct kobject {
            const char *name;
            struct list_head entry;
            struct kobject *parent;
            struct kset *kset;
            const struct kobj_type *ktype;
            struct kernfs_node *sd; /* sysfs directory entry */
            struct kref kref;
        #ifdef CONFIG_DEBUG_KOBJECT_RELEASE
            struct delayed_work release;
        #endif
            unsigned int state_initialized:1;
            unsigned int state_in_sysfs:1;
            unsigned int state_add_uevent_sent:1;
            unsigned int state_remove_uevent_sent:1;
            unsigned int uevent_suppress:1;
        };
        """
        cdev_map = KernelAddressHeuristicFinder.get_cdev_map()
        if cdev_map is None:
            err("Not found symbol")
            return None
        info("cdev_map: {:#x}".format(cdev_map))

        try:
            cdev_map_ = read_int_from_memory(cdev_map)
            info("*cdev_map: {:#x}".format(cdev_map_))
        except Exception:
            err("cdev_map is not initialized")
            return None

        cdev_addrs = []
        seen = []
        for i in range(255):
            addr = read_int_from_memory(cdev_map_ + i * current_arch.ptrsize)
            while addr:
                cdev = read_int_from_memory(addr + 6 * current_arch.ptrsize)
                dev = u32(read_memory(addr + current_arch.ptrsize, 4))
                major = dev >> 20
                minor = dev & ((1 << 20) - 1)
                if cdev and cdev not in seen:
                    cdev_addrs.append([cdev, major, minor])
                    seen.append(cdev)
                addr = read_int_from_memory(addr)
        return cdev_addrs

    def get_offset_ops(self, cdevs):
        for i in range(3, 0x20):
            offset_list = i * current_arch.ptrsize
            valid = True
            for cdev in cdevs:
                pos_next = cdev + offset_list
                pos_prev = cdev + offset_list + current_arch.ptrsize
                list_entry_next = [pos_next]
                list_entry_prev = [pos_prev]
                while valid:
                    # read check
                    try:
                        pos_next = read_int_from_memory(pos_next)
                        pos_prev = read_int_from_memory(pos_prev) + current_arch.ptrsize
                    except Exception: # memory read error
                        valid = False
                        break
                    # list validate
                    if pos_next in list_entry_next[1:]: # incomplete infinity loop detected
                        valid = False
                        break
                    if pos_prev in list_entry_prev[1:]: # incomplete infinity loop detected
                        valid = False
                        break
                    if pos_next == list_entry_next[0] and pos_prev == list_entry_prev[0]:
                        break
                    list_entry_next.append(pos_next)
                    list_entry_prev.append(pos_prev)
                if not valid:
                    break
            else:
                # for loop is finished until last element
                if valid:
                    offset_ops = offset_list - current_arch.ptrsize
                    info("offsetof(cdev, ops): {:#x}".format(offset_ops))
                    return offset_ops
        err("Not found offsetof(cdev, ops)")
        return None

    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        info("Wait for memory scan")

        chrdev_addrs = self.get_chrdev_list()
        if chrdev_addrs is None:
            return
        cdev_addrs = self.get_cdev_list()
        if cdev_addrs is None:
            return

        # merge chrdev (from chrdevs)
        merged = {}
        for chrdev in chrdev_addrs:
            major = u32(read_memory(chrdev + current_arch.ptrsize, 4))
            minor = u32(read_memory(chrdev + current_arch.ptrsize + 4, 4))
            name_string = read_cstring_from_memory(chrdev + current_arch.ptrsize + 4 * 3) or "<None>"
            off = chrdev + current_arch.ptrsize + 4 * 3 + 64
            while off % current_arch.ptrsize: # align
                off += 1
            cdev = read_int_from_memory(off)
            merged[major, minor] = {"chrdev": chrdev, "name": name_string, "cdev": cdev}

        # merge cdev (from cdev_map)
        for cdev, major, minor in cdev_addrs:
            kobj = read_int_from_memory(cdev)
            name_string = read_cstring_from_memory(kobj) or "<None>"

            if (major, minor) in merged:
                if merged[major, minor]["cdev"] == 0:
                    merged[major, minor]["cdev"] = cdev
                if merged[major, minor]["name"] == "<None>":
                    merged[major, minor]["name"] = name_string
            else:
                merged[major, minor] = {"chrdev": 0x0, "name": name_string, "cdev": cdev}

        # add ops info
        off_ops = self.get_offset_ops([v["cdev"] for k, v in merged.items() if v["cdev"]])
        if off_ops is None:
            return
        for k in merged.keys():
            if merged[k]["cdev"]:
                merged[k]["ops"] = read_int_from_memory(merged[k]["cdev"] + off_ops)
            else:
                merged[k]["ops"] = 0x0
            merged[k]["ops_sym"] = get_symbol_string(merged[k]["ops"])

        # add parent info
        for k in merged.keys():
            if merged[k]["cdev"]:
                parent = read_int_from_memory(merged[k]["cdev"] + current_arch.ptrsize * 3)
                merged[k]["parent"] = parent
                if parent:
                    name = read_int_from_memory(parent)
                    if name:
                        merged[k]["parent_name"] = read_cstring_from_memory(name) or "<None>"
                    else:
                        merged[k]["parent_name"] = "<None>"
                else:
                    merged[k]["parent_name"] = "<None>"
            else:
                merged[k]["parent"] = 0x0
                merged[k]["parent_name"] = "<None>"

        # print
        fmt = "{:<18s}: {:<18s} {:<6s} {:<6s} {:<18s} {:<18s} {:18s} {:<s}"
        legend = ["chrdev", "name", "major", "minor", "cdev", "cdev->kobj.parent", "parent_name", "cdev->ops"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        for (major, minor), m in sorted(merged.items()):
            fmt = "{:#018x}: {:<18s} {:<6d} {:<6d} {:#018x} {:#018x} {:<18s} {:#018x}{:s}"
            gef_print(fmt.format(m["chrdev"], m["name"], major, minor, m["cdev"], m["parent"], m["parent_name"], m["ops"], m["ops_sym"]))
        return


@register_command
class KernelFopsCommand(GenericCommand):
    """Display fops members under qemu-system."""
    _cmdline_ = "kfops"
    _syntax_ = "{:s} [ADDRESS]".format(_cmdline_)
    _example_ = "{:s}".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    def get_member(self):
        members = [
            ["ptr", "owner"],
            ["func_ptr", "llseek"],
            ["func_ptr", "read"],
            ["func_ptr", "write"],
            ["func_ptr", "read_iter"],
            ["func_ptr", "write_iter"],
            ["func_ptr", "iopoll"],
            ["func_ptr", "iterate"],
            ["func_ptr", "iterate_shared"],
            ["func_ptr", "poll"],
            ["func_ptr", "unlocked_ioctl"],
            ["func_ptr", "compat_ioctl"],
            ["func_ptr", "mmap"],
            ["ulong",    "mmap_supported_flags"],
            ["func_ptr", "open"],
            ["func_ptr", "flush"],
            ["func_ptr", "release"],
            ["func_ptr", "fsync"],
            ["func_ptr", "fasync"],
            ["func_ptr", "lock"],
            ["func_ptr", "sendpage"],
            ["func_ptr", "get_unmapped_area"],
            ["func_ptr", "check_flags"],
            ["func_ptr", "flock"],
            ["func_ptr", "splice_write"],
            ["func_ptr", "splice_read"],
            ["func_ptr", "setlease"],
            ["func_ptr", "fallocate"],
            ["func_ptr", "show_fdinfo"],
            ["(func_ptr)", "(mmap_capabilities)"], # only exists when CONFIG_MMU
            ["func_ptr", "copy_file_range"],
            ["func_ptr", "remap_file_range"],
            ["func_ptr", "fadvise"],
        ]
        return members

    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        members = self.get_member()

        if argv:
            try:
                addr = int(argv[0], 16)
                addrs = [read_int_from_memory(addr + current_arch.ptrsize * i) for i in range(len(members))]
            except Exception:
                self.usage()
                return
            fmt = "[{:3s}] {:<10s} {:<20s} {:s}"
            legend = ["idx", "type", "name", "value"]
            gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
            for idx, ((type, name), address) in enumerate(zip(members, addrs)):
                sym = get_symbol_string(address)
                gef_print("[{:3d}] {:10s} {:20s} {:#018x}{:s}".format(idx, type, name, address, sym))
        else:
            fmt = "[{:3s}] {:<10s} {:<20s}"
            legend = ["idx", "type", "name"]
            gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
            for idx, (type, name) in enumerate(members):
                gef_print("[{:3d}] {:10s} {:20s}".format(idx, type, name))
        return


@register_command
class SyscallTableViewCommand(GenericCommand):
    """Display syscall_table entries under qemu-system."""
    _cmdline_ = "syscall-table-view"
    _syntax_ = "{:s} [-h] [--filter REGEX]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s}\n".format(_cmdline_)
    _example_ += "{:s} --filter write".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    def syscall_table_view(self, sys_call_table_addr):
        if sys_call_table_addr is None:
            err("Not found symbol")
            return
        # scan
        i = 0
        seen = {}
        table = []
        while True:
            addr = sys_call_table_addr + i * current_arch.ptrsize
            try:
                syscall_function_addr = read_int_from_memory(addr)
            except gdb.MemoryError:
                break
            if is_x86() and syscall_function_addr % 0x10: # should be aligned
                break
            elif (is_arm32() or is_arm64()) and syscall_function_addr % 4: # should be aligned
                break
            try:
                read_int_from_memory(syscall_function_addr) # if entry is valid, no error
            except gdb.MemoryError:
                break
            symbol = get_symbol_string(syscall_function_addr, nosymbol_string=" <NO_SYMBOL>")
            seen[syscall_function_addr] = seen.get(syscall_function_addr, 0) + 1
            table.append([i, addr, syscall_function_addr, symbol])
            i += 1
        # print
        fmt = "{:5s} {:18s}: {:18s} {:s}"
        legend = ["Index", "Table Address", "Function Address", "Symbol"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        for i, addr, syscall_function_addr, symbol in table:
            if seen[syscall_function_addr] == 1: # valid entry
                msg = "[{:03d}] {:#018x}: {:#018x}{:s}".format(i, addr, syscall_function_addr, symbol)
            else: # invalid entry
                msg = "[{:03d}] {:#018x}: ".format(i, addr) + Color.grayify("{:#018x}{:s}".format(syscall_function_addr, symbol))
            if not self.filter:
                gef_print(msg)
            else:
                for filt in self.filter:
                    if re.search(filt, msg):
                        gef_print(msg)
        return

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64", "ARM32", "ARM64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        self.filter = []
        while "--filter" in argv:
            idx = argv.index("--filter")
            pattern = argv[idx + 1]
            self.filter.append(pattern)
            argv = argv[:idx] + argv[idx + 2:]

        if argv:
            self.usage()
            return

        if is_x86_32():
            gef_print(titlify("sys_call_table (x86)"))
            self.syscall_table_view(KernelAddressHeuristicFinder.get_sys_call_table_x86())
        elif is_x86_64():
            gef_print(titlify("sys_call_table (x64)"))
            self.syscall_table_view(KernelAddressHeuristicFinder.get_sys_call_table_x64())
            gef_print(titlify("ia32_sys_call_table"))
            self.syscall_table_view(KernelAddressHeuristicFinder.get_sys_call_table_x86())
            gef_print(titlify("x32_sys_call_table"))
            self.syscall_table_view(KernelAddressHeuristicFinder.get_sys_call_table_x32())
        elif is_arm32():
            gef_print(titlify("sys_call_table (arm32)"))
            self.syscall_table_view(KernelAddressHeuristicFinder.get_sys_call_table_arm32())
        elif is_arm64():
            gef_print(titlify("sys_call_table (arm64)"))
            self.syscall_table_view(KernelAddressHeuristicFinder.get_sys_call_table_arm64())
            gef_print(titlify("compat_sys_call_table (arm32)"))
            self.syscall_table_view(KernelAddressHeuristicFinder.get_sys_call_table_arm64_compat())
        return


@register_command
class AuxvCommand(GenericCommand):
    """Show ELF auxiliary vectors."""
    _cmdline_ = "auxv"
    _syntax_ = _cmdline_
    _category_ = "Process Information"

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        auxval = gef_get_auxiliary_values()
        if not auxval:
            return None

        gef_print(titlify("ELF auxiliary vector"))
        for k, v in auxval.items():
            for num, name in AT_CONSTANTS.items():
                if k == name:
                    break
            else:
                num = -1
            if k == "AT_NULL":
                gef_print("[{:#4x}] {:16s} {:#x} (End of vector)".format(num, k + ":", v))
            elif k in ["AT_EXECFN", "AT_PLATFORM"]:
                s = read_cstring_from_memory(v)
                gef_print("[{:#4x}] {:16s} {:#x}{:s}{}".format(num, k + ":", v, RIGHT_ARROW, Color.yellowify(repr(s))))
            elif k in ["AT_RANDOM"]:
                s = read_int_from_memory(v)
                gef_print("[{:#4x}] {:16s} {:#x}{:s}{:#x}".format(num, k + ":", v, RIGHT_ARROW, s))
            else:
                gef_print("[{:#4x}] {:16s} {:#x}".format(num, k + ":", v))
        return


@register_command
class ArgvCommand(GenericCommand):
    """Show argv."""
    _cmdline_ = "argv"
    _syntax_ = "{:s} [-v]".format(_cmdline_)
    _category_ = "Process Information"

    def get_address_from_symbol(self, symbol):
        try:
            return parse_address(symbol)
        except Exception:
            return None

    def print_from_mem(self, array, verbose):
        i = 0
        while True:
            addr = read_int_from_memory(array + i * current_arch.ptrsize)
            if addr == 0:
                break
            if not verbose and i > 99:
                gef_print("...")
                break
            s = read_cstring_from_memory(addr, gef_getpagesize())
            gef_print("[{:3d}]: {:#x}: {:#x}{:s}{:s}".format(i, array + i * current_arch.ptrsize, addr, RIGHT_ARROW, Color.yellowify(repr(s))))
            i += 1
        return

    def print_from_proc(self, filename, verbose):
        lines = open(filename).read()
        for i, elem in enumerate(lines.split("\0")):
            if not elem:
                break
            if not verbose and i > 99:
                gef_print("...")
                break
            gef_print("[{:3d}]: {:s}".format(i, repr(elem)))
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        verbose = (argv and argv[0] == "-v")

        paddr1 = self.get_address_from_symbol("&_dl_argv")
        addr1 = self.get_address_from_symbol("_dl_argv")
        if paddr1 and addr1:
            gef_print(titlify("ARGV from _dl_argv"))
            info("_dl_argv @ {:#x}".format(paddr1))
            self.print_from_mem(addr1, verbose)

        paddr2 = self.get_address_from_symbol("&__libc_argv")
        addr2 = self.get_address_from_symbol("__libc_argv")
        if paddr2 and addr2:
            gef_print(titlify("ARGV from __libc_argv"))
            info("__libc_argv @ {:#x}".format(paddr2))
            self.print_from_mem(addr2, verbose)

        if not is_remote_debug() or is_remote_but_same_host():
            gef_print(titlify("ARGV from /proc/{:d}/cmdline".format(get_pid())))
            self.print_from_proc("/proc/{:d}/cmdline".format(get_pid()), verbose)
        else:
            if not (paddr1 or paddr2):
                err("Not found argv")
        return


@register_command
class EnvpCommand(GenericCommand):
    """Show initial envp from __environ@ld, or modified envp from last_environ@libc."""
    _cmdline_ = "envp"
    _syntax_ = "{:s} [-h] [-v] [libc]".format(_cmdline_)
    _aliases_ = ["envs", "env"]
    _category_ = "Process Information"

    def get_address_from_symbol(self, symbol):
        try:
            return parse_address(symbol)
        except Exception:
            return None

    def print_from_mem(self, array, verbose):
        i = 0
        while True:
            pos = array + i * current_arch.ptrsize
            addr = read_int_from_memory(pos)
            if addr == 0:
                break
            if not verbose and i > 99:
                gef_print("...")
                break
            s = read_cstring_from_memory(addr, gef_getpagesize())
            gef_print("[{:3d}]: {:#x}: {:#x}{:s}{:s}".format(i, pos, addr, RIGHT_ARROW, Color.yellowify(repr(s))))
            i += 1
        return

    def print_from_proc(self, filename, verbose):
        lines = open(filename).read()
        for i, elem in enumerate(lines.split("\0")):
            if not elem:
                break
            if not verbose and i > 99:
                gef_print("...")
                break
            gef_print("[{:3d}]: {:s}".format(i, repr(elem)))
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        verbose = "-v" in argv

        if "libc" in argv:
            paddr = self.get_address_from_symbol("&last_environ")
            addr = self.get_address_from_symbol("last_environ")
            if paddr and addr:
                gef_print(titlify("ENVP from last_environ"))
                info("last_environ @ {:#x}".format(paddr))
                return self.print_from_mem(addr, verbose)
            else:
                if addr is None:
                    err("Not found last_environ")
                    return
                if addr == 0:
                    err("last_environ is 0x0")
                    return
        else:
            paddr = self.get_address_from_symbol("&__environ")
            addr = self.get_address_from_symbol("__environ")
            if paddr and addr:
                gef_print(titlify("ENVP from __environ"))
                info("__environ @ {:#x}".format(paddr))
                self.print_from_mem(addr, verbose)
                info("to see the result of putenv(), use `env libc`")
                return

            if not is_remote_debug() or is_remote_but_same_host():
                gef_print(titlify("ENVP from /proc/{:d}/environ".format(get_pid())))
                return self.print_from_proc("/proc/{:d}/environ".format(get_pid()), verbose)
        err("Not found envp")
        return


@register_command
class CetStatusCommand(GenericCommand):
    """Show Intel CET settings."""
    _cmdline_ = "cet-status"
    _syntax_ = _cmdline_
    _category_ = "Process Information"

    def get_state(self, code_len):
        d = {}
        d["pc"] = get_register("$pc")
        d["sp"] = get_register("$sp")
        d["code"] = read_memory(d["pc"], code_len)
        d["reg"] = {}
        for reg in current_arch.gpr_registers:
            d["reg"][reg] = get_register(reg)
        d["stack"] = {}
        for i in range(3):
            addr = d["sp"] + current_arch.ptrsize * i
            d["stack"][addr] = read_memory(addr, current_arch.ptrsize)
        return d

    def revert_state(self, d):
        write_memory(d["pc"], d["code"], len(d["code"]))
        gdb.execute("set $pc = {:#x}".format(d["pc"]), to_string=True)
        for regname, regvalue in d["reg"].items():
            gdb.execute("set {:s} = {:#x}".format(regname, regvalue), to_string=True)
        for addr, value in d["stack"].items():
            write_memory(addr, value)
        return

    def close_stdout(self):
        self.stdout = 1
        self.stdout_bak = os.dup(self.stdout)
        f = open("/dev/null")
        os.dup2(f.fileno(), self.stdout)
        f.close()
        return

    def revert_stdout(self):
        os.dup2(self.stdout_bak, self.stdout)
        os.close(self.stdout_bak)
        return

    def get_result(self):
        r = {}
        r["ret"] = get_register("$rax" if is_x86_64() else "$eax")
        r["data"] = []
        for i in range(3):
            addr = get_register("$rsi" if is_x86_64() else "$ecx") + current_arch.ptrsize * i
            v = read_int_from_memory(addr)
            r["data"].append(v)
        return r

    def execute_get_cet_status(self):
        if is_x86_64():
            code = b"\xeb\xfe\x0f\x05" # inf-loop (to stop another thread); syscall
        else:
            code = b"\xeb\xfe\xcd\x80" # inf-loop (to stop another thread); int 0x80
        gef_on_stop_unhook(hook_stop_handler)
        d = self.get_state(len(code))
        write_memory(d["pc"], code, len(code))
        if is_x86_64():
            gdb.execute("set $rax = 0x9e", to_string=True) # arch_prctl
            gdb.execute("set $rdi = 0x3001", to_string=True) # ARCH_CET_STATUS
            gdb.execute("set $rsi = $rsp", to_string=True) # buffer
        else:
            gdb.execute("set $eax = 0x180", to_string=True) # arch_prctl
            gdb.execute("set $ebx = 0x3001", to_string=True) # ARCH_CET_STATUS
            gdb.execute("set $ecx = $esp", to_string=True) # buffer
        gdb.execute("set $pc = {:#x}".format(d["pc"] + 2), to_string=True) # skip "\xeb\xfe"
        self.close_stdout()
        gdb.execute("stepi", to_string=True)
        self.revert_stdout()
        r = self.get_result()
        self.revert_state(d)
        gef_on_stop_hook(hook_stop_handler)
        return r

    @only_if_gdb_running
    @only_if_not_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        try:
            r = self.execute_get_cet_status()
        except Exception:
            err("Execute code fails. Memory write feature may not be supported.")
            return

        if r["ret"] != 0:
            err("OS does not support CET")
            return

        gef_print("ShadowStack/IndirectBranchTracking status: {:#x}".format(r["data"][0]))
        if r["data"][0] & 0b10:
            msg = Color.colorify("Enabled", "green bold")
        else:
            msg = Color.colorify("Disabled", "red bold")
        gef_print("  ShadowStack: {:s}".format(msg))
        if r["data"][0] & 0b01:
            msg = Color.colorify("Enabled", "green bold")
        else:
            msg = Color.colorify("Disabled", "red bold")
        gef_print("  IndirectBrannchTracking: {:s}".format(msg))
        gef_print("ShadowStack Base Address: {:#x}".format(r["data"][1]))
        gef_print("ShadowStack Size: {:#x}".format(r["data"][2]))
        return


@register_command
class TlsCommand(GenericCommand):
    """Show TLS base address."""
    _cmdline_ = "tls"
    _syntax_ = _cmdline_
    _category_ = "Process Information"

    @staticmethod
    def getfsgs_qemu_usermode():
        vmmap = get_process_maps()
        for m in vmmap[::-1]:
            if m.path != "<explored>":
                continue
            data = read_memory(m.page_start, m.size)
            data = slice_unpack(data, current_arch.ptrsize)
            addr = [x for x in range(m.page_start, m.page_end, current_arch.ptrsize)]
            assert len(data) == len(addr)
            for i in range(len(data) - 2):
                if data[i] == addr[i] and data[i + 2] == addr[i] and (data[i + 5] & 0xff) == 0 and data[i + 5] != 0:
                    return addr[i]
        return 0

    @staticmethod
    def getfs():
        if is_qemu_usermode():
            if is_x86_64():
                return TlsCommand.getfsgs_qemu_usermode()
            else:
                return 0
        # fast path
        fs = get_register("$fs_base")
        if fs is not None:
            return fs
        # slow path
        PTRACE_ARCH_PRCTL = 30
        ARCH_GET_FS = 0x1003
        pid, lwpid, tid = gdb.selected_thread().ptid
        ppvoid = ctypes.POINTER(ctypes.c_void_p)
        value = ppvoid(ctypes.c_void_p())
        value.contents.value = 0
        libc = ctypes.CDLL('libc.so.6')
        result = libc.ptrace(PTRACE_ARCH_PRCTL, lwpid, value, ARCH_GET_FS)
        if result == 0:
            return value.contents.value or 0
        else:
            return 0

    @staticmethod
    def getgs():
        if is_qemu_usermode():
            if is_x86_64():
                return 0
            else:
                return TlsCommand.getfsgs_qemu_usermode()
        # fast path
        gs = get_register("$gs_base")
        if gs is not None:
            return gs
        # slow path
        PTRACE_ARCH_PRCTL = 30
        ARCH_GET_GS = 0x1004
        pid, lwpid, tid = gdb.selected_thread().ptid
        ppvoid = ctypes.POINTER(ctypes.c_void_p)
        value = ppvoid(ctypes.c_void_p())
        value.contents.value = 0
        libc = ctypes.CDLL('libc.so.6')
        result = libc.ptrace(PTRACE_ARCH_PRCTL, lwpid, value, ARCH_GET_GS)
        if result == 0:
            return value.contents.value or 0
        else:
            return 0

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64", "ARM32", "ARM64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        if is_x86_64():
            fsvalue = self.getfs()
            if fsvalue:
                gef_print(titlify("TLS-0x80"))
                gdb.execute("telescope {:#x} 16".format(fsvalue - 0x80))
                gef_print(titlify("TLS"))
                gdb.execute("telescope {:#x} 16".format(fsvalue))
                gef_print("set $tls = {:#x}".format(fsvalue))
                gdb.execute("set $tls = {:#x}".format(fsvalue))
        elif is_x86_32():
            gsvalue = self.getgs()
            if gsvalue:
                gef_print(titlify("TLS-0x40"))
                gdb.execute("telescope {:#x} 16".format(gsvalue - 0x40))
                gef_print(titlify("TLS"))
                gdb.execute("telescope {:#x} 16".format(gsvalue))
                gef_print("set $tls = {:#x}".format(gsvalue))
                gdb.execute("set $tls = {:#x}".format(gsvalue))
        elif is_arm32():
            if not safe_parse_and_eval("__aeabi_read_tp"):
                err("Not found symbol (__aeabi_read_tp)")
                return
            gef_print("p $tls = (unsigned int)__aeabi_read_tp()")
            tls = gdb.execute("p $tls = (unsigned int)__aeabi_read_tp()", to_string=True)
            if tls:
                gef_print(titlify("TLS-0x40"))
                gdb.execute("telescope $tls-0x40 16")
                gef_print(titlify("TLS"))
                gdb.execute("telescope $tls 16")
        elif is_arm64():
            gef_print("p $tls = $TPIDR_EL0")
            tls = gdb.execute("p $tls = $TPIDR_EL0", to_string=True)
            if tls:
                gef_print(titlify("TLS-0x80"))
                gdb.execute("telescope $tls-0x80 16")
                gef_print(titlify("TLS"))
                gdb.execute("telescope $tls 16")
        return


@register_command
class FsbaseCommand(GenericCommand):
    """Show fsbase address."""
    _cmdline_ = "fsbase"
    _syntax_ = _cmdline_
    _category_ = "Process Information"

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, argv):
        self.dont_repeat()
        fs_base = TlsCommand.getfs()
        gef_print("$fs_base = {:#x}".format(fs_base))
        return


@register_command
class GsbaseCommand(GenericCommand):
    """Show gsbase address."""
    _cmdline_ = "gsbase"
    _syntax_ = _cmdline_
    _category_ = "Process Information"

    @only_if_gdb_running
    @only_if_gdb_target_local
    @only_if_not_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, argv):
        self.dont_repeat()
        gs_base = TlsCommand.getgs()
        gef_print("$gs_base = {:#x}".format(gs_base))
        return


@register_command
class GdtInfoCommand(GenericCommand):
    """Print GDT entries sample."""
    _cmdline_ = "gdtinfo"
    _syntax_ = "{:s} [-h] [-v]".format(_cmdline_)
    _category_ = "Misc"

    @staticmethod
    def seg2str(v):
        rpl = v & 0b11
        ti = (v >> 2) & 0b1
        index = (v >> 3)
        return f"{v:#4x} (=rpl:{rpl}, ti:{ti}, index:{index})"

    # dump segment register
    def print_seg_info(self):
        if not is_alive():
            return
        gef_print(titlify("Current register values"))
        red = lambda x: Color.colorify("{:4s}".format(x), "red bold")
        for k in ['cs', 'ds', 'es', 'fs', 'gs', 'ss']:
            v = get_register(k)
            gef_print("{:s}: {:s}".format(red(k), self.seg2str(v)))
        gef_print(" * rpl: Requested Privilege Level (0:Ring0, 3:Ring3)")
        gef_print(" * ti: Table Indicator (0:GDT, 1:LDT)")
        gef_print(" * index: Index of GDT/LDT")
        gef_print(" * segment register value = (index << 3) | (ti << 2) | rpl")
        gef_print(" * commonly used values:")
        gef_print("   - x64 code: 0x33")
        gef_print("   - x86 code (on x64): 0x23")
        gef_print("   - x86 code (native): 0x73")
        return

    # struct desc_struct -> dictionary(each value)
    @staticmethod
    def gdt_unpack(vals):
        if isinstance(vals, list):
            val = vals[0] # for TSS/LDT
        else:
            val = vals # for normal

        # parse
        d = {}
        d['_value'] = val

        d['limit0'] = val & 0xffff
        d['base0'] = (val >> 16) & 0xffff
        d['base1'] = (val >> 32) & 0xff
        d['_access_bytes'] = (val >> 40) & 0xff
        d['limit1'] = (val >> 48) & 0x0f
        d['_flag_bytes'] = (val >> 52) & 0x0f
        d['base2'] = (val >> 56) & 0xff

        d['p'] = (d['_access_bytes'] >> 7) & 0x01
        d['dpl'] = (d['_access_bytes'] >> 5) & 0x03
        d['s'] = (d['_access_bytes'] >> 4) & 0x01
        d['_type_bytes'] = d['_access_bytes'] & 0x0f
        d['ex'] = (d['_access_bytes'] >> 3) & 0x01
        d['dc'] = (d['_access_bytes'] >> 2) & 0x01
        d['rw'] = (d['_access_bytes'] >> 1) & 0x01
        d['ac'] = (d['_access_bytes'] >> 0) & 0x01

        d['gr'] = (d['_flag_bytes'] >> 3) & 0x01
        d['db'] = (d['_flag_bytes'] >> 2) & 0x01
        d['l'] = (d['_flag_bytes'] >> 1) & 0x01
        d['avl'] = (d['_flag_bytes'] >> 0) & 0x01
        d['_FLAGS'] = (d['_flag_bytes'] << 12) | d['_access_bytes'] # for easy use

        grsize = {0: 1, 1: 4096}[d['gr']]
        d['_limit'] = ((d['limit1'] << 16) | d['limit0']) * grsize
        d['_base'] = (d['base2'] << 24) | (d['base1'] << 16) | d['base0']

        # create memo
        if d['ex'] == 0: # data
            d['_exs'] = "DATA"
            d['_rws'] = ["RO", "RW"][d['rw']]
            d['_dcs'] = ["UP", "DN"][d['dc']]
        else: # code
            d['_exs'] = "CODE"
            d['_rws'] = ["RO", "RX"][d['rw']]
            d['_dcs'] = ["NC", "CO"][d['dc']]

        d['_ss'] = ["SYS", "C/D"][d['s']]
        dbl = (d['db'] << 1) | d['l']
        d['_dbl'] = "{:d}".format(dbl)
        d['_dbls'] = ["16bit", "64bit", "32bit", "(N/A)"][dbl]

        # for TSS/LDT
        if isinstance(vals, list):
            val = vals[1]
            d['_value2'] = d['_value']
            d['_value'] = val
            d['base3'] = val & 0xffffffff
            d['_base'] = (d['base3'] << 32) | d['_base']
        return d

    @staticmethod
    def segval2str(d, value_only=False, color=False):
        c = Color.boldify if color else lambda x: x
        if value_only:
            return c(f"{d:#018x}")
        d = GdtInfoCommand.gdt_unpack(d)
        if d['_value'] == 0:
            return c(f"{d['_value']:#018x}")
        else:
            fmt = ""
            fmt += c(f"{d['_value']:#018x}") + " : "
            fmt += c(f"{d['_base']:>#18x}") + " "
            fmt += c(f"{d['_limit']:>#10x}") + " "
            fmt += c(f"{d['gr']:>2d}") + " "
            fmt += c(f"{d['_dbl']:}") + f"({d['_dbls']:s}) "
            fmt += c(f"{d['avl']:>3d}") + " "
            fmt += c(f"{d['p']:d}") + " "
            fmt += c(f"{d['dpl']:>3}") + " "
            fmt += c(f"{d['s']:d}") + f"({d['_ss']:s}) "
            fmt += c(f"{d['ex']:d}") + f"({d['_exs']:s}) "
            fmt += c(f"{d['dc']:d}") + f"({d['_dcs']:s}) "
            fmt += c(f"{d['rw']:d}") + f"({d['_rws']:s}) "
            fmt += c(f"{d['ac']:d}")
            return fmt

    @staticmethod
    def segval2str_legend():
        legend = "[ #] "
        legend += f"{'segment name':20}: "
        legend += f"{'value':18} : {'base':>18} {'limit/size':} "
        legend += f"{'gr':} {'dbl':}      {'avl':>} "
        legend += f"{'p':} {'dpl':} {'s':}      "
        legend += f"{'ex':}      {'dc':}    {'rw':}    {'ac':}"
        return legend

    @staticmethod
    def get_segreg_list():
        regs = {}
        if is_alive():
            for k in ['cs', 'ds', 'es', 'fs', 'gs', 'ss']:
                v = get_register(k)
                ti = (v >> 2) & 0b1
                index = int(v >> 3)
                if v != 0 and ti == 0:
                    regs[index] = regs.get(index, []) + [k]
        return regs

    @staticmethod
    def is_emulated32():
        if is_qemu_usermode():
            return False

        if is_qemu_system():
            return False

        for m in get_process_maps():
            # native x86:
            # 0xbffdf000 0xc0000000 0x021000 0x000000 rw- [stack]
            # emulated x86 on x86_64
            # 0xfffdd000 0xffffe000 0x021000 0x000000 rw- [stack]
            if m.path == "[stack]":
                return (m.page_start >> 28) == 0xf
        else:
            return False # by default it considers on native

    # print useful gdt fixed entry
    def print_gdt_entry(self, entries):
        if is_x86_64() or self.is_emulated32():
            gef_print(titlify("GDT Entry (x64 sample)"))
        else:
            gef_print(titlify("GDT Entry (x86 sample)"))
        info("*** This is an {:s} (GDT/LDT exist per-CPU) ***".format(Color.boldify("EXAMPLE")))
        registers_color = get_gef_setting("theme.dereference_register_value")
        # print legend
        legend = self.segval2str_legend()
        gef_print(Color.colorify(legend, get_gef_setting("theme.table_heading")))
        # regs check
        regs = self.get_segreg_list()
        # parse entry
        for (i, print_flag, segname, value) in entries:
            # get segment regs value
            reglist = ', '.join(regs.get(i, []))
            if reglist:
                reglist = LEFT_ARROW + reglist
            # decode and print
            if print_flag:
                fmt = f"[{i:>2}] {segname:20}: " + self.segval2str(value) + " " + Color.colorify(f"{reglist:s}", registers_color)
            else:
                fmt = f"[{i:>2}] {segname:20}: {value:#018x} " + Color.colorify(f"{reglist:s}", registers_color)
            gef_print(fmt)
        return

    @staticmethod
    def print_gdt_entry_legend():
        gef_print(titlify("legend (Normal GDT entry)"))
        gef_print("              <flag_bytes->        <----access_bytes ---->")
        gef_print("                                             <type_bytes->")
        gef_print("31            23          19       15                    7             0bit")
        gef_print("------------------------------------------------------------------------")
        gef_print("|             |G |D |  |A |        |  |   |  |E |D |W |A |             |")
        gef_print("| BASE2 31:24 |  |/ |L |V | LIMIT1 |P |DPL|S |  |  |  |  | BASE1 23:16 | 4byte")
        gef_print("|             |R |B |  |L | 19:16  |  |   |  |X |C |R |C |             |")
        gef_print("------------------------------------------------------------------------")
        gef_print("|            BASE0 15:0            |           LIMIT0 15:0             | 0byte")
        gef_print("------------------------------------------------------------------------")
        gef_print(" * base               : Start address")
        gef_print(" * limit              : Segment size (4KB unit if gr==1)")
        gef_print(" * access_bytes")
        gef_print("   * p                : Segment Present Flag (0:SegmentNotInMemory, 1:SegmentInMemory)")
        gef_print("   * dpl              : Descriptor Privilege Level (0:Ring0, 3:Ring3)")
        gef_print("   * s                : Descriptor Type Flag (0:System Segment, 1:Code/Data Segment)")
        gef_print("   * type_bytes")
        gef_print("     * ex             : Segment type (0:Data, 1:Code)")
        gef_print("     * dc (Code Seg)  : Conforming bit (0:NoConform, 1:Conform)")
        gef_print("     * dc (Data Seg)  : Direction bit (0:Up, 1:Down)")
        gef_print("     * rw (Code Seg)  : Read/Exec bit (0:ReadOnly, 1:Read/Exec)")
        gef_print("     * rw (Data Seg)  : Read/Write bit (0:ReadOnly, 1:Read/Write)")
        gef_print("     * ac             : Access bit (0:NotAccessed, 1:Accessed)")
        gef_print(" * flag_bytes")
        gef_print("   * gr               : Granularity Flag (0:SegLimitAsByte, 1:SegLimitAs4KB)")
        gef_print("   * db               : Default Operation size (0:16bitSeg, 1:32bitSeg)")
        gef_print("   * l (Code Seg)     : 64-bits Code Segment Flag (0:32bit, 1:64bit)")
        gef_print("   * l (Data Seg)     : Reserved (0)")
        gef_print("   * avl              : Available bit (0)")
        gef_print(titlify("legend (GDT entry for TSS/LDT)"))
        gef_print("31            23          19       15                    7             0bit")
        gef_print("------------------------------------------------------------------------")
        gef_print("|                           ZERO1 (x64 only)                           | 12byte")
        gef_print("------------------------------------------------------------------------")
        gef_print("|                        BASE3 47:32 (x64 only)                        | 8byte")
        gef_print("------------------------------------------------------------------------")
        gef_print("|             |G |        |        |  |   |  |E |D |W |A |             |")
        gef_print("| BASE2 31:24 |  | ZERO0  | LIMIT1 |P |DPL|S |  |  |  |  | BASE1 23:16 | 4byte")
        gef_print("|             |R |        | 19:16  |  |   |  |X |C |R |C |             |")
        gef_print("------------------------------------------------------------------------")
        gef_print("|            BASE0 15:0            |           LIMIT0 15:0             | 0byte")
        gef_print("------------------------------------------------------------------------")
        gef_print(" * limit (tss)        : __KERNEL_TSS_LIMIT(=0x206f(x64) / 0x206b(x86))")
        gef_print(" * limit (ldt)        : (LDT entries * 8) - 1")
        return

    def print_gdt(self):
        self.print_seg_info()
        if is_x86_64() or self.is_emulated32():
            self.print_gdt_entry([
                # idx, print flag, segment name,        value
                (0,    True,       "NULL",              0x0000000000000000),
                (1,    True,       "KERNEL32_CS",       0x00cf9b000000ffff),
                (2,    True,       "KERNEL_CS",         0x00af9b000000ffff),
                (3,    True,       "KERNEL_DS",         0x00cf93000000ffff),
                (4,    True,       "DEFAULT_USER32_CS", 0x00cffb000000ffff),
                (5,    True,       "DEFAULT_USER_DS",   0x00cff3000000ffff),
                (6,    True,       "DEFAULT_USER_CS",   0x00affb000000ffff),
                (8,    False,      "TSS-part1",         0x00008b000000206f),
                (9,    True,       "TSS-part2",         [0x00008b000000206f, 0x00000000fffffe00]),
                (10,   True,       "LDT-part1",         0x0000000000000000),
                (11,   True,       "LDT-part2",         0x0000000000000000),
                (12,   True,       "TLS_#1",            0x0000000000000000),
                (13,   True,       "TLS_#2",            0x0000000000000000),
                (14,   True,       "TLS_#3",            0x0000000000000000),
                (15,   True,       "CPUNODE",           0x0040f50000000000),
            ])
        else:
            self.print_gdt_entry([
                # idx, print flag, segment name,        value
                (0,    True,       "NULL",              0x0000000000000000),
                (1,    True,       "RESERVED",          0x0000000000000000),
                (2,    True,       "RESERVED",          0x0000000000000000),
                (3,    True,       "RESERVED",          0x0000000000000000),
                (4,    True,       "UNUSED",            0x0000000000000000),
                (5,    True,       "UNUSED",            0x0000000000000000),
                (6,    True,       "TLS#1",             0x0000000000000000),
                (7,    True,       "TLS#2",             0x0000000000000000),
                (8,    True,       "TLS#3",             0x0000000000000000),
                (9,    True,       "RESERVED",          0x0000000000000000),
                (10,   True,       "RESERVED",          0x0000000000000000),
                (11,   True,       "RESERVED",          0x0000000000000000),
                (12,   True,       "KERNEL_CS",         0x00cf9a000000ffff),
                (13,   True,       "KERNEL_DS",         0x00cf93000000ffff),
                (14,   True,       "DEFAULT_USER_CS",   0x00cffa000000ffff),
                (15,   True,       "DEFAULT_USER_DS",   0x00cff3000000ffff),
                (16,   True,       "TSS",               0xff008b804000206b),
                (17,   True,       "LDT",               0x0000000000000000),
                (18,   True,       "PNPBIOS_CS32",      0x00409a000000ffff),
                (19,   True,       "PNPBIOS_CS16",      0x00009a000000ffff),
                (20,   True,       "PNPBIOS_DS",        0x000092000000ffff),
                (21,   True,       "PNPBIOS_TS1",       0x0000920000000000),
                (22,   True,       "PNPBIOS_TS2",       0x0000920000000000),
                (23,   True,       "APMBIOS_BASE",      0x00409a000000ffff),
                (24,   True,       "APMBIOS",           0x00009a000000ffff),
                (25,   True,       "APMBIOS",           0x004092000000ffff),
                (26,   True,       "ESPFIX_SS",         0x00cf92000000ffff),
                (27,   True,       "PERCPU",            0x038f93708000ffff),
                (28,   True,       "STACK_CANARY",      0x0000000000000000),
                (29,   True,       "UNUSED",            0x0000000000000000),
                (30,   True,       "UNUSED",            0x0000000000000000),
                (31,   True,       "DOUBLEFAULT_TSS",   0xc40089706000206b),
            ])
        if self.print_flags_info:
            self.print_gdt_entry_legend()
        else:
            info("for flags description, use `-v`")
        return

    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        self.print_flags_info = "-v" in argv
        self.print_gdt()
        info("if qemu-system, use `qreg -v` to confirm real GDT value")
        return


@register_command
class MemoryCompareCommand(GenericCommand):
    """Memory Compare."""
    _cmdline_ = "memcmp"
    _syntax_ = "{:s} [-h] [--phys] ADDRESS1 [--phys] ADDRESS2 SIZE".format(_cmdline_)
    _category_ = "Misc"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    def diff(self, from1data, from2data):
        diff_found = False
        asterisk = True
        for pos in range(0, self.size, 16):
            f1_bin = from1data[pos : pos + 16]
            f2_bin = from2data[pos : pos + 16]
            if f1_bin == f2_bin:
                if asterisk is False:
                    gef_print("*")
                    asterisk = True
                continue

            addr1 = self.from1 + pos
            addr2 = self.from2 + pos

            diff_found = True
            asterisk = False
            f1_hex = []
            f2_hex = []
            f1_ascii = []
            f2_ascii = []
            for i in range(min(len(f1_bin), 16)):
                if f1_bin[i] == f2_bin[i]:
                    color_func = lambda x: x
                else:
                    color_func = Color.boldify
                f1_hex.append(color_func("{:02x}".format(f1_bin[i])))
                f2_hex.append(color_func("{:02x}".format(f2_bin[i])))
                f1_ascii.append(color_func(chr(f1_bin[i]) if 0x20 <= f1_bin[i] < 0x7f else "."))
                f2_ascii.append(color_func(chr(f2_bin[i]) if 0x20 <= f2_bin[i] < 0x7f else "."))
            f1_hex_s = ' '.join(f1_hex) + " " * ((16 - len(f1_hex)) * 3)
            f2_hex_s = ' '.join(f2_hex) + " " * ((16 - len(f2_hex)) * 3)
            f1_ascii_s = ''.join(f1_ascii) + " " * (16 - len(f1_ascii))
            f2_ascii_s = ''.join(f2_ascii) + " " * (16 - len(f2_ascii))
            msg = "{:#018x}: {:s} | {:s} | {:#018x}: {:s} | {:s} |".format(addr1, f1_hex_s, f1_ascii_s, addr2, f2_hex_s, f2_ascii_s)
            gef_print(msg)

        if diff_found is False:
            info("Not found diff")
        return

    def memcmp(self):
        try:
            if self.from1_phys:
                from1data = read_physmem(self.from1, self.size)
            else:
                from1data = read_memory(self.from1, self.size)
        except Exception:
            err("Read error {:#x}".format(self.from1))
            return

        try:
            if self.from2_phys:
                from2data = read_physmem(self.from2, self.size)
            else:
                from2data = read_memory(self.from2, self.size)
        except Exception:
            err("Read error {:#x}".format(self.from2))
            return

        self.diff(from1data, from2data)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "--phys" in argv and not is_qemu_system():
            err("Unsupported")
            return

        if "-h" in argv:
            self.usage()
            return

        try:
            if argv[0] == "--phys":
                self.from1_phys = True
                self.from1 = parse_address(argv[1])
                argv = argv[2:]
            else:
                self.from1_phys = False
                self.from1 = parse_address(argv[0])
                argv = argv[1:]

            if argv[0] == "--phys":
                self.from2_phys = True
                self.from2 = parse_address(argv[1])
                argv = argv[2:]
            else:
                self.from2_phys = False
                self.from2 = parse_address(argv[0])
                argv = argv[1:]

            self.size = int(argv[0], 0)
        except Exception:
            self.usage()
            return

        if self.size == 0:
            info("The size is zero, maybe wrong.")

        self.memcmp()
        return


@register_command
class MemoryCopyCommand(GenericCommand):
    """Memory Copy."""
    _cmdline_ = "memcpy"
    _syntax_ = "{:s} [-h] [--phys] TO [--phys] FROM SIZE".format(_cmdline_)
    _category_ = "Misc"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    def memcpy(self):
        try:
            if self.from_phys:
                data = read_physmem(self.from_addr, self.size)
            else:
                data = read_memory(self.from_addr, self.size)
        except Exception:
            err("Read error {:#x}".format(self.from_addr))
            return

        info("Read count: {:#x}".format(len(data)))

        try:
            if self.to_phys:
                written = write_physmem(self.to_addr, data)
            else:
                written = write_memory(self.to_addr, data, len(data))
        except Exception:
            err("Write error {:#x}".format(self.to_addr))
            return

        info("Write count: {:#x}".format(written))
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "--phys" in argv and not is_qemu_system():
            err("Unsupported")
            return

        if "-h" in argv:
            self.usage()
            return

        try:
            if argv[0] == "--phys":
                self.to_phys = True
                self.to_addr = parse_address(argv[1])
                argv = argv[2:]
            else:
                self.to_phys = False
                self.to_addr = parse_address(argv[0])
                argv = argv[1:]

            if argv[0] == "--phys":
                self.from_phys = True
                self.from_addr = parse_address(argv[1])
                argv = argv[2:]
            else:
                self.from_phys = False
                self.from_addr = parse_address(argv[0])
                argv = argv[1:]

            self.size = int(argv[0], 0)
        except Exception:
            self.usage()
            return

        if self.size == 0:
            info("The size is zero, maybe wrong.")

        self.memcpy()
        return


@register_command
class IsMemoryZeroCommand(GenericCommand):
    """Checks if all the memory in the specified range is 0x00, 0xff."""
    _cmdline_ = "is-mem-zero"
    _syntax_ = "{:s} [-h] [--phys] ADDRESS SIZE".format(_cmdline_)
    _category_ = "Misc"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    def memcheck(self):
        current = self.addr
        end = self.addr + self.size
        is_zero = True
        is_ff = True
        while current < end:
            read_size = min(end - current, 0x1000)
            try:
                if self.phys_mode:
                    data = read_physmem(current, read_size)
                else:
                    data = read_memory(current, read_size)
            except Exception:
                err("Read error {:#x}".format(self.addr))
                return
            if data == b"\0" * len(data):
                is_ff = False
            elif data == b"\xff" * len(data):
                is_zero = False
            else:
                is_zero = False
                is_ff = False
            if is_zero is False and is_ff is False:
                break
            current += 0x1000

        if is_zero:
            info("{:#x} - {:#x} is {:s}".format(self.addr, self.addr + self.size, Color.colorify("All 0x00", "bold yellow")))
        elif is_ff:
            info("{:#x} - {:#x} is {:s}".format(self.addr, self.addr + self.size, Color.colorify("All 0xFF", "bold yellow")))
        else:
            info("{:#x} - {:#x} is {:s}".format(self.addr, self.addr + self.size, Color.colorify("NON-ZERO", "bold yellow")))
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        self.phys_mode = False
        if "--phys" in argv:
            if not is_qemu_system():
                err("Unsupported")
                return
            self.phys_mode = True
            argv.remove("--phys")

        if len(argv) < 2:
            self.usage()
            return
        self.size = int(argv[-1], 16)
        self.addr = int(argv[-2], 16)

        self.memcheck()
        return


@register_command
class FindFakeFastCommand(GenericCommand):
    """Find candidate fake fast chunks from rw memory."""
    _cmdline_ = "find-fake-fast"
    _syntax_ = "{:s} [-h] size [--include-heap] [--aligned]".format(_cmdline_)
    _category_ = "Heap"

    def print_result(self, m, pos, size_candidate):
        path = "unknown" if m.path == "" else m.path
        info("Found at {:#x} in {:s} [{:s}]".format(m.page_start + pos, repr(path), str(m.permission)))

        if current_arch.ptrsize == 4:
            res = gdb.execute("x/6xw {:#x}".format(m.page_start + pos), to_string=True)
        else:
            res = gdb.execute("x/6xg {:#x}".format(m.page_start + pos), to_string=True)
        flag = []
        flag += [Color.colorify("NON_MAIN_ARENA", "bold yellow") if (size_candidate & 0b100) else Color.colorify("NON_MAIN_ARENA", "normal")]
        flag += [Color.colorify("IS_MMAPED", "bold blue") if (size_candidate & 0b10) else Color.colorify("IS_MMAPED", "normal")]
        flag += [Color.colorify("PREV_INUSE", "bold red") if (size_candidate & 0b1) else Color.colorify("PREV_INUSED", "normal")]
        gef_print("    [{:s}]".format(' '.join(flag)))
        for line in res.splitlines():
            gef_print("    {:s}".format(line))

    def find_fake_fast(self, target_size):
        mask = ~0x7 if current_arch.ptrsize == 4 else ~0xf
        target_size &= mask
        vmmap = get_process_maps()
        unpack = u32 if current_arch.ptrsize == 4 else u64
        for m in vmmap:
            if not (m.permission & Permission.READ) or not (m.permission & Permission.WRITE):
                continue
            if m.path == "[vvar]":
                continue
            if not self.include_heap and m.path == "[heap]":
                continue
            data = read_memory(m.page_start, m.size)
            # Scanning page-by-page
            for pos in range(0, m.size, gef_getpagesize()):
                # fast check for all zero, because there may be huge mmap-ed memory
                if b"\0" * gef_getpagesize() == data[pos:pos + gef_getpagesize()]:
                    continue
                # this page has some data
                unit = 0x10 if self.aligned else 1
                for posb in range(pos, pos + gef_getpagesize(), unit):
                    size_candidate = data[posb + current_arch.ptrsize:posb + current_arch.ptrsize * 2]
                    if len(size_candidate) != current_arch.ptrsize:
                        break
                    size_candidate = unpack(size_candidate)
                    if (size_candidate & mask) != target_size:
                        continue
                    self.print_result(m, posb, size_candidate)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        self.include_heap = False
        if "--include-heap" in argv:
            self.include_heap = True
            argv.remove("--include-heap")

        self.aligned = False
        if "--aligned" in argv:
            self.aligned = True
            argv.remove("--aligned")

        if len(argv) == 0:
            self.usage()
            return

        target_size = int(argv[0], 0)
        self.find_fake_fast(target_size)
        return


@register_command
class VisualHeapCommand(GenericCommand):
    """Visualize top 10 chunks on a heap (default: main_arena)."""
    _cmdline_ = "visual-heap"
    _syntax_ = "{:s} [-h] [DUMP_START_ADDRESS] [-c CHUNK_PRINT_COUNT|all] [-a ARENA_ADDRESS] [-v]".format(_cmdline_)
    _category_ = "Heap"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    def subinfo(self, addr):
        s = ""
        for k, v in self.tcache_list.items():
            if addr in v:
                s += "{} {}".format(LEFT_ARROW, "tcache[{}]".format(k))
        for k, v in self.fastbin_list.items():
            if addr in v:
                s += "{} {}".format(LEFT_ARROW, "fastbin[{}]".format(k))
        for k, v in self.unsortedbin_list.items():
            if addr in v:
                s += "{} {}".format(LEFT_ARROW, "unsortedbin")
        for k, v in self.smallbin_list.items():
            if addr in v:
                s += "{} {}".format(LEFT_ARROW, "smallbin[{}]".format(k))
        for k, v in self.largebin_list.items():
            if addr in v:
                s += "{} {}".format(LEFT_ARROW, "largebin[{}]".format(k))
        if addr == self.top:
            s += "{} {}".format(LEFT_ARROW, "top chunk")
        return s

    def print_chunk(self, chunk, color_func):
        ptrsize = current_arch.ptrsize
        unpack = u32 if ptrsize == 4 else u64
        data = slicer(chunk.data, ptrsize * 2)
        group_line_threshold = 8

        addr = chunk.chunk_base_address
        width = ptrsize * 2 + 2
        dump = ""
        done = False
        for blk, blks in itertools.groupby(data):
            repeat_count = len(list(blks))
            d1, d2 = unpack(blk[:ptrsize]), unpack(blk[ptrsize:])
            dascii = ''.join(list(map(lambda x: chr(x) if 0x20 <= x < 0x7f else '.', list(blk))))

            if repeat_count < group_line_threshold or self.verbose:
                for i in range(repeat_count):
                    dump += f"{addr:#x}: {d1:#0{width:d}x} {d2:#0{width:d}x} | {dascii:s} | " + self.subinfo(addr) + "\n"
                    addr += ptrsize * 2
                    if addr > self.top + ptrsize * 4:
                        dump += "..."
                        done = True
                        break
            else:
                dump += f"{addr:#x}: {d1:#0{width:d}x} {d2:#0{width:d}x} | {dascii:s} | " + self.subinfo(addr) + "\n"
                dump += "* {:#d} lines, {:#x} bytes \n".format(repeat_count - 1, (repeat_count - 1) * ptrsize * 2)
                addr += ptrsize * 2 * repeat_count

            if done:
                break

        gef_print(color_func(dump.rstrip()))
        return

    def print_heap(self):
        sect = process_lookup_address(self.dump_start)
        addr = self.dump_start
        i = 0
        color = [Color.redify, Color.greenify, Color.blueify, Color.yellowify]
        while addr < sect.page_end and (self.count is None or i < self.count):
            chunk = GlibcChunk(addr + current_arch.ptrsize * 2)
            # corrupt check
            if addr != self.top and addr + chunk.size > self.top:
                err("Corrupted (addr + chunk.size > self.top)")
                chunk.data = read_memory(addr, self.top - addr + 0x10)
                self.print_chunk(chunk, Color.grayify)
                break
            elif addr + chunk.size > sect.page_end:
                err("Corrupted (addr + chunk.size > sect.page_end)")
                chunk.data = read_memory(addr, self.top - addr + 0x10)
                self.print_chunk(chunk, Color.grayify)
                break
            # maybe not corrupted
            try:
                chunk.data = read_memory(addr, chunk.size)
            except gdb.MemoryError:
                break
            color_func = color[i % len(color)]
            self.print_chunk(chunk, color_func)
            addr += chunk.size
            i += 1
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if argv and "-h" in argv:
            self.usage()
            return

        # parse verbose
        if argv and "-v" in argv:
            self.verbose = True
            argv.remove("-v")
        else:
            self.verbose = False

        # parse arena
        if "-a" in argv:
            try:
                idx = argv.index("-a")
                arena_addr = argv[idx + 1]
                self.arena = GlibcArena("*{:s}".format(arena_addr))
                argv = argv[:idx] + argv[idx + 2:]
            except Exception:
                self.usage()
                return
        else:
            self.arena = get_main_arena()
        if self.arena is None:
            err("No valid arena")
            return
        if self.arena.heap_base is None:
            err("No heap section")
            return

        # parse count
        if "-c" in argv:
            try:
                idx = argv.index("-c")
                if argv[idx + 1] == "all":
                    self.count = None
                else:
                    self.count = int(argv[idx + 1], 0)
                argv = argv[:idx] + argv[idx + 2:]
            except Exception:
                self.usage()
                return
        else:
            self.count = 10

        # parse start address
        if len(argv) == 1:
            try:
                self.dump_start = int(argv[0], 0)
                argv = None
            except Exception:
                self.usage()
                return
        elif len(argv) == 0:
            self.dump_start = self.arena.heap_base
            # specific pattern
            if current_arch.ptrsize == 4 and self.arena.is_main_arena():
                self.dump_start += 8
        else:
            self.usage()
            return

        self.tcache_list = self.arena.tcache_list() if self.arena else []
        self.fastbin_list = self.arena.fastbin_list() if self.arena else []
        self.unsortedbin_list = self.arena.unsortedbin_list() if self.arena else []
        self.smallbin_list = self.arena.smallbin_list() if self.arena else []
        self.largebin_list = self.arena.largebin_list() if self.arena else []
        self.top = int(self.arena.top) if self.arena else None

        try:
            self.print_heap()
        except Exception:
            pass
        return


@register_command
class MultiLineCommand(GenericCommand):
    """Execute multiple GDB commands in sequence."""
    _cmdline_ = "multi-line"
    _syntax_ = "{:s} [-h] GDB_CMD [; GDB_CMD [; GDB_CMD [...]]]".format(_cmdline_)
    _category_ = "Misc"
    _aliases_ = ["ml"]

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_COMMAND)
        return

    def do_command(self, commands):
        if commands == []:
            return True

        # make comnand string
        cmd = ""
        for c in commands:
            if "\\" in c or " " in c:
                cmd += " " + repr(c)
            else:
                cmd += " " + c
        cmd = cmd.strip()

        # blank command, so skip
        if cmd.replace(" ", "") == "":
            return True

        gef_print(titlify(cmd))
        try:
            gdb.execute(cmd)
        except Exception as e:
            gef_print(e)
            return False # fail
        return True

    def do_invoke(self, argv):
        if len(argv) == 1 and argv[0] == "-h":
            self.usage()
            return

        commands = []
        for arg in argv:
            if arg.endswith(";"):
                commands.append(arg.rstrip(";").lstrip(";"))
                if self.do_command(commands) is False:
                    break
                commands = []
            elif arg.startswith(";"):
                if self.do_command(commands) is False:
                    break
                commands = []
                commands.append(arg.lstrip(";"))
            elif arg == ";":
                if self.do_command(commands) is False:
                    break
                commands = []
            else:
                commands.append(arg)
        else:
            self.do_command(commands)
        return


@register_command
class TimeCommand(GenericCommand):
    """Measures the time of the GDB command."""
    _cmdline_ = "time"
    _syntax_ = "{:s} GDB_CMD [, ARG]".format(_cmdline_)
    _category_ = "Misc"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_COMMAND)
        return

    def do_invoke(self, argv):
        self.dont_repeat()

        start_time_real = time.perf_counter()
        start_time_proc = time.process_time()

        cmd = ""
        for c in argv:
            if "\\" in c or " " in c:
                cmd += " " + repr(c)
            else:
                cmd += " " + c
        cmd = cmd.strip()

        gef_print(titlify(cmd))
        try:
            gdb.execute(cmd)
        except Exception:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            gef_print(exc_value)
            return

        end_time_real = time.perf_counter()
        end_time_proc = time.process_time()
        gef_print(titlify("time elapsed"))
        gef_print("Real: {:.3f} s".format(end_time_real - start_time_real))
        gef_print("CPU:  {:.3f} s".format(end_time_proc - start_time_proc))
        return


@register_command
class LsCommand(GenericCommand):
    """`ls` command wrapper."""
    _cmdline_ = "ls"
    _syntax_ = "{:s} [filename|dirname, ...]".format(_cmdline_)
    _category_ = "Misc"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_FILENAME)
        return

    def do_invoke(self, argv):
        self.dont_repeat()

        try:
            ls = which("ls")
        except Exception:
            err("Missing `ls` command")
            return

        try:
            result = gef_execute_external([ls, "-la", "--color=always"] + argv, as_list=True)
            for line in result:
                gef_print(line)
        except Exception:
            gef_print("file/dir is not found")
        return


@register_command
class CatCommand(GenericCommand):
    """`cat` command wrapper."""
    _cmdline_ = "cat"
    _syntax_ = "{:s} filename [filename, ...]".format(_cmdline_)
    _category_ = "Misc"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_FILENAME)
        return

    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) == 0:
            return
        try:
            cat = which("cat")
        except Exception:
            err("Missing `cat` command")
            return

        try:
            result = gef_execute_external([cat] + argv, as_list=True)
            for line in result:
                gef_print(line.replace("\0", "\\x00"))
        except Exception:
            gef_print("file not found")
        return


@register_command
class PdisasCommand(GenericCommand):
    """Shortcut `cs-dis $pc LENGTH=50 OPCODES`."""
    _cmdline_ = "pdisas"
    _syntax_ = "{:s} [addr] [length]".format(_cmdline_)
    _category_ = "Assemble"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        try:
            if len(argv) >= 2:
                length = int(argv[1], 0)
            else:
                length = 50

            if len(argv) >= 1:
                addr = argv[0]
            else:
                addr = "$pc"
        except Exception:
            self.usage()
            return

        gdb.execute("cs-dis {:s} length={:d} OPCODES".format(addr, length))
        return


@register_command
class IiCommand(GenericCommand):
    """Shortcut `x/50i $pc`."""
    _cmdline_ = "ii"
    _syntax_ = "{:s} [addr]".format(_cmdline_)
    _category_ = "Assemble"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    def is_all_zero(self, addr, N):
        res = read_memory(addr, N)
        return res == b"\0" * N

    def is_all_ff(self, addr, N):
        res = read_memory(addr, N)
        return res == b"\xff" * N

    def ii(self, addr, N):
        if isinstance(addr, int):
            if N >= 50 and self.is_all_zero(addr, N):
                info("all targeted area is 0x00")
                return
            if N >= 50 and self.is_all_ff(addr, N):
                info("all targeted area is 0xff")
                return
            res = gdb.execute("x/{:d}i {:#x}".format(N, addr), to_string=True)
        else:
            res = gdb.execute("x/{:d}i {:s}".format(N, addr), to_string=True)

        for line in res.splitlines():
            line = line.rstrip()
            try:
                if is_arm32():
                    addr = int(line.split("; ")[-1], 16)
                elif is_x86_64():
                    addr = int(line.split("# ")[-1], 16)
                else:
                    raise
                val = read_int_from_memory(addr)
                line += " -> [{:#x}]".format(val)
            except Exception:
                pass
            gef_print(line)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        N = 50
        try:
            if len(argv) == 0:
                self.ii("$pc", N)
            else:
                try:
                    self.ii(int(argv[0], 16), N)
                except Exception:
                    self.ii(argv[0], N)
        except Exception:
            self.usage()
        return


@register_command
class ConstGrepCommand(GenericCommand):
    """Grep from `/usr/include`."""
    _cmdline_ = "constgrep"
    _syntax_ = "{:s} GREP_PATTERN".format(_cmdline_)
    _example_ = "constgrep '__NR_*'"
    _category_ = "Misc"

    def read_normalize(self, path):
        try:
            content = open(path, "rb").read()
        except Exception:
            return None
        content = content.replace(b"\\\n", b"")
        content = content.replace(b"\t", b" ")
        content = content.replace(b"  ", b" ")
        for i in range(0x80, 0x100):
            content = content.replace(bytes([i]), b"")
        try:
            content = content.decode("UTF-8")
        except Exception:
            err("decode error: " + path)
            return None
        return content

    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) == 0:
            self.usage()
            return

        srcdir = "/usr/include"
        pattern = re.compile(r"^#define\s+\S*" + argv[0])
        for cur, dirs, files in os.walk(srcdir):
            for f in files:
                path = os.path.join(cur, f)
                content = self.read_normalize(path)
                if content is None:
                    continue
                for line in content.splitlines():
                    if pattern.search(line):
                        gef_print("{:s}: {:s}".format(Color.redify(path), line))
        return


@register_command
class SlubDumpCommand(GenericCommand):
    """Dump slab freelist with kenrel memory scanning. Thanks to https://github.com/PaoloMonti42/salt"""
    _cmdline_ = "slub-dump"
    _syntax_ = "{:s} [-h] [SLAB_CACHE_NAME] [--cpu N] [--no-xor] [--list]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} kmalloc-256 # dump kmalloc-256 from all cpus\n".format(_cmdline_)
    _example_ += "{:s} kmalloc-256 --cpu 1 # dump kmalloc-256 from cpu 1\n".format(_cmdline_)
    _example_ += "{:s} kmalloc-256 --no-xor # skip xor to chunk->next\n".format(_cmdline_)
    _example_ += "{:s} --list # list up slab cache names\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "Search flow:\n"
    _example_ += "1. get address of `__per_cpu_offset`\n"
    _example_ += "2. get address of `slab_caches`\n"
    _example_ += "3. parse member of `kmem_cache`\n"
    _example_ += "4. walk slub\n"
    _example_ += "THIS FEATURE IS EXPERIMENTAL AND HEURISTIC.\n"
    _example_ += "\n"
    _example_ += "Simplified SLUB structure:\n"
    _example_ += "                         +-kmem_cache-+         +-kmem_cache-+   +-kmem_cache-+\n"
    _example_ += "                         | cpu_slab   |---+     | cpu_slab   |   | cpu_slab   |\n"
    _example_ += "                         | obj_size   |   |     | obj_size   |   | obj_size   |\n"
    _example_ += "                         | offset     |---|-+   | offset     |   | offset     |\n"
    _example_ += "       +-slab_caches-+   | name       |   | |   | name       |   | name       |\n"
    _example_ += " ...<->| list_head   |<->| list_head  |<------->| list_head  |<->| list_head  |<-> ...\n"
    _example_ += "       +-------------+   | random     |   | |   | random     |   | random     |\n"
    _example_ += "                         +------------+   | |   +------------+   +------------+\n"
    _example_ += "                                          | |\n"
    _example_ += "    +-__per_cpu_offset-+                  | |\n"
    _example_ += "    | cpu0_offset      |---+--------------+ |\n"
    _example_ += "    | cpu1_offset      |   |                |\n"
    _example_ += "    | cpu2_offset      |   |        +-------+\n"
    _example_ += "    | ...              |   |        |\n"
    _example_ += "    +------------------+   |        |\n"
    _example_ += "                           |        |\n"
    _example_ += "      +--------------------+        |\n"
    _example_ += "      |                             |\n"
    _example_ += "      |                 +-chunk--------+  +-chunk--------+  +-chunk--------+\n"
    _example_ += "      |                 | ^         |  |  | ^            |  | ^            |\n"
    _example_ += "      v                 | |offset <-+  |  | |offset      |  | |offset      |\n"
    _example_ += "    +-kmem_cache_cpu-+  | v            |  | v            |  | v            |\n"
    _example_ += "    | freelist       |->| next         |->| next         |->| next         |->NULL\n"
    _example_ += "    |                |  |              |  |              |  |              |\n"
    _example_ += "    +----------------+  +--------------+  +--------------+  +--------------+\n"
    _example_ += "                        * next has 3 patterns.\n"
    _example_ += "                          1. next\n"
    _example_ += "                          2. xor(next, random)\n"
    _example_ += "                          3. xor(byteswap(next), random)"
    _category_ = "Qemu-system Cooperation"

    """
    struct kmem_cache {
        struct kmem_cache_cpu *cpu_slab;         // In fact, the offset value, not the pointer
        slab_flags_t flags;                      // unsigned int (+ padding 4 byte)
        unsigned long min_partial;
        unsigned int size;
        unsigned int object_size;
        struct reciprocal_value {                //
            u32 m;                               //
            u8 sh1, sh2;                         // (+ padding 2 byte)
        } reciprocal_size;                       // if kernel >= 5.9-rc1
        unsigned int offset;
        unsigned int cpu_partial;                // if CONFIG_SLUB_CPU_PARTIAL=y
        struct kmem_cache_order_objects oo;
        struct kmem_cache_order_objects max;
        struct kmem_cache_order_objects min;
        gfp_t allocflags;
        int refcount;
        void (*ctor)(void *);
        unsigned int inuse;
        unsigned int align;
        unsigned int red_left_pad;
        const char *name;
        struct list_head list; <-----> struct list_head <-----> struct list_head <-----> ...
        struct kobject kobj;                     // if CONFIG_SYSFS=y
        struct work struct kobj_remove_work;     // if CONFIG_SYSFS=y && kernel < 5.9-rc1
        struct memcg_cache_params memcg_params;  // if CONFIG_MEMCG=y && kernel < 5.9-rc1
        unsigned int max_attr_size;              // if CONFIG_MEMCG=y && kernel < 5.9-rc1
        struct kset *memcg_kset;                 // if CONFIG_MEMCG=y && CONFIG_SYSFS=y && kernel < 5.9-rc1
        unsigned long random;                    // if CONFIG_SLAB_FREELIST_HARDENED=y
        unsigned int remote_node_defrag_ratio;   // if CONFIG_NUMA=y
        unsigned int *random_seq;                // if CONFIG_SLAB_FREELIST_RANDOM=y
        struct kasan_cache kasan_info;           // if CONFIG_KASAN=y
        unsigned int useroffset;
        unsigned int usersize;
        struct kmem_cache_node *node[64];
    }

    struct kmem_cache_cpu {
        void **freelist;
        unsigned long tid;
        struct page *page;
        struct page *partial;                    // if CONFIG_SLUB_CPU_PARTIAL=y
        unsigned stat[NR_SLUB_STAT_ITEMS];       // if CONFIG_SLUB_STATS=y
    }
    """

    def init_offset(self):
        # resolve __per_cpu_offset
        self.__per_cpu_offset = KernelAddressHeuristicFinder.get_per_cpu_offset()
        if self.__per_cpu_offset is None:
            err("Failed to resolve `__per_cpu_offset`")
            return False
        else:
            info("__per_cpu_offset: {:#x}".format(self.__per_cpu_offset))

        # resolve each cpu_offset
        self.cpu_offset = [read_int_from_memory(self.__per_cpu_offset)]
        i = 1
        while True:
            off = read_int_from_memory(self.__per_cpu_offset + i * 8)
            if off == self.cpu_offset[-1]:
                self.cpu_offset = self.cpu_offset[:-1]
                break
            self.cpu_offset.append(off)
            i += 1

        # resolve slab_caches
        self.slab_caches = KernelAddressHeuristicFinder.get_slab_caches()
        if self.slab_caches is None:
            err("Failed to resolve `slab_caches`")
            return False
        else:
            info("slab_caches: {:#x}".format(self.slab_caches))

        # offsetof(kmem_cache, list)
        current = list_next = read_int_from_memory(self.slab_caches)
        for off in range(0, 0x70, current_arch.ptrsize): # backward search for the start of `struct kmem_cache`
            val = read_int_from_memory(current - off)
            # search condition 1 (rare case)
            if (is_32bit() and (val & 0x80000000)) or (is_64bit() and (val & 0x8000000000000000)):
                try:
                    b = read_memory(val, 0x100)
                    if b == b"\x00" * 0x100: # read ok, but data is none. `off` just points `struct kmem_cache->cpu_slab`
                        break
                except gdb.MemoryError: # read error, so this is not address. `off` just points `struct kmem_cache->cpu_slab`
                    break
            # search condition 2 (normal case)
            a = read_int_from_memory(current - off - current_arch.ptrsize * 1)
            b = read_int_from_memory(current - off - current_arch.ptrsize * 2)
            if (a == b == 0) or (a == b == 0xcccccccc) or (a == b == 0xcccccccccccccccc):
                # normal case: [..., 0x0, 0x0, struct kmem_cache, ...]
                # rare case: [..., 0xcccccccc, 0xcccccccc, struct kmem_cache, ...]
                # rare case: [..., 0xcccccccccccccccc, 0xcccccccccccccccc, struct kmem_caches, ...]
                break
        else:
            # not found, so try x64 specific condition
            for diff in [0, 0x40]: # 0x80 or 0x40 align
                off = (current & 0x7f) + diff
                flags = read_int_from_memory(current - off + current_arch.ptrsize)
                if is_x86_64() and (flags & 0xfffffffffbf00fff) == 0x0000000040000000: # heuristic flags value
                    break
            else:
                err("offsetof(kmem_cache, list): Not Found")
                raise
        self.kmem_cache_offset_list = off
        info("offsetof(kmem_cache, list): {:#x}".format(self.kmem_cache_offset_list))

        # offsetof(kmem_cache, name)
        self.kmem_cache_offset_name = self.kmem_cache_offset_list - current_arch.ptrsize
        info("offsetof(kmem_cache, name): {:#x}".format(self.kmem_cache_offset_name))

        # offsetof(kmem_cache, offset)
        top = list_next - self.kmem_cache_offset_list
        objsize = u32(read_memory(top + current_arch.ptrsize * 3 + 4, 4))
        maybe_recip = u32(read_memory(top + current_arch.ptrsize * 3 + 4 + 4, 4))
        if objsize < maybe_recip or (maybe_recip % 8) != 0:
            self.kmem_cache_offset_offset = current_arch.ptrsize * 3 + 4 + 4 + current_arch.ptrsize
        else:
            self.kmem_cache_offset_offset = current_arch.ptrsize * 3 + 4 + 4
        info("offsetof(kmem_cache, offset): {:#x}".format(self.kmem_cache_offset_offset))

        # offsetof(kmem_cache, random)
        if self.no_xor:
            self.kmem_cache_offset_random = None
        else:
            current = top
            for i in range(64): # walk from list for heuristic search
                val = read_int_from_memory(current + i * current_arch.ptrsize)
                if is_64bit():
                    if (val >> 48) in [0, 0xffff, 0xfffe, 0xdead, current >> 48]: # for la57: current >> 48
                        continue
                    if (val >> 32) == (val & 0xffffffff):
                        continue
                    if "{:064b}".format(val).count("1") < 6: # low entrorpy is not `random`
                        continue
                    if "{:064b}".format(val).count("1") > 64 - 6: # low entrorpy is not `random`
                        continue
                    self.kmem_cache_offset_random = i * current_arch.ptrsize
                    info("offsetof(kmem_cache, random): {:#x}".format(self.kmem_cache_offset_random))
                    break
                elif is_32bit():
                    if (val >> 8) in [0, 0xffffff]: # 0x000000**, 0xffffff** are not `random`
                        continue
                    if (val & ~0x0f0ff000) == 0x40000000: # flag are not `random`
                        continue
                    if "{:032b}".format(val).count("1") < 6: # low entrorpy is not `random`
                        continue
                    if "{:032b}".format(val).count("1") > 32 - 6: # low entrorpy is not `random`
                        continue
                    if (val & 0xf) % 4 != 0: # not aligned, it is maybe `random`
                        self.kmem_cache_offset_random = i * current_arch.ptrsize
                        info("offsetof(kmem_cache, random): {:#x}".format(self.kmem_cache_offset_random))
                        break
                    try:
                        read_int_from_memory(val) # if no error, it is not `random`
                        continue
                    except Exception:
                        self.kmem_cache_offset_random = i * current_arch.ptrsize
                        info("offsetof(kmem_cache, random): {:#x}".format(self.kmem_cache_offset_random))
                        break
            else:
                info("offsetof(kmem_cache, random): Not found")
                self.kmem_cache_offset_random = None # maybe CONFIG_SLAB_FREELIST_HARDENED=n

        # offsetof(kmem_cache, cpu_slab)
        self.kmem_cache_offset_cpu_slab = 0
        # offsetof(kmem_cache, object_size)
        self.kmem_cache_offset_object_size = current_arch.ptrsize * 3 + 4
        # offsetof(kmem_cache_cpu, freelist)
        self.kmem_cache_cpu_offset_freelist = 0
        return True

    def get_next_kmem_cache(self, addr, point_to_base=True):
        if point_to_base:
            addr += self.kmem_cache_offset_list
        return read_int_from_memory(addr) - self.kmem_cache_offset_list

    def get_objsize(self, addr):
        return u32(read_memory(addr + self.kmem_cache_offset_object_size, 4))

    def get_offset(self, addr):
        return u32(read_memory(addr + self.kmem_cache_offset_offset, 4))

    def get_name(self, addr):
        name_addr = read_int_from_memory(addr + self.kmem_cache_offset_name)
        return read_cstring_from_memory(name_addr)

    def get_random(self, addr):
        if self.kmem_cache_offset_random is None:
            return 0
        else:
            return read_int_from_memory(addr + self.kmem_cache_offset_random)

    def get_kmem_cache_cpu(self, addr, cpu):
        cpu_slab = read_int_from_memory(addr + self.kmem_cache_offset_cpu_slab)
        kmem_cache_cpu = cpu_slab + self.cpu_offset[cpu]
        if is_64bit():
            return kmem_cache_cpu & 0xffffffffffffffff
        else:
            return kmem_cache_cpu & 0xffffffff

    def get_freelist(self, addr):
        return read_int_from_memory(addr + self.kmem_cache_cpu_offset_freelist)

    def byteswap(self, x):
        bits = 64 if is_64bit() else 32
        s = 0
        for i in range(0, bits, 8):
            s += ((x >> i) & 0xff) << (bits - (i + 8))
        return s

    def pointer_xor(self, addr, chunk, cache):
        def pattern1(addr, chunk, cache):
            return chunk ^ addr ^ cache['random']

        def pattern2(addr, chunk, cache):
            return chunk ^ self.byteswap(addr) ^ cache['random']

        shift_bits = 48 if is_64bit() else 24

        if self.swap is False:
            chunk = pattern1(addr, chunk, cache)
        elif self.swap is True:
            chunk = pattern2(addr, chunk, cache)

        elif self.swap is None: # swap type is unknown, try heuristic check
            if pattern1(addr, chunk, cache) == 0:
                chunk = pattern1(addr, chunk, cache)
                self.swap = False
            elif (chunk >> shift_bits) == (cache['random'] >> shift_bits):
                chunk = pattern1(addr, chunk, cache)
                self.swap = False
            else:
                chunk = pattern2(addr, chunk, cache)
                self.swap = True
        return chunk

    def walk_caches(self, cpu):
        current_kmem_cache = self.get_next_kmem_cache(self.slab_caches, point_to_base=False)
        self.parsed_caches = [{'name': 'slab_caches', 'next': current_kmem_cache}]
        self.swap = None

        while current_kmem_cache + self.kmem_cache_offset_list != self.slab_caches:
            new_cache = {}
            # parse member
            new_cache['address'] = current_kmem_cache
            new_cache['objsize'] = self.get_objsize(current_kmem_cache)
            new_cache['offset'] = self.get_offset(current_kmem_cache)
            new_cache['name'] = self.get_name(current_kmem_cache)
            new_cache['random'] = self.get_random(current_kmem_cache)
            # parse free_list
            new_cache['kmem_cache_cpu'] = self.get_kmem_cache_cpu(current_kmem_cache, cpu)
            chunk = self.get_freelist(new_cache['kmem_cache_cpu'])
            new_cache['freelist'] = [chunk]
            while chunk:
                try:
                    addr = chunk + new_cache['offset']
                    chunk = read_int_from_memory(addr) # get next chunk
                except Exception:
                    new_cache['freelist'].append("{:s}".format(Color.colorify("Corrupted (Memory access denied)", "bold yellow")))
                    break
                if self.kmem_cache_offset_random is not None: # fix if randomized
                    chunk = self.pointer_xor(addr, chunk, new_cache)
                if chunk % 8:
                    new_cache['freelist'].append("{:#x}: {:s}".format(chunk, Color.colorify("Corrupted (Not aligned)", "bold yellow")))
                    break
                if chunk in new_cache['freelist']:
                    new_cache['freelist'].append("{:#x}: {:s}".format(chunk, Color.colorify("Corrupted (Loop detected)", "bold yellow")))
                    break
                new_cache['freelist'].append(chunk)
            # goto next
            new_cache['next'] = current_kmem_cache = self.get_next_kmem_cache(current_kmem_cache)
            self.parsed_caches.append(new_cache)
        return

    def dump_caches(self, targets, cpu):
        gef_print('  ' + '-' * 14)
        gef_print(' | ' + ' ' * 11 + ' |')
        gef_print(' |        slab_caches @ {:#x}'.format(self.slab_caches))
        gef_print(' | ' + ' ' * 11 + ' |')
        if targets != []:
            gef_print(' | ' + ' ' * 10 + ' ...')
            gef_print(' | ' + ' ' * 11 + ' |')
        gef_print(' | ' + ' ' * 11 + ' v')
        for c in self.parsed_caches[1:]:
            if targets != [] and not c['name'] in targets:
                continue
            gef_print(' |   name: {:s}'.format(c['name']))
            gef_print(' |   kmem_cache: {:#x}'.format(c['address']))
            gef_print(' |   kmem_cache_cpu (cpu{:d}): {:#x}'.format(cpu, c['kmem_cache_cpu']))
            gef_print(' |   offset (offset to next pointer in chunk): {:#x}'.format(c['offset']))
            gef_print(' |   objsize: {:s}'.format(Color.colorify("{:#x}".format(c['objsize']), "bold pink")))
            if c['random']:
                if self.no_xor is False and self.swap is True:
                    gef_print(' |   random (xor key): {:#x} ^ byteswap(address of chunk->next)'.format(c['random']))
                else:
                    gef_print(' |   random (xor key): {:#x} ^ address of chunk->next'.format(c['random']))
            if len(c['freelist']) > 0:
                if isinstance(c['freelist'][0], str):
                    gef_print(' |   freelist:   {:s}'.format(c['freelist'][0]))
                else:
                    gef_print(' |   freelist:   {:s}'.format(Color.colorify("{:#x}".format(c['freelist'][0]), "bold yellow")))
                for f in c['freelist'][1:]:
                    if isinstance(f, str):
                        gef_print(' | ' + ' ' * 14 + '{:s}'.format(f))
                    else:
                        gef_print(' | ' + ' ' * 14 + '{:s}'.format(Color.colorify("{:#x}".format(f), "bold yellow")))
            gef_print(' |   next: {:#x}'.format(c['next']))
            gef_print(' | ' + ' ' * 11 + ' |')
            if targets != []:
                gef_print(' | ' + ' ' * 10 + ' ...')
            gef_print(' | ' + ' ' * 11 + ' |')
            gef_print(' | ' + ' ' * 11 + ' v')
        gef_print('  <' + '-' * 13)
        return

    def dump_names(self):
        gef_print(Color.colorify("Object Size              : Name", get_gef_setting("theme.table_heading")))
        for c in sorted(self.parsed_caches[1:], key=lambda x: x['name']):
            gef_print("{:5d} byte ({:#6x} bytes): {:s}".format(c['objsize'], c['objsize'], c['name']))
        return

    def slabwalk(self, targets):
        if self.init_offset() is False:
            err("Initialize failed")
            return

        if self.listup:
            self.walk_caches(0)
            self.dump_names()
            return

        if self.cpuN is None:
            for i in range(len(self.cpu_offset)):
                gef_print(titlify("CPU {:d}".format(i)))
                self.walk_caches(i)
                self.dump_caches(targets, i)
        else:
            if len(self.cpu_offset) > self.cpuN:
                gef_print(titlify("CPU {:d}".format(self.cpuN)))
                self.walk_caches(self.cpuN)
                self.dump_caches(targets, self.cpuN)
            else:
                err("CPU number is invalid (valid range:{:d}-{:d})".format(0, len(self.cpu_offset) - 1))
        return

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64", "ARM32", "ARM64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        try:
            self.cpuN = None
            while "--cpu" in argv:
                idx = argv.index("--cpu")
                self.cpuN = int(argv[idx + 1])
                argv = argv[:idx] + argv[idx + 2:]
        except Exception:
            self.usage()
            return

        self.no_xor = False
        if "--no-xor" in argv:
            self.no_xor = True
            argv.remove("--no-xor")

        self.listup = False
        if "--list" in argv:
            self.listup = True
            argv.remove("--list")

        info("Wait for memory scan")

        try:
            self.slabwalk(argv)
        except Exception:
            err("Memory corrupted")
        return


@register_command
class KsymaddrRemoteCommand(GenericCommand):
    """Solve kernel symbols from kallsyms table using kenrel memory scanning.
    See: kernel/kallsyms.c"""
    _cmdline_ = "ksymaddr-remote"
    _syntax_ = "{:s} [-h] KEYWORD|--print-all [--head N] [--silent] [--exact] [--meta]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} --print-all # print all symbols found\n".format(_cmdline_)
    _example_ += "{:s} cred --head 30 # print symbols included \"cred\" with only first 30 hit\n".format(_cmdline_)
    _example_ += "{:s} cred --silent # print symbols included \"cred\" with quiet mode\n".format(_cmdline_)
    _example_ += "{:s} commit_creds prepare_kernel_cred # OR search\n".format(_cmdline_)
    _example_ += "Search flow:\n"
    _example_ += "1. get address of kernel_base\n"
    _example_ += "2. get address of kernel_base_rodata\n"
    _example_ += "3. get address of kallsyms_relative_base\n"
    _example_ += "4. get address of kallsyms_names\n"
    _example_ += "5. get address of kallsyms_offsets\n"
    _example_ += "6. get address of kallsyms_token_table\n"
    _example_ += "7. get address of kallsyms_token_index\n"
    _example_ += "8. walk kallsyms\n"
    _example_ += "THIS FEATURE IS EXPERIMENTAL AND HEURISTIC."
    _category_ = "Qemu-system Cooperation"

    def __init__(self, *args, **kwargs):
        super().__init__()
        self.initialized = False
        self.maps = None
        self.kallsyms = []
        return

    def expand_symbol(self, off):
        data = off
        len_ = self.kallsyms_names[data]
        data += 1

        symbol = ""
        skipped_first = False
        off = len_ + 1
        while len_:
            tptr = self.kallsyms_token_index[self.kallsyms_names[data]]
            data += 1
            len_ -= 1

            while True:
                c = self.kallsyms_token_table[tptr]
                if c == 0:
                    break
                if skipped_first:
                    symbol += chr(c)
                else:
                    skipped_first = True
                tptr += 1
        return off, symbol

    def kallsyms_sym_address(self, idx):
        if self.kallsyms_relative_base is None:
            relative_base = 0
        else:
            relative_base = self.kallsyms_relative_base

        val = self.kallsyms_offsets[idx]
        if not self.CONFIG_KALLSYMS_ABSOLUTE_PERCPU:
            return relative_base + val
        if val >= 0:
            return val
        else:
            return relative_base - 1 - val

    def kallsyms_get_symbol_type(self, off):
        idx1 = self.kallsyms_names[off + 1]
        idx2 = self.kallsyms_token_index[idx1]
        typ = self.kallsyms_token_table[idx2]
        return chr(typ)

    def resolve_kallsyms(self):
        if self.kallsyms != []: # resolved already
            return
        off = 0
        for i in range(self.kallsyms_num_syms):
            offdiff, symbol = self.expand_symbol(off)
            typ = self.kallsyms_get_symbol_type(off)
            off += offdiff
            addr = self.kallsyms_sym_address(i)
            self.kallsyms.append([addr, symbol, typ])
        return

    def print_kallsyms(self, keywords):
        if is_32bit():
            fmt = "{:#010x} {:s} {:s}"
        else:
            fmt = "{:#018x} {:s} {:s}"
        print_count = 0
        for addr, symbol, typ in self.kallsyms:
            if print_count == self.head:
                break
            if self.print_all:
                gef_print(fmt.format(addr, typ, symbol))
                print_count += 1
            else:
                for k in keywords:
                    text = fmt.format(addr, typ, symbol)
                    if self.exact and k == symbol:
                        gef_print(text)
                        print_count += 1
                        break
                    elif not self.exact and k in text:
                        gef_print(text)
                        print_count += 1
                        break
        return

    # Initialize variables in different ways, depending on the situation.
    #
    # The variables need to find are as follows.
    # 1. kallsyms_relative_base
    # 2. kallsyms_num_syms
    # 3. kallsyms_names
    # 4. CONFIG_KALLSYMS_ABSOLUTE_PERCPU is enabled or not
    # 5. kallsyms_offsets
    # 6. kallsyms_markers
    # 7. kallsyms_token_table
    # 8. kallsyms_token_index
    #
    # The method for searching the above variables is different for 64bit / 32bit.
    # It also depends on whether each variable in memory has a large padding (called sparse) or not (called normal).
    #
    # Variables to use
    #   self.kbase:         address of kernel .text
    #   self.krobase:       address of kernel .rodata
    #   self.RO_REGION:     data of .rodata; bytes([0xef, 0xbe, 0xad, 0xde...])
    #   self.RO_REGION_u32: data of .rodata; [0xdeadbeef, ...]
    #   self.RO_REGION_u64: data of .rodata; [0x00000000deadbeef, ...]

    # 32bit is very complicated. 64bit is simple
    def initialize32_kallsyms_relative_base(self):
        # 1. find kbase from rodata
        if is_x86_32():
            # recent kernel (buildroot:5.4.58, debian11.3:5.10.0-13)
            for idx, tmp in enumerate(self.RO_REGION_u32[:-1]):
                if tmp & 0xfff: # should be aligned
                    continue
                if (tmp & 0xffff0000) != (self.kbase & 0xffff0000): # holds around kbase
                    continue
                if self.RO_REGION_u32[idx + 1] > 0x4ffff: # next address is kallsyms_num_syms. too large number is fail
                    continue
                if 0 < self.RO_REGION_u32[idx + 1] < 0x100 : # next address is kallsyms_num_syms. too small number is fail
                    continue
                self.kallsyms_relative_base = tmp
                self.kallsyms_relative_base_off = idx
                self.kallsyms_relative_base_addr = self.krobase + self.kallsyms_relative_base_off * 4
                return

            # i386 (ooofs:4.4.223)
            for i, val in enumerate(self.RO_REGION_u32[::-1]): # use backward search because if found multiple then select the last one
                if val == self.kbase:
                    pos = len(self.RO_REGION_u32) - i - 1
                    # found contiguous, go prev as possilbe
                    while self.RO_REGION_u32[pos] == self.RO_REGION_u32[pos - 1]:
                        pos -= 1
                    self.kallsyms_relative_base = self.kbase
                    self.kallsyms_relative_base_off = pos
                    self.kallsyms_relative_base_addr = self.krobase + self.kallsyms_relative_base_off * 4
                    return

        elif is_arm32():
            # recent kernel (debian 11.3:5.10.0-14)
            for idx, tmp in enumerate(self.RO_REGION_u32[:-1]):
                if tmp & 0xfff: # should be aligned
                    continue
                if (tmp & 0xffff0000) != (self.kbase & 0xffff0000): # holds around kbase
                    continue
                if self.RO_REGION_u32[idx + 1] > 0x4ffff: # next address is kallsyms_num_syms. too large number is fail
                    continue
                if 0 < self.RO_REGION_u32[idx + 1] < 0x100 : # next address is kallsyms_num_syms. too small number is fail
                    continue
                self.kallsyms_relative_base = tmp
                self.kallsyms_relative_base_off = idx
                self.kallsyms_relative_base_addr = self.krobase + self.kallsyms_relative_base_off * 4
                return

            # ARM has specific relative_base (buildroot:5.4.58, debian10.4:4.19.0-9)
            for i in range(4):
                try:
                    kbase_diff = -(0x100000 * i + 0xf8000)
                    self.kallsyms_relative_base = self.kbase + kbase_diff
                    self.kallsyms_relative_base_off = self.RO_REGION_u32.index(self.kallsyms_relative_base)
                    self.kallsyms_relative_base_addr = self.krobase + self.kallsyms_relative_base_off * 4
                    if self.meta:
                        info("kbase difference is {:#x}".format(kbase_diff))
                    return
                except Exception:
                    pass

        # not found
        if not self.silent:
            err("Failed to identified kallsyms_relative_base (not found kernel_base in kernel_robase)")
        self.kallsyms_relative_base = None
        self.kallsyms_relative_base_off = None
        self.kallsyms_relative_base_addr = None
        return

    def initialize32_sparse_kallsyms_num_syms(self):
        # 1. next to it (16 bytes aligned)
        self.kallsyms_num_syms_addr = self.kallsyms_relative_base_addr + 0x10
        self.kallsyms_num_syms_off = self.kallsyms_relative_base_off + 4
        self.kallsyms_num_syms = self.RO_REGION_u32[self.kallsyms_num_syms_off]
        return

    def initialize32_sparse_kallsyms_names(self):
        # 1. next to it (16 bytes aligned)
        self.kallsyms_names_addr = self.kallsyms_num_syms_addr + 0x10
        self.kallsyms_names_off = self.kallsyms_num_syms_off + 4
        return

    def initialize32_sparse_CONFIG_KALLSYMS_ABSOLUTE_PERCPU(self):
        # 1. walk to prev and found non-zero value
        # 2. if the MSB of the element is on, then it is pattern 4 at kallsyms_sym_address() in root/kernel/kallsyms.c.
        #    so not pattern 2, therefore, CONFIG_KALLSYMS_ABSOLUTE_PERCPU = True
        pos = self.kallsyms_relative_base_off - 4
        while self.RO_REGION_u32[pos] == 0:
            pos -= 1
        self.CONFIG_KALLSYMS_ABSOLUTE_PERCPU = (((self.RO_REGION_u32[pos] >> 31) & 1) == 1)
        return

    def initialize32_sparse_kallsyms_offsets(self):
        # 1. calc
        if self.kallsyms_relative_base is None:
            self.kallsyms_offsets_addr = self.kallsyms_num_syms_addr - self.kallsyms_num_syms * 4
        else:
            self.kallsyms_offsets_addr = self.kallsyms_relative_base_addr - self.kallsyms_num_syms * 4
        self.kallsyms_offsets_addr &= ~0xf # 16 bytes aligned
        return

    def initialize32_sparse_kallsyms_markers(self):
        # 1. walk to next until zero value
        # 2. align
        pos = self.kallsyms_names_off
        while True:
            if self.RO_REGION_u32[pos] == 0 and pos % 4 == 0:
                self.kallsyms_markers_off = pos
                self.kallsyms_markers_addr = self.krobase + pos * 4
                break
            pos += 1
        return

    def initialize32_sparse_kallsyms_token_table(self):
        # 1. walk to next until zero value
        # 2. align
        pos = self.kallsyms_markers_off
        while True: # use pos above
            v = self.RO_REGION_u32[pos]
            if v & 0xff000000 > 0 or (self.RO_REGION_u32[pos - 1] > 0 and self.RO_REGION_u32[pos - 1] * 4 < v):
                self.kallsyms_token_table_addr = self.krobase + pos * 4
                break
            pos += 4
        return

    def initialize32_sparse_kallsyms_token_index(self):
        # 1. walk to next until contiguous zero value. it is end of marker of kallsyms_token_table
        # 2. align
        pos = self.kallsyms_token_table_addr - self.krobase
        while True:
            if self.RO_REGION[pos] == 0 and self.RO_REGION[pos + 1] == 0:
                pos += 1
                while pos % 16: # need align
                    pos += 1
                self.kallsyms_token_index_addr = self.krobase + pos
                break
            pos += 1
        return

    def initialize32_normal_kallsyms_num_syms(self):
        # 1. next to it
        self.kallsyms_num_syms_addr = self.kallsyms_relative_base_addr + 0x4
        self.kallsyms_num_syms_off = self.kallsyms_relative_base_off + 1
        self.kallsyms_num_syms = self.RO_REGION_u32[self.kallsyms_num_syms_off]
        return

    def initialize32_normal_kallsyms_names(self):
        # 1. next to it
        self.kallsyms_names_addr = self.kallsyms_num_syms_addr + 0x4
        self.kallsyms_names_off = self.kallsyms_num_syms_off + 1
        return

    def initialize32_normal_CONFIG_KALLSYMS_ABSOLUTE_PERCPU(self):
        # 1. prev to it
        # 2. if the MSB of the element is on, then it is pattern 4 at kallsyms_sym_address() in root/kernel/kallsyms.c.
        #    so not pattern 2, therefore, CONFIG_KALLSYMS_ABSOLUTE_PERCPU = True
        pos = self.kallsyms_relative_base_off - 4
        self.CONFIG_KALLSYMS_ABSOLUTE_PERCPU = (((self.RO_REGION_u32[pos] >> 31) & 1) == 1)
        return

    def initialize32_normal_kallsyms_offsets(self):
        # 1. calc
        if self.kallsyms_relative_base is None:
            self.kallsyms_offsets_addr = self.kallsyms_num_syms_addr - self.kallsyms_num_syms * 4
        else:
            self.kallsyms_offsets_addr = self.kallsyms_relative_base_addr - self.kallsyms_num_syms * 4
        return

    def initialize32_normal_kallsyms_markers(self):
        # 1. walk to next until zero value
        # 2. align
        pos = self.kallsyms_names_off
        while True:
            if self.RO_REGION_u32[pos] == 0: # search kallsyms_markers
                self.kallsyms_markers_off = pos
                self.kallsyms_markers_addr = self.krobase + pos * 4 # need not align
                break
            pos += 1
        return

    def initialize32_normal_kallsyms_token_table(self):
        # 1. walk to next until specific value
        # 2. align
        pos = self.kallsyms_markers_off
        pos += 1 # skip first zero
        while True:
            v = self.RO_REGION_u32[pos]
            """
            0xcc7c3ee0:     0x00069468      0x0006a096      0x0006aebe      0x0006baaa
            0xcc7c3ef0:     0x0006c5b4      0x0006d186      0x0006dc59     [0x005f7366] <-- begining of kallsyms_token_table
            0xcc7c3f00:     0x00657374      0x61007474      0x7400646e      0x006e6f69      (heuristic: prev_value * 4 < this_value)
            0xcc7c3f10:     0x66006f66      0x5f656572      0x65735f00      0x656d0074
            0xcc7c3f20:     0x6474006d      0x005f7200      0x74006354      0x63005f6f
            """
            if v == 0 or (v & 0xff000000) > 0 or (self.RO_REGION_u32[pos - 1] > 0 and self.RO_REGION_u32[pos - 1] * 4 < v) :
                self.kallsyms_token_table_addr = self.krobase + pos * 4 # need not align
                break
            pos += 1
        return

    def initialize32_normal_kallsyms_token_index(self):
        # 1. walk to next until contiguous zero value. it is end of marker of kallsyms_token_table
        # 2. align
        pos = self.kallsyms_token_table_addr - self.krobase
        while True:
            if self.RO_REGION[pos] == 0 and self.RO_REGION[pos + 1] == 0:
                pos += 1
                while pos % 4: # need align
                    pos += 1
                self.kallsyms_token_index_addr = self.krobase + pos
                break
            pos += 1
        return

    def initialize64_kallsyms_relative_base(self):
        # 1. find kbase from rodata
        for idx, tmp in enumerate(self.RO_REGION_u64[:-1]):
            if tmp & 0xffff: # kbase should be aligned
                continue
            if (tmp & 0xfffffffffff00000) != (self.kbase & 0xfffffffffff00000): # the candidate holds around kbase (usually just kbase)
                continue
            if self.RO_REGION_u64[idx + 1] > 0x4ffff: # next element is kallsyms_num_syms. too large number is fail
                continue
            self.kallsyms_relative_base = tmp
            self.kallsyms_relative_base_off = idx
            self.kallsyms_relative_base_addr = self.krobase + self.kallsyms_relative_base_off * 8
            return
        if not self.silent:
            err("Failed to identified kallsyms_relative_base (not found kernel_base in kernel_robase)")
        self.kallsyms_relative_base = None
        self.kallsyms_relative_base_off = None
        self.kallsyms_relative_base_addr = None
        return

    def initialize64_sparse_kallsyms_num_syms(self):
        # 1. next to it (256 bytes aligned)
        self.kallsyms_num_syms_addr = self.kallsyms_relative_base_addr + 0x100
        self.kallsyms_num_syms_off = self.kallsyms_relative_base_off + 32
        self.kallsyms_num_syms = self.RO_REGION_u64[self.kallsyms_num_syms_off]
        return

    def initialize64_sparse_kallsyms_names(self):
        # 1. next to it (256 bytes aligned)
        self.kallsyms_names_addr = self.kallsyms_num_syms_addr + 0x100
        self.kallsyms_names_off = self.kallsyms_num_syms_off + 32
        return

    def initialize64_sparse_CONFIG_KALLSYMS_ABSOLUTE_PERCPU(self):
        # 1. walk to prev and found non-zero value
        # 2. if the MSB of the element is on, then it is pattern 4 at kallsyms_sym_address() in root/kernel/kallsyms.c.
        #    so not pattern 2, therefore, CONFIG_KALLSYMS_ABSOLUTE_PERCPU = True
        pos = self.kallsyms_relative_base_off * 2 - 4 # from u64 pos to u32 pos
        while self.RO_REGION_u32[pos] == 0:
            pos -= 1
        self.CONFIG_KALLSYMS_ABSOLUTE_PERCPU = (((self.RO_REGION_u32[pos] >> 31) & 1) == 1)
        return

    def initialize64_sparse_kallsyms_offsets(self):
        # 1. calc
        if self.kallsyms_relative_base is None:
            self.kallsyms_offsets_addr = self.kallsyms_num_syms_addr - self.kallsyms_num_syms * 8
        else:
            self.kallsyms_offsets_addr = self.kallsyms_relative_base_addr - self.kallsyms_num_syms * 4
        self.kallsyms_offsets_addr &= ~0xff # 256 bytes aligned
        return

    def initialize64_sparse_kallsyms_markers(self):
        # 1. walk to next until zero value
        # 2. align
        pos = self.kallsyms_names_off
        while True:
            if self.RO_REGION_u64[pos] == 0 and pos % 32 == 0:
                self.kallsyms_markers_off = pos
                self.kallsyms_markers_addr = self.krobase + pos * 8
                break
            pos += 1
        return

    def initialize64_sparse_kallsyms_token_table(self):
        # 1. walk to next until zero value
        # 2. align
        pos = self.kallsyms_markers_off
        while True: # use pos above
            v = self.RO_REGION_u64[pos]
            if v & 0xffffffffff000000 > 0 or (self.RO_REGION_u64[pos - 1] > 0 and self.RO_REGION_u64[pos - 1] * 4 < v):
                self.kallsyms_token_table_addr = self.krobase + pos * 8
                break
            pos += 32
        return

    def initialize64_sparse_kallsyms_token_index(self):
        # 1. walk to next until contiguous zero value. it is end of marker of kallsyms_token_table
        # 2. align
        pos = self.kallsyms_token_table_addr - self.krobase
        while True:
            if self.RO_REGION[pos] == 0 and self.RO_REGION[pos + 1] == 0:
                pos += 1
                while pos % 256: # need align
                    pos += 1
                self.kallsyms_token_index_addr = self.krobase + pos
                break
            pos += 1
        return

    def initialize64_normal_kallsyms_num_syms(self):
        # 1. next to it
        self.kallsyms_num_syms_addr = self.kallsyms_relative_base_addr + 0x8
        self.kallsyms_num_syms_off = self.kallsyms_relative_base_off + 1
        self.kallsyms_num_syms = self.RO_REGION_u64[self.kallsyms_num_syms_off]
        return

    def initialize64_normal_kallsyms_names(self):
        # 1. next to it
        self.kallsyms_names_addr = self.kallsyms_num_syms_addr + 0x8
        self.kallsyms_names_off = self.kallsyms_num_syms_off + 1
        return

    def initialize64_normal_CONFIG_KALLSYMS_ABSOLUTE_PERCPU(self):
        # 1. prev to it
        # 2. if the MSB of the element is on, then it is pattern 4 at kallsyms_sym_address() in root/kernel/kallsyms.c.
        #    so not pattern 2, therefore, CONFIG_KALLSYMS_ABSOLUTE_PERCPU = True
        pos = self.kallsyms_relative_base_off * 2 - 4 # from u64 pos to u32 pos
        self.CONFIG_KALLSYMS_ABSOLUTE_PERCPU = (((self.RO_REGION_u32[pos] >> 31) & 1) == 1)
        return

    def initialize64_normal_kallsyms_offsets(self):
        # 1. calc
        # 2. align
        if self.kallsyms_relative_base is None:
            self.kallsyms_offsets_addr = self.kallsyms_num_syms_addr - self.kallsyms_num_syms * 8
        else:
            self.kallsyms_offsets_addr = self.kallsyms_relative_base_addr - self.kallsyms_num_syms * 4
        self.kallsyms_offsets_addr &= ~0x7
        return

    def initialize64_normal_kallsyms_markers(self):
        # 1. walk to next until zero value
        # 2. align
        pos = self.kallsyms_names_off * 2 # needs twice to use RO_REGION_u32
        while True:
            if self.RO_REGION_u32[pos] == 0: # search kallsyms_markers
                while pos % 2: # need align
                    pos += 1
                self.kallsyms_markers_off = pos
                self.kallsyms_markers_addr = self.krobase + pos * 4
                break
            pos += 1
        return

    def initialize64_normal_kallsyms_token_table(self):
        # 1. check array type is u32 or u64
        # 2. walk to next until specific value
        # 3. align
        pos = self.kallsyms_markers_off
        if self.RO_REGION_u32[pos] == 0 and self.RO_REGION_u32[pos + 1] == 0: # u64 mode
            if self.meta:
                info("u64 mode at initialize64_normal_kallsyms_token_table")
            """
                0xffffffff987aaf80:     0x0000000000086329      0x000000000008724d
                0xffffffff987aaf90:     0x3131323038656565 *    0x6572007365725f00
                0xffffffff987aafa0:     0x65735f0074736967      0x6c6261005f360074
                0xffffffff987aafb0:     0x656565006c660065      0x2e00656b00647400
            """
            pos = pos // 2 + 1 # skip first zero
            while True:
                if self.RO_REGION_u64[pos] == 0 or (self.RO_REGION_u64[pos] & 0xffffffffff000000) > 0:
                    self.kallsyms_token_table_addr = self.krobase + pos * 8
                    break
                pos += 1
        else: # u32 mode
            if self.meta:
                info("u32 mode at initialize64_normal_kallsyms_token_table")
            """
            [pattern 1 krce]
                0xffffffffbd101840:     0x000595e8      0x0005a026      0x0005a966      0x00000000
                0xffffffffbd101850:     0x00686361 *    0x00706572      0x63007674      0x00636568
                0xffffffffbd101860:     0x7465735f      0x34367800      0x0079735f      0x00343678
                0xffffffffbd101870:     0x00726f63      0x66006354      0x6900726f      0x74005f63
            [pattern 2 poe]
                0xffffffff9a866400:     0x0010c631      0x0010d091      0x0010db64      0x0010e677
                0xffffffff9a866410:     0x0010f0f2      0x00000000      0x00646e61 *    0x61727474
                0xffffffff9a866420:     0x005f6563      0x69676572      0x72657473      0x6f74005f
                0xffffffff9a866430:     0x332e005f      0x6e696600      0x74786500      0x78005f34
            [pattern 3 own buildroot]
                0xffffffff9d0e9dd0:     0x000506f3      0x00051205      0x00051dfc      0x000529fc
                0xffffffff9d0e9de0:     0x0005354d      0x00053fdc      0x00054a51      0x000554e1
                0xffffffff9d0e9df0:     0x6c006563 *    0x62740061      0x00767400      0x7465735f
                0xffffffff9d0e9e00:     0x666e6900      0x676e6900      0x006c6f00      0x00726f66
            [pattern 4 kone_gadget]
                0xffffffff81cfbff0:     0x00056381      0x00056f2b      0x00057a59      0x00058451
                0xffffffff81cfc000:     0x00058ebd      0x0005994f      0x00686361 *    0x7465735f
                0xffffffff81cfc010:     0x65686300      0x6f630063      0x76740072      0x70657200
                0xffffffff81cfc020:     0x726f6600      0x34367800      0x0079735f      0x00343678
            """
            pos += 1 # skip first zero
            pos += 2 # we want to use (pos, pos-1, pos-2), so avoid bug
            while True:
                if self.RO_REGION_u32[pos] == 0: # pattern 1, 2
                    self.kallsyms_token_table_addr = self.krobase + (pos + 1) * 4
                    break
                diff1 = self.RO_REGION_u32[pos - 1] - self.RO_REGION_u32[pos - 2]
                diff2 = self.RO_REGION_u32[pos - 0] - self.RO_REGION_u32[pos - 1]
                if diff1 * 100 < diff2: # pattern 3, 4
                    self.kallsyms_token_table_addr = self.krobase + pos * 4
                    break
                pos += 1
        return

    def initialize64_normal_kallsyms_token_index(self):
        # 1. walk to next until contiguous zero value. it is end of marker of kallsyms_token_table
        # 2. align
        pos = self.kallsyms_token_table_addr - self.krobase
        while True:
            if self.RO_REGION[pos] == 0 and self.RO_REGION[pos + 1] == 0:
                pos += 1
                while pos % 8: # need align
                    pos += 1
                self.kallsyms_token_index_addr = self.krobase + pos
                break
            pos += 1
        return

    def initialize32_kallsyms_num_syms_2(self):
        # 1. walk next
        # because used aboslute value, similar addresses are lined up
        # 0xc1940888:     0xc1000000      0xc1000000      0xc10000bc      0xc10000cc
        # 0xc1940898:     0xc10000ed      0xc1000165      0xc10001e7      0xc1000239
        # ...
        # 0xc198f0ac:     0xc1e85000      0xc1e95000      0xc1e9b000      0xc1e9b000
        # 0xc198f0bc:     0x00013a0d <- kallsyms_num_syms_addr
        pos = self.kallsyms_relative_base_off
        while True:
            val = self.RO_REGION_u32[pos]
            if val != 0 and (val >> 20) == 0:
                self.kallsyms_num_syms_addr = self.krobase + pos * 4
                self.kallsyms_num_syms_off = pos
                self.kallsyms_num_syms = val
                break
            pos += 1
        return

    def initialize64_kallsyms_num_syms_2(self):
        # 1. walk next
        # because used aboslute value, similar addresses are lined up
        pos = self.kallsyms_relative_base_off
        while True:
            val = self.RO_REGION_u64[pos]
            if val != 0 and (val >> 32) == 0:
                self.kallsyms_num_syms_addr = self.krobase + pos * 8
                self.kallsyms_num_syms_off = pos
                self.kallsyms_num_syms = val
                break
            pos += 1
        return

    def initialize32(self):
        self.RO_REGION = read_memory(self.krobase, self.krobase_size)
        self.RO_REGION_u32 = [u32(self.RO_REGION[i:i + 4]) for i in range(0, len(self.RO_REGION), 4)]
        self.initialize32_kallsyms_relative_base()

        if self.kallsyms_relative_base_off is None:
            return None

        # rare case (maybe no kASLR kernel)
        if self.RO_REGION_u32[self.kallsyms_relative_base_off + 1] == self.RO_REGION_u32[self.kallsyms_relative_base_off]:
            self.initialize32_kallsyms_num_syms_2() # common to sparse and normal
            # do not use kallsyms_relative_base, use absolute value
            self.kallsyms_relative_base = None
            if self.RO_REGION_u32[self.kallsyms_num_syms_off + 1] == 0: # sparse mode (rare case)
                if self.meta:
                    info("does not detect relative_base. treat as sparse mode (rare case)")
                # all variables placed as 16 bytes aligned
                self.initialize32_sparse_kallsyms_names()
                self.initialize32_sparse_CONFIG_KALLSYMS_ABSOLUTE_PERCPU()
                self.initialize32_sparse_kallsyms_offsets()
                self.initialize32_sparse_kallsyms_markers()
                self.initialize32_sparse_kallsyms_token_table()
                self.initialize32_sparse_kallsyms_token_index()
            else: # normal mode (rare case)
                if self.meta:
                    info("does not detect relative_base, treat as normal mode (rare case)")
                self.initialize32_normal_kallsyms_names()
                self.initialize32_normal_CONFIG_KALLSYMS_ABSOLUTE_PERCPU()
                self.initialize32_normal_kallsyms_offsets()
                self.initialize32_normal_kallsyms_markers()
                self.initialize32_normal_kallsyms_token_table()
                self.initialize32_normal_kallsyms_token_index()
        elif self.RO_REGION_u32[self.kallsyms_relative_base_off + 1] == 0: # sparse mode
            if self.meta:
                info("detect relative_base, treat as sparse mode")
            # all variables placed as 16 bytes aligned
            self.initialize32_sparse_kallsyms_num_syms()
            self.initialize32_sparse_kallsyms_names()
            self.initialize32_sparse_CONFIG_KALLSYMS_ABSOLUTE_PERCPU()
            self.initialize32_sparse_kallsyms_offsets()
            self.initialize32_sparse_kallsyms_markers()
            self.initialize32_sparse_kallsyms_token_table()
            self.initialize32_sparse_kallsyms_token_index()
        else: # normal mode
            if self.meta:
                info("detect relative_base, treat as normal mode")
            self.initialize32_normal_kallsyms_num_syms()
            self.initialize32_normal_kallsyms_names()
            self.initialize32_normal_CONFIG_KALLSYMS_ABSOLUTE_PERCPU()
            self.initialize32_normal_kallsyms_offsets()
            self.initialize32_normal_kallsyms_markers()
            self.initialize32_normal_kallsyms_token_table()
            self.initialize32_normal_kallsyms_token_index()
        return True

    def initialize64(self):
        self.RO_REGION = read_memory(self.krobase, self.krobase_size)
        self.RO_REGION_u64 = [u64(self.RO_REGION[i:i + 8]) for i in range(0, len(self.RO_REGION), 8)]
        self.RO_REGION_u32 = [u32(self.RO_REGION[i:i + 4]) for i in range(0, len(self.RO_REGION), 4)]
        self.initialize64_kallsyms_relative_base()

        if self.RO_REGION_u64[self.kallsyms_relative_base_off + 1] == self.RO_REGION_u64[self.kallsyms_relative_base_off]: # rare case
            self.initialize64_kallsyms_num_syms_2() # common to sparse and normal
            # do not use kallsyms_relative_base, use absolute value
            self.kallsyms_relative_base = None
            if self.RO_REGION_u64[self.kallsyms_num_syms_off + 1] == 0: # sparse mode (rare case)
                if self.meta:
                    info("does not detect relative_base, treat as sparse mode (rare case)")
                # all variables placed as 256 bytes aligned
                self.initialize64_sparse_kallsyms_names()
                self.initialize64_sparse_CONFIG_KALLSYMS_ABSOLUTE_PERCPU()
                self.initialize64_sparse_kallsyms_offsets()
                self.initialize64_sparse_kallsyms_markers()
                self.initialize64_sparse_kallsyms_token_table()
                self.initialize64_sparse_kallsyms_token_index()
            else: # normal mode (rare case)
                if self.meta:
                    info("does not detect relative_base, treat as normal mode (rare case)")
                self.initialize64_normal_kallsyms_names()
                self.initialize64_normal_CONFIG_KALLSYMS_ABSOLUTE_PERCPU()
                self.initialize64_normal_kallsyms_offsets()
                self.initialize64_normal_kallsyms_markers()
                self.initialize64_normal_kallsyms_token_table()
                self.initialize64_normal_kallsyms_token_index()
        elif self.RO_REGION_u64[self.kallsyms_relative_base_off + 1] == 0: # sparse mode
            if self.meta:
                info("detect relative_base, treat as sparse mode")
            # all variables placed as 256 bytes aligned
            self.initialize64_sparse_kallsyms_num_syms()
            self.initialize64_sparse_kallsyms_names()
            self.initialize64_sparse_CONFIG_KALLSYMS_ABSOLUTE_PERCPU()
            self.initialize64_sparse_kallsyms_offsets()
            self.initialize64_sparse_kallsyms_markers()
            self.initialize64_sparse_kallsyms_token_table()
            self.initialize64_sparse_kallsyms_token_index()
        else: # normal mode
            if self.meta:
                info("detect relative_base, treat as normal mode")
            self.initialize64_normal_kallsyms_num_syms()
            self.initialize64_normal_kallsyms_names()
            self.initialize64_normal_CONFIG_KALLSYMS_ABSOLUTE_PERCPU()
            self.initialize64_normal_kallsyms_offsets()
            self.initialize64_normal_kallsyms_markers()
            self.initialize64_normal_kallsyms_token_table()
            self.initialize64_normal_kallsyms_token_index()
        return True

    def print_meta(self, force=False):
        if self.meta or force:
            try:
                info("kernel_base:            {:#x}".format(self.kbase)) # to search kallsyms_*
                info("kernel_robase:          {:#x}".format(self.krobase)) # to search kallsyms_*
                if self.kallsyms_relative_base:
                    info("kallsyms_relative_base: {:#x}: {:#x}".format(self.kallsyms_relative_base_addr, self.kallsyms_relative_base))
                    info("kallsyms_num_syms:      {:#x}: {:#x}".format(self.kallsyms_num_syms_addr, self.kallsyms_num_syms))
                    gdb.execute("x/4x{} {}".format(["w", "g"][is_64bit()], self.kallsyms_relative_base_addr))
                else:
                    info("kallsyms_relative_base: None")
                    info("kallsyms_num_syms:      {:#x}: {:#x}".format(self.kallsyms_num_syms_addr, self.kallsyms_num_syms))
                    gdb.execute("x/4x{} {}".format(["w", "g"][is_64bit()], self.kallsyms_num_syms_addr))
                info("kallsyms_names          {:#x}".format(self.kallsyms_names_addr)) # to lookup symbol
                gdb.execute("x/8x{} {}".format(["w", "g"][is_64bit()], self.kallsyms_names_addr - 0x10))
                info("CONFIG_KALLSYMS_ABSOLUTE_PERCPU: {:d}".format(self.CONFIG_KALLSYMS_ABSOLUTE_PERCPU)) # to calculate address
                info("kallsyms_offsets:       {:#x}".format(self.kallsyms_offsets_addr)) # to lookup symbol
                gdb.execute("x/8x{} {}".format(["w", "g"][is_64bit()], self.kallsyms_offsets_addr - 0x10))
                info("kallsyms_markers:       {:#x}".format(self.kallsyms_markers_addr)) # to search kallsyms_*
                gdb.execute("x/8x{} {}".format(["w", "g"][is_64bit()], self.kallsyms_markers_addr - 0x10))
                info("kallsyms_token_table:   {:#x}".format(self.kallsyms_token_table_addr)) # to calculate address
                gdb.execute("x/8x{} {}".format(["w", "g"][is_64bit()], self.kallsyms_token_table_addr - 0x10))
                info("kallsyms_token_index:   {:#x}".format(self.kallsyms_token_index_addr)) # to calculate address
                gdb.execute("x/8x{} {}".format(["w", "g"][is_64bit()], self.kallsyms_token_index_addr - 0x10))
            except Exception:
                pass
        return

    def initialize(self):
        if self.initialized:
            self.print_meta()
            return True
        # get kernel memory maps
        if not self.silent:
            info("Wait for memory scan")
        dic = KernelbaseCommand.get_kernel_base()
        if None in dic.values():
            err("Failed to resolve")
            return None
        self.maps = dic["maps"]
        self.kbase = dic["kbase"]
        self.kbase_size = dic["kbase_size"]
        self.krobase = dic["krobase"]
        self.krobase_size = dic["krobase_size"]
        # resolve some address
        if is_32bit():
            res = self.initialize32()
        elif is_64bit():
            res = self.initialize64()
        if res:
            # prepare each byte array
            if self.kallsyms_relative_base is None:
                r = self.RO_REGION[self.kallsyms_offsets_addr - self.krobase: self.kallsyms_num_syms_addr - self.krobase]
                if is_64bit():
                    self.kallsyms_offsets = [u64(r[i:i + 8]) for i in range(0, len(r), 8)] # unsigned 64bit
                else:
                    self.kallsyms_offsets = [u32(r[i:i + 4]) for i in range(0, len(r), 4)] # unsigned 32bit
            else:
                r = self.RO_REGION[self.kallsyms_offsets_addr - self.krobase: self.kallsyms_relative_base_addr - self.krobase]
                self.kallsyms_offsets = [u32(r[i:i + 4], s=True) for i in range(0, len(r), 4)] # signed 32bit
            r = self.RO_REGION[self.kallsyms_names_addr - self.krobase: self.kallsyms_markers_addr - self.krobase]
            self.kallsyms_names = [u8(r[i:i + 1]) for i in range(0, len(r), 1)] # 8bit
            r = self.RO_REGION[self.kallsyms_token_table_addr - self.krobase: self.kallsyms_token_index_addr - self.krobase]
            self.kallsyms_token_table = [u8(r[i:i + 1]) for i in range(0, len(r), 1)] # 8bit
            r = self.RO_REGION[self.kallsyms_token_index_addr - self.krobase:][:0x100 * 2] # fixed table size
            self.kallsyms_token_index = [u16(r[i:i + 2]) for i in range(0, len(r), 2)] # 16bit
            self.initialized = True
        # finish
        self.print_meta()
        return True if res else False

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64", "ARM32", "ARM64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        if not argv:
            self.usage()
            return

        if "-h" in argv:
            self.usage()
            return

        self.meta = False
        if "--meta" in argv:
            self.meta = True
            argv.remove("--meta")

        self.silent = False
        if "--silent" in argv:
            self.silent = True
            argv.remove("--silent")

        self.exact = False
        if "--exact" in argv:
            self.exact = True
            argv.remove("--exact")

        self.head = -1
        if "--head" in argv:
            try:
                idx = argv.index("--head")
                headN = argv[idx + 1]
                self.head = int(headN)
                argv = argv[:idx] + argv[idx + 2:]
            except Exception:
                self.usage()
                return

        self.print_all = False
        if "--print-all" in argv:
            self.print_all = True
            argv.remove("--print-all")
        if argv == []:
            self.print_all = True

        if not self.initialize():
            return
        self.resolve_kallsyms()
        self.print_kallsyms(argv)
        return


@register_command
class VmlinuxToElfApplyCommand(GenericCommand):
    """Apply symbol from kallsyms in memory using vmlinux-to-elf (too slow but more accurate)"""
    _cmdline_ = "vmlinux-to-elf-apply"
    _syntax_ = "{:s} [--reparse]".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    @staticmethod
    def dump_kernel_elf(dumped_mem_file, symboled_vmlinux_file, force=False):
        """Dump the kernel from the memory, then apply vmlinux-to-elf to create symboled ELF"""
        # check
        try:
            vmlinux2elf = which("vmlinux-to-elf")
        except FileNotFoundError as e:
            err("{}".format(e))
            return None

        # resolve kbase, krobase
        info("Wait for memory scan")

        dic = KernelbaseCommand.get_kernel_base()
        if None in dic.values():
            err("Failed to resolve")
            return None

        gef_print("kernel base:   {:#x} ({:#x} bytes)".format(dic["kbase"], dic["kbase_size"]))
        gef_print("kernel rodata: {:#x} ({:#x} bytes)".format(dic["krobase"], dic["krobase_size"]))
        gef_print("kernel data:   {:#x} ({:#x} bytes)".format(dic["krwbase"], dic["krwbase_size"]))

        # resolve area
        area = []
        for addr in dic['maps']:
            if addr[0] < dic['kbase']:
                continue
            if addr[0] >= dic['krwbase']:
                continue
            area.append([addr[0], addr[0] + addr[1]])
        if area == []:
            err("area is blank")
            return None

        # check if it can be reused
        if not force and os.path.exists(symboled_vmlinux_file):
            data = open(symboled_vmlinux_file, "rb").read()
            data = ''.join([chr(x) for x in data])
            r1 = re.findall(r"(Linux version (?:\d+\.[\d.]*\d)[ -~]+)", data)

            data = read_memory(dic["krobase"], dic["krobase_size"])
            data = ''.join([chr(x) for x in data])
            r2 = re.findall(r"(Linux version (?:\d+\.[\d.]*\d)[ -~]+)", data)

            if r1 and r2 and r1[0] != r2[0]:
                info("Run vmlinux-to-elf again because the kernel version is different")
                force = True

        # dump memory
        if force or (not os.path.exists(dumped_mem_file) and not os.path.exists(symboled_vmlinux_file)):
            # remove old file
            if os.path.exists(dumped_mem_file):
                info("Remove old {}".format(dumped_mem_file))
                os.unlink(dumped_mem_file)

            # dump
            info("Dumping memory")
            old_end_addr = None
            for i, (start_addr, end_addr) in enumerate(area):
                if i == 0:
                    gef_print("Dumping area:     {:#x} - {:#x}".format(start_addr, end_addr))
                    try:
                        gdb.execute("dump memory {} {:#x} {:#x}".format(dumped_mem_file, start_addr, end_addr), to_string=True)
                    except gdb.MemoryError:
                        err("Memory read error. Make sure the context is in supervisor mode / Ring-0")
                        return None
                else:
                    size_diff = start_addr - old_end_addr
                    if size_diff:
                        gef_print("Non-mapping area: {:#x} - {:#x} (ZERO fill)".format(old_end_addr, start_addr))
                        open(dumped_mem_file, "a").write("\0" * size_diff)
                    gef_print("Dumping area:     {:#x} - {:#x}".format(start_addr, end_addr))
                    try:
                        gdb.execute("append memory {} {:#x} {:#x}".format(dumped_mem_file, start_addr, end_addr), to_string=True)
                    except gdb.MemoryError:
                        err("Memory read error. Make sure the context is in supervisor mode / Ring-0")
                        return None
                old_end_addr = end_addr
            gef_print("Dumped to {}".format(dumped_mem_file))
        else:
            # reuse by default
            pass

        # apply vmlinux-to-elf
        if force or not os.path.exists(symboled_vmlinux_file):
            info("Execute `{} '{}' '{}' --base-address={:#x}`".format(vmlinux2elf, dumped_mem_file, symboled_vmlinux_file, dic["kbase"]))
            os.system("{} '{}' '{}' --base-address={:#x}".format(vmlinux2elf, dumped_mem_file, symboled_vmlinux_file, dic["kbase"]))
        else:
            # reuse by default
            pass

        # Error
        if not os.path.exists(symboled_vmlinux_file):
            return None
        if os.path.getsize(symboled_vmlinux_file) == 0:
            return None

        # Success
        return dic

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64", "ARM32", "ARM64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        force_reparse = False
        if "--reparse" in argv:
            force_reparse = True
            argv.remove("--reparse")

        if argv:
            self.usage()
            return

        DUMPED_MEM_FILE = "/tmp/gef-dump-memory.raw"
        SYMBOLED_VMLINUX_FILE = "/tmp/gef-dump-memory.elf"
        dic = self.dump_kernel_elf(DUMPED_MEM_FILE, SYMBOLED_VMLINUX_FILE, force=force_reparse)
        if dic is None:
            err("Failed to create kernel ELF")
            return

        # load symbol
        info("Adding symbol")
        # Prior to gdb 8.x, add-symbol-file command requires a .text address
        #   gdb 9.x: Usage: add-symbol-file FILE [-readnow | -readnever] [-o OFF] [ADDR] [-s SECT-NAME SECT-ADDR]...
        #   gdb 8.x: Usage: add-symbol-file FILE ADDR [-readnow | -readnever | -s SECT-NAME SECT-ADDR]...
        # But the created ELF has no .text, only a .kernel
        # Applying an empty symbol has no effect, so tentatively specify the same address as the .kernel.
        cmd = "add-symbol-file {} {:#x} -s .kernel {:#x}".format(SYMBOLED_VMLINUX_FILE, dic['kbase'], dic['kbase'])
        info(cmd)
        gdb.execute(cmd)
        return


@register_command
class TcmallocDumpCommand(GenericCommand):
    """tcmalloc thread_heap freelist viewer (supported x86_64 only)."""
    _cmdline_ = "tcmalloc-dump"
    _syntax_ = "{:s} old|chrome [-h] [self|all|NAME[,NAME,..]|central] [--th PRINT_THRESHOLD] [--idx PRINT_TARGET_IDX]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} chrome\n".format(_cmdline_)
    _example_ += "{:s} chrome self # (default) print freelist of thread cache for current thread\n".format(_cmdline_)
    _example_ += "{:s} chrome all # print freelist of thread cache for all thread\n".format(_cmdline_)
    _example_ += "{:s} chrome \"Chrome_DevTools,Bluez D-Bus thr\" # print freelist of thread cache for specified thread\n".format(_cmdline_)
    _example_ += "{:s} chrome central # print freelist of central cache\n".format(_cmdline_)
    _example_ += "{:s} chrome --th 10 --idx 32 # Number of chunks to display per freelist = 10, target idx = 32.\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "THIS FEATURE IS EXPERIMENTAL AND HEURISTIC."
    _category_ = "Heap"

    def __init__(self, *args, **kwargs):
        prefix = kwargs.get("prefix", True)
        super().__init__(prefix=prefix)
        self.initialized = None
        return

    def get_central_cache_(self):
        try:
            return parse_address("&'tcmalloc::Static::central_cache_'")
        except Exception:
            return None

    def get_thread_heaps_(self):
        try:
            return parse_address("&'tcmalloc::ThreadCache::thread_heaps_'")
        except Exception:
            return None

    def get_sizemap(self):
        try:
            return parse_address("&'tcmalloc::Static::sizemap_'")
        except Exception:
            return None

    def get_tls_addr(self, lwpid):
        PTRACE_ARCH_PRCTL = 30
        ARCH_GET_FS = 0x1003
        ppvoid = ctypes.POINTER(ctypes.c_void_p)
        fsvalue = ppvoid(ctypes.c_void_p())
        fsvalue.contents.value = 0
        libc = ctypes.CDLL('libc.so.6')
        result = libc.ptrace(PTRACE_ARCH_PRCTL, lwpid, fsvalue, ARCH_GET_FS)
        if result == 0:
            return fsvalue.contents.value
        else:
            return None

    def get_thread_list(self): # create dict: {tls_addr: lwpid}
        dic = {}
        lwpids = []
        for inf in gdb.inferiors():
            lwpids += [x.ptid[1] for x in inf.threads()]
        for lwpid in lwpids:
            tls = self.get_tls_addr(lwpid)
            if tls is not None:
                dic[tls] = lwpid
        return dic

    def get_thread_name_list(self): # create dict: {lwpid: name}
        lines = gdb.execute("info threads", to_string=True)
        dic = {}
        for line in lines.splitlines():
            r = re.findall(r'\(LWP (\d+)\) "(.+?)"', line)
            if not r:
                continue
            lwpid, name = int(r[0][0]), r[0][1]
            dic[lwpid] = name
        return dic

    def dump_thread_heap_freelist_single(self, freelist, idx):
        if self.FreeList_print_target_index is None:
            pass
        elif self.FreeList_print_target_index != idx:
            return

        seen = []
        chunk = read_int_from_memory(freelist + self.FreeList_offset_list)
        length = read_int_from_memory(freelist + self.FreeList_offset_length) & 0xffffffff
        real_length = 0
        error = False
        if chunk != 0: # freelist exists
            chunklist_string = ""
            while chunk != 0:
                real_length += 1
                seen.append(chunk)
                # print threshold check
                if real_length < self.FreeList_print_threshold:
                    chunklist_string += " -> " + Color.colorify(f"{chunk:#x}", "yellow bold underline")
                else:
                    if not chunklist_string.endswith(" -> ..."):
                        chunklist_string += " -> ..."
                # corrupted memory check
                try:
                    chunk = read_int_from_memory(chunk)
                except Exception:
                    if chunklist_string.endswith(" -> ..."):
                        chunklist_string += " -> " + Color.colorify(f"{seen[-2]:#x}", "yellow bold underline")
                        chunklist_string += " -> " + Color.colorify(f"{chunk:#x}", "red bold underline")
                    chunklist_string += " (corrupted)"
                    error = True
                    break
                # heap key decode
                chunk ^= self.get_heap_key()
                # loop check
                if chunk in seen:
                    chunklist_string += " -> " + Color.colorify(f"{chunk:#x}", "red bold underline") + " (loop)"
                    error = True
                    break
            # corrupted length check
            if length != real_length and error is False:
                chunklist_string += " (length currupted)"
                error = True
            # print
            chunksize = self.index_to_size(freelist, idx)
            if chunksize is None:
                gef_print(f"freelist[idx={idx:2d}, size=unknown, len={length:d}] @ {freelist:#x}{chunklist_string}")
            else:
                chunksize = Color.colorify("{:#x}".format(chunksize), "bold pink")
                gef_print(f"freelist[idx={idx:2d}, size={chunksize}, len={length:d}] @ {freelist:#x}{chunklist_string}")
        return

    def dump_thread_heap_freelist_array(self, thread_heap):
        # lwpid check
        tls = read_int_from_memory(thread_heap + self.ThreadCache_offset_tls)
        lwpid = self.get_thread_list()[tls]
        _, current_lwpid, _ = gdb.selected_thread().ptid
        name = self.get_thread_name_list()[lwpid]

        if self.FreeList_print_target_thread == "all":
            pass
        elif self.FreeList_print_target_thread == "self" and lwpid != current_lwpid:
            return
        elif isinstance(self.FreeList_print_target_thread, list) and name not in self.FreeList_print_target_thread:
            return

        current_or_not = "(current thread)" if lwpid == current_lwpid else ""
        gef_print(titlify(f"thread cache [lwpid={lwpid}{current_or_not:s},name=\"{name}\"] @ {thread_heap:#x} freelist"))

        freelist = thread_heap + self.ThreadCache_offset_freelist_array
        for i in range(self.ThreadCache_freelist_slot_count):
            self.dump_thread_heap_freelist_single(freelist, i)
            freelist += self.sizeof_FreeList
        return

    def dump_thread_heaps(self):
        thread_heap_head = self.get_thread_heaps_()
        if thread_heap_head is None:
            err("Not found tcmalloc::ThreadCache::thread_heaps_")
            return
        gef_print(titlify(f"thread_heaps_ (head) @ {thread_heap_head:#x}"))

        heap_key = self.get_heap_key()
        if heap_key != 0:
            gef_print(f"heap_key: {heap_key:#x} (xor chunk->fd)")

        thread_heap = read_int_from_memory(thread_heap_head)
        while thread_heap:
            self.dump_thread_heap_freelist_array(thread_heap)
            thread_heap = read_int_from_memory(thread_heap + self.ThreadCache_offset_next)
        return

    def dump_central_cache_freelist_single(self, freelist, _i, _j):
        seen = []
        chunk = read_int_from_memory(freelist + self.FreeList_offset_list)
        real_length = 0
        if chunk != 0: # freelist exists
            chunklist_string = ""
            while chunk != 0:
                real_length += 1
                seen.append(chunk)
                # print threshold check
                if real_length < self.FreeList_print_threshold:
                    chunklist_string += " -> " + Color.colorify(f"{chunk:#x}", "yellow bold underline")
                else:
                    if not chunklist_string.endswith(" -> ..."):
                        chunklist_string += " -> ..."
                # corrupted memory check
                try:
                    chunk = read_int_from_memory(chunk)
                except Exception:
                    if chunklist_string.endswith(" -> ..."):
                        chunklist_string += " -> " + Color.colorify(f"{seen[-2]:#x}", "yellow bold underline")
                        chunklist_string += " -> " + Color.colorify(f"{chunk:#x}", "red bold underline")
                    chunklist_string += " (corrupted)"
                    break
                # heap key decode
                chunk ^= self.get_heap_key()
                # loop check
                if chunk in seen:
                    chunklist_string += " -> " + Color.colorify(f"{chunk:#x}", "red bold underline") + " (loop)"
                    break
            # print
            gef_print(f"central_cache_[{_i}].tc_slot[{_j}] @ {freelist:#x}{chunklist_string}")
        return

    def dump_central_cache(self):
        central_cache_ = self.get_central_cache_()
        if central_cache_ is None:
            err("Not found tcmalloc::Static::central_cache_")
            return
        gef_print(titlify(f"central_cache_ @ {central_cache_:#x}"))

        heap_key = self.get_heap_key()
        if heap_key != 0:
            gef_print(f"heap_key: {heap_key:#x} (xor chunk->fd)")

        for i in range(self.CentralCache_array_count):
            central_cache_i = central_cache_ + i * self.sizeof_CentralCache # &central_cache[i]

            # check slot count
            used_slots = read_int_from_memory(central_cache_i + self.CentralCache_offset_used_slots_) & 0xffffffff
            max_slots = self.CentralCache_freelist_slot_count
            if used_slots == 0:
                continue

            # calc class -> size
            size_class = read_int_from_memory(central_cache_i + self.CentralCache_offset_size_class_)
            class_to_size_array = [
                0,     16,    32,    48,    64,   80,    96,    112,   128,   144,
                160,   176,   192,   208,   224,  240,   256,   288,   320,   352,
                384,   448,   512,   576,   640,  704,   768,   896,   1024,  1152,
                1280,  1536,  1792,  2048,  2304, 2560,  2816,  3072,  3328,  4096,
                4608,  5120,  6144,  6656,  8192, 10240, 12288, 13312, 16384, 20480,
                24576, 28672, 32768,
            ]
            size_byte = class_to_size_array[size_class]

            # dump
            gef_print(titlify(f"central_cache_[{i}] @ {central_cache_i:#x} (used_slots:{used_slots}/{max_slots}, chunk_size:{size_byte:#x})"))
            tc_slots = central_cache_i + self.CentralCache_offset_tc_slots_ # &central_cache[i].tc_slots_
            for j in range(min(used_slots, self.CentralCache_freelist_slot_count)):
                addr = tc_slots + j * 0x10 # &central_cache[i].tc_slots_[j]
                self.dump_central_cache_freelist_single(addr, i, j)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if not self.initialized:
            self.usage()
            return

        if not is_x86_64():
            err("Unsupported")
            return

        if "-h" in argv:
            self.usage()
            return

        self.FreeList_print_threshold = 5
        if "--th" in argv:
            try:
                idx = argv.index("--th")
                self.FreeList_print_threshold = int(argv[idx + 1], 0)
                argv = argv[:idx] + argv[idx + 2:]
            except Exception:
                self.usage()
                return

        self.FreeList_print_target_index = None
        if "--idx" in argv:
            try:
                idx = argv.index("--idx")
                self.FreeList_print_target_index = int(argv[idx + 1], 0)
                argv = argv[:idx] + argv[idx + 2:]
            except Exception:
                self.usage()
                return

        if argv and argv[0] == "central":
            self.dump_central_cache()
            return

        self.FreeList_print_target_thread = "self"
        if argv:
            if argv[0] in ['all', 'self']:
                self.FreeList_print_target_thread = argv[0]
            else:
                self.FreeList_print_target_thread = argv[0].split(",")
        self.dump_thread_heaps()
        return


@register_command
class TcmallocDumpChromeCommand(TcmallocDumpCommand):
    """tcmalloc (chrome edition (improved from google-perftools-2.5)) freelist viewer (supported x86_64 only)."""
    _cmdline_ = "tcmalloc-dump chrome"
    _syntax_ = "tcmalloc-dump chrome [-h] [self|all|NAME[,NAME,..]|central] [--th PRINT_THRESHOLD] [--idx PRINT_TARGET_IDX]"
    _category_ = "Heap"

    def __init__(self):
        super().__init__(prefix=False)
        # chromium/third_party/tcmalloc/chromium/src/common.h
        self.kClassSizesMax = 96
        self.kMaxSize = 32 * 1024
        self.kClassArraySize = ((self.kMaxSize + 127 + (120 << 7)) >> 7) + 1
        # chromium/third_party/tcmalloc/chromium/src/thread_cache.h
        """
        00000000 ThreadCache     struc ; (sizeof=0xC48, align=0x8)
        00000000 list_           FreeList 96 dup(?) # kClassSizesMax
        00000C00 size_           dd ?
        00000C04 max_size_       dd ?
        00000C08 total_bytes_allocated_ dd ?
        00000C0C unused          dd ?
        00000C10 sampler_        Sampler ?
        00000C28 tid_            dq ?
        00000C30 in_setspecific_ db ?
        00000C31 unused2         db 7 dup(?)
        00000C38 next_           dq ?
        00000C40 prev_           dq ?
        00000C48 ThreadCache     ends
        """
        self.ThreadCache_offset_next = 0xc38
        self.ThreadCache_offset_freelist_array = 0x0
        self.ThreadCache_offset_tls = 0xc28 # actually this is not tid, but TLS base address
        self.ThreadCache_freelist_slot_count = self.kClassSizesMax
        # chromium/third_party/tcmalloc/chromium/src/thread_cache.h
        """
        00000000 FreeList        struc ; (sizeof=0x20, align=0x8)
        00000000 list_           dq ?
        00000008 length_         dd ?
        0000000C lowater_        dd ?
        00000010 max_length_     dd ?
        00000014 length_overages_ dd ?
        00000018 size_           dd ?
        0000001C unused          dd ?
        00000020 FreeList        ends
        """
        self.sizeof_FreeList = 0x20
        self.FreeList_offset_list = 0x0
        self.FreeList_offset_length = 0x8
        self.FreeList_offset_size = 0x18
        # chromium/third_party/tcmalloc/chromium/src/central_freelist.h
        self.kMaxNumTransferEntries = 64
        self.CentralCache_freelist_slot_count = self.kMaxNumTransferEntries
        # chromium/third_party/tcmalloc/chromium/src/static_vars.cc
        self.CentralCache_array_count = self.kClassSizesMax
        # chromium/third_party/tcmalloc/chromium/src/central_freelist.h
        """
        struct TCEntry {
          void *head;  // Head of chain of objects.
          void *tail;  // Tail of chain of objects.
        };
        class central_cache_[kClassSizesMax=96]
          0x0   SpinLock lock_;
          0x8   size_t   size_class_;     // My size class
          0x10  Span     empty_;          // Dummy header for list of empty spans
          0x40  Span     nonempty_;       // Dummy header for list of non-empty spans
          0x70  size_t   num_spans_;      // Number of spans in empty_ plus nonempty_
          0x78  size_t   counter_;        // Number of free objects in cache entry
          0x80  TCEntry tc_slots_[kMaxNumTransferEntries=64]
          0x480 int32_t used_slots_;
          0x484 int32_t cache_size_;
          0x488 int32_t max_cache_size_;
          0x48c char pad[0x34];
        } // size:0x4c0, total_size:0x1c800
        """
        self.sizeof_TCEntry = 0x10
        self.sizeof_CentralCache = 0x4c0
        self.CentralCache_offset_size_class_ = 0x8
        self.CentralCache_offset_tc_slots_ = 0x80
        self.CentralCache_offset_used_slots_ = 0x480
        # settings
        self.initialized = True
        return

    def get_heap_key(self):
        # chromium/third_party/tcmalloc/chromium/src/thread_cache.cc
        aslr = parse_address("TCMalloc_SystemAlloc")
        return (~(aslr >> 13)) & 0xffffffffffffffff

    def index_to_size(self, freelist, t): # freelist_index -> chunk_size
        size = read_int_from_memory(freelist + self.FreeList_offset_size)
        return size


@register_command
class TcmallocDumpOldCommand(TcmallocDumpCommand):
    """tcmalloc (google-perftools-2.5 edition) freelist viewer (supported x86_64 only)."""
    _cmdline_ = "tcmalloc-dump old"
    _syntax_ = "tcmalloc-dump old [-h] [self|all|NAME[,NAME,..]|central] [--th PRINT_THRESHOLD] [--idx PRINT_TARGET_IDX]"
    _category_ = "Heap"

    def __init__(self):
        super().__init__(prefix=False)
        # google-perftools-2.5/src/common.h
        self.kBaseClasses = 9 # or 16
        self.kNumClasses = self.kBaseClasses + 79 # or 73 or 69
        self.kMaxSize = 256 * 1024
        self.kClassArraySize = ((self.kMaxSize + 127 + (120 << 7)) >> 7) + 1
        self.kClassSizesMax = 128
        # google-perftools-2.5/src/thread_cache.h
        """
        00000000 ThreadCache     struc ; (sizeof=0x880)
        00000000 next_           dq ?
        00000008 prev_           dq ?
        00000010 size_           dq ?
        00000018 max_size_       dq ?
        00000020 sampler_        Sampler ?
        00000030 list_           FreeList 88 dup(?) # kNumClasses
        00000870 tid_            dq ?
        00000878 in_setspecific_ db ?
        00000879 unused          db 7 dup(?)
        00000880 ThreadCache     ends
        """
        self.ThreadCache_offset_next = 0x0
        self.ThreadCache_offset_freelist_array = 0x30
        self.ThreadCache_offset_tls = 0x870 # actually this is not tid, but TLS base address
        self.ThreadCache_freelist_slot_count = self.kNumClasses
        # google-perftools-2.5/src/thread_cache.h
        """
        00000000 FreeList        struc ; (sizeof=0x18)
        00000000 list_           dq ?
        00000008 length_         dd ?
        0000000C lowater_        dd ?
        00000010 max_length_     dd ?
        00000014 length_overages_ dd ?
        00000018 FreeList        ends
        """
        self.sizeof_FreeList = 0x18
        self.FreeList_offset_list = 0x0
        self.FreeList_offset_length = 0x8
        # google-perftools-2.5/src/common.h
        """
        00000000 SizeMap         struc ; (sizeof=0xF60)
        00000000 num_objects_to_move_ dd 88 dup(?) # kNumClasses
        00000160 class_array_    db 2169 dup(?) # kClassArraySize
        000009D9 field_9D9       db 7 dup(?)
        000009E0 class_to_size_  dq 88 dup(?) # kNumClasses
        00000CA0 class_to_pages_ dq 88 dup(?) # kNumClasses
        00000F60 SizeMap         ends
        """
        self.SizeMap_offset_class_array = self.kNumClasses * 4
        self.SizeMap_offset_class_to_size = self.SizeMap_offset_class_array + ((self.kClassArraySize + 7) // 8 * 8)
        # google-perftools-2.5/src/central_freelist.h
        self.kMaxNumTransferEntries = 64
        self.CentralCache_freelist_slot_count = self.kMaxNumTransferEntries
        # google-perftools-2.5//src/static_vars.cc
        self.CentralCache_array_count = self.kClassSizesMax
        # google-perftools-2.5/src/central_freelist.h
        """
        struct TCEntry {
          void *head;  // Head of chain of objects.
          void *tail;  // Tail of chain of objects.
        };
        class central_cache_[kClassSizesMax=128]
          0x0   SpinLock lock_;
          0x8   size_t   size_class_;     // My size class
          0x10  Span     empty_;          // Dummy header for list of empty spans
          0x40  Span     nonempty_;       // Dummy header for list of non-empty spans
          0x70  size_t   num_spans_;      // Number of spans in empty_ plus nonempty_
          0x78  size_t   counter_;        // Number of free objects in cache entry
          0x80  TCEntry tc_slots_[kMaxNumTransferEntries=64]
          0x480 int32_t used_slots_;
          0x484 int32_t cache_size_;
          0x488 int32_t max_cache_size_;
          0x48c char pad[0x34];
        } // size:0x4c0, total_size:0x26000
        """
        self.sizeof_TCEntry = 0x10
        self.sizeof_CentralCache = 0x4c0
        self.CentralCache_offset_size_class_ = 0x8
        self.CentralCache_offset_tc_slots_ = 0x80
        self.CentralCache_offset_used_slots_ = 0x480
        # settings
        self.initialized = True
        return

    def get_heap_key(self):
        return 0

    def index_to_size(self, freelist, t): # freelist_index -> chunk_size
        sizemap = self.get_sizemap()
        if sizemap is None:
            return None
        size = read_int_from_memory(sizemap + self.SizeMap_offset_class_to_size + 8 * t)
        return size


isolate_root = None


def get_isolate_root():

    def to_int32(v):
        """Cast a gdb.Value to int32"""
        return int(v.cast(gdb.Value(2 ** 32 - 1).type))

    def lookup_symbol_hack(symbol):
        """Hacky way to lookup symbol's address, I've tried other options like parse_and_eval but they
           throw errors like `No symbol "v8" in current context.`. I would like to replace this function
           once I figure out the proper way."""
        return int(gdb.execute("info address {}".format(symbol), to_string=True).split(" is at ")[1].split(" ")[0], 16)

    global isolate_root
    if isolate_root:
        return isolate_root
    else:
        try:
            isolate_key_addr = lookup_symbol_hack("v8::internal::Isolate::isolate_key_")
            isolate_key = to_int32(gdb.parse_and_eval("*(int *){}".format(isolate_key_addr)))
        except Exception:
            err("Failed to get value of v8::internal::Isolate::isolate_key_")
            return None

        getthreadlocal_addr = lookup_symbol_hack("v8::base::Thread::GetThreadLocal")
        res = gdb.execute("call (void*){}({})".format(getthreadlocal_addr, isolate_key), to_string=True)
        isolate_root = int(res.split("0x")[1], 16)
        return isolate_root


def del_isolate_root(event):
    global isolate_root
    isolate_root = None


@register_command
class V8DereferenceCommand(GenericCommand):
    """Dereference recursively from an address and display information. Handles v8 specific values like tagged and compressed pointers"""
    _cmdline_ = "v8deref"
    _syntax_ = "{:s} [LOCATION] [l[NB]]".format(_cmdline_)
    _example_ = "{:s} $sp l20".format(_cmdline_)
    _category_ = "Chrome"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        gef_on_exit_hook(del_isolate_root)
        return

    @staticmethod
    def pprint_dereferenced(addr, off):
        base_address_color = get_gef_setting("theme.dereference_base_address")
        registers_color = get_gef_setting("theme.dereference_register_value")

        regs = [(k, get_register(k)) for k in current_arch.all_registers]

        sep = " {:s} ".format(RIGHT_ARROW)
        memalign = current_arch.ptrsize
        ma = memalign * 2 + 2

        offset = off * memalign
        current_address = align_address(addr + offset)
        addrs = V8DereferenceCommand.dereference_from(current_address)
        if not addrs:
            return ""
        if addrs[1]:
            addr_l0 = format_address(int(addrs[0][0], 16))
            addr_l0_c = Color.colorify(addr_l0, base_address_color)
            line = ""
            line += "{:s}{:s}+{:#06x}: {:{ma}s}".format(addr_l0_c, VERTICAL_LINE, offset, sep.join(addrs[0][1:]), ma=ma)

            addr_l1 = " " * len(addr_l0)
            addr_l1_c = Color.colorify(addr_l1, base_address_color)
            line += "\n"
            line += "{:s}{:s}+{:#06x}: {:{ma}s}".format(addr_l1_c, VERTICAL_LINE, offset + 4, sep.join(addrs[1][1:]), ma=ma)
        else:
            addr_l = format_address(int(addrs[0][0], 16))
            addr_l_c = Color.colorify(addr_l, base_address_color)
            line = ""
            line += "{:s}{:s}+{:#06x}: {:{ma}s}".format(addr_l_c, VERTICAL_LINE, offset, sep.join(addrs[0][1:]), ma=ma)

            register_hints = []
            for regname, regvalue in regs:
                if current_address == regvalue:
                    register_hints.append(regname)
            if register_hints:
                m = "\t{:s}{:s}".format(LEFT_ARROW, ", ".join(list(register_hints)))
                line += Color.colorify(m, registers_color)
        return line

    @only_if_gdb_running
    def do_invoke(self, argv):
        target = "$sp"
        nb = 10

        for arg in argv:
            if arg.isdigit():
                nb = int(arg)
            elif arg[0] in ("l", "L") and arg[1:].isdigit():
                nb = int(arg[1:])
            else:
                target = arg

        addr = safe_parse_and_eval(target)
        if addr is None:
            err("Invalid address")
            return

        addr = int(addr)
        # Remove tagging (tagged pointers)
        addr = addr & (2 ** (8 * current_arch.ptrsize) - 2)
        if process_lookup_address(addr) is None:
            err("Unmapped address")
            return

        if get_gef_setting("context.grow_stack_down") is True:
            from_insnum = nb * (self.repeat_count + 1) - 1
            to_insnum = self.repeat_count * nb - 1
            insnum_step = -1
        else:
            from_insnum = 0 + self.repeat_count * nb
            to_insnum = nb * (self.repeat_count + 1)
            insnum_step = 1

        start_address = align_address(addr)

        for i in range(from_insnum, to_insnum, insnum_step):
            line = V8DereferenceCommand.pprint_dereferenced(start_address, i)
            if not line:
                break
            gef_print(line)
        return

    @staticmethod
    def dereference_from(addr):
        def format_compressed(addr):
            heap_color = get_gef_setting("theme.address_heap")
            addr_high = Color.colorify("0x{:08x}".format(addr >> 32), "gray")
            addr_low = Color.colorify("{:08x}".format(addr & 0xffffffff), heap_color)
            return "{:s}{:s}".format(addr_high, addr_low)

        if not is_alive():
            return ([format_address(addr)], None)

        code_color = get_gef_setting("theme.dereference_code")
        string_color = get_gef_setting("theme.dereference_string")
        max_recursion = get_gef_setting("dereference.max_recursion") or 10
        addr = lookup_address(align_address(int(addr)))
        msg = ([format_address(addr.value)], [])
        seen_addrs = set()

        # Is this address pointing to a normal pointer?
        deref = addr.dereference()
        if deref is None:
            pass # Regular execution if so
        else:
            # Is this address pointing to compressed pointers instead?
            # Only for valid for 64-bit address space
            if current_arch.ptrsize == 8:
                isolate_root = get_isolate_root()
                if isolate_root is None:
                    err("Not found isolate_root")
                    return ""
                addr0 = lookup_address(align_address(isolate_root + (deref & 0xffffffff)))
                addr1 = lookup_address(align_address(isolate_root + (deref >> 32)))
                compressed = [False, False]
                compressed[0] = addr0.dereference() and addr0.value > isolate_root + 0x0c000 and addr0.value & 1
                compressed[1] = addr1.dereference() and addr1.value > isolate_root + 0x0c000 and addr1.value & 1
                if True in compressed:
                    msg[1].append(format_address(addr.value + 4))
                    for i in range(2):
                        if compressed[i]:
                            msg[i].append(format_compressed(addr0.value if not i else addr1.value))
                        else:
                            val = int(deref & 0xffffffff) if not i else int(deref >> 32)
                            if not (val & 1): # Maybe SMI
                                msg[i].append("        {:#0{ma}x} (SMI: {:#x})".format(val, val >> 1, ma=10))
                            else:
                                msg[i].append("        {:#0{ma}x}".format(val, ma=10))
                    return msg

        while addr.section and max_recursion:
            if addr.value in seen_addrs:
                msg[0].append("[loop detected]")
                break
            seen_addrs.add(addr.value)

            max_recursion -= 1

            # Is this value a pointer or a value?
            # -- If it's a pointer, dereference
            deref = addr.dereference()
            if deref is None:
                # if here, dereferencing addr has triggered a MemoryError, no need to go further
                msg[0].append(str(addr))
                break

            new_addr = lookup_address(deref)
            if new_addr.valid:
                addr = new_addr
                msg[0].append(str(addr))
                continue

            # -- Otherwise try to parse the value
            if addr.section:
                if addr.section.is_executable() and addr.is_in_text_segment() and not is_ascii_string(addr.value):
                    insn = gef_current_instruction(addr.value)
                    insn_str = "{} {} {}".format(insn.location, insn.mnemonic, ", ".join(insn.operands))
                    msg[0].append(Color.colorify(insn_str, code_color))
                    break

                elif addr.section.permission.value & Permission.READ:
                    if is_ascii_string(addr.value):
                        s = read_cstring_from_memory(addr.value)
                        if len(s) < get_memory_alignment():
                            txt = '{:s} ("{:s}"?)'.format(format_address(deref), Color.colorify(s, string_color))
                        elif len(s) > 50:
                            txt = Color.colorify('"{:s}[...]"'.format(s[:50]), string_color)
                        else:
                            txt = Color.colorify('"{:s}"'.format(s), string_color)

                        msg[0].append(txt)
                        break

            # if not able to parse cleanly, simply display and break
            val = "{:#0{ma}x}".format(int(deref & 0xFFFFFFFFFFFFFFFF), ma=(current_arch.ptrsize * 2 + 2))
            msg[0].append(val)
            break

        return msg


@register_command
class PartitionAllocDumpStableCommand(GenericCommand):
    """PartitionAlloc freelist viewer for chromium stable (supported x64/x86/ARM64/ARM only)."""
    _cmdline_ = "partition-alloc-dump-stable"
    _syntax_ = "{:s} [-h] fast_malloc|array_buffer|buffer|all [-v]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} array_buffer # walk from array_buffer_root_\n".format(_cmdline_)
    _example_ += "{:s} ab # same above (fm, ab and b are valid)\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "THIS FEATURE IS EXPERIMENTAL AND HEURISTIC.\n"
    _example_ += "Chromium mainline is too fast to develop. So if parse is failed, you need fix this gef.py."
    _category_ = "Chrome"

    """
    partition alloc freelist is following.

     +-root-----------------+
     | ...                  |    +---> +-extent------------+  +-> +-extent------------+  +-> ...
     | next_super_page      |    |     | next              | -+   | next              | -+
     | next_partition_page  |    |     +-------------------+      +-------------------+
     | ...                  |    |
     | first_extent         | ---+
     | direct_map_list      | -------> +-direct_map_extent-+  +-> +-direct_map_extent-+  +-> ...
     | ...                  |          | bucket            |  |   | bucket            |  |
     |                      |          | next_extent       | -+   | next_extent       | -+
     |                      |          +-------------------+      +-------------------+
     |                      |
     +-bucket[0](0x20)------+
     | head                 | -------> +-slot_span---------+  +-> +-slot_span---------+  +-> ...
     | slot_size            | <------- | bucket            |  |   | bucket            |  |
     | ...                  |    +---- | freelist_head     |  |   | freelist_head     |  |
     +-bucket[1](0x20)------+    |     | next_slot_span    | -+   | next_slot_span    | -+
     | head                 |    |     +-------------------+      +-------------------+
     | slot_size            |    |
     | ...                  |    |
     +----------------------+    |
     | ...                  |    |
     |                      |    +---> +-slot--------------+
     |                      |          | next              | --+
     +----------------------+          | (freed)           |   |
                                       +-slot--------------+   |
                                       |                   |   |
                                       | (used)            |   |
                                       +-slot--------------+ <-+
                                   +-- | next              |
                                   |   | (freed)           |
                                   |   +-slot--------------+
                                   |   |                   |
                                   |   | (used)            |
                                   +-> +-slot--------------+
                                       | next              | --> NULL
                                       | (freed)           |
                                       +-slot--------------+
                                       |                   |
                                       |                   |
                                       +-------------------+

    `extent`, `slot_span` and `slot` are in super_page.

          +-super_page-(2MB)----+
     4KB  | Guard Page          |
          +---------------------+
     4KB  | extent * 1          |
          | slot_span * 126     |
          | unused * 1          |
          +---------------------+
     8KB  | Guard Page          |
          +---------------------+
     16KB | Partition Page #1   |
          |   slot              |
          |   slot              |
          |   ...               |
          +---------------------+
          | ...                 |
          +---------------------+
     16KB | Partition Page #126 |
          |   slot              |
          |   slot              |
          |   ...               |
          +---------------------+
     12KB | Unused              |
          +---------------------+
      4KB | Guard Page          |
          +---------------------+
    """

    @functools.lru_cache()
    def get_roots_heuristic(self):
        """searches for fast_malloc_root, array_buffer_root_ and buffer_root_"""
        # the pointers to each root are in the RW area.
        # first, we list up the RW area.
        filepath = get_filepath(for_vmmap=True)
        if is_64bit():
            codebase = get_section_base_address(filepath)
            mask = 0x0000ffff00000000
            chromium_rw_maps = [p for p in get_process_maps() if p.permission.value == Permission.READ | Permission.WRITE]
            chromium_rw_maps = [p for p in chromium_rw_maps if (p.page_start & mask) == (codebase & mask) and p.path != filepath]
        elif is_32bit():
            mask = 0xff000000
            heapbase = HeapBaseFunction.heap_base()
            chromium_rw_maps = [p for p in get_process_maps() if p.permission.value == Permission.READ | Permission.WRITE]
            chromium_rw_maps = [p for p in chromium_rw_maps if p.page_start < heapbase and p.path != filepath]

        # n_gram([1,2,3,4,5],3) -> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
        def n_gram(target, n):
            for idx in range(len(target) - n + 1):
                yield target[idx:idx + n]

        # Check the RW area
        roots = []
        for maps in chromium_rw_maps:
            # explode to each qword (if 64 bit arch) or dword (if 32 bit arch)
            datas = slice_unpack(read_memory(maps.page_start, maps.size), current_arch.ptrsize)
            addrs = [x for x in range(maps.page_start, maps.page_end, current_arch.ptrsize)]

            """
            https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/platform/wtf/allocator/partitions.cc
            base::ThreadSafePartitionRoot* Partitions::fast_malloc_root_ = nullptr;
            base::ThreadSafePartitionRoot* Partitions::array_buffer_root_ = nullptr;
            base::ThreadSafePartitionRoot* Partitions::buffer_root_ = nullptr;

            0x564883728440 <WTF::Partitions::fast_malloc_root_>:    0x0000000000000000
            0x564883728448 <WTF::Partitions::array_buffer_root_>:   0x000056488372a380
            0x564883728450 <WTF::Partitions::buffer_root_>: 0x0000564883729400
            0x564883728458 <guard variable for WTF::Partitions::Initialize()::initialized>: 0x0000000100000101
            ...
            0x55c7e358d480 <WTF::Partitions::InitializeOnce()::fast_malloc_allocator>:      0x0000000000000000
            ...
            0x55c7e358e400 <WTF::Partitions::InitializeOnce()::buffer_allocator>:   0x0000000100000001
            ...
            0x55c7e358f380 <WTF::Partitions::InitializeArrayBufferPartition()::array_buffer_allocator>:     0x0000000100000001
            """
            # check consecutive quadruples
            for addr, data in zip(n_gram(addrs, 4), n_gram(datas, 4)):
                # root pointer address and root address are close (see above example)
                if data[0] != 0 and (addr[0] & mask) != (data[0] & mask):
                    # fast_malloc_root_ may be zero. but if non-zero, it holds address close to itself
                    continue
                if (addr[1] & mask) != (data[1] & mask):
                    # array_buffer_root_ is must be non-zero. it holds address close to itself
                    continue
                if (addr[2] & mask) != (data[2] & mask):
                    # buffer_root_ is must be non-zero. it holds address close to itself
                    continue
                # they should be aligned
                if data[0] & 0x7:
                    continue
                if data[1] & 0x7:
                    continue
                if data[2] & 0x7:
                    continue
                # initialized must be bool 0x01
                if (data[3] & 0xff) != 0x01:
                    continue
                # check root size
                buffer_root_size = data[1] - data[2]
                if buffer_root_size < 0x300: # 0x300 is heuristic value
                    continue
                if buffer_root_size > 0x2000: # 0x2000 is heuristic value
                    continue
                # check root struct.
                """
                The first 64 bytes of root are mostly 0 due to padding considering the cache line.
                This is same both at 64-bit and 32bit arch.
                0x55719118e380: 0x0000000100000001      0x0000000000000000     <--- here may be used
                0x55719118e390: 0x0000000000000000      0x0000000000000000     <--- here may be used
                0x55719118e3a0: 0x0000000000000000      0x0000000000000000     <--- hare may be not used
                0x55719118e3b0: 0x0000000000000000      0x0000000000000000     <--- here may be not used
                """
                if read_memory(data[1], 64)[32:] != b"\0" * 32:
                    continue
                if read_memory(data[2], 64)[32:] != b"\0" * 32:
                    continue
                # add candidate
                root_candidate = [
                    ["fast_malloc_root_", addr[0]],
                    ["array_buffer_root_", addr[1]],
                    ["buffer_root_", addr[2]],
                ]
                roots.append(root_candidate)

        # debug print
        if len(roots) == 0:
            err("roots were not found. try check code")
            return []

        elif len(roots) == 1:
            root = roots[0]
            for r in root:
                info("found: {:s}: {:#x}".format(r[0], r[1]))
            return roots[0] # [["fast_malloc_root_", addr], ["array_buffer_root_", addr], ["buffer_root_", addr]]

        else:
            err("candidates for root are found in multiple places. try check code")
            for root in roots:
                for r in root:
                    gef_print("  candidate: {:20s} {:#x}".format(r[0], r[1]))
                gef_print()
            return []

    @functools.lru_cache()
    def get_roots(self):
        def get_root(root_string):
            try:
                root_addr = parse_address("&'WTF::Partitions::{:s}'".format(root_string))
                return [[root_string, root_addr]]
            except Exception:
                return []

        roots = []
        # try from symbols
        for root_string in ["fast_malloc_root_", "array_buffer_root_", "buffer_root_"]:
            roots += get_root(root_string)
        # maybe no symbols, try heuristic
        if len(roots) == 0:
            info("Symbol is not found. It will use heuristic search")
            roots = self.get_roots_heuristic()
        # retry checking
        if len(roots) == 0:
            info("Symbol is not found.")
        return roots

    @functools.lru_cache()
    def get_sentinel_slot_spans(self):
        """sentinel_slot_span is default slot_span, so search it"""
        sentinel = []
        try:
            t = parse_address("&'base::internal::SlotSpanMetadata<true>::sentinel_slot_span_'")
            sentinel.append(t)
        except Exception:
            pass
        try:
            f = parse_address("&'base::internal::SlotSpanMetadata<false>::sentinel_slot_span_'")
            sentinel.append(f)
        except Exception:
            pass
        return sentinel

    def byteswap(self, x):
        p = lambda a: struct.pack("<I", a & 0xffffffff)
        ube = lambda a: struct.unpack(">I", a)[0]
        pQ = lambda a: struct.pack("<Q", a & 0xffffffffffffffff)
        uQbe = lambda a: struct.unpack(">Q", a)[0]
        if is_64bit():
            converted = uQbe(pQ(x))
        elif is_32bit():
            converted = ube(p(x))
        return converted

    def read_root(self, addr, name):
        ptrsize = current_arch.ptrsize
        root = {}
        root["name"] = name
        root["addr"] = current = read_int_from_memory(addr)
        """
        https://source.chromium.org/chromium/chromium/src/+/main:base/allocator/partition_allocator/partition_root.h
        struct base::PartitionRoot {
            union {
                struct {
                    QuarantineMode quarantine_mode; // uint8_t
                    ScanMode scan_mode;             // uint8_t
                    BucketDistribution bucket_distribution = BucketDistribution::kCoarser; // uint8_t
                    bool with_thread_cache = false;
                    bool allow_aligned_alloc;
                    bool allow_cookie;
                    bool brp_enabled_;
                    bool brp_zapping_enabled_;
                    //bool mac11_malloc_size_hack_enabled_ = false;
                    bool use_configurable_pool;
                    //int pkey; // v109.x~
                    //uint32_t extras_size;
                    //uint32_t extras_offset;
                }
                uint8_t one_cacheline[internal::kPartitionCachelineSize]; // 64 bytes
            }
            ::partition_alloc::Lock lock_;  // 8 bytes
            Bucket buckets[internal::kNumBuckets] = {};
            Bucket sentinel_bucket{};
            bool initialized = false;
            std::atomic<size_t> total_size_of_committed_pages{0};
            std::atomic<size_t> max_size_of_committed_pages{0};
            std::atomic<size_t> total_size_of_super_pages{0};
            std::atomic<size_t> total_size_of_direct_mapped_pages{0};
            size_t total_size_of_allocated_bytes PA_GUARDED_BY(lock_) = 0;
            size_t max_size_of_allocated_bytes PA_GUARDED_BY(lock_) = 0;
            std::atomic<uint64_t> syscall_count{};
            std::atomic<uint64_t> syscall_total_time_ns{};
            //std::atomic<size_t> total_size_of_brp_quarantined_bytes{0};
            //std::atomic<size_t> total_count_of_brp_quarantined_slots{0};
            //std::atomic<size_t> cumulative_size_of_brp_quarantined_bytes{0};
            //std::atomic<size_t> cumulative_count_of_brp_quarantined_slots{0};
            size_t empty_slot_spans_dirty_bytes PA_GUARDED_BY(lock_) = 0;
            int max_empty_slot_spans_dirty_bytes_shift = 3;
            uintptr_t next_super_page = 0;
            uintptr_t next_partition_page = 0;
            uintptr_t next_partition_page_end = 0;
            SuperPageExtentEntry* current_extent = nullptr;
            SuperPageExtentEntry* first_extent = nullptr;
            DirectMapExtent* direct_map_list PA_GUARDED_BY(lock_) = nullptr;
            SlotSpan* global_empty_slot_span_ring[internal::kMaxFreeableSpans] PA_GUARDED_BY(lock_) = {};
            int16_t global_empty_slot_span_ring_index PA_GUARDED_BY(lock_) = 0;
            int16_t global_empty_slot_span_ring_size PA_GUARDED_BY(lock_) = internal::kDefaultEmptySlotSpanRingSize;
            uintptr_t inverted_self = 0;
            std::atomic<int> thread_caches_being_constructed_{0};
            bool quarantine_always_for_testing = false;
            //partition_alloc::PartitionTag current_partition_tag = 0; // if ARM MTE is enable
            //uintptr_t next_tag_bitmap_page = 0; // if ARM MTE is enable
        }
        """
        x = u64(read_memory(current, 8))
        current += 64 # sizeof(union {...})

        root["lock_"] = u64(read_memory(current, 8))
        current += 8

        # for 32bit, there is 2 patterns because aligned or packed
        if is_32bit():
            if self.align_pad is None:
                x = read_int_from_memory(current)
                if x == 0:
                    self.align_pad = True
                else:
                    self.align_pad = False
            if self.align_pad:
                current += ptrsize

        root["buckets"] = []
        while True:
            if read_int_from_memory(current) == 1: # search `bool initialized`
                break
            bucket, current = self.read_bucket(current)
            root["buckets"].append(bucket)
        root["sentinel_bucket"] = root["buckets"].pop()

        root["initialized"] = read_int_from_memory(current) & 0xff
        current += ptrsize # with pad
        root["total_size_of_committed_pages"] = read_int_from_memory(current)
        current += ptrsize
        root["max_size_of_committed_pages"] = read_int_from_memory(current)
        current += ptrsize
        root["total_size_of_super_pages"] = read_int_from_memory(current)
        current += ptrsize
        root["total_size_of_direct_mapped_pages"] = read_int_from_memory(current)
        current += ptrsize
        root["total_size_of_allocated_bytes"] = read_int_from_memory(current)
        current += ptrsize
        root["max_size_of_allocated_bytes"] = read_int_from_memory(current)
        current += ptrsize
        root["syscall_count"] = read_int_from_memory(current)
        current += ptrsize
        root["syscall_total_time_ns"] = read_int_from_memory(current)
        current += ptrsize
        root["empty_slot_spans_dirty_bytes"] = u32(read_memory(current, 4))
        current += ptrsize # with pad
        root["max_empty_slot_spans_dirty_bytes_shift"] = u32(read_memory(current, 4))
        current += ptrsize # with pad
        root["next_super_page"] = read_int_from_memory(current)
        current += ptrsize
        root["next_partition_page"] = read_int_from_memory(current)
        current += ptrsize
        root["next_partition_page_end"] = read_int_from_memory(current)
        current += ptrsize
        root["current_extent"] = read_int_from_memory(current)
        current += ptrsize
        root["first_extent"] = read_int_from_memory(current)
        current += ptrsize
        root["direct_map_list"] = read_int_from_memory(current)
        current += ptrsize

        root["global_empty_slot_span_ring"] = []
        inv = root["addr"] ^ ((1 << (current_arch.ptrsize * 8)) - 1)
        while True:
            if read_int_from_memory(current + ptrsize) == inv: # search `inverted_self`
                break
            x = read_int_from_memory(current)
            current += ptrsize
            root["global_empty_slot_span_ring"].append(x)

        root["global_empty_slot_span_ring_index"] = u16(read_memory(current, 2))
        current += 2
        root["global_empty_slot_span_ring_size"] = u16(read_memory(current, 2))
        current += ptrsize - 2 # with pad
        root["inverted_self"] = read_int_from_memory(current)
        current += ptrsize
        root["thread_caches_being_constructed_"] = u32(read_memory(current, 4))
        current += 4
        root["quarantine_always_for_testing"] = u32(read_memory(current, 4)) & 0xff
        current += 4
        return root, current

    def read_bucket(self, addr):
        ptrsize = current_arch.ptrsize
        bucket = {}
        bucket["addr"] = current = addr
        """
        https://source.chromium.org/chromium/chromium/src/+/main:base/allocator/partition_allocator/partition_bucket.h
        struct base::internal::PartitionBucket {
            SlotSpanMetadata<thread_safe>* active_slot_spans_head;
            SlotSpanMetadata<thread_safe>* empty_slot_spans_head;
            SlotSpanMetadata<thread_safe>* decommitted_slot_spans_head;
            uint32_t slot_size;
            uint32_t num_system_pages_per_slot_span : 8;
            uint32_t num_full_slot_spans : 24;
            uint64_t slot_size_reciprocal;
        };
        """
        bucket["active_slot_spans_head"] = read_int_from_memory(current)
        current += ptrsize
        bucket["empty_slot_spans_head"] = read_int_from_memory(current)
        current += ptrsize
        bucket["decommitted_slot_spans_head"] = read_int_from_memory(current)
        current += ptrsize
        bucket["slot_size"] = u32(read_memory(current, 4))
        current += 4
        x = u32(read_memory(current, 4))
        bucket["num_system_pages_per_slot_span"] = x & 0xff
        bucket["num_full_slot_spans"] = (x >> 8) & 0xffffff
        current += 4

        # for 32bit, there is 2 patterns because aligned or packed
        if is_32bit() and self.align_pad:
            current += 4
        bucket["slot_size_reciprocal"] = u64(read_memory(current, 8))
        current += 8
        return bucket, current

    def read_extent(self, addr):
        ptrsize = current_arch.ptrsize
        extent = {}
        extent["addr"] = current = addr
        extent["super_page_base"] = current - 0x1000
        """
        https://source.chromium.org/chromium/chromium/src/+/main:base/allocator/partition_allocator/partition_page.h
        struct PartitionSuperPageExtentEntry {
          PartitionRootBase* root;
          PartitionSuperPageExtentEntry* next;
          uint16_t number_of_consecutive_super_pages;
          uint16_t number_of_nonempty_slot_spans;
        };
        """
        extent["root"] = read_int_from_memory(current)
        current += ptrsize
        extent["next"] = read_int_from_memory(current)
        current += ptrsize
        extent["number_of_consecutive_super_pages"] = u16(read_memory(current, 2))
        current += 2
        extent["number_of_nonempty_slot_spans"] = u16(read_memory(current, 2))
        current += 2
        extent["super_page_end"] = extent["super_page_base"] + extent["number_of_consecutive_super_pages"] * 0x200000
        return extent, current

    def read_direct_map(self, addr):
        ptrsize = current_arch.ptrsize
        direct_map = {}
        direct_map["addr"] = current = addr
        """
        https://source.chromium.org/chromium/chromium/src/+/main:base/allocator/partition_allocator/partition_direct_map_extent.h
        struct PartitionDirectMapExtent {
          PartitionDirectMapExtent<thread_safe>* next_extent;
          PartitionDirectMapExtent<thread_safe>* prev_extent;
          PartitionBucket<thread_safe>* bucket;
          size_t reservation_size;
          size_t padding_for_alignment;
        };
        """
        direct_map["next_extent"] = read_int_from_memory(current)
        current += ptrsize
        direct_map["prev_extent"] = read_int_from_memory(current)
        current += ptrsize
        direct_map["bucket"] = read_int_from_memory(current)
        current += ptrsize
        direct_map["reservation_size"] = read_int_from_memory(current)
        current += ptrsize
        direct_map["padding_for_alignment"] = read_int_from_memory(current)
        current += ptrsize
        return direct_map, current

    def read_slot_span(self, addr):
        ptrsize = current_arch.ptrsize
        slot_span = {}
        slot_span["addr"] = current = addr
        slot_span["super_page_addr"] = (slot_span["addr"] & gef_getpagesize_mask()) - gef_getpagesize()
        slot_span["partition_page_index"] = (slot_span["addr"] & (gef_getpagesize() - 1)) // 0x20
        slot_span["partition_page_start"] = slot_span["super_page_addr"] + slot_span["partition_page_index"] * gef_getpagesize() * 4
        """
        https://source.chromium.org/chromium/chromium/src/+/main:base/allocator/partition_allocator/partition_page.h
        struct SlotSpanMetadata {
          PartitionFreelistEntry* freelist_head = nullptr;
          SlotSpanMetadata<thread_safe>* next_slot_span = nullptr;
          PartitionBucket<thread_safe>* const bucket = nullptr;
          uint32_t marked_full : 1
          uint32_t num_allocated_slots : kMaxSlotsPerSlotSpanBits; // 13 bits
          uint32_t num_unprovisioned_slots : kMaxSlotsPerSlotSpanBits; // 13 bits
          const uint32_t can_store_raw_size_ : 1;
          uint32_t freelist_is_sorted_ : 1;
          uint32_t unused1_ : (32 - 1 - 2 * kMaxSlotsPerSlotSpanBits - 1 - 1); // 3 bits
          uint16_t in_empty_cache_ : 1;
          uint16_t empty_cache_index_ : kEmptyCacheIndexBits; // 7 bits
          uint16_t unused2_ : (16 - 1 - kEmptyCacheIndexBits); // 8 bits
        }
        """
        slot_span["freelist_head"] = read_int_from_memory(current)
        current += ptrsize
        slot_span["next_slot_span"] = read_int_from_memory(current)
        current += ptrsize
        slot_span["bucket"] = read_int_from_memory(current)
        current += ptrsize
        x = u32(read_memory(current, 4))
        current += 4
        slot_span["marked_full"] = (x >> 0) & 1
        slot_span["num_allocated_slots"] = (x >> 1) & 0x1fff
        slot_span["num_unprovisioned_slots"] = (x >> 14) & 0x1fff
        slot_span["can_store_raw_size_"] = (x >> 27) & 1
        slot_span["freelist_is_sorted_"] = (x >> 28) & 1
        slot_span["unused1_"] = (x >> 29) & 0x7
        x = u16(read_memory(current, 2))
        current += 2
        slot_span["in_empty_cache_"] = (x >> 0) & 1
        slot_span["empty_cache_index_"] = (x >> 1) & 0x7f
        slot_span["unused2_"] = (x >> 8) & 0xff
        return slot_span, current

    def print_root(self, root):
        gef_print(titlify("*{} @ {:#x}".format(root["name"], root["addr"])))
        gef_print("uint8_t one_cacheline[64]:                             ...")
        gef_print("::partition_alloc::Lock lock_;                         {:#x}".format(root["lock_"]))
        gef_print("Bucket buckets[{:3d}]:".format(len(root["buckets"])))
        for idx, bucket in enumerate(root["buckets"]):
            self.print_bucket(bucket, root, idx)
        if self.verbose:
            gef_print("Bucket sentinel_bucket:")
            self.print_bucket(root["sentinel_bucket"], root)
        else:
            gef_print("Bucket sentinel_bucket:                                ...")
        gef_print("bool initialized:                                      {:#x}".format(root["initialized"]))
        gef_print("std::atomic<size_t> total_size_of_committed_pages:     {:#x}".format(root["total_size_of_committed_pages"]))
        gef_print("std::atomic<size_t> max_size_of_committed_pages:       {:#x}".format(root["max_size_of_committed_pages"]))
        gef_print("std::atomic<size_t> total_size_of_super_pages:         {:#x}".format(root["total_size_of_super_pages"]))
        gef_print("std::atomic<size_t> total_size_of_direct_mapped_pages: {:#x}".format(root["total_size_of_direct_mapped_pages"]))
        gef_print("size_t total_size_of_allocated_bytes:                  {:#x}".format(root["total_size_of_allocated_bytes"]))
        gef_print("size_t max_size_of_allocated_bytes:                    {:#x}".format(root["max_size_of_allocated_bytes"]))
        gef_print("std::atomic<uint64_t> syscall_count:                   {:#x}".format(root["syscall_count"]))
        gef_print("std::atomic<uint64_t> syscall_total_time_ns:           {:#x}".format(root["syscall_total_time_ns"]))
        gef_print("size_t empty_slot_spans_dirty_bytes:                   {:#x}".format(root["empty_slot_spans_dirty_bytes"]))
        gef_print("int max_empty_slot_spans_dirty_bytes_shift:            {:#x}".format(root["max_empty_slot_spans_dirty_bytes_shift"]))
        gef_print("uintptr_t next_super_page:                             {:#x}".format(root["next_super_page"]))
        gef_print("uintptr_t next_partition_page:                         {:#x}".format(root["next_partition_page"]))
        gef_print("uintptr_t next_partition_page_end:                     {:#x}".format(root["next_partition_page_end"]))
        gef_print("SuperPageExtentEntry* current_extent:                  {:#x}".format(root["current_extent"]))
        self.print_extent_list(root["current_extent"])
        gef_print("SuperPageExtentEntry* first_extent:                    {:#x}".format(root["first_extent"]))
        self.print_extent_list(root["first_extent"])
        gef_print("DirectMapExtent* direct_map_list:                      {:#x}".format(root["direct_map_list"]))
        self.print_direct_map_list(root["direct_map_list"], root)
        ring_len = len(root["global_empty_slot_span_ring"])
        if self.verbose:
            gef_print("SlotSpan* global_empty_slot_span_ring[{:2d}]:".format(ring_len))
            for i in range(len(root["global_empty_slot_span_ring"])):
                x = root["global_empty_slot_span_ring"][i]
                gef_print("    global_empty_slot_span_ring[{:2d}]:                       {:#x}".format(i, x))
        else:
            gef_print("SlotSpan* global_empty_slot_span_ring[{:2d}]:             ...".format(ring_len))
        gef_print("int16_t global_empty_slot_span_ring_index:             {:#x}".format(root["global_empty_slot_span_ring_index"]))
        gef_print("int16_t global_empty_slot_span_ring_size:              {:#x}".format(root["global_empty_slot_span_ring_size"]))
        inv = root["inverted_self"]
        inv_inv = inv ^ ((1 << (current_arch.ptrsize * 8)) - 1)
        gef_print("uintptr_t inverted_self:                               {:#x} (=~{:#x})".format(inv, inv_inv))
        gef_print("std::atomic<int> thread_caches_being_constructed_:     {:#x}".format(root["thread_caches_being_constructed_"]))
        gef_print("bool quarantine_always_for_testing:                    {:#x}".format(root["quarantine_always_for_testing"]))
        return

    def print_extent_list(self, head):
        try:
            current = head
            while current:
                extent, _ = self.read_extent(current)
                gef_print("    -> extent @{:<#14x}".format(extent["addr"]))
                gef_print("           root:{:<#14x} ".format(extent["root"]))
                super_page_info = "{:<#14x} - {:<#14x}".format(extent["super_page_base"], extent["super_page_end"])
                page_info = "(total 0x200000(2MB) * {:d} pages)".format(extent["number_of_consecutive_super_pages"])
                gef_print("           super_page:{:s} {:s}".format(Color.colorify(super_page_info, "yellow bold"), page_info))
                gef_print("           non_empty_slot_spans:{:d} ".format(extent["number_of_nonempty_slot_spans"]))
                gef_print("           next:{:<#14x}".format(extent["next"]))
                current = extent["next"]
        except Exception:
            err("Corrupted?")
        return

    def print_direct_map_list(self, head, root):
        try:
            current = head
            while current:
                direct_map, _ = self.read_direct_map(current)
                gef_print("    -> direct_map @{:<#14x}: ".format(direct_map["addr"]))
                gef_print("           next_extent:{:<#14x} ".format(direct_map["next_extent"]))
                gef_print("           prev_extent:{:<#14x} ".format(direct_map["prev_extent"]))
                gef_print("           bucket:{:<#14x} ".format(direct_map["bucket"]))
                gef_print("           reservation_size:{:#x}".format(direct_map["reservation_size"]))
                gef_print("           padding_for_alignment:{:#x}".format(direct_map["padding_for_alignment"]))
                bucket, _ = self.read_bucket(direct_map["bucket"])
                self.print_bucket(bucket, root)
                current = direct_map["next_extent"]
        except Exception:
            err("Corrupted?")
        return

    def print_bucket(self, bucket, root, idx=None):
        sentinel1 = self.get_sentinel_slot_spans() # from symbol
        sentinel2 = [root["sentinel_bucket"]["active_slot_spans_head"]] # from heuristic search
        sentinel = list(set(sentinel1 + sentinel2)) # uniq

        if not self.verbose:
            if bucket["active_slot_spans_head"] in sentinel + [0x0]:
                return # skip printing

        slot_size = Color.colorify("{:#7x}".format(bucket["slot_size"]), "bold pink")
        if idx is not None:
            gef_print("    buckets[{:3d}](slot_size:{:s}) @{:<#14x}".format(idx, slot_size, bucket["addr"]))
        else:
            gef_print("    bucket(slot_size:{:s}) @{:<#14x}".format(slot_size, bucket["addr"]))
        gef_print("        num_system_pages_per_slot_span:{:<#4x} ".format(bucket["num_system_pages_per_slot_span"]))
        gef_print("        num_full_slot_spans:{:<#4x} ".format(bucket["num_full_slot_spans"]))
        gef_print("        slot_size_reciprocal:{:#x}".format(bucket["slot_size_reciprocal"]))

        if self.verbose:
            target_list = ["active_slot_spans_head", "empty_slot_spans_head", "decommitted_slot_spans_head"]
        else:
            target_list = ["active_slot_spans_head"]

        for key in target_list:
            head = bucket[key]
            # sentinel can be ignored, so skip
            if not self.verbose and (head in sentinel + [0x0]):
                continue
            if head in sentinel:
                # print sentinel (verbose)
                gef_print("        {:s}:sentinel_pages".format(Color.colorify(key, "bold cyan underline")))
            else:
                # default
                gef_print("        {:s}:{:<#14x}".format(Color.colorify(key, "bold cyan underline"), head))
            self.print_slot_span(head, bucket)
        return

    def print_slot_span(self, head, bucket):
        current = head
        while current:
            try:
                slot_span, _ = self.read_slot_span(current)
            except Exception:
                err("Corrupted?")
                break
            text_fmt = "            -> slot_span @{:<#14x} (#{:3d} of super_page @{:<#14x})"
            gef_print(text_fmt.format(slot_span["addr"], slot_span["partition_page_index"], slot_span["super_page_addr"]))
            gef_print("                   next_slot_span:{:<#14x} ".format(slot_span["next_slot_span"]))
            page_start = slot_span["partition_page_start"]
            page_end = slot_span["partition_page_start"] + bucket["num_system_pages_per_slot_span"] * gef_getpagesize()
            gef_print("                   slot_span_area:{:#x}-{:#x} ".format(page_start, page_end))
            gef_print("                   num_allocated_slots:{:#x}".format(slot_span["num_allocated_slots"]))
            self.print_freelist(slot_span["freelist_head"], bucket, slot_span)
            current = slot_span["next_slot_span"]
        return

    def print_freelist(self, head, bucket, slot_span):
        gef_print("                   freelist_head:{:<#14x} ".format(head))

        slot_size = bucket["slot_size"]
        page_start = slot_span["partition_page_start"]
        page_end = slot_span["partition_page_start"] + bucket["num_system_pages_per_slot_span"] * gef_getpagesize()

        text = ""
        cnt = 0
        chunk = head
        seen = []
        while chunk:
            if cnt % 7 == 0:
                if cnt > 0:
                    text += "\n"
                text += " " * 23

            if chunk in seen:
                text += Color.colorify("-> {:<#14x} (loop) ".format(chunk), "red bold")
                break

            if not ((page_start <= chunk < page_end) and ((chunk - page_start) % slot_size == 0)):
                text += Color.colorify("-> {:<#14x} (corrupted) ".format(chunk), "red bold")
                break

            try:
                next_chunk = self.byteswap(read_int_from_memory(chunk))
            except Exception:
                text += Color.colorify("-> {:<#14x} (corrupted) ".format(chunk), "red bold")
                break

            text += "-> " + Color.colorify("{:<#14x} ".format(chunk), "yellow bold")
            cnt += 1
            seen.append(chunk)
            chunk = next_chunk

        if cnt > 0:
            text += "(num: {:#x})".format(cnt)

        if text:
            gef_print(text)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64", "ARM32", "ARM64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        if is_32bit():
            self.align_pad = None

        if "-h" in argv:
            self.usage()
            return

        self.verbose = False
        if "-v" in argv:
            self.verbose = True
            argv.remove("-v")

        if len(argv) != 1:
            self.usage()
            return

        if not argv[0] in ["fast_malloc", "fm", "array_buffer", "ab", "buffer", "b", "all"]:
            self.usage()
            return
        target = argv[0]

        for name, addr in self.get_roots():
            ok = False
            if target == "all":
                ok = True
            elif target in ["fast_malloc", "fm"] and name == "fast_malloc_root_":
                ok = True
            elif target in ["array_buffer", "ab"] and name == "array_buffer_root_":
                ok = True
            elif target in ["buffer", "b"] and name == "buffer_root_":
                ok = True

            if ok:
                try:
                    root, _ = self.read_root(addr, name)
                except Exception:
                    mem_value = read_int_from_memory(addr)
                    err("Parse error {:s}: @ {:#x} -> {:#x}".format(name, addr, mem_value))
                    continue
                self.print_root(root)
        return


@register_command
class PartitionAllocDumpBetaCommand(PartitionAllocDumpStableCommand):
    """PartitionAlloc freelist viewer for chromium beta (supported x64/x86/ARM64/ARM only)."""
    _cmdline_ = "partition-alloc-dump-beta"
    _syntax_ = "{:s} [-h] fast_malloc|array_buffer|buffer|all [-v]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} array_buffer # walk from array_buffer_root_\n".format(_cmdline_)
    _example_ += "{:s} ab # same above (fm, ab and b are valid)\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "THIS FEATURE IS EXPERIMENTAL AND HEURISTIC.\n"
    _example_ += "Chromium mainline is too fast to develop. So if parse is failed, you need fix this gef.py."
    _category_ = "Chrome"

    # No diffs affecting this command


@register_command
class PartitionAllocDumpDevCommand(PartitionAllocDumpBetaCommand):
    """PartitionAlloc freelist viewer for chromium dev (supported x64/x86/ARM64/ARM only)."""
    _cmdline_ = "partition-alloc-dump-dev"
    _syntax_ = "{:s} [-h] fast_malloc|array_buffer|buffer|all [-v]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} array_buffer # walk from array_buffer_root_\n".format(_cmdline_)
    _example_ += "{:s} ab # same above (fm, ab and b are valid)\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "THIS FEATURE IS EXPERIMENTAL AND HEURISTIC.\n"
    _example_ += "Chromium mainline is too fast to develop. So if parse is failed, you need fix this gef.py."
    _category_ = "Chrome"

    # No diffs affecting this command


@register_command
class PartitionAllocDumpOld1Command(GenericCommand):
    """PartitionAlloc freelist viewer (supported x64/x86/ARM64/ARM only). This is old command, based on Google CTF 2021 - fullchain."""
    _cmdline_ = "partition-alloc-dump-old1"
    _syntax_ = "{:s} [-h] fast_malloc|array_buffer|buffer|layout|all [-v]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} array_buffer # walk from array_buffer_root_\n".format(_cmdline_)
    _example_ += "{:s} ab # same above (fm, ab, b and l are valid)\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "For the implementation in 2021 Jul (tested on Google CTF 2021 - fullchain).\n"
    _example_ += "THIS FEATURE IS EXPERIMENTAL AND HEURISTIC.\n"
    _category_ = "Chrome"

    """
    partition alloc freelist is following.

     +-root-----------------+
     | ...                  |    +---> +-extent------------+  +-> +-extent------------+  +-> ...
     | next_super_page      |    |     | super_page_base   |  |   | super_page_base   |  |
     | next_partition_page  |    |     | next              | -+   | next              | -+
     | ...                  |    |     +-------------------+      +-------------------+
     | first_extent         | ---+
     | direct_map_list      | -------> +-direct_map_extent-+  +-> +-direct_map_extent-+  +-> ...
     | ...                  |          | bucket            |  |   | bucket            |  |
     |                      |          | next_extent       | -+   | next_extent       | -+
     |                      |          +-------------------+      +-------------------+
     |                      |
     +-bucket[0](0x20)------+
     | head                 | -------> +-slot_span---------+  +-> +-slot_span---------+  +-> ...
     | slot_size            | <------- | bucket            |  |   | bucket            |  |
     | ...                  |    +---- | freelist_head     |  |   | freelist_head     |  |
     +-bucket[1](0x20)------+    |     | next_slot_span    | -+   | next_slot_span    | -+
     | head                 |    |     +-------------------+      +-------------------+
     | slot_size            |    |
     | ...                  |    |
     +----------------------+    |
     | ...                  |    |
     |                      |    +---> +-slot--------------+
     |                      |          | next              | --+
     +----------------------+          | (freed)           |   |
                                       +-slot--------------+   |
                                       |                   |   |
                                       | (used)            |   |
                                       +-slot--------------+ <-+
                                   +-- | next              |
                                   |   | (freed)           |
                                   |   +-slot--------------+
                                   |   |                   |
                                   |   | (used)            |
                                   +-> +-slot--------------+
                                       | next              | --> NULL
                                       | (freed)           |
                                       +-slot--------------+
                                       |                   |
                                       |                   |
                                       +-------------------+

    `slot_span` and `slot` are in super_page.

          +-super_page-(2MB)----+
     4KB  | Guard Page          |
          +---------------------+
     4KB  | slot_span * 128     |
          +---------------------+
     8KB  | Guard Page          |
          +---------------------+
     16KB | Partition Page #1   |
          |   slot              |
          |   slot              |
          |   ...               |
          +---------------------+
          | ...                 |
          +---------------------+
     16KB | Partition Page #126 |
          +---------------------+
     12KB | Unused              |
          +---------------------+
      4KB | Guard Page          |
          +---------------------+
    """

    @functools.lru_cache()
    def get_roots_heuristic(self):
        """searches for array_buffer_root_, buffer_root_, layout_root_ and fast_malloc_root_"""
        filepath = get_filepath(for_vmmap=True)
        if is_64bit():
            codebase = get_section_base_address(filepath)
            mask = 0x0000ffff00000000
            chromium_rw_maps = [p for p in get_process_maps() if p.permission.value == Permission.READ | Permission.WRITE]
            chromium_rw_maps = [p for p in chromium_rw_maps if (p.page_start & mask) == (codebase & mask) and p.path != filepath]
        elif is_32bit():
            mask = 0xff000000
            heapbase = HeapBaseFunction.heap_base()
            chromium_rw_maps = [p for p in get_process_maps() if p.permission.value == Permission.READ | Permission.WRITE]
            chromium_rw_maps = [p for p in chromium_rw_maps if p.page_start < heapbase and p.path != filepath]

        roots = []
        for maps in chromium_rw_maps:
            datas = slice_unpack(read_memory(maps.page_start, maps.size), current_arch.ptrsize)
            addrs = [x for x in range(maps.page_start, maps.page_end, current_arch.ptrsize)]

            """
            #if !BUILDFLAG(USE_PARTITION_ALLOC_AS_MALLOC)
            base::ThreadSafePartitionRoot* Partitions::fast_malloc_root_ = nullptr;
            #endif
            base::ThreadSafePartitionRoot* Partitions::array_buffer_root_ = nullptr;
            base::ThreadSafePartitionRoot* Partitions::buffer_root_ = nullptr;
            base::ThreadUnsafePartitionRoot* Partitions::layout_root_ = nullptr;
            """
            for i in range(len(addrs) - 3):
                if (datas[i] & mask) != (addrs[i] & mask): # maybe it points near
                    continue
                if (datas[i] & 0x7) != 0: # maybe it is aligned
                    continue

                # roots are next to each other
                # calc diff                              # [fast_malloc_root_ exists]            # [fast_malloc_root_ does not exist] #
                root_size1 = datas[i + 1] - datas[i]     # array_buffer_root - fast_malloc_root_ # buffer_root_ - array_buffer_root_  # valid
                root_size2 = datas[i + 2] - datas[i + 1] # buffer_root_ - array_buffer_root_     # layout_root_ - buffer_root_        # valid
                root_size3 = datas[i + 3] - datas[i + 2] # layout_root_ - buffer_root_           # xxx - xxx                          # maybe invalid

                # sizeof(root) is all same
                if root_size1 != root_size2:
                    continue

                if is_64bit() and ((root_size1 < 0x1000) or (0x1800 < root_size1)): # sizeof(*root) is valid
                    continue
                elif is_32bit() and ((root_size1 < 0x800) or (0x1800 < root_size1)): # sizeof(*root) is valid
                    continue

                # here, maybe found
                if addrs[i] in [root[1] for root in roots]: # but it has already checked
                    continue

                if root_size2 == root_size3: # fast_malloc_root_ exists
                    roots.append(["fast_malloc_root_", addrs[i]])
                    roots.append(["array_buffer_root_", addrs[i + 1]])
                    roots.append(["buffer_root_", addrs[i + 2]])
                    roots.append(["layout_root_", addrs[i + 3]])
                else: # fast_malloc_root_ does not exist
                    roots.append(["array_buffer_root_", addrs[i]])
                    roots.append(["buffer_root_", addrs[i + 1]])
                    roots.append(["layout_root_", addrs[i + 2]])

        if len(roots) in [3, 4]:
            for root in roots:
                info("found: {:s}: {:#x}".format(root[0], root[1]))
        elif len(roots) == 0:
            err("root were not found. try check code")
        else:
            err("candidates for root are found in multiple places. try check code")
            for root in roots:
                gef_print("  candidate: {:s} {:#x}".format(root[0], root[1]))
                if root[0] == "layout_root_":
                    gef_print("")
            roots = []
        return roots

    @functools.lru_cache()
    def get_roots(self):
        def get_root(root_string):
            try:
                root_addr = parse_address("&'WTF::Partitions::{:s}'".format(root_string))
                return [[root_string, root_addr]]
            except Exception:
                return []

        roots = []
        # try from symbols
        for root_string in ["fast_malloc_root_", "array_buffer_root_", "buffer_root_", "layout_root_"]:
            roots += get_root(root_string)
        # maybe no symbols, try heuristic
        if len(roots) == 0:
            info("Symbol is not found. It will use heuristic search")
            roots += self.get_roots_heuristic()
        # retry checking
        if len(roots) == 0:
            info("Symbol is not found.")
        return roots

    @functools.lru_cache()
    def get_sentinel_slot_spans(self):
        """sentinel_slot_span is default slot_span, so search it"""
        sentinel = []
        try:
            t = parse_address("&'base::internal::SlotSpanMetadata<true>::sentinel_slot_span_'")
            sentinel.append(t)
        except Exception:
            pass
        try:
            f = parse_address("&'base::internal::SlotSpanMetadata<false>::sentinel_slot_span_'")
            sentinel.append(f)
        except Exception:
            pass
        return sentinel

    def byteswap(self, x):
        p = lambda a: struct.pack("<I", a & 0xffffffff)
        ube = lambda a: struct.unpack(">I", a)[0]
        pQ = lambda a: struct.pack("<Q", a & 0xffffffffffffffff)
        uQbe = lambda a: struct.unpack(">Q", a)[0]
        if is_64bit():
            converted = uQbe(pQ(x))
        elif is_32bit():
            converted = ube(p(x))
        return converted

    def read_root(self, addr, name):
        ptrsize = current_arch.ptrsize
        root = {}
        root["name"] = name
        root["addr"] = current = read_int_from_memory(addr)
        """
        struct base::PartitionRoot {
            bool with_thread_cache = false;
            const bool is_thread_safe = thread_safe;
            bool allow_aligned_alloc;
            bool allow_cookies;
            bool allow_ref_count;
            //static constexpr bool use_lazy_commit = false;
            //static constexpr bool never_used_lazy_commit = true;
            //uint32_t extras_size;
            //uint32_t extras_offset;
            internal::MaybeSpinLock<thread_safe> lock_;
            Bucket buckets[kNumBuckets] = {};
            Bucket sentinel_bucket;
            bool initialized = false;
            std::atomic<size_t> total_size_of_committed_pages{0};
            std::atomic<size_t> total_size_of_super_pages{0};
            std::atomic<size_t> total_size_of_direct_mapped_pages{0};
            char* next_super_page = nullptr;
            char* next_partition_page = nullptr;
            char* next_partition_page_end = nullptr;
            SuperPageExtentEntry* current_extent = nullptr;
            SuperPageExtentEntry* first_extent = nullptr;
            DirectMapExtent* direct_map_list GUARDED_BY(lock_) = nullptr;
            SlotSpan* global_empty_slot_span_ring[kMaxFreeableSpans] = {};
            int16_t global_empty_slot_span_ring_index = 0;
            uintptr_t inverted_self = 0;
            std::atomic<int> thread_caches_being_constructed_{0};
        }
        """
        x = u64(read_memory(current, 8))
        current += 8
        root["with_thread_cache"] = (x >> 0) & 0xff
        root["is_thread_safe"] = (x >> 8) & 0xff
        root["allow_aligned_alloc"] = (x >> 16) & 0xff
        root["allow_cookies"] = (x >> 24) & 0xff
        root["allow_ref_count"] = (x >> 32) & 0xff

        root["lock_"] = read_int_from_memory(current)
        current += ptrsize

        # for 32bit, there is 2 patterns because aligned or packed
        if is_32bit():
            if self.align_pad is None:
                x = read_int_from_memory(current)
                if x == 0:
                    self.align_pad = True
                else:
                    self.align_pad = False
            if self.align_pad:
                current += ptrsize

        root["buckets"] = []
        while True:
            if read_int_from_memory(current) == 1: # search initialized
                break
            bucket, current = self.read_bucket(current)
            root["buckets"].append(bucket)
        root["sentinel_bucket"] = root["buckets"].pop()

        root["initialized"] = read_int_from_memory(current) & 0xff
        current += ptrsize # with pad
        root["total_size_of_committed_pages"] = read_int_from_memory(current)
        current += ptrsize
        root["total_size_of_super_pages"] = read_int_from_memory(current)
        current += ptrsize
        root["total_size_of_direct_mapped_pages"] = read_int_from_memory(current)
        current += ptrsize
        root["next_super_page"] = read_int_from_memory(current)
        current += ptrsize
        root["next_partition_page"] = read_int_from_memory(current)
        current += ptrsize
        root["next_partition_page_end"] = read_int_from_memory(current)
        current += ptrsize
        root["current_extent"] = read_int_from_memory(current)
        current += ptrsize
        root["first_extent"] = read_int_from_memory(current)
        current += ptrsize
        root["direct_map_list"] = read_int_from_memory(current)
        current += ptrsize

        root["global_empty_slot_span_ring"] = []
        inv = root["addr"] ^ ((1 << (current_arch.ptrsize * 8)) - 1)
        while True:
            if read_int_from_memory(current + ptrsize) == inv: # search inverted_self
                break
            x = read_int_from_memory(current)
            current += ptrsize
            root["global_empty_slot_span_ring"].append(x)

        root["global_empty_slot_span_ring_index"] = u16(read_memory(current, 2))
        current += ptrsize # with pad
        root["inverted_self"] = read_int_from_memory(current)
        current += ptrsize
        root["thread_caches_being_constructed_"] = u32(read_memory(current, 4))
        current += 4
        return root, current

    def read_bucket(self, addr):
        ptrsize = current_arch.ptrsize
        bucket = {}
        bucket["addr"] = current = addr
        """
        struct base::internal::PartitionBucket {
            SlotSpanMetadata<thread_safe>* active_slot_spans_head;
            SlotSpanMetadata<thread_safe>* empty_slot_spans_head;
            SlotSpanMetadata<thread_safe>* decommitted_slot_spans_head;
            uint32_t slot_size;
            uint32_t num_system_pages_per_slot_span : 8;
            uint32_t num_full_slot_spans : 24;
            uint64_t slot_size_reciprocal;
        };
        """
        bucket["active_slot_spans_head"] = read_int_from_memory(current)
        current += ptrsize
        bucket["empty_slot_spans_head"] = read_int_from_memory(current)
        current += ptrsize
        bucket["decommitted_slot_spans_head"] = read_int_from_memory(current)
        current += ptrsize
        bucket["slot_size"] = u32(read_memory(current, 4))
        current += 4
        x = u32(read_memory(current, 4))
        bucket["num_system_pages_per_slot_span"] = x & 0xff
        bucket["num_full_slot_spans"] = (x >> 8) & 0xffffff
        current += 4

        # for 32bit, there is 2 patterns because aligned or packed
        if is_32bit() and self.align_pad:
            current += 4
        bucket["slot_size_reciprocal"] = u64(read_memory(current, 8))
        current += 8
        return bucket, current

    def read_extent(self, addr):
        ptrsize = current_arch.ptrsize
        extent = {}
        extent["addr"] = current = addr
        """
        struct PartitionSuperPageExtentEntry {
          PartitionRootBase* root;
          char* super_page_base;
          char* super_pages_end;
          PartitionSuperPageExtentEntry* next;
        };
        """
        kSuperPageShift = 21
        extent["root"] = read_int_from_memory(current)
        current += ptrsize
        extent["super_page_base"] = read_int_from_memory(current)
        current += ptrsize
        extent["super_pages_end"] = read_int_from_memory(current)
        current += ptrsize
        extent["next"] = read_int_from_memory(current)
        current += ptrsize
        extent["num_pages"] = (extent["super_pages_end"] - extent["super_page_base"]) >> kSuperPageShift
        return extent, current

    def read_direct_map(self, addr):
        ptrsize = current_arch.ptrsize
        direct_map = {}
        direct_map["addr"] = current = addr
        """
        struct PartitionDirectMapExtent {
          PartitionDirectMapExtent<thread_safe>* next_extent;
          PartitionDirectMapExtent<thread_safe>* prev_extent;
          PartitionBucket<thread_safe>* bucket;
          size_t map_size;
        };
        """
        direct_map["next_extent"] = read_int_from_memory(current)
        current += ptrsize
        direct_map["prev_extent"] = read_int_from_memory(current)
        current += ptrsize
        direct_map["bucket"] = read_int_from_memory(current)
        current += ptrsize
        direct_map["map_size"] = read_int_from_memory(current)
        current += ptrsize
        return direct_map, current

    def read_slot_span(self, addr):
        ptrsize = current_arch.ptrsize
        slot_span = {}
        slot_span["addr"] = current = addr
        slot_span["super_page_addr"] = (slot_span["addr"] & gef_getpagesize_mask()) - gef_getpagesize()
        slot_span["partition_page_index"] = (slot_span["addr"] & (gef_getpagesize() - 1)) // 0x20
        slot_span["partition_page_start"] = slot_span["super_page_addr"] + slot_span["partition_page_index"] * gef_getpagesize() * 4
        """
        struct SlotSpanMetadata {
          PartitionFreelistEntry* freelist_head = nullptr;
          SlotSpanMetadata<thread_safe>* next_slot_span = nullptr;
          PartitionBucket<thread_safe>* const bucket;
          int16_t num_allocated_slots = 0;
          uint16_t num_unprovisioned_slots = 0;
          int8_t empty_cache_index = 0;
          const bool can_store_raw_size;
        }
        """
        slot_span["freelist_head"] = read_int_from_memory(current)
        current += ptrsize
        slot_span["next_slot_span"] = read_int_from_memory(current)
        current += ptrsize
        slot_span["bucket"] = read_int_from_memory(current)
        current += ptrsize
        slot_span["num_allocated_slots"] = u16(read_memory(current, 2))
        current += 2
        slot_span["num_unprovisioned_slots"] = u16(read_memory(current, 2))
        current += 2
        slot_span["empty_cache_index"] = u8(read_memory(current, 1))
        current += 1
        slot_span["can_store_raw_size"] = u8(read_memory(current, 1))
        current += 1
        return slot_span, current

    def print_root(self, root):
        gef_print(titlify("*{} @ {:#x}".format(root["name"], root["addr"])))
        gef_print("bool with_thread_cache:                                {:#x}".format(root["with_thread_cache"]))
        gef_print("const bool is_thread_safe:                             {:#x}".format(root["is_thread_safe"]))
        gef_print("bool allow_aligned_alloc:                              {:#x}".format(root["allow_aligned_alloc"]))
        gef_print("bool allow_cookies:                                    {:#x}".format(root["allow_cookies"]))
        gef_print("bool allow_ref_count:                                  {:#x}".format(root["allow_ref_count"]))
        gef_print("internal::MaybeSpinLock:                               {:#x}".format(root["lock_"]))
        gef_print("Bucket buckets[{:3d}]:".format(len(root["buckets"])))
        for idx, bucket in enumerate(root["buckets"]):
            self.print_bucket(bucket, root, idx)
        if self.verbose:
            gef_print("Bucket sentinel_bucket:")
            self.print_bucket(root["sentinel_bucket"], root)
        else:
            gef_print("Bucket sentinel_bucket:                                ...")
        gef_print("bool initialized:                                      {:#x}".format(root["initialized"]))
        gef_print("std::atomic<size_t> total_size_of_commited_pages:      {:#x}".format(root["total_size_of_committed_pages"]))
        gef_print("std::atomic<size_t> total_size_of_super_pages:         {:#x}".format(root["total_size_of_super_pages"]))
        gef_print("std::atomic<size_t> total_size_of_direct_mapped_pages: {:#x}".format(root["total_size_of_direct_mapped_pages"]))
        gef_print("char* next_super_page:                                 {:#x}".format(root["next_super_page"]))
        gef_print("char* next_partition_page:                             {:#x}".format(root["next_partition_page"]))
        gef_print("char* next_partition_page_end:                         {:#x}".format(root["next_partition_page_end"]))
        gef_print("SuperPageExtentEntry* current_extent:                  {:#x}".format(root["current_extent"]))
        gef_print("SuperPageExtentEntry* first_extent:                    {:#x}".format(root["first_extent"]))
        self.print_extent_list(root["first_extent"])
        gef_print("DirectMapExtent* direct_map_list:                      {:#x}".format(root["direct_map_list"]))
        self.print_direct_map_list(root["direct_map_list"], root)
        ring_len = len(root["global_empty_slot_span_ring"])
        if self.verbose:
            gef_print("SlotSpan* global_empty_slot_span_ring[{:2d}]:".format(ring_len))
            for i in range(len(root["global_empty_slot_span_ring"])):
                x = root["global_empty_slot_span_ring"][i]
                gef_print("    global_empty_slot_span_ring[{:2d}]:                       {:#x}".format(i, x))
        else:
            gef_print("SlotSpan* global_empty_slot_span_ring[{:2d}]:             ...".format(ring_len))
        gef_print("int16_t global_empty_slot_span_ring_index:             {:#x}".format(root["global_empty_slot_span_ring_index"]))
        inv = root["inverted_self"]
        inv_inv = inv ^ ((1 << (current_arch.ptrsize * 8)) - 1)
        gef_print("uintptr_t inverted_self:                               {:#x} (=~{:#x})".format(inv, inv_inv))
        gef_print("std::atomic<int> thread_caches_being_constructed_:     {:#x}".format(root["thread_caches_being_constructed_"]))
        return

    def print_extent_list(self, head):
        try:
            current = head
            while current:
                extent, _ = self.read_extent(current)
                text = "    -> extent @{:<#14x}: ".format(extent["addr"])
                text += "root:{:<#14x} ".format(extent["root"])
                super_page_info = "{:<#14x} - {:<#14x}".format(extent["super_page_base"], extent["super_pages_end"])
                text += "super_page:" + Color.colorify(super_page_info, "yellow bold")
                text += " (total 0x200000(2MB) * {:d} pages) ".format(extent["num_pages"])
                text += "next:{:<#14x}".format(extent["next"])
                gef_print(text)
                current = extent["next"]
        except Exception:
            err("Corrupted?")
        return

    def print_direct_map_list(self, head, root):
        bugged = False

        def bugcheck(bucket):
            # maybe chromium's bug: bucket used by direct_map is strange
            """
            I confirmed under v89.0.4389.114, v92.0.4515.107. but it is fixed under v93.0.4540.0
            gef> x/16xg 0x2000201040 <--- direct_map_list->bucket
            0x2000201040:   0x00000000001e0000 *    0x0000000000000000 <-- * is strange, it should be valid pointer or null
            0x2000201050:   0x0000000000000000      0x00000000001e0000     because it is `active_slot_spans_head`
            0x2000201060:   0x0000000000000000      0x0000002000001068
            0x2000201070:   0x0000000000000000      0x0000002000201040
            0x2000201080:   0x00000000001fc000      0x0000000000000000
            """
            nonlocal bugged
            if bugged: # already printed
                return
            x = bucket["active_slot_spans_head"]
            if x == 0: # nullptr is valid
                return
            try:
                read_memory(x)
            except gdb.MemoryError:
                info("maybe chrome bug; direct_map_list->bucket->active_slot_spans_head is broken? it was fixed at least v93.0.4540.0")
                bugged = True
            return

        try:
            current = head
            while current:
                direct_map, _ = self.read_direct_map(current)
                text = "    -> direct_map @{:<#14x}: ".format(direct_map["addr"])
                text += "next_extent:{:<#14x} ".format(direct_map["next_extent"])
                text += "prev_extent:{:<#14x} ".format(direct_map["prev_extent"])
                text += "bucket:{:<#14x} ".format(direct_map["bucket"])
                text += "map_size:{:#x}".format(direct_map["map_size"])
                gef_print(text)
                bucket, _ = self.read_bucket(direct_map["bucket"])
                bugcheck(bucket)
                self.print_bucket(bucket, root)
                current = direct_map["next_extent"]
        except Exception:
            err("Corrupted?")
        return

    def print_bucket(self, bucket, root, idx=None):
        sentinel1 = self.get_sentinel_slot_spans() # from symbol
        sentinel2 = [root["sentinel_bucket"]["active_slot_spans_head"]] # from heuristic search
        sentinel = list(set(sentinel1 + sentinel2)) # uniq

        if not self.verbose:
            if bucket["active_slot_spans_head"] in sentinel + [0x0]:
                return # skip printing

        slot_size = Color.colorify("{:#7x}".format(bucket["slot_size"]), "bold pink")
        if idx is not None:
            text = "    buckets[{:3d}](slot_size:{:s}) @{:<#14x}".format(idx, slot_size, bucket["addr"])
        else:
            text = "    bucket(slot_size:{:s}) @{:<#14x}".format(slot_size, bucket["addr"])
        gef_print(text)
        text = "        "
        text += "num_system_pages_per_slot_span:{:<#4x} ".format(bucket["num_system_pages_per_slot_span"])
        text += "num_full_slot_spans:{:<#4x} ".format(bucket["num_full_slot_spans"])
        text += "slot_size_reciprocal:{:#x}".format(bucket["slot_size_reciprocal"])
        gef_print(text)

        if self.verbose:
            target_list = ["active_slot_spans_head", "empty_slot_spans_head", "decommitted_slot_spans_head"]
        else:
            target_list = ["active_slot_spans_head"]

        for key in target_list:
            head = bucket[key]
            if not self.verbose and (head in sentinel + [0x0]):
                continue
            if head in sentinel:
                gef_print("        {:s}:sentinel_pages".format(Color.colorify(key, "bold cyan underline")))
            else:
                gef_print("        {:s}:{:<#14x}".format(Color.colorify(key, "bold cyan underline"), head))
            self.print_slot_span(head, bucket)
        return

    def print_slot_span(self, head, bucket):
        current = head
        while current:
            try:
                slot_span, _ = self.read_slot_span(current)
            except Exception:
                err("Corrupted?")
                break
            text_fmt = "            -> slot_span @{:<#14x} (#{:3d} of super_page @{:<#14x})"
            text = text_fmt.format(slot_span["addr"], slot_span["partition_page_index"], slot_span["super_page_addr"])
            gef_print(text)
            text = "                "
            text += "next_slot_span:{:<#14x} ".format(slot_span["next_slot_span"])
            page_start = slot_span["partition_page_start"]
            page_end = slot_span["partition_page_start"] + bucket["num_system_pages_per_slot_span"] * gef_getpagesize()
            text += "slot_span_area:{:#x}-{:#x} ".format(page_start, page_end)
            text += "num_allocated_slots:{:#x}".format(slot_span["num_allocated_slots"])
            gef_print(text)
            self.print_freelist(slot_span["freelist_head"], bucket, slot_span)
            current = slot_span["next_slot_span"]
        return

    def print_freelist(self, head, bucket, slot_span):
        gef_print("                freelist_head:{:<#14x} ".format(head))

        slot_size = bucket["slot_size"]
        page_start = slot_span["partition_page_start"]
        page_end = slot_span["partition_page_start"] + bucket["num_system_pages_per_slot_span"] * gef_getpagesize()

        text = ""
        cnt = 0
        chunk = head
        seen = []
        while chunk:
            if cnt % 7 == 0:
                if cnt > 0:
                    text += "\n"
                text += " " * 20

            if chunk in seen:
                text += Color.colorify("-> {:<#14x} (loop) ".format(chunk), "red bold")
                break

            if not ((page_start <= chunk < page_end) and ((chunk - page_start) % slot_size == 0)):
                text += Color.colorify("-> {:<#14x} (corrupted) ".format(chunk), "red bold")
                break

            try:
                next_chunk = self.byteswap(read_int_from_memory(chunk))
            except Exception:
                text += Color.colorify("-> {:<#14x} (corrupted) ".format(chunk), "red bold")
                break

            text += "-> " + Color.colorify("{:<#14x} ".format(chunk), "yellow bold")
            cnt += 1
            seen.append(chunk)
            chunk = next_chunk

        if cnt > 0:
            text += "(num: {:#x})".format(cnt)

        if text:
            gef_print(text)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64", "ARM32", "ARM64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        if is_32bit():
            self.align_pad = None

        if "-h" in argv:
            self.usage()
            return

        self.verbose = False
        if "-v" in argv:
            self.verbose = True
            argv.remove("-v")

        if len(argv) != 1:
            self.usage()
            return

        if not argv[0] in ["fast_malloc", "fm", "array_buffer", "ab", "buffer", "b", "layout", "l", "all"]:
            self.usage()
            return
        target = argv[0]

        for name, addr in self.get_roots():
            ok = False
            if target == "all":
                ok = True
            elif target in ["fast_malloc", "fm"] and name == "fast_malloc_root_":
                ok = True
            elif target in ["array_buffer", "ab"] and name == "array_buffer_root_":
                ok = True
            elif target in ["buffer", "b"] and name == "buffer_root_":
                ok = True
            elif target in ["layout", "l"] and name == "layout_root_":
                ok = True

            if ok:
                try:
                    root, _ = self.read_root(addr, name)
                except Exception:
                    err("Parse error {:s}: @ {:#x}".format(name, addr))
                    continue
                self.print_root(root)
        return


@register_command
class PartitionAllocDumpOld2Command(GenericCommand):
    """PartitionAlloc freelist viewer (supported x64 only). This is old command, based on 0ctf 2020 chromium fullchain."""
    _cmdline_ = "partition-alloc-dump-old2"
    _syntax_ = "{:s} [-h] fast_malloc|array_buffer|buffer|layout|all [-v]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} array_buffer # walk from array_buffer_root_\n".format(_cmdline_)
    _example_ += "{:s} ab # same above (fm, ab, b and l are valid)\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "For the implementation in 2020 Jun (tested on 0CTF 2020 - chromium fullchain).\n"
    _example_ += "THIS FEATURE IS EXPERIMENTAL AND HEURISTIC.\n"
    _category_ = "Chrome"

    """
    See https://qiita.com/msmania/items/1a10d5b7d20f6455b9b1

    partition alloc freelist is following.

     +-root-----------------+
     | ...                  |    +---> +-extent------------+  +-> +-extent------------+  +-> ...
     | next_super_page      |    |     | super_page_base   |  |   | super_page_base   |  |
     | next_partition_page  |    |     | next              | -+   | next              | -+
     | ...                  |    |     +-------------------+      +-------------------+
     | first_extent         | ---+
     | direct_map_list      | -------> +-direct_map_extent-+  +-> +-direct_map_extent-+  +-> ...
     | ...                  |          | bucket            |  |   | bucket            |  |
     |                      |          | next_extent       | -+   | next_extent       | -+
     |                      |          +-------------------+      +-------------------+
     |                      |
     +-bucket[0](0x20)------+
     | head                 | -------> +-page--------------+  +-> +-page--------------+  +-> ...
     | slot_size            | <------- | bucket            |  |   | bucket            |  |
     | ...                  |    +---- | freelist_head     |  |   | freelist_head     |  |
     +-bucket[1](0x20)------+    |     | next_page         | -+   | next_page         | -+
     | head                 |    |     +-------------------+      +-------------------+
     | slot_size            |    |
     | ...                  |    |
     +----------------------+    |
     | ...                  |    |
     |                      |    +---> +-slot--------------+
     |                      |          | next              | --+
     +----------------------+          | (freed)           |   |
                                       +-slot--------------+   |
                                       |                   |   |
                                       | (used)            |   |
                                       +-slot--------------+ <-+
                                   +-- | next              |
                                   |   | (freed)           |
                                   |   +-slot--------------+
                                   |   |                   |
                                   |   | (used)            |
                                   +-> +-slot--------------+
                                       | next              | --> NULL
                                       | (freed)           |
                                       +-slot--------------+
                                       |                   |
                                       |                   |
                                       +-------------------+

    `page` and `slot` are in super_page.

          +-super_page-(2MB)----+
     4KB  | Guard Page          |
          +---------------------+
     4KB  | page * 128          |
          +---------------------+
     8KB  | Guard Page          |
          +---------------------+
     16KB | Partition Page #1   |
          |   slot              |
          |   slot              |
          |   ...               |
          +---------------------+
          | ...                 |
          +---------------------+
     16KB | Partition Page #126 |
          +---------------------+
     12KB | Unused              |
          +---------------------+
      4KB | Guard Page          |
          +---------------------+
    """

    def get_roots(self):
        roots = []
        try:
            fast_malloc_root = parse_address("&'WTF::Partitions::fast_malloc_root_'")
            roots.append(("fast_malloc_root_", fast_malloc_root))
        except Exception:
            err("'WTF::Partitions::fast_malloc_root_' is not found")
        try:
            array_buffer_root = parse_address("&'WTF::Partitions::array_buffer_root_'")
            roots.append(("array_buffer_root_", array_buffer_root))
        except Exception:
            err("'WTF::Partitions::array_buffer_root_' is not found")
        try:
            buffer_root = parse_address("&'WTF::Partitions::buffer_root_'")
            roots.append(("buffer_root_", buffer_root))
        except Exception:
            err("'WTF::Partitions::buffer_root_' is not found")
        try:
            layout_root = parse_address("&'WTF::Partitions::layout_root_'")
            roots.append(("layout_root_", layout_root))
        except Exception:
            err("'WTF::Partitions::layout_root_' is not found")
        return roots

    def get_sentinel_buckets(self):
        sentinel = []
        try:
            t = parse_address("&'base::internal::PartitionBucket<true>::sentinel_bucket_'")
            sentinel.append(t)
        except Exception:
            err("'base::internal::PartitionBucket<true>::sentinel_bucket_' is not found")
        try:
            f = parse_address("&'base::internal::PartitionBucket<false>::sentinel_bucket_'")
            sentinel.append(f)
        except Exception:
            err("'base::internal::PartitionBucket<false>::sentinel_bucket_' is not found")
        return sentinel

    def get_sentinel_pages(self):
        sentinel = []
        try:
            t = parse_address("&'base::internal::PartitionPage<true>::sentinel_page_'")
            sentinel.append(t)
        except Exception:
            err("'base::internal::PartitionPage<true>::sentinel_page_' is not found")
        try:
            f = parse_address("&'base::internal::PartitionPage<false>::sentinel_page_'")
            sentinel.append(f)
        except Exception:
            err("'base::internal::PartitionPage<false>::sentinel_page_' is not found")
        return sentinel

    def byteswap(self, x):
        pQ = lambda a: struct.pack("<Q", a & 0xffffffffffffffff)
        uQbe = lambda a: struct.unpack(">Q", a)[0]
        return uQbe(pQ(x))

    def read_root(self, addr, name):
        ptrsize = current_arch.ptrsize
        root = {}
        root["name"] = name
        root["addr"] = current = read_int_from_memory(addr)
        """
        struct PartitionRootGeneric {
            struct PartitionRootBase {
              size_t total_size_of_committed_pages = 0;
              size_t total_size_of_super_pages = 0;
              size_t total_size_of_direct_mapped_pages = 0;
              unsigned num_buckets = 0;
              unsigned max_allocation = 0;
              bool initialized = false;
              char* next_super_page = nullptr;
              char* next_partition_page = nullptr;
              char* next_partition_page_end = nullptr;
              PartitionSuperPageExtentEntry* current_extent = nullptr;
              PartitionSuperPageExtentEntry* first_extent = nullptr;
              PartitionDirectMapExtent* direct_map_list = nullptr;
              PartitionPage* global_empty_page_ring[kMaxFreeableSpans] = {};
              int16_t global_empty_page_ring_index = 0;
              uintptr_t inverted_self = 0;
            }
            size_t order_index_shifts[kBitsPerSizeT + 1] = {};
            size_t order_sub_index_masks[kBitsPerSizeT + 1] = {};
            internal::PartitionBucket* bucket_lookups[((kBitsPerSizeT + 1) * kGenericNumBucketsPerOrder) + 1] = {};
            struct PartitionBucket buckets[kGenericNumBuckets] = {};
        }
        """
        kBitsPerSizeT = 64
        kMaxFreeableSpans = 16
        kGenericMinBucketedOrder = 4
        kGenericMaxBucketedOrder = 20
        kGenericNumBucketedOrders = (kGenericMaxBucketedOrder - kGenericMinBucketedOrder) + 1
        kGenericNumBucketsPerOrder = 8
        kGenericNumBuckets = kGenericNumBucketedOrders * kGenericNumBucketsPerOrder
        # kGenericSmallestBucket = 1 << (kGenericMinBucketedOrder - 1)
        # kSystemPageSize = 4096
        # kPartitionPageShift = 14
        # kPageMetadataShift = 5
        # kSuperPageShift = 21
        # kSuperPageSize = 1 << kSuperPageShift
        # kSuperPageOffsetMask = kSuperPageSize - 1
        # kSuperPageBaseMask = ~kSuperPageOffsetMask

        current += ptrsize # needed, but why?
        root["total_size_of_committed_pages"] = read_int_from_memory(current)
        current += ptrsize
        root["total_size_of_super_pages"] = read_int_from_memory(current)
        current += ptrsize
        root["total_size_of_direct_mapped_pages"] = read_int_from_memory(current)
        current += ptrsize
        root["num_buckets"] = u32(read_memory(current, 4))
        current += 4
        root["max_allocation"] = u32(read_memory(current, 4))
        current += 4
        root["initialized"] = u8(read_memory(current, 1))
        current += ptrsize # with pad
        root["next_super_page"] = read_int_from_memory(current)
        current += ptrsize
        root["next_partition_page"] = read_int_from_memory(current)
        current += ptrsize
        root["next_partition_page_end"] = read_int_from_memory(current)
        current += ptrsize
        root["current_extent"] = read_int_from_memory(current)
        current += ptrsize
        root["first_extent"] = read_int_from_memory(current)
        current += ptrsize
        root["direct_map_list"] = read_int_from_memory(current)
        current += ptrsize
        root["global_empty_page_ring"] = []
        for i in range(kMaxFreeableSpans):
            x = read_int_from_memory(current)
            current += ptrsize
            root["global_empty_page_ring"].append(x)
        root["global_empty_page_ring_index"] = u16(read_memory(current, 2))
        current += ptrsize # with pad
        root["inverted_self"] = read_int_from_memory(current)
        current += ptrsize
        root["order_index_shifts"] = []
        for i in range(kBitsPerSizeT + 1):
            x = read_int_from_memory(current)
            current += ptrsize
            root["order_index_shifts"].append(x)
        root["order_sub_index_masks"] = []
        for i in range(kBitsPerSizeT + 1):
            x = read_int_from_memory(current)
            current += ptrsize
            root["order_sub_index_masks"].append(x)
        root["bucket_lookups"] = []
        for i in range(((kBitsPerSizeT + 1) * kGenericNumBucketsPerOrder) + 1):
            x = read_int_from_memory(current)
            current += ptrsize
            root["bucket_lookups"].append(x)
        root["buckets"] = []
        for i in range(kGenericNumBuckets):
            bucket, current = self.read_bucket(current)
            root["buckets"].append(bucket)
            if bucket["slot_size"] == 0xf0000: # some system use different size
                break
        return root, current

    def read_bucket(self, addr):
        ptrsize = current_arch.ptrsize
        bucket = {}
        bucket["addr"] = current = addr
        """
        struct PartitionBucket {
          PartitionPage* active_pages_head;
          PartitionPage* empty_pages_head;
          PartitionPage* decommitted_pages_head;
          uint32_t slot_size;
          uint32_t num_system_pages_per_slot_span : 8;
          uint32_t num_full_pages : 24;
        };
        """
        bucket["active_pages_head"] = read_int_from_memory(current)
        current += ptrsize
        bucket["empty_pages_head"] = read_int_from_memory(current)
        current += ptrsize
        bucket["decommitted_pages_head"] = read_int_from_memory(current)
        current += ptrsize
        bucket["slot_size"] = u32(read_memory(current, 4))
        current += 4
        x = u32(read_memory(current, 4))
        bucket["num_system_pages_per_slot_span"] = x & 0xff
        bucket["num_full_pages"] = (x >> 8) & 0xffffff
        current += 4
        return bucket, current

    def read_extent(self, addr):
        ptrsize = current_arch.ptrsize
        extent = {}
        extent["addr"] = current = addr
        """
        struct PartitionSuperPageExtentEntry {
          PartitionRootBase* root;
          char* super_page_base;
          char* super_pages_end;
          PartitionSuperPageExtentEntry* next;
        };
        """
        kSuperPageShift = 21

        extent["root"] = read_int_from_memory(current)
        current += ptrsize
        extent["super_page_base"] = read_int_from_memory(current)
        current += ptrsize
        extent["super_pages_end"] = read_int_from_memory(current)
        current += ptrsize
        extent["next"] = read_int_from_memory(current)
        current += ptrsize
        extent["num_pages"] = (extent["super_pages_end"] - extent["super_page_base"]) >> kSuperPageShift
        return extent, current

    def read_direct_map(self, addr):
        ptrsize = current_arch.ptrsize
        direct_map = {}
        direct_map["addr"] = current = addr
        """
        struct PartitionDirectMapExtent {
          PartitionDirectMapExtent<thread_safe>* next_extent;
          PartitionDirectMapExtent<thread_safe>* prev_extent;
          PartitionBucket<thread_safe>* bucket;
          size_t map_size;  // Mapped size, not including guard pages and meta-data.
        };
        """
        direct_map["next_extent"] = read_int_from_memory(current)
        current += ptrsize
        direct_map["prev_extent"] = read_int_from_memory(current)
        current += ptrsize
        direct_map["bucket"] = read_int_from_memory(current)
        current += ptrsize
        direct_map["map_size"] = read_int_from_memory(current)
        current += ptrsize
        return direct_map, current

    def read_page(self, addr):
        ptrsize = current_arch.ptrsize
        page = {}
        page["addr"] = current = addr
        page["super_page_addr"] = (page["addr"] & gef_getpagesize_mask()) - gef_getpagesize()
        page["partition_page_index"] = (page["addr"] & (gef_getpagesize() - 1)) // 0x20
        page["partition_page_start"] = page["super_page_addr"] + page["partition_page_index"] * gef_getpagesize() * 4
        """
        struct PartitionPage {
          PartitionFreelistEntry* freelist_head;
          PartitionPage* next_page;
          PartitionBucket* bucket; // Deliberately signed, 0 for empty or decommitted page, -n for full pages:
          int16_t num_allocated_slots;
          uint16_t num_unprovisioned_slots;
          uint16_t page_offset;
          int16_t empty_cache_index; // -1 if not in the empty cache.
        }
        """
        page["freelist_head"] = read_int_from_memory(current)
        current += ptrsize
        page["next_page"] = read_int_from_memory(current)
        current += ptrsize
        page["bucket"] = read_int_from_memory(current)
        current += ptrsize
        page["num_allocated_slots"] = u16(read_memory(current, 2))
        current += 2
        page["num_unprovisioned_slots"] = u16(read_memory(current, 2))
        current += 2
        page["page_offset"] = u16(read_memory(current, 2))
        current += 2
        page["empty_cache_index"] = u16(read_memory(current, 2))
        current += 2
        return page, current

    def print_root(self, root):
        sentinel_buckets = self.get_sentinel_buckets()
        gef_print(titlify("*{} @ {:#x}".format(root["name"], root["addr"])))
        gef_print("size_t total_size_of_committed_pages:          {:#x}".format(root["total_size_of_committed_pages"]))
        gef_print("size_t total_size_of_super_pages:              {:#x}".format(root["total_size_of_super_pages"]))
        gef_print("size_t total_size_of_direct_mapped_pages:      {:#x}".format(root["total_size_of_direct_mapped_pages"]))
        gef_print("unsigned int num_buckets:                      {:#x}".format(root["num_buckets"]))
        gef_print("unsigned int max_allocation:                   {:#x}".format(root["max_allocation"]))
        gef_print("bool initialized:                              {:#x}".format(root["initialized"]))
        gef_print("char* next_super_page:                         {:#x}".format(root["next_super_page"]))
        gef_print("char* next_partition_page:                     {:#x}".format(root["next_partition_page"]))
        gef_print("char* next_partition_page_end:                 {:#x}".format(root["next_partition_page_end"]))
        gef_print("PartitionSuperPageExtentEntry* current_extent: {:#x}".format(root["current_extent"]))
        gef_print("PartitionSuperPageExtentEntry* first_extent:   {:#x}".format(root["first_extent"]))
        self.print_extent_list(root["first_extent"])

        gef_print("PartitionDirectMapExtent* direct_map_list:     {:#x}".format(root["direct_map_list"]))
        self.print_direct_map_list(root["direct_map_list"])

        if self.verbose:
            gef_print("PartitionPage* global_empty_page_ring[16]:")
            for i in range(len(root["global_empty_page_ring"])):
                gef_print("    global_empty_page_ring[{:2d}]:                    {:#x}".format(i, root["global_empty_page_ring"][i]))
        else:
            gef_print("PartitionPage* global_empty_page_ring[16]:     ...")

        gef_print("int16_t global_empty_page_ring_index:          {:#x}".format(root["global_empty_page_ring_index"]))
        inv = root["inverted_self"]
        gef_print("uintptr_t inverted_self:                       {:#x} (=~{:#x})".format(inv, inv ^ 0xffffffffffffffff))

        if self.verbose:
            gef_print("size_t order_index_shifts[{:2d}]".format(len(root["order_index_shifts"])))
            for i in range(len(root["order_index_shifts"])):
                gef_print("    order_index_shifts[{:2d}]:                        {:#x}".format(i, root["order_index_shifts"][i]))
        else:
            gef_print("size_t order_index_shifts[{:2d}]                  ...".format(len(root["order_index_shifts"])))

        if self.verbose:
            gef_print("size_t order_sub_index_masks[{:2d}]:".format(len(root["order_sub_index_masks"])))
            for i in range(len(root["order_sub_index_masks"])):
                gef_print("    order_sub_index_masks[{:2d}]:                     {:#x}".format(i, root["order_sub_index_masks"][i]))
        else:
            gef_print("size_t order_sub_index_masks[{:2d}]:              ...".format(len(root["order_sub_index_masks"])))

        if self.verbose:
            gef_print("internal::PartitionBucket* bucket_lookups[{:d}]:".format(len(root["bucket_lookups"])))
            for i in range(len(root["bucket_lookups"])):
                if root["bucket_lookups"][i] in sentinel_buckets:
                    gef_print("    bucket_lookups[{:3d}]:                           sentinel_bucket".format(i))
                else:
                    gef_print("    bucket_lookups[{:3d}]:                           {:#x}".format(i, root["bucket_lookups"][i]))
        else:
            gef_print("internal::PartitionBucket* bucket_lookups[{:3d}]:...".format(len(root["bucket_lookups"])))

        gef_print("internal::PartitionBucket buckets[{:3d}]:".format(len(root["buckets"])))
        for idx, bucket in enumerate(root["buckets"]):
            self.print_bucket(bucket, idx)
        return

    def print_extent_list(self, head):
        try:
            current = head
            while current:
                extent, _ = self.read_extent(current)
                text = "    -> extent @{:<#14x}: ".format(extent["addr"])
                text += "root:{:<#14x} ".format(extent["root"])
                super_page_info = "{:<#14x} - {:<#14x}".format(extent["super_page_base"], extent["super_pages_end"])
                text += "super_page:" + Color.colorify(super_page_info, "yellow bold")
                text += " (total 0x200000(2MB) * {:d} pages) ".format(extent["num_pages"])
                text += "next:{:<#14x}".format(extent["next"])
                gef_print(text)
                current = extent["next"]
        except Exception:
            err("Corrupted?")
        return

    def print_direct_map_list(self, head):
        try:
            current = head
            while current:
                direct_map, _ = self.read_direct_map(current)
                text = "    -> direct_map @{:<#14x}: ".format(direct_map["addr"])
                text += "next_extent:{:<#14x} ".format(direct_map["next_extent"])
                text += "prev_extent:{:<#14x} ".format(direct_map["prev_extent"])
                text += "bucket:{:<#14x} ".format(direct_map["bucket"])
                text += "map_size:{:#x}".format(direct_map["map_size"])
                gef_print(text)
                bucket, _ = self.read_bucket(direct_map["bucket"])
                self.print_bucket(bucket)
                current = direct_map["next_extent"]
        except Exception:
            err("Corrupted?")
        return

    def print_bucket(self, bucket, idx=None):
        skip_pages = self.get_sentinel_pages()

        slot_size = Color.colorify("{:#7x}".format(bucket["slot_size"]), "bold pink")
        if idx is not None:
            text = "    buckets[{:3d}](slot_size:{:s}) @{:<#14x}: ".format(idx, slot_size, bucket["addr"])
        else:
            text = "    bucket(slot_size:{:s}) @{:<#14x}: ".format(slot_size, bucket["addr"])
        text += "num_system_pages_per_slot_span:{:<#4x} ".format(bucket["num_system_pages_per_slot_span"])
        text += "num_full_pages:{:#x}".format(bucket["num_full_pages"])
        gef_print(text)

        if self.verbose:
            target_list = ["active_pages_head", "empty_pages_head", "decommitted_pages_head"]
        else:
            target_list = ["active_pages_head"]

        for key in target_list:
            head = bucket[key]
            if not self.verbose and (head in skip_pages + [0x0]):
                continue
            if head in skip_pages:
                gef_print("        {:s}:sentinel_pages".format(Color.colorify(key, "bold cyan underline")))
            else:
                gef_print("        {:s}:{:<#14x}".format(Color.colorify(key, "bold cyan underline"), head))
            self.print_pages(head, bucket)
        return

    def print_pages(self, head, bucket):
        current = head
        while current:
            try:
                page, _ = self.read_page(current)
            except Exception:
                err("Corrupted?")
                break
            text_fmt = "            -> page @{:<#14x} (#{:3d} of super_page @{:<#14x}): "
            text = text_fmt.format(page["addr"], page["partition_page_index"], page["super_page_addr"])
            text += "next_page:{:<#14x} ".format(page["next_page"])
            page_start = page["partition_page_start"]
            page_end = page["partition_page_start"] + bucket["num_system_pages_per_slot_span"] * gef_getpagesize()
            text += "page_area:{:#x}-{:#x} ".format(page_start, page_end)
            text += "num_allocated_slots:{:#x}".format(page["num_allocated_slots"])
            gef_print(text)
            self.print_freelist(page["freelist_head"], bucket, page)
            current = page["next_page"]
        return

    def print_freelist(self, head, bucket, page):
        gef_print("                freelist_head:{:<#14x} ".format(head))

        slot_size = bucket["slot_size"]
        page_start = page["partition_page_start"]
        page_end = page["partition_page_start"] + bucket["num_system_pages_per_slot_span"] * gef_getpagesize()

        text = ""
        cnt = 0
        chunk = head
        seen = []
        while chunk:
            if cnt % 7 == 0:
                if cnt > 0:
                    text += "\n"
                text += " " * 20

            if chunk in seen:
                text += Color.colorify("-> {:<#14x} (loop) ".format(chunk), "red bold")
                break

            if not ((page_start <= chunk < page_end) and ((chunk - page_start) % slot_size == 0)):
                text += Color.colorify("-> {:<#14x} (corrupted) ".format(chunk), "red bold")
                break

            try:
                next_chunk = self.byteswap(read_int_from_memory(chunk))
            except Exception:
                text += Color.colorify("-> {:<#14x} (corrupted) ".format(chunk), "red bold")
                break

            text += "-> " + Color.colorify("{:<#14x} ".format(chunk), "yellow bold")
            cnt += 1
            seen.append(chunk)
            chunk = next_chunk

        if cnt > 0:
            text += "(num: {:#x})".format(cnt)

        if text:
            gef_print(text)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if not is_x86_64():
            err("Unsupported")
            return

        if "-h" in argv:
            self.usage()
            return

        self.verbose = False
        if "-v" in argv:
            self.verbose = True
            argv.remove("-v")

        if len(argv) != 1:
            self.usage()
            return

        if not argv[0] in ["fast_malloc", "fm", "array_buffer", "ab", "buffer", "b", "layout", "l", "all"]:
            self.usage()
            return
        target = argv[0]

        for name, addr in self.get_roots():
            if target == "all":
                root, _ = self.read_root(addr, name)
                self.print_root(root)
            elif target in ["fast_malloc", "fm"] and name == "fast_malloc_root_":
                root, _ = self.read_root(addr, name)
                self.print_root(root)
            elif target in ["array_buffer", "ab"] and name == "array_buffer_root_":
                root, _ = self.read_root(addr, name)
                self.print_root(root)
            elif target in ["buffer", "b"] and name == "buffer_root_":
                root, _ = self.read_root(addr, name)
                self.print_root(root)
            elif target in ["layout", "l"] and name == "layout_root_":
                root, _ = self.read_root(addr, name)
                self.print_root(root)
        return


@register_command
class MuslDumpCommand(GenericCommand):
    """musl heap reusable chunks viewer (supported on x64/x86, based on musl libc v1.2.2; src/malloc/mallocng).
    See https://h-noson.hatenablog.jp/entry/2021/05/03/161933#-177pts-mooosl"""
    _cmdline_ = "musl-dump"
    _syntax_ = "{:s} ctx|unused [-v] [-a ACTIVE_IDX]".format(_cmdline_)
    _category_ = "Heap"

    def get_malloc_context_heuristic(self):
        try:
            # search malloc
            malloc = parse_address("malloc")
            info("malloc: {:#x}".format(malloc))

            # search __libc_malloc_impl
            """
            [pattern 1]
               0x7ffff7d7dde0 <malloc>:     jmp    0x7ffff7d8ece2 <__libc_malloc_impl>

            [pattern 2]
               0x7ffff7f71650 <malloc>:     endbr64
               0x7ffff7f71654 <malloc+4>:   jmp    0x7ffff7f72ff0

            [pattern 3]
               0xf7f78bf0 <malloc>: jmp    0xf7f8bc3c
            """
            res = gdb.execute("x/10i {:#x}".format(malloc), to_string=True)
            for line in res.splitlines():
                m = re.search(r"jmp\s*(0x\w+)", line)
                if not m:
                    continue
                __libc_malloc_impl = int(m.group(1), 16)
                break
            info("__libc_malloc_impl: {:#x}".format(__libc_malloc_impl))

            # search __malloc_alloc_meta
            """
            [pattern 1]
               0x7ffff7d8ed0a <__libc_malloc_impl+40>:      call   0x7ffff7d88dc1 <__errno_location>
               0x7ffff7d8ed34 <__libc_malloc_impl+82>:      call   0x7ffff7da0c3b <mmap64>
               0x7ffff7d8ed48 <__libc_malloc_impl+102>:     call   0x7ffff7d8e36b <wrlock>
               0x7ffff7d8ed4d <__libc_malloc_impl+107>:     call   0x7ffff7d8e382 <step_seq>
               0x7ffff7d8ed52 <__libc_malloc_impl+112>:     call   0x7ffff7d8e45a <__malloc_alloc_meta>

            [pattern 2]
               0x7ffff7f7303b:      call   0x7ffff7f8a640 <mmap64>
               0x7ffff7f73074:      call   0x7ffff7f72290

            [pattern 3]
               0xf7f8bc40:  call   0xf7f7cf84
               0xf7f8bc67:  call   0xf7f84e85 <__errno_location>
               0xf7f8bc88:  call   0xf7f9cd53 <mmap64>
               0xf7f8bc9b:  call   0xf7f8b3aa
               0xf7f8bca0:  call   0xf7f8b3d2
               0xf7f8bca5:  call   0xf7f8b439
            """
            __malloc_alloc_meta_candidate = []
            res = gdb.execute("x/100i {:#x}".format(__libc_malloc_impl), to_string=True)
            for line in res.splitlines():
                m = re.search(r"call\s*(0x\w+)", line)
                if not m:
                    continue
                addr = int(m.group(1), 16)
                __malloc_alloc_meta_candidate.append(addr)

            # search __malloc_context
            """
            [patttern 1]
               0x7ffff7d8e45a <__malloc_alloc_meta>:        push   r12
               0x7ffff7d8e45c <__malloc_alloc_meta+2>:      push   rbp
               0x7ffff7d8e45d <__malloc_alloc_meta+3>:      push   rbx
               0x7ffff7d8e45e <__malloc_alloc_meta+4>:      sub    rsp,0x10
               0x7ffff7d8e462 <__malloc_alloc_meta+8>:      cmp    DWORD PTR [rip+0x26d67f],0x0        # 0x7ffff7ffbae8 <__malloc_context+8>

            [patttern 2]
               0x7ffff7f72290:      endbr64
               0x7ffff7f72294:      push   r12
               0x7ffff7f72296:      push   rbp
               0x7ffff7f72297:      push   rbx
               0x7ffff7f72298:      sub    rsp,0x10
               0x7ffff7f7229c:      mov    rax,QWORD PTR fs:0x28
               0x7ffff7f722a5:      mov    QWORD PTR [rsp+0x8],rax
               0x7ffff7f722aa:      xor    eax,eax
               0x7ffff7f722ac:      mov    eax,DWORD PTR [rip+0x89816]        # 0x7ffff7ffbac8
               0x7ffff7f722b2:      test   eax,eax

            [pattern 3]
               0xf7f8b439:  push   ebp
               0xf7f8b43a:  push   edi
               0xf7f8b43b:  push   esi
               0xf7f8b43c:  push   ebx
               0xf7f8b43d:  call   0xf7f7cf84
               0xf7f8b442:  add    ebx,0x6fbbe       # libc_bss_base
               0xf7f8b448:  sub    esp,0x1c
               0xf7f8b44b:  cmp    DWORD PTR [ebx+0x708],0x0
            """
            for cand in __malloc_alloc_meta_candidate:
                info("alloc_meta (candidate): {:#x}".format(cand))
                res = gdb.execute("x/10i {:#x}".format(cand), to_string=True)
                for line in res.splitlines():
                    if is_x86_64():
                        m = re.search(r"DWORD PTR \[rip\+0x\w+\].*#\s*(0x\w+)", line)
                        if not m:
                            continue
                        __malloc_context_init_done = int(m.group(1), 16)
                    else:
                        m = re.search(r"DWORD PTR \[e[abcd]x\+(0x\w+)\]", line)
                        if not m:
                            continue
                        __malloc_context_init_done_offset = int(m.group(1), 16)
                        rw_maps = [p for p in get_process_maps() if p.permission.value == Permission.READ | Permission.WRITE]
                        rw_maps = [p for p in rw_maps if "libc.so" in p.path]
                        libc_bss_base = rw_maps[0].page_start
                        __malloc_context_init_done = libc_bss_base + __malloc_context_init_done_offset
                    # check
                    value = u32(read_memory(__malloc_context_init_done, 4))
                    if value not in [0, 1]: # init_done is 1 or 0
                        continue
                    # found
                    info("__malloc_context.init_done: {:#x}".format(__malloc_context_init_done))
                    __malloc_context = __malloc_context_init_done - current_arch.ptrsize
                    x = read_int_from_memory(__malloc_context)
                    if x == gef_getpagesize():
                        __malloc_context -= current_arch.ptrsize
                    info("__malloc_context: {:#x}".format(__malloc_context))
                    return __malloc_context
            return None
        except Exception:
            err("Not found &__malloc_context")
            return None

    def get_malloc_context(self):
        try:
            return parse_address("&__malloc_context")
        except Exception:
            info("Symbol is not found. It will use heuristic search")
            return self.get_malloc_context_heuristic()

    @functools.lru_cache()
    def class_to_size(self, cl):
        class_to_size_list = [
            1, 2, 3, 4, 5, 6, 7, 8,
            9, 10, 12, 15,
            18, 20, 25, 31,
            36, 42, 50, 63,
            72, 84, 102, 127,
            146, 170, 204, 255,
            292, 340, 409, 511,
            584, 682, 818, 1023,
            1169, 1364, 1637, 2047,
            2340, 2730, 3276, 4095,
            4680, 5460, 6552, 8191,
        ]
        assert cl < len(class_to_size_list)
        return class_to_size_list[cl] * 0x10

    def read_ctx(self):
        ptrsize = current_arch.ptrsize
        ctx = {}
        ctx["addr"] = current = self.get_malloc_context()
        if current is None:
            return None
        """
        struct malloc_context {
            uint64_t secret;
        #ifndef PAGESIZE
            size_t pagesize;
        #endif
            int init_done;
            unsigned mmap_counter;
            struct meta *free_meta_head;
            struct meta *avail_meta;
            size_t avail_meta_count;
            size_t avail_meta_area_count;
            size_t meta_alloc_shift;
            struct meta_area *meta_area_head;
            struct meta_area *meta_area_tail;
            unsigned char *avail_meta_areas;
            struct meta *active[48];
            size_t usage_by_class[48];
            uint8_t unmap_seq[32];
            uint8_t bounces[32];
            uint8_t seq;
            uintptr_t brk;
        };
        """
        ctx["secret"] = u64(read_memory(current, 8))
        current += 8
        x = read_int_from_memory(current)
        if x == gef_getpagesize():
            ctx["pagesize"] = x
            current += ptrsize
        else:
            ctx["pagesize"] = None

        ctx["init_done"] = u32(read_memory(current, 4))
        current += 4
        ctx["mmap_counter"] = u32(read_memory(current, 4))
        current += 4
        ctx["free_meta_head"] = read_int_from_memory(current)
        current += ptrsize
        ctx["avail_meta"] = read_int_from_memory(current)
        current += ptrsize
        ctx["avail_meta_count"] = read_int_from_memory(current)
        current += ptrsize
        ctx["avail_meta_area_count"] = read_int_from_memory(current)
        current += ptrsize
        ctx["alloc_shift"] = read_int_from_memory(current)
        current += ptrsize
        ctx["meta_area_head"] = read_int_from_memory(current)
        current += ptrsize
        ctx["meta_area_tail"] = read_int_from_memory(current)
        current += ptrsize
        ctx["avail_meta_areas"] = read_int_from_memory(current)
        current += ptrsize
        ctx["active"] = []
        for i in range(48):
            ctx["active"].append(read_int_from_memory(current))
            current += ptrsize
        ctx["usage_by_class"] = []
        for i in range(48):
            ctx["usage_by_class"].append(read_int_from_memory(current))
            current += ptrsize
        ctx["unmap_seq"] = read_memory(current, 32)
        current += 32
        ctx["bounces"] = read_memory(current, 32)
        current += 32
        ctx["seq"] = ord(read_memory(current, 1))
        current += ptrsize # with padding
        ctx["brk"] = read_int_from_memory(current)
        current += ptrsize
        return ctx

    def print_ctx(self, ctx):
        gef_print(titlify("__malloc_context: {:#x}".format(ctx["addr"])))
        gef_print("  uint64_t secret:                    {:#x}".format(ctx["secret"]))
        if ctx["pagesize"]:
            gef_print("  size_t pagesize:                    {:#x}".format(ctx["pagesize"]))
        gef_print("  int init_done:                      {:#x}".format(ctx["init_done"]))
        gef_print("  unsigned int mmap_counter:          {:#x}".format(ctx["mmap_counter"]))
        gef_print("  struct meta* free_meta_head:        {:#x}".format(ctx["free_meta_head"]))
        gef_print("  struct meta* avail_meta:            {:#x}".format(ctx["avail_meta"]))
        gef_print("  size_t avail_meta_count:            {:#x}".format(ctx["avail_meta_count"]))
        gef_print("  size_t avail_meta_area_count:       {:#x}".format(ctx["avail_meta_area_count"]))
        gef_print("  size_t alloc_shift:                 {:#x}".format(ctx["alloc_shift"]))
        gef_print("  struct meta_area* meta_area_head:   {:#x}".format(ctx["meta_area_head"]))
        gef_print("  struct meta_area* meta_area_tail:   {:#x}".format(ctx["meta_area_tail"]))
        gef_print("  unsigned char* avail_meta_areas:    {:#x}".format(ctx["avail_meta_areas"]))
        gef_print("  struct meta* active[48]:")
        for i in range(48):
            gef_print("     active[{:2d}] (for chunk_size={:#7x}):     {:#x}".format(i, self.class_to_size(i), ctx["active"][i]))
        gef_print("  size_t usage_by_class[48]:")
        for i in range(48):
            gef_print("     usage_by_class[{:2d}]:                     {:#x}".format(i, ctx["usage_by_class"][i]))
        gef_print("  uint8_t unmap_seq[32]:              {}".format(' '.join(["%02x" % x for x in ctx["unmap_seq"]])))
        gef_print("  uint8_t bounces[32]:                {}".format(' '.join(["%02x" % x for x in ctx["bounces"]])))
        gef_print("  uint8_t seq:                        {:#x}".format(ctx["seq"]))
        gef_print("  uintptr_t brk:                      {:#x}".format(ctx["brk"]))
        return

    def read_meta(self, addr):
        ptrsize = current_arch.ptrsize
        meta = {}
        meta["addr"] = current = addr
        """
        struct meta {
            struct meta *prev;
            struct meta *next;
            struct group *mem;
            volatile int avail_mask;
            volatile int freed_mask;
            uintptr_t last_idx:5;
            uintptr_t freeable:1;
            uintptr_t sizeclass:6;
            uintptr_t maplen:8*sizeof(uintptr_t)-12;
        };
        """
        meta["prev"] = read_int_from_memory(current)
        current += ptrsize
        meta["next"] = read_int_from_memory(current)
        current += ptrsize
        meta["mem"] = read_int_from_memory(current)
        current += ptrsize
        meta["avail_mask"] = u32(read_memory(current, 4))
        current += 4
        meta["freed_mask"] = u32(read_memory(current, 4))
        current += 4
        x = read_int_from_memory(current)
        meta["last_idx"] = x & 0b11111
        meta["freeable"] = (x >> 5) & 0b1
        meta["sizeclass"] = (x >> 6) & 0b111111
        meta["maplen"] = (x >> 12)
        current += ptrsize
        return meta

    def make_state(self, meta):
        avail_mask = meta["avail_mask"]
        freed_mask = meta["freed_mask"]
        last_idx = meta["last_idx"]

        text = ""
        for i in range(last_idx + 1):
            if avail_mask & 1:
                text = "A" + text
            elif freed_mask & 1:
                text = "F" + text
            else:
                text = "U" + text
            avail_mask >>= 1
            freed_mask >>= 1
        return text

    def read_group(self, meta, offset):
        ptrsize = current_arch.ptrsize
        group = {}
        group["addr"] = current = meta["mem"] + offset
        group["data"] = read_memory(group["addr"], self.class_to_size(meta["sizeclass"]))
        """
        from source code:
        struct group {
            struct meta *meta;
            unsigned char active_idx:5;
            char pad[UNIT - sizeof(struct meta *) - 1]; // UNIT = 16
            unsigned char storage[];
        };

        however, the actual usage is as follows. (x64)
        struct group {
            struct meta *meta;
            unsigned int slot_offset32;
            unsigned char is_slot_offset32;
            unsigned char slot_index:5;
            unsigned char reserved:3;
            unsigned short slot_offset16;
        }
        """
        group["meta"] = read_int_from_memory(current)
        current += ptrsize
        x = u32(read_memory(current, 4))
        current += 4 if is_x86_64() else 8
        y = u32(read_memory(current, 4))
        group["reserved"] = (x >> 13) & 0b111
        group["slot_idx"] = (y >> 8) & 0b11111
        if y & 0xff:
            group["slot_offset"] = x
        else:
            group["slot_offset"] = (y >> 16) & 0xffff
        current += ptrsize
        return group

    def dump_chunk(self, group, state):
        ptrsize = current_arch.ptrsize

        subinfo = "state:{:5s} meta:{:<#14x} reserved:{:#x}".format(state, group["meta"], group["reserved"])
        if state == "Used":
            subinfo += " slot_idx:{:<#3x} slot_offset:{:#x}".format(group["slot_idx"], group["slot_offset"])

        data = slicer(group["data"], ptrsize * 2)
        addr = group["addr"]
        group_line_threshold = 8

        # create dump text
        unpack = u32 if ptrsize == 4 else u64
        width = ptrsize * 2 + 2
        dump = ""
        done = False
        for blk, blks in itertools.groupby(data):
            repeat_count = len(list(blks))
            d1, d2 = unpack(blk[:ptrsize]), unpack(blk[ptrsize:])
            dascii = ''.join(list(map(lambda x: chr(x) if 0x20 <= x < 0x7f else '.', list(blk))))
            if repeat_count < group_line_threshold:
                for i in range(repeat_count):
                    dump += f"{addr:#x}: {d1:#0{width:d}x} {d2:#0{width:d}x} | {dascii:s} | " + subinfo + "\n"
                    addr += ptrsize * 2
                    if subinfo:
                        subinfo = ""
            else:
                dump += f"{addr:#x}: {d1:#0{width:d}x} {d2:#0{width:d}x} | {dascii:s} | " + subinfo + "\n"
                dump += "* {:#d} lines, {:#x} bytes \n".format(repeat_count - 1, (repeat_count - 1) * ptrsize * 2)
                addr += ptrsize * 2 * repeat_count
                if subinfo:
                    subinfo = ""
            if done:
                break

        # print
        dump = dump.rstrip()
        if state == "Used":
            gef_print(dump)
        else:
            gef_print(Color.grayify(dump))
        return

    def print_meta(self, ctx):
        gef_print(Color.colorify("Legend for `Unused chunks list`: A:Avail F:Freed U:Used", "yellow"))
        gef_print(Color.colorify("  1. Search most right 'A' and return it", "yellow"))
        gef_print(Color.colorify("  2. Search most right 'F' and return it", "yellow"))
        gef_print(Color.colorify("  3. If nothing is found, create new meta", "yellow"))

        # iterate __malloc_context.active
        for idx in range(48):
            if self.active_idx and idx != self.active_idx:
                continue
            current = ctx["active"][idx]
            if current == 0:
                continue

            gef_print(titlify("active[{:2d}] (chunk_size={:#x})".format(idx, self.class_to_size(idx))))

            # iterate list of meta
            seen = []
            while current not in seen:
                meta = self.read_meta(current)
                gef_print("meta @ {:#x}".format(meta["addr"]))
                text = "  "
                text += "prev:{:#x} next:{:#x} ".format(meta["prev"], meta["next"])
                text += Color.colorify("mem:{:#x} ".format(meta["mem"]), "bold cyan")
                text += "avail_mask:{:#x} freed_mask:{:#x} ".format(meta["avail_mask"], meta["freed_mask"])
                text += "last_idx:{:#x} freeable:{:#x} ".format(meta["last_idx"], meta["freeable"])
                text += "sizeclass:{:#x} maplen:{:#x}".format(meta["sizeclass"], meta["maplen"])
                gef_print(text)

                state = self.make_state(meta)
                gef_print("  Unused chunks list: {}".format(repr(state)))

                # dump chunks
                if self.verbose:
                    dic = {"A": "Avail", "F": "Freed", "U": "Used"}
                    for i in range(meta["last_idx"] + 1):
                        offset = self.class_to_size(idx) * i
                        group = self.read_group(meta, offset)
                        self.dump_chunk(group, dic[state[-i - 1]])
                    gef_print("")

                seen.append(current)
                current = meta["next"]
        return

    @only_if_gdb_running
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        self.verbose = False
        if "-v" in argv:
            self.verbose = True
            argv.remove("-v")

        try:
            self.active_idx = False
            while "-a" in argv:
                idx = argv.index("-a")
                self.active_idx = int(argv[idx + 1])
                argv = argv[:idx] + argv[idx + 2:]
        except Exception:
            self.usage()
            return

        if not argv:
            self.usage()
            return

        ctx = self.read_ctx()
        if ctx is None:
            return
        if argv[0] == "ctx":
            self.print_ctx(ctx)
        elif argv[0] == "unused":
            self.print_meta(ctx)
        return


@register_command
class XphysAddrCommand(GenericCommand):
    """Dump physical memory via qemu-monitor."""
    _cmdline_ = "xp"
    _syntax_ = "{:s} [-h] [OPTION] ADDRESS".format(_cmdline_)
    _example_ = "{:s} /16xg 0x11223344".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    def dump_physmem(self, argv):
        result = gdb.execute("monitor xp {:s}".format(' '.join(argv)), to_string=True)
        gef_print(result.strip())
        return

    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, argv):
        if "-h" in argv:
            self.usage()
            return
        self.dump_physmem(argv)
        return


@register_command
class XSecureMemAddrCommand(GenericCommand):
    """Dump secure memory via qemu-system memory map."""
    _cmdline_ = "xsm"
    _syntax_ = "{:s} [-h] [-v] /FMT --phys|--off|--virt ADDRESS".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} /16xw --phys 0xe11e3d0 # absolute (physical/non-ASLR) address of secure memory\n".format(_cmdline_)
    _example_ += "{:s} /16xw --off 0x11e3d0 # the offset from secure memory area\n".format(_cmdline_)
    _example_ += "{:s} /16xw --virt 0x783ae3d0 # secure memory ASLR is supported".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    @staticmethod
    def get_secure_memory_base_and_size(verbose=False):
        result = gdb.execute("monitor info mtree -f", to_string=True)
        for line in result.splitlines():
            m = re.search(r"([0-9a-f]{16})-([0-9a-f]{16}).*virt.secure-ram", line)
            if m:
                secure_memory_base = int(m.group(1), 16)
                secure_memory_size = int(m.group(2), 16) + 1 - secure_memory_base
                break
        else:
            return None, None
        if verbose:
            start = secure_memory_base
            end = secure_memory_base + secure_memory_size
            info("secure memory base: {:#x}-{:#x} ({:#x} bytes)".format(start, end, secure_memory_size))
        return secure_memory_base, secure_memory_size

    @staticmethod
    def get_secure_memory_qemu_map(secure_memory_base, secure_memory_size, verbose=False):
        qemu_system_pid = get_pid()
        if qemu_system_pid is None:
            err("Not found qemu-system pid")
            return None
        # fast path
        ret = gdb.execute("monitor gpa2hva {:#x}".format(secure_memory_base), to_string=True)
        r = re.search("is (0x[0-9a-f]+)", ret)
        if r:
            secure_memory_page_addr = int(r.group(1), 16)
            sm = process_lookup_address(secure_memory_page_addr)
            if sm:
                if verbose:
                    info("secure memory page of pid {:d}: {:#x}".format(qemu_system_pid, secure_memory_page_addr))
                return sm

        # slow path
        maps = get_process_maps_linux(qemu_system_pid)
        secure_memory_maps = [m for m in maps if m.size == secure_memory_size]
        if len(secure_memory_maps) == 1:
            if verbose:
                secure_memory_page_addr = secure_memory_maps[0].page_start
                info("secure memory page of pid {:d}: {:#x}".format(qemu_system_pid, secure_memory_page_addr))
            return secure_memory_maps[0]
        return None

    @staticmethod
    def virt2phys(vaddr, verbose=False): # vaddr -> addr1 or None
        maps = V2PCommand.get_maps(FORCE_PREFIX_S=True, verbose=verbose)
        if maps is None:
            return None
        for vstart, vend, pstart, pend in maps:
            if vstart <= vaddr < vend:
                offset = vaddr - vstart
                paddr = pstart + offset
                if verbose:
                    info("virt2phys: {:#x} -> {:#x}".format(vaddr, paddr))
                return paddr
        return None

    @staticmethod
    def phys2virt(paddr, verbose=False): # paddr -> [addr1, addr2, ...] or []
        maps = V2PCommand.get_maps(FORCE_PREFIX_S=True, verbose=verbose)
        if maps is None:
            return []
        result = []
        for vstart, vend, pstart, pend in maps:
            if pstart <= paddr < pend:
                offset = paddr - pstart
                vaddr = vstart + offset
                if verbose:
                    info("phys2virt: {:#x} -> {:#x}".format(paddr, vaddr))
                result.append(vaddr)
        return result

    @staticmethod
    def read_secure_memory(sm, offset, dump_size, verbose=False):
        qemu_system_pid = get_pid()
        if qemu_system_pid is None:
            err("Not found qemu-system pid")
            return None

        if dump_size > sm.size:
            dump_size = sm.size

        if verbose:
            info("target offset: {:#x}".format(offset))
            info("read address: {:#x}, size:{:#x}".format(sm.page_start + offset, dump_size))

        with open("/proc/{:d}/mem".format(qemu_system_pid), "rb") as fd:
            try:
                fd.seek(sm.page_start + offset, 0)
                data = fd.read(dump_size)
            except Exception:
                return None
        if verbose:
            info("read size result: {:#x}".format(len(data)))
        return data

    def print_secure_memory_x(self, target, data):
        for i, data16 in enumerate(slicer(data, 16)):
            addr = int(target) + i * 0x10
            data_units = slicer(data16, self.dump_unit)
            if self.dump_unit == 1:
                data_units_hex = ["{:#04x}".format(ord(x)) for x in data_units]
            elif self.dump_unit == 2:
                data_units_hex = ["{:#06x}".format(u16(x)) for x in data_units]
            elif self.dump_unit == 4:
                data_units_hex = ["{:#010x}".format(u32(x)) for x in data_units]
            elif self.dump_unit == 8:
                data_units_hex = ["{:#018x}".format(u64(x)) for x in data_units]
            gef_print("{:#018x}: {:s}".format(addr, ' '.join(data_units_hex)))
        return

    def print_secure_memory_i(self, target, data):
        kwargs = {}
        kwargs["code"] = data.hex()
        if is_arm32():
            kwargs["arch"] = "ARM"
            if target & 1:
                kwargs["mode"] = "THUMB"
            else:
                kwargs["mode"] = "ARM"
        elif is_arm64():
            kwargs["arch"] = "ARM64"
            kwargs["mode"] = "ARM"

        try:
            for insn in capstone_disassemble(target, self.dump_count, **kwargs):
                insn_fmt = "{:12o}"
                text_insn = insn_fmt.format(insn)
                msg = "{} {}".format(" " * 5, text_insn)
                gef_print(msg)
        except gdb.error:
            pass
        return

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["ARM32", "ARM64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        # arg parse
        if "-h" in argv:
            self.usage()
            return

        verbose = False
        if "-v" in argv:
            verbose = True
            argv.remove("-v")

        self.dump_type = "x"
        self.dump_unit = current_arch.ptrsize
        self.dump_count = 1
        if argv and argv[0].startswith("/"):
            m = re.search(r"/(\d*)(\S*)", argv[0])
            if m:
                if m.group(1):
                    self.dump_count = int(m.group(1))
                for c in m.group(2):
                    if c in ["x", "i"]:
                        self.dump_type = c
                    elif c in ["b", "h", "w", "g"]:
                        self.dump_unit = {"b": 1, "h": 2, "w": 4, "g": 8}[c]
                    else:
                        err("Unsupported format: {}".format(c))
                        return
            argv = argv[1:]

        if argv and argv[0] in ["--phys", "--off", "--virt"]:
            addr_type = argv[0]
            argv = argv[1:]
        else:
            self.usage()
            return

        try:
            target = int(gdb.parse_and_eval(''.join(argv)))
        except Exception:
            self.usage()
            return

        # initialize
        sm_base, sm_size = self.get_secure_memory_base_and_size(verbose)
        if sm_base is None or sm_size is None:
            err("Not found memory tree of secure memory (see monitor info mtree -f)")
            return
        sm = self.get_secure_memory_qemu_map(sm_base, sm_size, verbose)
        if sm is None:
            err("Not found secure memory maps")
            return

        # dump
        if addr_type == "--phys":
            if sm_base <= target < sm_base + sm_size:
                target_offset = target - sm_base
            else:
                err("Phys {:#x} is not default secure memory (unsupported)".format(target))
                return
        elif addr_type == "--off":
            if 0 <= target < sm_size:
                target_offset = target
            else:
                err("Offset {:#x} is not default secure memory (unsupported)".format(target))
                return
        elif addr_type == "--virt":
            target_phys = self.virt2phys(target, verbose)
            if target_phys is None:
                err("Not found physical address")
                return
            if sm_base <= target_phys < sm_base + sm_size:
                target_offset = target_phys - sm_base
            else:
                err("Virt {:#x} is not default secure memory (unsupported)".format(target))
                return

        if self.dump_type == "x":
            dump_size = self.dump_count * self.dump_unit
        elif self.dump_type == "i":
            dump_size = self.dump_count * 4 # ARM opcode is at most 4byte
            if target_offset & 1:
                target_offset -= 1
        data = self.read_secure_memory(sm, target_offset, dump_size, verbose)
        if data is None:
            err("Read error")
            return

        # print
        if self.dump_type == "x":
            self.print_secure_memory_x(target, data)
        elif self.dump_type == "i":
            self.print_secure_memory_i(target, data)
        return


# The wsm command directly modifies /proc/<PID>/mem of qemu-system.
# However, even though the memory change was successful, it may not be reflected in the behavior of the code.
# I don't know the cause, but I'm guessing it's because qemu has an internal cache.
# Apparently setting a breakpoint ignores this cache, so setting a temporary breakpoint avoids this problem.
class TemporaryDummyBreakpoint(gdb.Breakpoint):
    """Create a breakpoint to avoid gdb cache problem"""
    def __init__(self):
        super().__init__("*{:#x}".format(0x0), type=gdb.BP_BREAKPOINT, internal=True, temporary=True)
        return

    def stop(self):
        return False


@register_command
class WSecureMemAddrCommand(GenericCommand):
    """Write secure memory via qemu-system memory map."""
    _cmdline_ = "wsm"
    _syntax_ = "{:s} [-h] [-v] -b byte|short|dword|qword|string|hex VALUE --phys|--off|--virt ADDRESS".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} -b dword 0x41414141 --phys 0xe11e3d0 # absolute (physical/non-ASLR) address of secure memory\n".format(_cmdline_)
    _example_ += "{:s} -b string \"\\\\x41\\\\x41\\\\x41\\\\x41\" --off 0x11e3d0 # the offset of secure memory\n".format(_cmdline_)
    _example_ += "{:s} -b hex \"4141 4141\" --off 0x11e3d0 # hex string is supported (invalid character is ignored)\n".format(_cmdline_)
    _example_ += "{:s} -b byte 0x41 --virt 0x783ae3d0 # secure memory ASLR is supported".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    @staticmethod
    def write_secure_memory(sm, offset, data, verbose=False):
        qemu_system_pid = get_pid()
        if qemu_system_pid is None:
            return None

        write_size = len(data)
        if write_size > sm.size:
            write_size = sm.size
            data = data[:write_size]

        if verbose:
            info("target offset: {:#x}".format(offset))
            info("write address: {:#x}, size:{:#x}".format(sm.page_start + offset, write_size))

        with open("/proc/{:d}/mem".format(qemu_system_pid), "r+b") as fd:
            try:
                fd.seek(sm.page_start + offset, 0)
                ret = fd.write(data)
            except Exception:
                return None
        if verbose:
            info("written size result: {:#x}".format(ret))

        # avoid qemu-system caches
        TemporaryDummyBreakpoint()

        # By default, "context code" uses gdb_disassemble.
        # However, due to gdb's internal cache, changes to secure memory may not be reflected in the disassembled results.
        # Therefore, if capstone is available, change it to disassemble by capstone.
        if get_gef_setting("context.use_capstone") is False:
            set_gef_setting("context.use_capstone", True)
        return ret

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["ARM32", "ARM64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        # arg parse
        if "-h" in argv:
            self.usage()
            return

        verbose = False
        if "-v" in argv:
            verbose = True
            argv.remove("-v")

        if len(argv) >= 3 and argv[0] == "-b":
            try:
                if argv[1] == "byte":
                    data = p8(int(argv[2], 0))
                elif argv[1] == "short":
                    data = p16(int(argv[2], 0))
                elif argv[1] == "dword":
                    data = p32(int(argv[2], 0))
                elif argv[1] == "qword":
                    data = p64(int(argv[2], 0))
                elif argv[1] == "string":
                    try:
                        data = codecs.escape_decode(argv[2])[0]
                    except binascii.Error:
                        gef_print("Could not decode '\\xXX' encoded string \"{}\"".format(data))
                        return
                elif argv[1] == "hex":
                    _data = ""
                    for c in argv[2].lower():
                        if c in '0123456789abcdef':
                            _data += c
                    data = bytes.fromhex(_data)
                else:
                    self.usage()
                    return
                argv = argv[3:]
            except Exception:
                self.usage()
                return

        if argv and argv[0] in ["--phys", "--off", "--virt"]:
            addr_type = argv[0]
            argv = argv[1:]
        else:
            self.usage()
            return

        try:
            target = int(gdb.parse_and_eval(''.join(argv)))
        except Exception:
            self.usage()
            return

        # initialize
        sm_base, sm_size = XSecureMemAddrCommand.get_secure_memory_base_and_size(verbose)
        if sm_base is None or sm_size is None:
            err("Not found memory tree of secure memory (see monitor info mtree -f)")
            return
        sm = XSecureMemAddrCommand.get_secure_memory_qemu_map(sm_base, sm_size, verbose)
        if sm is None:
            err("Not found secure memory maps")
            return

        # write
        if addr_type == "--phys":
            if sm_base <= target < sm_base + sm_size:
                target_offset = target - sm_base
            else:
                err("Phys {:#x} is not default secure memory (unsupported)".format(target))
                return
        elif addr_type == "--off":
            if 0 <= target < sm_size:
                target_offset = target
            else:
                err("Offset {:#x} is not default secure memory (unsupported)".format(target))
                return
        elif addr_type == "--virt":
            target_phys = XSecureMemAddrCommand.virt2phys(target, verbose)
            if target_phys is None:
                err("Not found physical address")
                return
            if sm_base <= target_phys < sm_base + sm_size:
                target_offset = target_phys - sm_base
            else:
                err("Virt {:#x} is not default secure memory (unsupported)".format(target))
                return
        ret = self.write_secure_memory(sm, target_offset, data, verbose)
        if ret is None:
            err("Write error")
            return
        return


@register_command
class BreakSecureMemAddrCommand(GenericCommand):
    """Set a breakpoint in virtual memory by specifying the physical memory of the secure world."""
    _cmdline_ = "bsm"
    _syntax_ = "{:s} [-h] [-v] PHYS_ADDRESS".format(_cmdline_)
    _example_ = "{:s} 0xe1008d8".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["ARM32", "ARM64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        # arg parse
        verbose = False
        if "-v" in argv:
            verbose = True
            argv.remove("-v")

        try:
            phys_addr = parse_address(' '.join(argv))
            if verbose:
                info("phys address: {:#x}".format(phys_addr))
        except Exception:
            self.usage()
            return

        virt_addrs = XSecureMemAddrCommand.phys2virt(phys_addr, verbose)

        for virt_addr in virt_addrs:
            gdb.execute("break *{:#x}".format(virt_addr))
        return


class OpteeThreadEnterUserModeBreakpoint(gdb.Breakpoint):
    """Create a breakpoint to thread_enter_user_mode"""
    def __init__(self, vaddr, ta_offset):
        super().__init__("*{:#x}".format(vaddr), type=gdb.BP_BREAKPOINT, internal=True)
        self.count = 0
        self.ta_offset = ta_offset
        return

    @staticmethod
    def get_ta_loaded_address():
        if is_arm32():
            res = get_maps_by_pagewalk("pagewalk -q -S")
            res = sorted(set(res.splitlines()))
            res = list(filter(lambda line: "PL0/R-X" in line, res))
        elif is_arm64():
            res = get_maps_by_pagewalk("pagewalk 1 -q")
            res = sorted(set(res.splitlines()))
            res = list(filter(lambda line: "EL0/R-X" in line, res))
        maps = []
        for line in res:
            vrange, prange, *_ = line.split()
            vstart, vend = [int(x, 16) for x in vrange.split("-")]
            pstart, pend = [int(x, 16) for x in prange.split("-")]
            maps.append((vstart, vend, pstart, pend))
        if len(maps) == 2:
            return maps[1]
        else:
            return None

    def stop(self):
        if self.count != 1:
            self.count += 1
            return False

        ta_address = self.get_ta_loaded_address()
        if ta_address is None:
            err("TA address is not found")
            self.enabled = False
            return False

        ta_vstart, ta_vend, _, _ = ta_address
        info("TA address: {:#x}".format(ta_vstart))

        ta_vsize = ta_vend - ta_vstart
        if self.ta_offset >= ta_vsize:
            err("TA offset {:#x} is greater than the size of TA R-X area ({:#x})".format(self.ta_offset, ta_vsize))
            self.enabled = False
            return False

        gdb.execute("break *{:#x}".format(ta_vstart + self.ta_offset))
        self.enabled = False
        return False


@register_command
class OpteeBreakTaAddrCommand(GenericCommand):
    """Set a breakpoint to OPTEE-TA."""
    _cmdline_ = "optee-break-ta"
    _syntax_ = "{:s} [-h] [-v] ADDR_thread_enter_user_mode TA_OFFSET\n".format(_cmdline_)
    _syntax_ += "  ADDR_thread_enter_user_mode: The physical address of `thread_enter_user_mode` at OPTEE-OS\n"
    _syntax_ += "  TA_OFFSET:                   The breakpoint target offset of OPTEE-TA"
    _example_ = "{:s} 0xe137c78 0x2784".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["ARM32", "ARM64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        # arg parse
        verbose = False
        if "-v" in argv:
            verbose = True
            argv.remove("-v")

        try:
            thread_enter_user_mode = parse_address(argv[0])
            if verbose:
                info("thread_enter_user_mode @ OPTEE-OS: {:#x}".format(thread_enter_user_mode))
            argv = argv[1:]
        except Exception:
            self.usage()
            return

        try:
            ta_offset = parse_address(' '.join(argv))
            if verbose:
                info("breakpoint target offset of TA: {:#x}".format(ta_offset))
        except Exception:
            self.usage()
            return

        thread_enter_user_mode_virt = XSecureMemAddrCommand.phys2virt(thread_enter_user_mode, verbose)

        for vaddr in thread_enter_user_mode_virt:
            OpteeThreadEnterUserModeBreakpoint(vaddr, ta_offset)
            info("Temporarily breakpoint at {:#x}".format(vaddr))
        return


@register_command
class OpteeBgetDumpCommand(GenericCommand):
    """Dump bget allocator of OPTEE-Trusted-App."""
    _cmdline_ = "optee-bget-dump"
    _syntax_ = "{:s} [-h] [-v] OFFSET_malloc_ctx\n".format(_cmdline_)
    _syntax_ += "  OFFSET_malloc_ctx:   The offset of `malloc_ctx` at OPTEE-TA"
    _example_ = "{:s} 0x2a408\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "Simplified heap structure\n"
    _example_ += "+-malloc_ctx-------------------+         +-free-ed chunk----------+\n"
    _example_ += "| bufsize prevfree             |<--+ +-->| bufsize prevfree       |= 0 (if upper chunk is used)  +--> ...\n"
    _example_ += "| bufsize bsize                |   | |   | bufsize bsize          |= the size of this chunk      |\n"
    _example_ += "| struct bfhead *flink         |-----+   | struct bfhead *flink   |------------------------------+\n"
    _example_ += "| struct bfhead *blink         |   +-----| struct bfhead *blink   |\n"
    _example_ += "| (bufsize totalloc)           |         |                        |\n"
    _example_ += "| (long numget)                |         |                        |\n"
    _example_ += "| (long numrel)                |         |                        |\n"
    _example_ += "| (long numpblk)               |         +-used chunk-------------+\n"
    _example_ += "| (long numpget)               |         | bufsize prevfree       |= the size of upper chunk (if upper chunk is free-ed)\n"
    _example_ += "| (long numprel)               |         | bufsize bsize          |= the size of this chunk (negative number)\n"
    _example_ += "| (long numdget)               |         | uchar user_data[bsize] |\n"
    _example_ += "| (long numdrel)               |         |                        |\n"
    _example_ += "| (func_ptr compfcn)           |         |                        |\n"
    _example_ += "| (func_ptr acqfcn)            |         +------------------------+\n"
    _example_ += "| (func_ptr relfcn)            |\n"
    _example_ += "| (bufsize exp_incr)           |\n"
    _example_ += "| (bufsize pool_len)           |\n"
    _example_ += "| struct malloc_pool* pool     |\n"
    _example_ += "| size_t pool_len              |\n"
    _example_ += "| (struct malloc_stats mstats) |\n"
    _example_ += "+------------------------------+"
    _category_ = "Qemu-system Cooperation"

    def is_readable_virt_memory(self, addr):
        if is_arm32():
            res = get_maps_by_pagewalk("pagewalk -q -S")
            res = sorted(set(res.splitlines()))
            res = list(filter(lambda line: "PL0/RW-" in line, res))
        elif is_arm64():
            res = get_maps_by_pagewalk("pagewalk 1 -q")
            res = sorted(set(res.splitlines()))
            res = list(filter(lambda line: "EL0/RW-" in line, res))
        for line in res:
            vrange, prange, *_ = line.split()
            vstart, vend = [int(x, 16) for x in vrange.split("-")]
            pstart, pend = [int(x, 16) for x in prange.split("-")]
            if vstart <= addr < vend:
                return True
        return False

    def parse_flink(self, head):
        current = head
        flinks = []
        seen = [current]
        while True:
            try:
                prevfree = read_int_from_memory(current + current_arch.ptrsize * 0)
                bsize = read_int_from_memory(current + current_arch.ptrsize * 1)
                flink = read_int_from_memory(current + current_arch.ptrsize * 2)
                blink = read_int_from_memory(current + current_arch.ptrsize * 3)
                next_prevfree = read_int_from_memory(current + bsize)
                next_bsize = read_int_from_memory(current + bsize + current_arch.ptrsize)
            except Exception:
                flinks.append("memory corrupted")
                break
            if flink % 8 or blink % 8 or bsize % 8 or next_prevfree % 8 or next_bsize % 8:
                flinks.append("unaligned corrupted")
                break
            flinks.append({"_addr": current, "prevfree": prevfree, "bsize": bsize, "flink": flink, "blink": blink,
                           "next_prevfree": next_prevfree, "next_bsize": next_bsize})
            if flink == head:
                break
            if flink in seen[1:]:
                flinks.append("loop detected")
                break
            seen.append(current)
            current = flink
        return flinks

    def parse_blink(self, head):
        current = head
        blinks = []
        seen = [current]
        while True:
            try:
                prevfree = read_int_from_memory(current + current_arch.ptrsize * 0)
                bsize = read_int_from_memory(current + current_arch.ptrsize * 1)
                flink = read_int_from_memory(current + current_arch.ptrsize * 2)
                blink = read_int_from_memory(current + current_arch.ptrsize * 3)
                next_prevfree = read_int_from_memory(current + bsize)
                next_bsize = read_int_from_memory(current + bsize + current_arch.ptrsize)
            except Exception:
                blinks.append("memory corrupted")
                break
            if flink % 8 or blink % 8 or bsize % 8 or next_prevfree % 8 or next_bsize % 8:
                blinks.append("unaligned corrupted")
                break
            blinks.append({"_addr": current, "prevfree": prevfree, "bsize": bsize, "flink": flink, "blink": blink,
                           "next_prevfree": next_prevfree, "next_bsize": next_bsize})
            if blink == head:
                break
            if blink in seen[1:]:
                blinks.append("loop detected")
                break
            seen.append(current)
            current = blink
        return blinks

    def parse_malloc_ctx(self, malloc_ctx_addr):
        malloc_ctx = {}
        malloc_ctx["_addr"] = current = malloc_ctx_addr

        malloc_ctx["prevfree"] = read_int_from_memory(current)
        current += current_arch.ptrsize
        malloc_ctx["bsize"] = read_int_from_memory(current)
        current += current_arch.ptrsize
        malloc_ctx["flink"] = read_int_from_memory(current)
        malloc_ctx["flink_list"] = self.parse_flink(malloc_ctx["flink"])
        current += current_arch.ptrsize
        malloc_ctx["blink"] = read_int_from_memory(current)
        malloc_ctx["blink_list"] = self.parse_blink(malloc_ctx["blink"])
        current += current_arch.ptrsize

        # search pool
        for i in range(14):
            pool_candidate = read_int_from_memory(current)
            current += current_arch.ptrsize
            if self.is_readable_virt_memory(pool_candidate):
                malloc_ctx["pool"] = pool_candidate
                break
        else:
            err("Not found malloc_ctx->pool")
            return None

        malloc_ctx["pool_len"] = read_int_from_memory(current)
        current += current_arch.ptrsize

        malloc_ctx["pool_list"] = []
        for i in range(malloc_ctx["pool_len"]):
            buf = read_int_from_memory(malloc_ctx["pool"] + (i * 2) * current_arch.ptrsize)
            size = read_int_from_memory(malloc_ctx["pool"] + (i * 2 + 1) * current_arch.ptrsize)
            malloc_ctx["pool_list"].append({"buf": buf, "len": size})

        return malloc_ctx

    def print_malloc_ctx(self, malloc_ctx):
        gef_print(titlify("malloc_ctx @ {:#x}".format(malloc_ctx["_addr"])))
        gef_print("prevfree: {:#x}".format(malloc_ctx["prevfree"]))
        gef_print("bsize:    {:#x}".format(malloc_ctx["bsize"]))
        gef_print("flink:    {:#x}".format(malloc_ctx["flink"]))
        for chunk in malloc_ctx["flink_list"]:
            if isinstance(chunk, str):
                gef_print("  -> {:s}".format(Color.colorify(chunk, "red bold")))
            else:
                chunk_addr = Color.colorify("{:#010x}".format(chunk["_addr"]), "yellow bold")
                fmt = "  -> {:s}: (prevfree:{:#x}  bsize:{:#010x}  flink:{:#010x}  blink:{:#010x}"
                fmt += "  next_prevfree:{:#010x}  next_bsize:{:#010x}({:#010x}))"
                gef_print(fmt.format(chunk_addr, chunk["prevfree"], chunk["bsize"], chunk["flink"], chunk["blink"],
                                     chunk["next_prevfree"], chunk["next_bsize"], (-chunk["next_bsize"]) & 0xffffffff))
        gef_print("blink:    {:#x}".format(malloc_ctx["blink"]))
        for chunk in malloc_ctx["blink_list"]:
            if isinstance(chunk, str):
                gef_print("  -> {:s}".format(Color.colorify(chunk, "red bold")))
            else:
                chunk_addr = Color.colorify("{:#010x}".format(chunk["_addr"]), "yellow bold")
                fmt = "  -> {:s}: (prevfree:{:#x}  bsize:{:#010x}  flink:{:#010x}  blink:{:#010x}"
                fmt += "  next_prevfree:{:#010x}  next_bsize:{:#010x}({:#010x}))"
                gef_print(fmt.format(chunk_addr, chunk["prevfree"], chunk["bsize"], chunk["flink"], chunk["blink"],
                                     chunk["next_prevfree"], chunk["next_bsize"], (-chunk["next_bsize"]) & 0xffffffff))
        gef_print("pool:     {:#x}".format(malloc_ctx["pool"]))
        gef_print("pool_len: {:#x}".format(malloc_ctx["pool_len"]))

        for i in range(malloc_ctx["pool_len"]):
            pool = malloc_ctx["pool_list"][i]
            gef_print("  pool[{:d}]  buf:{:#x}  size:{:#x}".format(i, pool["buf"], pool["len"]))
        return

    def print_chunk_list(self, malloc_ctx):
        for i in range(malloc_ctx["pool_len"]):
            pool = malloc_ctx["pool_list"][i]
            pool_start = pool["buf"]
            pool_end = pool["buf"] + pool["len"]
            gef_print(titlify("pool[{:d}] @ {:#x} - {:#x}".format(i, pool_start, pool_end)))

            chunk = pool_start
            used = Color.colorify("used", "green underline")
            freed = Color.colorify("free", "grey bold")
            seen = []
            while chunk < pool_end:
                if chunk in seen:
                    gef_print(Color.colorify("loop detected", "red bold"))
                    break
                seen.append(chunk)
                try:
                    prevfree = read_int_from_memory(chunk + current_arch.ptrsize * 0)
                    bsize = read_int_from_memory(chunk + current_arch.ptrsize * 1)
                    flink = read_int_from_memory(chunk + current_arch.ptrsize * 2)
                    blink = read_int_from_memory(chunk + current_arch.ptrsize * 3)
                except Exception:
                    gef_print(Color.colorify("unaligned orrupted", "red bold"))
                    break
                chunk_addr = Color.colorify("{:#010x}".format(chunk), "yellow bold")
                bsize_inv = (-bsize) & 0xffffffff
                if bsize_inv < 0x80000000: # used
                    fmt = "{:s} {:s}: prevfree:{:#010x}  bsize:{:#010x}({:#010x})"
                    gef_print(fmt.format(used, chunk_addr, prevfree, bsize, bsize_inv))
                    chunk += bsize_inv
                else: # freed
                    fmt = "{:s} {:s}: prevfree:{:#010x}  bsize:{:#010x}              flink:{:#010x}  blink:{:#010x}"
                    gef_print(fmt.format(freed, chunk_addr, prevfree, bsize, flink, blink))
                    chunk += bsize
                if chunk % 8:
                    gef_print(Color.colorify("unaligned orrupted", "red bold"))
                    break
            return

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["ARM32", "ARM64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        # arg parse
        if "-h" in argv:
            self.usage()
            return

        verbose = False
        if "-v" in argv:
            verbose = True
            argv.remove("-v")

        try:
            malloc_ctx_offset = parse_address(argv[0])
            if verbose:
                info("offset of malloc_ctx: {:#x}".format(malloc_ctx_offset))
        except Exception:
            self.usage()
            return

        ta_address_map = OpteeThreadEnterUserModeBreakpoint.get_ta_loaded_address()
        if ta_address_map is None:
            err("TA address is not found")
            return
        ta_address = ta_address_map[0]
        if verbose:
            info("TA loaded address: {:#x}".format(ta_address))

        malloc_ctx_addr = ta_address + malloc_ctx_offset
        if verbose:
            info("malloc_ctx: {:#x}".format(malloc_ctx_addr))

        malloc_ctx = self.parse_malloc_ctx(malloc_ctx_addr)
        if malloc_ctx is None:
            err("parse failed")
            return
        self.print_malloc_ctx(malloc_ctx)
        self.print_chunk_list(malloc_ctx)
        return


@register_command
class CpuidCommand(GenericCommand):
    """Get cpuid result."""
    _cmdline_ = "cpuid"
    _syntax_ = "{:s}".format(_cmdline_)
    _example_ = "{:s}\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "DISABLE `-enbale-kvm` option for qemu-system; This command will be aborted if the option is set"
    _category_ = "Show/Modify Register"

    def get_state(self, code_len):
        d = {}
        d["pc"] = get_register("$pc")
        d["code"] = read_memory(d["pc"], code_len)
        if is_x86_64():
            d["rax"] = get_register("$rax")
            d["rbx"] = get_register("$rbx")
            d["rdx"] = get_register("$rdx")
            d["rcx"] = get_register("$rcx")
        else:
            d["eax"] = get_register("$eax")
            d["ebx"] = get_register("$ebx")
            d["edx"] = get_register("$edx")
            d["ecx"] = get_register("$ecx")
        return d

    def revert_state(self, d):
        write_memory(d["pc"], d["code"], len(d["code"]))
        gdb.execute("set $pc = {:#x}".format(d["pc"]), to_string=True)
        if is_x86_64():
            gdb.execute("set $rax = {:#x}".format(d["rax"]), to_string=True)
            gdb.execute("set $rbx = {:#x}".format(d["rbx"]), to_string=True)
            gdb.execute("set $rdx = {:#x}".format(d["rdx"]), to_string=True)
            gdb.execute("set $rcx = {:#x}".format(d["rcx"]), to_string=True)
        else:
            gdb.execute("set $eax = {:#x}".format(d["eax"]), to_string=True)
            gdb.execute("set $ebx = {:#x}".format(d["ebx"]), to_string=True)
            gdb.execute("set $edx = {:#x}".format(d["edx"]), to_string=True)
            gdb.execute("set $ecx = {:#x}".format(d["ecx"]), to_string=True)
        return

    def close_stdout(self):
        self.stdout = 1
        self.stdout_bak = os.dup(self.stdout)
        f = open("/dev/null")
        os.dup2(f.fileno(), self.stdout)
        f.close()
        return

    def revert_stdout(self):
        os.dup2(self.stdout_bak, self.stdout)
        os.close(self.stdout_bak)
        return

    def execute_cpuid(self, num, subnum=0):
        code = b"\xeb\xfe\x0f\xa2" # inf-loop (to stop another thread); cpuid
        gef_on_stop_unhook(hook_stop_handler)
        d = self.get_state(len(code))
        write_memory(d["pc"], code, len(code))
        if is_x86_64():
            gdb.execute("set $rax = {:#x}".format(num), to_string=True)
            gdb.execute("set $rcx = {:#x}".format(subnum), to_string=True)
        else:
            gdb.execute("set $eax = {:#x}".format(num), to_string=True)
            gdb.execute("set $ecx = {:#x}".format(subnum), to_string=True)
        gdb.execute("set $pc = {:#x}".format(d["pc"] + 2), to_string=True) # skip "\xeb\xfe"
        self.close_stdout()
        gdb.execute("stepi", to_string=True)
        self.revert_stdout()
        eax = get_register("$eax") & 0xffffffff
        ebx = get_register("$ebx") & 0xffffffff
        ecx = get_register("$ecx") & 0xffffffff
        edx = get_register("$edx") & 0xffffffff
        self.revert_state(d)
        gef_on_stop_hook(hook_stop_handler)
        return eax, ebx, ecx, edx

    def show_result(self, id, subid, eax, ebx, ecx, edx):
        if eax == ebx == ecx == edx == 0:
            return

        if subid is None:
            info("cpuid (eax={:#x})".format(id))
        else:
            info("cpuid (eax={:#x}, ecx={:#x})".format(id, subid))
        gef_print(Color.colorify("    eax={:#x}, ebx={:#x}, ecx={:#x}, edx={:#x}".format(eax, ebx, ecx, edx), "bold yellow"))

        def c(reg, shift, mask, msg):
            val = (reg >> shift) & mask
            msg = msg + " (={:#x})".format(val)
            if val:
                return Color.colorify(msg, "white bold")
            else:
                return msg

        if id == 0:
            vid = (p32(ebx) + p32(edx) + p32(ecx)).decode("utf-8")
            gef_print("    eax: Maximum Input Value for Basic CPUID Information")
            gef_print("    ebx+edx+ecx: Vendor ID (={:s})".format(repr(vid)))
        elif id == 1:
            gef_print("    eax: Version Information")
            gef_print(c(eax,  0, 0xf,        "        EAX  3- 0: Stepping ID"))
            gef_print(c(eax,  4, 0xf,        "        EAX  7- 4: Model Number"))
            gef_print(c(eax,  8, 0xf,        "        EAX 11- 8: Family Code"))
            gef_print(c(eax, 12, 0b11,       "        EAX 13-12: Processor Type"))
            gef_print(c(eax, 14, 0b11,       "        EAX 15-14: Reserved"))
            gef_print(c(eax, 16, 0xf,        "        EAX 19-16: Extended Model"))
            gef_print(c(eax, 20, 0xff,       "        EAX 27-20: Extended Family"))
            gef_print(c(eax, 28, 0xf,        "        EAX 31-28: Reserved"))
            gef_print("    ebx: Additional Information")
            gef_print(c(ebx,  0, 0xff,       "        EBX  7- 0: Brand Index"))
            gef_print(c(ebx,  8, 0xff,       "        EBX 15- 8: CLFLUSH line size"))
            gef_print(c(ebx, 16, 0xff,       "        EBX 23-16: The number of logical processors"))
            gef_print(c(ebx, 24, 0xff,       "        EBX 31-24: Initial APIC ID"))
            gef_print("    edx,ecx: Feature Information")
            gef_print(c(edx,  0, 1,          "        EDX     0: FPU (Floating Point Unit on-chip)"))
            gef_print(c(edx,  1, 1,          "        EDX     1: VME (Virtual 8086 Mode Enhancements)"))
            gef_print(c(edx,  2, 1,          "        EDX     2: DE (Debugging Extensions)"))
            gef_print(c(edx,  3, 1,          "        EDX     3: PSE (Page Size Extension)"))
            gef_print(c(edx,  4, 1,          "        EDX     4: TSC (Time Stamp Counter)"))
            gef_print(c(edx,  5, 1,          "        EDX     5: MSR (Model Specific Registers RDMSR and WRMSR instructions)"))
            gef_print(c(edx,  6, 1,          "        EDX     6: PAE (Physical Address Extension)"))
            gef_print(c(edx,  7, 1,          "        EDX     7: MCE (Machine Check Exception)"))
            gef_print(c(edx,  8, 1,          "        EDX     8: CX8 (CMPXCHG8B instruction)"))
            gef_print(c(edx,  9, 1,          "        EDX     9: APIC (APIC on-chip)"))
            gef_print(c(edx, 10, 1,          "        EDX    10: Reserved"))
            gef_print(c(edx, 11, 1,          "        EDX    11: SEP (SYSENTER and SYSEXIT instructions)"))
            gef_print(c(edx, 12, 1,          "        EDX    12: MTRR (Memory Type Range Registers)"))
            gef_print(c(edx, 13, 1,          "        EDX    13: PGE (Page Global Bit)"))
            gef_print(c(edx, 14, 1,          "        EDX    14: MCA (Machine Check Architecture)"))
            gef_print(c(edx, 15, 1,          "        EDX    15: CMOV (Conditional Move instructions)"))
            gef_print(c(edx, 16, 1,          "        EDX    16: PAT (Page Attribute Table)"))
            gef_print(c(edx, 17, 1,          "        EDX    17: PSE-36 (36-Bit Page Size Extension)"))
            gef_print(c(edx, 18, 1,          "        EDX    18: PSN (Processor Serial Number)"))
            gef_print(c(edx, 19, 1,          "        EDX    19: CLFSH (CLFLUSH instruction)"))
            gef_print(c(edx, 20, 1,          "        EDX    20: Reserved"))
            gef_print(c(edx, 21, 1,          "        EDX    21: DS (Debug Store)"))
            gef_print(c(edx, 22, 1,          "        EDX    22: ACPI (Thermal Monitor and Software Controlled Clock Facilities)"))
            gef_print(c(edx, 23, 1,          "        EDX    23: MMX (Intel MMX technology)"))
            gef_print(c(edx, 24, 1,          "        EDX    24: FXSR (FXSAVE and FXRSTOR instructions)"))
            gef_print(c(edx, 25, 1,          "        EDX    25: SSE (Streaming SIMD Extension)"))
            gef_print(c(edx, 26, 1,          "        EDX    26: SSE2 (STreaming SIMD Extension 2)"))
            gef_print(c(edx, 27, 1,          "        EDX    27: SS (Self Snoop)"))
            gef_print(c(edx, 28, 1,          "        EDX    28: HTT (Max APIC IDs reserved field is Valid)"))
            gef_print(c(edx, 29, 1,          "        EDX    29: TM (Thermal Monitor)"))
            gef_print(c(edx, 30, 1,          "        EDX    30: Reserved"))
            gef_print(c(edx, 31, 1,          "        EDX    31: PBE (Pending Break Enable)"))
            gef_print(c(ecx,  0, 1,          "        ECX     0: SSE3 (Streaming SIMD Extensions 3)"))
            gef_print(c(ecx,  1, 1,          "        ECX     1: PCLMULQDQ (PCLMULQDQ instruction)"))
            gef_print(c(ecx,  2, 1,          "        ECX     2: DTES64 (64-bit DS Area)"))
            gef_print(c(ecx,  3, 1,          "        ECX     3: MONITOR (MONITOR/MWAIT instruction)"))
            gef_print(c(ecx,  4, 1,          "        ECX     4: DS-CPL (CPL Qualified Debug Store)"))
            gef_print(c(ecx,  5, 1,          "        ECX     5: VMX (Intel VT (Virtual Machine eXtensions))"))
            gef_print(c(ecx,  6, 1,          "        ECX     6: SMX (Safer Mode eXtensions)"))
            gef_print(c(ecx,  7, 1,          "        ECX     7: EIST (Enhanced Intel SpeedStep Technology)"))
            gef_print(c(ecx,  8, 1,          "        ECX     8: TM2 (Thermal Monitor 2)"))
            gef_print(c(ecx,  9, 1,          "        ECX     9: SSSE3 (Supplemental Streaming SIMD Extensions 3)"))
            gef_print(c(ecx, 10, 1,          "        ECX    10: CNXT-ID (L1 Context ID)"))
            gef_print(c(ecx, 11, 1,          "        ECX    11: SDBG (IA32_DEBUG_INTERFACE MSR for silicon debug)"))
            gef_print(c(ecx, 12, 1,          "        ECX    12: FMA (FMA extensions using YMM state)"))
            gef_print(c(ecx, 13, 1,          "        ECX    13: CMPXCHG16B (CMPXCHG16B instruction)"))
            gef_print(c(ecx, 14, 1,          "        ECX    14: xTPR (xTPR update control)"))
            gef_print(c(ecx, 15, 1,          "        ECX    15: PDCM (Perfmon and Debug Capability MSR)"))
            gef_print(c(ecx, 16, 1,          "        ECX    16: Reserved"))
            gef_print(c(ecx, 17, 1,          "        ECX    17: PCID (Process-Context IDentifiers)"))
            gef_print(c(ecx, 18, 1,          "        ECX    18: DCA (Direct Cache Access)"))
            gef_print(c(ecx, 19, 1,          "        ECX    19: SSE4_1 (Streaming SIMD Extensions 4.1)"))
            gef_print(c(ecx, 20, 1,          "        ECX    20: SSE4_2 (Streaming SIMD Extensions 4.2)"))
            gef_print(c(ecx, 21, 1,          "        ECX    21: x2APIC"))
            gef_print(c(ecx, 22, 1,          "        ECX    22: MOVBE (MOVBE instruction)"))
            gef_print(c(ecx, 23, 1,          "        ECX    23: POPCNT (POPulation CouNt instruction)"))
            gef_print(c(ecx, 24, 1,          "        ECX    24: TSC-Deadline"))
            gef_print(c(ecx, 25, 1,          "        ECX    25: AESNI (AESNI Instruction)"))
            gef_print(c(ecx, 26, 1,          "        ECX    26: XSAVE (XSAVE instruction)"))
            gef_print(c(ecx, 27, 1,          "        ECX    27: OSXSAVE (OSXSAVE instruction)"))
            gef_print(c(ecx, 28, 1,          "        ECX    28: AVX (Intel Advanced Vector eXtensions)"))
            gef_print(c(ecx, 29, 1,          "        ECX    29: F16C (16-bit Floating-point Conversion instructions)"))
            gef_print(c(ecx, 30, 1,          "        ECX    30: RDRAND (RDRAND instruction)"))
            gef_print(c(ecx, 31, 1,          "        ECX    31: RAZ (Reserved for use by hypervisor to indicate guest status)"))
        elif id == 2:
            gef_print("    Cache and TLB Information")
        elif id == 3:
            gef_print("    eax,ebx: Reserved")
            gef_print("    edx+ecx: Processor Serial Number")
        elif id == 4:
            gef_print("    Information of cache configuration descriptor")
        elif id == 5:
            gef_print("    Information of MONITOR/MWAIT")
        elif id == 6:
            gef_print("    Information of power management")
            gef_print(c(eax,  0, 1,          "        EAX     0: Digital temperature sensor"))
            gef_print(c(eax,  1, 1,          "        EAX     1: Intel Turbo Boost Technology"))
            gef_print(c(eax,  2, 1,          "        EAX     2: ARAT (Always Running APIC Timer)"))
            gef_print(c(eax,  3, 1,          "        EAX     3: Reserved"))
            gef_print(c(eax,  4, 1,          "        EAX     4: Power limit notification controls"))
            gef_print(c(eax,  5, 1,          "        EAX     5: Clock modulation duty cycle extensions"))
            gef_print(c(eax,  6, 1,          "        EAX     6: Package thermal management"))
            gef_print(c(eax,  7, 1,          "        EAX     7: Hardware-managed P-state base support (HWP)"))
            gef_print(c(eax,  8, 1,          "        EAX     8: HWP notification interrupt enable MSR"))
            gef_print(c(eax,  9, 1,          "        EAX     9: HWP activity window MSR"))
            gef_print(c(eax, 10, 1,          "        EAX    10: HWP energy/performance preference MSR"))
            gef_print(c(eax, 11, 1,          "        EAX    11: HWP package level request MSR"))
            gef_print(c(eax, 12, 1,          "        EAX    12: Reserved"))
            gef_print(c(eax, 13, 1,          "        EAX    13: HDC (Hardware Duty Cycle programming)"))
            gef_print(c(eax, 14, 1,          "        EAX    14: Intel Turbo Boost Max Technology 3.0"))
            gef_print(c(eax, 15, 1,          "        EAX    15: HWP Capabilities, Highest Performance change"))
            gef_print(c(eax, 16, 1,          "        EAX    16: HWP PECI override"))
            gef_print(c(eax, 17, 1,          "        EAX    17: Flexible HWP"))
            gef_print(c(eax, 18, 1,          "        EAX    18: Fast access mode for IA32_HWP_REQUEST MSR"))
            gef_print(c(eax, 19, 1,          "        EAX    19: Hardware feedback MSRs"))
            gef_print(c(eax, 20, 1,          "        EAX    20: Ignoring Idle Logical Processor HWP request"))
            gef_print(c(eax, 21, 1,          "        EAX    21: Reserved"))
            gef_print(c(eax, 22, 1,          "        EAX    22: Reserved"))
            gef_print(c(eax, 23, 1,          "        EAX    23: Enhanced hardware feedback MSRs"))
            gef_print(c(eax, 24, 0x7f,       "        EAX 30-24: Reserved"))
            gef_print(c(eax, 31, 1,          "        EAX    31: IP payloads are LIP"))
            gef_print(c(ebx,  0, 0xf,        "        EBX  3- 0: Number of interrupted thresholds of digital temperature sensor"))
            gef_print(c(ebx,  4, 0xfffffff,  "        EBX 31- 4: Reserved"))
            gef_print(c(ecx,  0, 1,          "        ECX     0: Hardware Coordination Feedback Capability (APERF and MPERF)"))
            gef_print(c(ecx,  1, 1,          "        ECX     1: Reserved"))
            gef_print(c(ecx,  2, 1,          "        ECX     2: Reserved"))
            gef_print(c(ecx,  3, 1,          "        ECX     3: Performance-energy bias preference"))
            gef_print(c(ecx,  4, 0xfffffff,  "        ECX 31- 4: Reserved"))
            gef_print(c(edx,  0, 1,          "        EDX     0: Performance feature report"))
            gef_print(c(edx,  1, 1,          "        EDX     1: Energy efficiency capacity report"))
            gef_print(c(edx,  2, 0x3f,       "        EDX  7- 2: Reserved"))
            gef_print(c(edx,  8, 0xf,        "        EDX 11- 8: The size of the hardware feedback interface structure"))
            gef_print(c(edx, 12, 0xf,        "        EDX 15-12: Reserved"))
            gef_print(c(edx, 16, 0xffff,     "        EDX 31-16: Index of rows for the hardware feedback interface structure"))
        elif id == 7 and subid == 0:
            gef_print("    eax: Maximum Input Value for Extended CPUID Information")
            gef_print("    ebx,edx,edx: Extended Feature Information")
            gef_print(c(ebx,  0, 1,          "        EBX     0: FSGSBASE (FSGSBASE instructions)"))
            gef_print(c(ebx,  1, 1,          "        EBX     1: TSC_ADJUST (IA32_TSC_ADJUST MSR supported)"))
            gef_print(c(ebx,  2, 1,          "        EBX     2: SGX (Software Guard Extensions)"))
            gef_print(c(ebx,  3, 1,          "        EBX     3: BMI1 (Bit Manipulation Instructions)"))
            gef_print(c(ebx,  4, 1,          "        EBX     4: HLE (Hardware Lock Elision)"))
            gef_print(c(ebx,  5, 1,          "        EBX     5: AVX2 (Advanced Vector Extensions 2.0)"))
            gef_print(c(ebx,  6, 1,          "        EBX     6: FDP_EXCPTN_ONLY (x87 FPU Data Pointer updated only on x87 Exceptions)"))
            gef_print(c(ebx,  7, 1,          "        EBX     7: SMEP (Supervisor Mode Execution Protection)"))
            gef_print(c(ebx,  8, 1,          "        EBX     8: BMI2 (Bit Manipulation Instructions 2)"))
            gef_print(c(ebx,  9, 1,          "        EBX     9: ERMS (Enhanced REP MOVSB/STOSB)"))
            gef_print(c(ebx, 10, 1,          "        EBX    10: INVPCID (INVPCID instruction)"))
            gef_print(c(ebx, 11, 1,          "        EBX    11: RTM (Restricted Transactional Memor)"))
            gef_print(c(ebx, 12, 1,          "        EBX    12: PQM (Platform QoS Monitoring)"))
            gef_print(c(ebx, 13, 1,          "        EBX    13: x87 FPU CS and DS deprecated"))
            gef_print(c(ebx, 14, 1,          "        EBX    14: MPX (Memory Protection eXtensions)"))
            gef_print(c(ebx, 15, 1,          "        EBX    15: PQE (Platform QoS Enforcement)"))
            gef_print(c(ebx, 16, 1,          "        EBX    16: AVX512F (AVX512 Foundation)"))
            gef_print(c(ebx, 17, 1,          "        EBX    17: AVX512DQ (AVX512 Double/Quadword instructions)"))
            gef_print(c(ebx, 18, 1,          "        EBX    18: RDSEED (RDSEED instruction)"))
            gef_print(c(ebx, 19, 1,          "        EBX    19: ADX (Multi-Precision Add-Carry instruction eXtensions)"))
            gef_print(c(ebx, 20, 1,          "        EBX    20: SMAP (Supervisor Mode Access Prevention)"))
            gef_print(c(ebx, 21, 1,          "        EBX    21: AVX512IFMA (AVX512 Integer FMA instructions)"))
            gef_print(c(ebx, 22, 1,          "        EBX    22: (Intel) PCOMMIT (Persistent Commit instruction)"))
            gef_print(c(ebx, 22, 1,          "        EBX    22: (AMD) RDPID (RDPID instruction and TSC_AUX MSR iupport)"))
            gef_print(c(ebx, 23, 1,          "        EBX    23: CLFLUSHOPT (CLFLUSHOPT instruction)"))
            gef_print(c(ebx, 24, 1,          "        EBX    24: CLWB (Cache Line Write-Back instruction)"))
            gef_print(c(ebx, 25, 1,          "        EBX    25: PT (Intel Processor Trace)"))
            gef_print(c(ebx, 26, 1,          "        EBX    26: AVX512PF (AVX512 Prefetch instructions)"))
            gef_print(c(ebx, 27, 1,          "        EBX    27: AVX512ER (AVX512 Exponent/Reciprocal instructions)"))
            gef_print(c(ebx, 28, 1,          "        EBX    28: AVX512CD (AVX512 Conflict Detection instructions)"))
            gef_print(c(ebx, 29, 1,          "        EBX    29: SHA (SHA-1/SHA-256 instructions)"))
            gef_print(c(ebx, 30, 1,          "        EBX    30: AVX512BW (AVX512 Byte/Word instructions)"))
            gef_print(c(ebx, 31, 1,          "        EBX    31: AVX512VL (AVX512 Vector Length Extensions)"))
            gef_print(c(ecx,  0, 1,          "        ECX     0: PREFETCHWT1 (PREFETCHWT1 instruction)"))
            gef_print(c(ecx,  1, 1,          "        ECX     1: AVX512VBMI (AVX512 Vector Byte Manipulation Instructions)"))
            gef_print(c(ecx,  2, 1,          "        ECX     2: UMIP (User Mode Instruction Prevention)"))
            gef_print(c(ecx,  3, 1,          "        ECX     3: PKU (Protection Keys for User-mode pages)"))
            gef_print(c(ecx,  4, 1,          "        ECX     4: OSPKE (OS has Enabled Protection Keys)"))
            gef_print(c(ecx,  5, 1,          "        ECX     5: WAITPKG (Wait and Pause Enhancements)"))
            gef_print(c(ecx,  6, 1,          "        ECX     6: AVX512VBMI2 (AVX512 Vector Byte Manipulation Instructions 2)"))
            gef_print(c(ecx,  7, 1,          "        ECX     7: CET_SS (CET shadow stack)"))
            gef_print(c(ecx,  8, 1,          "        ECX     8: GFNI (Galois Field NI / Galois Field Affine Transformation)"))
            gef_print(c(ecx,  9, 1,          "        ECX     9: VAES (VEX-encoded AES-NI)"))
            gef_print(c(ecx, 10, 1,          "        ECX    10: VPCL (VEX-encoded PCLMUL)"))
            gef_print(c(ecx, 11, 1,          "        ECX    11: AVX512VNNI (AVX512 Vector Neural Network Instructions)"))
            gef_print(c(ecx, 12, 1,          "        ECX    12: AVX512BITALG (AVX512 Bitwise Algorithms)"))
            gef_print(c(ecx, 13, 1,          "        ECX    13: TME_EN (Total Memory Encryption)"))
            gef_print(c(ecx, 14, 1,          "        ECX    14: AVX512 VPOPCNTDQ"))
            gef_print(c(ecx, 15, 1,          "        ECX    15: Reserved"))
            gef_print(c(ecx, 16, 1,          "        ECX    16: LA57 (5-Level paging)"))
            gef_print(c(ecx, 17, 0x1f,       "        ECX 21-17: MAWAU (MPX Address-Width Adjust for CPL=3)"))
            gef_print(c(ecx, 22, 1,          "        ECX    22: RDPID (Read Processor ID)"))
            gef_print(c(ecx, 23, 1,          "        ECX    23: KL (Key Locker)"))
            gef_print(c(ecx, 24, 1,          "        ECX    24: Reserved"))
            gef_print(c(ecx, 25, 1,          "        ECX    25: CLDEMOTE (Cache Line Demote)"))
            gef_print(c(ecx, 26, 1,          "        ECX    26: Reserved"))
            gef_print(c(ecx, 27, 1,          "        ECX    27: MOVDIRI (32-bit Direct Stores)"))
            gef_print(c(ecx, 28, 1,          "        ECX    28: MOVDIRI64B (64-bit Direct Stores)"))
            gef_print(c(ecx, 29, 1,          "        ECX    29: ENQCMD (ENQueue Stores)"))
            gef_print(c(ecx, 30, 1,          "        ECX    30: SGX_LC (SGX Launch Configuration)"))
            gef_print(c(ecx, 31, 1,          "        ECX    31: PKS (Protection Keys for Supervisor-mode pages)"))
            gef_print(c(edx,  0, 1,          "        EDX     0: Reserved"))
            gef_print(c(edx,  1, 1,          "        EDX     1: Reserved"))
            gef_print(c(edx,  2, 1,          "        EDX     2: AVX512_4VNNIW"))
            gef_print(c(edx,  3, 1,          "        EDX     3: AVX512_4FMAPS"))
            gef_print(c(edx,  4, 1,          "        EDX     4: Fast Short REP MOV"))
            gef_print(c(edx,  5, 1,          "        EDX     5: UINTR (User Interrupts)"))
            gef_print(c(edx,  6, 1,          "        EDX     6: Reserved"))
            gef_print(c(edx,  7, 1,          "        EDX     7: Reserved"))
            gef_print(c(edx,  8, 1,          "        EDX     8: AVX512_VP2INTERSECT"))
            gef_print(c(edx,  9, 1,          "        EDX     9: Reserved"))
            gef_print(c(edx, 10, 1,          "        EDX    10: MD_CLEAR"))
            gef_print(c(edx, 11, 1,          "        EDX    11: Reserved"))
            gef_print(c(edx, 12, 1,          "        EDX    12: Reserved"))
            gef_print(c(edx, 13, 1,          "        EDX    13: TSX force abort MSR"))
            gef_print(c(edx, 14, 1,          "        EDX    14: SERIALIZE"))
            gef_print(c(edx, 15, 1,          "        EDX    15: Hybrid"))
            gef_print(c(edx, 16, 1,          "        EDX    16: TSX suspend load address tracking"))
            gef_print(c(edx, 17, 1,          "        EDX    17: Reserved"))
            gef_print(c(edx, 18, 1,          "        EDX    18: PCONFIG"))
            gef_print(c(edx, 19, 1,          "        EDX    19: Reserved"))
            gef_print(c(edx, 20, 1,          "        EDX    20: CET_IBT (CET Indirect Branch Tracking)"))
            gef_print(c(edx, 21, 1,          "        EDX    21: Reserved"))
            gef_print(c(edx, 22, 1,          "        EDX    22: AMX-BF16 (Tile computation on bfloat16)"))
            gef_print(c(edx, 23, 1,          "        EDX    23: AVX512FP16"))
            gef_print(c(edx, 24, 1,          "        EDX    24: AMX-TILE (Tile architecture)"))
            gef_print(c(edx, 25, 1,          "        EDX    25: AMX-INT8 (Tile computation on 8-bit integers)"))
            gef_print(c(edx, 26, 1,          "        EDX    26: IBRS/IBPB (Indirect Branch Restricted Speculation/Predictor Barrier)"))
            gef_print(c(edx, 27, 1,          "        EDX    27: STIBP (Single Thread Indirect Branch Predictors)"))
            gef_print(c(edx, 28, 1,          "        EDX    28: L1D_FLUSH (L1 Data Cache Flush)"))
            gef_print(c(edx, 29, 1,          "        EDX    29: IA32_ARCH_CAPABILITIES MSR"))
            gef_print(c(edx, 30, 1,          "        EDX    30: IA32_CORE_CAPABILITIES MSR"))
            gef_print(c(edx, 31, 1,          "        EDX    31: SSBD (Speculative Store Bypass Disable)"))
        elif id == 7 and subid != 0:
            gef_print("    ebx,edx,edx: Extended Feature Information")
        elif id == 8:
            gef_print("    Reserved")
        elif id == 9:
            gef_print("    eax: PLATFORM_DCA_CAP MSR")
            gef_print("    ebx,ecx,edx: Reserved")
        elif id == 10:
            gef_print("    DCA parameters")
            gef_print(c(eax,  0, 0xff,       "        EAX  7- 0: Revision"))
            gef_print(c(eax,  8, 0xff,       "        EAX 15- 8: Number of PeMo counters per logical processor"))
            gef_print(c(eax, 16, 0xff,       "        EAX 23-16: Bit width of PeMo counter"))
            gef_print(c(eax, 24, 0xff,       "        EAX 31-24: EBX bit vector length"))
            gef_print(c(ebx,  0, 1,          "        EBX     0: Core cycles event unavailable"))
            gef_print(c(ebx,  1, 1,          "        EBX     1: Instructions retired event unavailable"))
            gef_print(c(ebx,  2, 1,          "        EBX     2: Reference cycles event unavailable"))
            gef_print(c(ebx,  3, 1,          "        EBX     3: Last level cache references event unavailable"))
            gef_print(c(ebx,  4, 1,          "        EBX     4: Last level cache misses event unavailable"))
            gef_print(c(ebx,  5, 1,          "        EBX     5: Branch instructions retired event unavailable"))
            gef_print(c(ebx,  6, 1,          "        EBX     6: Branch mispredicts retired event unavailable"))
            gef_print(c(ebx,  7, 0x1ffffff,  "        EBX 31- 7: Reserved"))
            gef_print(c(ecx,  0, 0xffffffff, "        ECX 31- 0: Reserved"))
            gef_print(c(edx,  0, 0x1f,       "        EDX  4- 0: Number of fixed function PeMo counters"))
            gef_print(c(edx,  5, 0xff,       "        EDX 12- 5: Bit width of fixed function PeMo counter"))
            gef_print(c(edx, 13, 1,          "        EDX    13: Reserved"))
            gef_print(c(edx, 14, 1,          "        EDX    14: Reserved"))
            gef_print(c(edx, 15, 1,          "        EDX    15: AnyThread deprecation"))
            gef_print(c(edx, 16, 0xffff,     "        EDX 31-16: Reserved"))
        elif id == 11:
            gef_print("    Information of topology enumeration")
        elif id == 12:
            gef_print("    Reserved")
        elif id == 13:
            if subid == 0:
                m = "main"
            elif subid == 1:
                m = "sub"
            else:
                m = "XCR0.{:d}".format(subid)
            gef_print("    Information of extended state enumeration ({:s})".format(m))
        elif id in [15, 16]:
            gef_print("    Intel Resource Director Technology (Intel RDT), Cache, Memory Bandwidth Allocation Enumeration")
        elif id == 18:
            gef_print("    Information of Intel SGX")
        elif id == 20:
            gef_print("    Information of Intel Processor Trace Enumeration")
            gef_print(c(ebx,  0, 1,          "        EBX     0: CR3 filtering"))
            gef_print(c(ebx,  1, 1,          "        EBX     1: Configurable PSB, Cycle-Accurate Mode"))
            gef_print(c(ebx,  2, 1,          "        EBX     2: Filtering preserved across warm reset"))
            gef_print(c(ebx,  3, 1,          "        EBX     3: MTC timing packet, suppression of COFI-based packets"))
            gef_print(c(ebx,  4, 1,          "        EBX     4: PTWRITE"))
            gef_print(c(ebx,  5, 1,          "        EBX     5: Power Event Trace"))
            gef_print(c(ebx,  6, 1,          "        EBX     6: PSB and PMI preservation MSRs"))
            gef_print(c(ebx,  7, 0x1ffffff,  "        EBX 31- 7: Reserved"))
            gef_print(c(ecx,  0, 1,          "        ECX     0: ToPA output scheme"))
            gef_print(c(ecx,  1, 1,          "        ECX     1: ToPA tables hold multiple output entries"))
            gef_print(c(ecx,  2, 1,          "        ECX     2: Single-range output scheme"))
            gef_print(c(ecx,  3, 1,          "        ECX     3: Trace Transport output support"))
            gef_print(c(ecx,  4, 0x7ffffff,  "        ECX 30- 4: Reserved"))
            gef_print(c(ecx, 31, 1,          "        ECX    31: IP payloads are LIP"))
        elif id == 21:
            gef_print("    TSC and Nominal Core Crystal Clock")
        elif id == 22:
            gef_print("    Information of CPU frequency")
            gef_print(c(eax,  0, 0xffff,     "        EAX 15- 0: Processor Base Frequency (MHz)"))
            gef_print(c(eax, 16, 0xffff,     "        EAX 31-16: Reserved"))
            gef_print(c(ebx,  0, 0xffff,     "        EBX 15- 0: Maximum Frequency (MHz)"))
            gef_print(c(ebx, 16, 0xffff,     "        EBX 31-16: Reserved"))
            gef_print(c(ecx,  0, 0xffff,     "        ECX 15- 0: Bus (Reference) Frequency (MHz)"))
            gef_print(c(ecx, 16, 0xffff,     "        ECX 31-16: Reserved"))
            gef_print(c(edx,  0, 0xffffffff, "        EDX 31- 0: Reserved"))
        elif id == 23:
            gef_print("    Information of System-On-Chip Vendor Attribute Enumeration")
        elif id == 24:
            gef_print("    Information of Deterministic Address Translation Parameters")
        elif id == 26:
            gef_print("    Information of Hybrid Information Enumeration")
        elif id == 31:
            gef_print("    Information of V2 Extended Topology Enumeration")
        elif id == 0x40000000:
            vid = (p32(ebx) + p32(ecx) + p32(edx)).decode("utf-8")
            gef_print("    eax: Maximum Input Value for Hypervisor Function CPUID Information")
            gef_print("    ebx+ecx+edx: Hypervisor Brand String (={:s})".format(repr(vid)))
        elif id == 0x40000001:
            gef_print("    Hypervisor")
            gef_print(c(eax,  0, 1,          "        EAX     0: Clocksource"))
            gef_print(c(eax,  1, 1,          "        EAX     1: NOP IO Delay"))
            gef_print(c(eax,  2, 1,          "        EAX     2: MMU Op"))
            gef_print(c(eax,  3, 1,          "        EAX     3: Clocksource 2"))
            gef_print(c(eax,  4, 1,          "        EAX     4: Async PF"))
            gef_print(c(eax,  5, 1,          "        EAX     5: Steal Time"))
            gef_print(c(eax,  6, 1,          "        EAX     6: PV EOI"))
            gef_print(c(eax,  7, 1,          "        EAX     7: PV UNHALT"))
            gef_print(c(eax,  8, 1,          "        EAX     8: Reserved"))
            gef_print(c(eax,  9, 1,          "        EAX     9: PV TLB flush"))
            gef_print(c(eax, 10, 1,          "        EAX    10: PV async PF VMEXIT"))
            gef_print(c(eax, 11, 1,          "        EAX    11: PV send IPI"))
            gef_print(c(eax, 12, 1,          "        EAX    12: PV poll control"))
            gef_print(c(eax, 13, 1,          "        EAX    13: PV sched yield"))
            gef_print(c(eax, 14, 1,          "        EAX    14: Async PF INT"))
            gef_print(c(eax, 15, 1,          "        EAX    15: MSI extended destination ID"))
            gef_print(c(eax, 16, 1,          "        EAX    16: Hypercall map GPA range"))
            gef_print(c(eax, 17, 1,          "        EAX    17: Hypercall map GPA range"))
            gef_print(c(eax, 18, 1,          "        EAX    18: Migration control"))
            gef_print(c(eax, 19, 0x3f,       "        EAX 24-19: Reserved"))
            gef_print(c(eax, 25, 1,          "        EAX    25: Clocksource Stable"))
            gef_print(c(eax, 26, 0x3f,       "        EAX 31-26: Reserved"))
            gef_print(c(edx,  0, 1,          "        EDX     0: vCPUs realtime, never preempted"))
            gef_print(c(edx,  1, 0x7fffffff, "        EDX 31- 1: Reserved"))
        elif id == 0x40000003:
            gef_print("    Hypervisor")
            gef_print(c(eax,  0, 1,          "        EAX     0: VP_RUNTIME"))
            gef_print(c(eax,  1, 1,          "        EAX     1: TIME_REF_COUNT"))
            gef_print(c(eax,  2, 1,          "        EAX     2: Basic SynIC MSRs"))
            gef_print(c(eax,  3, 1,          "        EAX     3: Synthetic Timer"))
            gef_print(c(eax,  4, 1,          "        EAX     4: APIC access"))
            gef_print(c(eax,  5, 1,          "        EAX     5: Hypercall MSRs"))
            gef_print(c(eax,  6, 1,          "        EAX     6: VP Index MSR"))
            gef_print(c(eax,  7, 1,          "        EAX     7: System Reset MSR"))
            gef_print(c(eax,  8, 1,          "        EAX     8: Access stats MSRs"))
            gef_print(c(eax,  9, 1,          "        EAX     9: Reference TSC"))
            gef_print(c(eax, 10, 1,          "        EAX    10: Guest Idle MSR"))
            gef_print(c(eax, 11, 1,          "        EAX    11: Timer Frequency MSRs"))
            gef_print(c(eax, 12, 1,          "        EAX    12: Debug MSRs"))
            gef_print(c(eax, 13, 1,          "        EAX    13: Reenlightenment controls"))
            gef_print(c(eax, 14, 0x3ffff,    "        EAX 31-14: Reserved"))
            gef_print(c(ebx,  0, 1,          "        EBX     0: CreatePartitions"))
            gef_print(c(ebx,  1, 1,          "        EBX     1: AccessPartitionId"))
            gef_print(c(ebx,  2, 1,          "        EBX     2: AccessMemoryPool"))
            gef_print(c(ebx,  3, 1,          "        EBX     3: AdjustMemoryBuffers"))
            gef_print(c(ebx,  4, 1,          "        EBX     4: PostMessages"))
            gef_print(c(ebx,  5, 1,          "        EBX     5: SignalEvents"))
            gef_print(c(ebx,  6, 1,          "        EBX     6: CreatePort"))
            gef_print(c(ebx,  7, 1,          "        EBX     7: ConnectPort"))
            gef_print(c(ebx,  8, 1,          "        EBX     8: AccessStats"))
            gef_print(c(ebx,  9, 1,          "        EBX     9: Reserved"))
            gef_print(c(ebx, 10, 1,          "        EBX    10: Reserved"))
            gef_print(c(ebx, 11, 1,          "        EBX    11: Debugging"))
            gef_print(c(ebx, 12, 1,          "        EBX    12: CpuManagement"))
            gef_print(c(ebx, 13, 1,          "        EBX    13: ConfigureProfiler"))
            gef_print(c(ebx, 14, 1,          "        EBX    14: EnableExpandedStackwalking"))
            gef_print(c(ebx, 15, 1,          "        EBX    15: Reserved"))
            gef_print(c(ebx, 16, 1,          "        EBX    16: AccessVSM"))
            gef_print(c(ebx, 17, 1,          "        EBX    17: AccessVpRegisters"))
            gef_print(c(ebx, 18, 1,          "        EBX    18: Reserved"))
            gef_print(c(ebx, 19, 1,          "        EBX    19: Reserved"))
            gef_print(c(ebx, 20, 1,          "        EBX    20: EnableExtendedHypercalls"))
            gef_print(c(ebx, 21, 1,          "        EBX    21: StartVirtualProcessor"))
            gef_print(c(ebx, 22, 0x3ff,      "        EBX 31-22: Reserved"))
            gef_print(c(edx,  0, 1,          "        EDX     0: MWAIT instruction support (deprecated)"))
            gef_print(c(edx,  1, 1,          "        EDX     1: Guest debugging support"))
            gef_print(c(edx,  2, 1,          "        EDX     2: Performance Monitor support"))
            gef_print(c(edx,  3, 1,          "        EDX     3: Physical CPU dynamic partitioning event support"))
            gef_print(c(edx,  4, 1,          "        EDX     4: Hypercall input params via XMM registers"))
            gef_print(c(edx,  5, 1,          "        EDX     5: Virtual guest idle state support"))
            gef_print(c(edx,  6, 1,          "        EDX     6: Hypervisor sleep state support"))
            gef_print(c(edx,  7, 1,          "        EDX     7: NUMA distance query support"))
            gef_print(c(edx,  8, 1,          "        EDX     8: Timer frequency details available"))
            gef_print(c(edx,  9, 1,          "        EDX     9: Synthetic machine check injection support"))
            gef_print(c(edx, 10, 1,          "        EDX    10: Guest crash MSR support"))
            gef_print(c(edx, 11, 1,          "        EDX    11: Debug MSR support"))
            gef_print(c(edx, 12, 1,          "        EDX    12: NPIEP support"))
            gef_print(c(edx, 13, 1,          "        EDX    13: Hypervisor disable support"))
            gef_print(c(edx, 14, 1,          "        EDX    14: Extended GVA ranges for flush virtual address list available"))
            gef_print(c(edx, 15, 1,          "        EDX    15: Hypercall output via XMM registers"))
            gef_print(c(edx, 16, 1,          "        EDX    16: Virtual guest idle state"))
            gef_print(c(edx, 17, 1,          "        EDX    17: Soft interrupt polling mode available"))
            gef_print(c(edx, 18, 1,          "        EDX    18: Hypercall MSR lock available"))
            gef_print(c(edx, 19, 1,          "        EDX    19: Direct synthetic timers support"))
            gef_print(c(edx, 20, 1,          "        EDX    20: PAT register available for VSM"))
            gef_print(c(edx, 21, 1,          "        EDX    21: BNDCFGS register available for VSM"))
            gef_print(c(edx, 22, 1,          "        EDX    22: Reserved"))
            gef_print(c(edx, 23, 1,          "        EDX    23: Synthetic time unhalted timer"))
            gef_print(c(edx, 24, 1,          "        EDX    24: Reserved"))
            gef_print(c(edx, 25, 1,          "        EDX    25: Reserved"))
            gef_print(c(edx, 26, 1,          "        EDX    26: Intel Last Branch Record (LBR) feature"))
            gef_print(c(edx, 27, 1,          "        EDX 31-27: Reserved"))
        elif id == 0x40000004:
            gef_print("    Hypervisor implementation recommendations")
            gef_print(c(eax,  0, 1,          "        EAX     0: Hypercall for address space switches"))
            gef_print(c(eax,  1, 1,          "        EAX     1: Hypercall for local TLB flushes"))
            gef_print(c(eax,  2, 1,          "        EAX     2: Hypercall for remote TLB flushes"))
            gef_print(c(eax,  3, 1,          "        EAX     3: MSRs for accessing APIC registers"))
            gef_print(c(eax,  4, 1,          "        EAX     4: Hypervisor MSR for system RESET"))
            gef_print(c(eax,  5, 1,          "        EAX     5: Relaxed timing"))
            gef_print(c(eax,  6, 1,          "        EAX     6: DMA remapping"))
            gef_print(c(eax,  7, 1,          "        EAX     7: Interrupt remapping"))
            gef_print(c(eax,  8, 1,          "        EAX     8: x2APIC MSRs"))
            gef_print(c(eax,  9, 1,          "        EAX     9: Deprecating AutoEOI"))
            gef_print(c(eax, 10, 1,          "        EAX    10: Hypercall for SyntheticClusterIpi"))
            gef_print(c(eax, 11, 1,          "        EAX    11: Interface ExProcessorMasks"))
            gef_print(c(eax, 12, 1,          "        EAX    12: Nested Hyper-V partition"))
            gef_print(c(eax, 13, 1,          "        EAX    13: INT for MBEC system calls"))
            gef_print(c(eax, 14, 1,          "        EAX    14: Enlightenment VMCS interface"))
            gef_print(c(eax, 15, 1,          "        EAX    15: Synced timeline"))
            gef_print(c(eax, 16, 1,          "        EAX    16: Reserved"))
            gef_print(c(eax, 17, 1,          "        EAX    17: Direct local flush entire"))
            gef_print(c(eax, 18, 1,          "        EAX    18: No architectural core sharing"))
            gef_print(c(eax, 19, 0x1fff,     "        EAX 31-19: Reserved"))
        elif id == 0x40000006:
            gef_print("    Hypervisor hardware features enable")
            gef_print(c(eax,  0, 1,          "        EAX     0: APIC overlay assist"))
            gef_print(c(eax,  1, 1,          "        EAX     1: MSR bitmaps"))
            gef_print(c(eax,  2, 1,          "        EAX     2: Architectural performance counters"))
            gef_print(c(eax,  3, 1,          "        EAX     3: Second-level address translation"))
            gef_print(c(eax,  4, 1,          "        EAX     4: DMA remapping"))
            gef_print(c(eax,  5, 1,          "        EAX     5: Interrupt remapping"))
            gef_print(c(eax,  6, 1,          "        EAX     6: Memory patrol scrubber"))
            gef_print(c(eax,  7, 1,          "        EAX     7: DMA protection"))
            gef_print(c(eax,  8, 1,          "        EAX     8: HPET"))
            gef_print(c(eax,  9, 1,          "        EAX     9: Volatile synthetic timers"))
            gef_print(c(eax, 10, 0x3fffff,   "        EAX 31-10: Reserved"))
        elif id == 0x40000007:
            gef_print("    Hypervisor CPU management features")
            gef_print(c(eax,  0, 1,          "        EAX     0: Start logical processor"))
            gef_print(c(eax,  1, 1,          "        EAX     1: Create root virtual processor"))
            gef_print(c(eax,  2, 1,          "        EAX     2: Performance counter sync"))
            gef_print(c(eax,  3, 0x1fffffff, "        EAX 31- 3: Reserved"))
            gef_print(c(ebx,  0, 1,          "        EBX     0: Processor power management"))
            gef_print(c(ebx,  1, 1,          "        EBX     1: MWAIT idle states"))
            gef_print(c(ebx,  2, 1,          "        EBX     2: Logical processor idling"))
            gef_print(c(ebx,  3, 0x1fffffff, "        EBX 31- 3: Reserved"))
            gef_print(c(ecx,  0, 1,          "        ECX     0: Remap guest uncached"))
            gef_print(c(ecx,  1, 0x7fffffff, "        ECX 31- 1: Reserved"))
        elif id == 0x40000008:
            gef_print("    Hypervisor shared virtual memory (SVM) features")
            gef_print(c(eax,  0, 1,          "        EAX     0: SVM (Shared Virtual Memory)"))
            gef_print(c(eax,  1, 0x7fffffff, "        EAX 31- 1: Reserved"))
        elif id == 0x40000009:
            gef_print("    Nested hypervisor feature indentification")
            gef_print(c(eax,  0, 1,          "        EAX     0: Reserved"))
            gef_print(c(eax,  1, 1,          "        EAX     1: Reserved"))
            gef_print(c(eax,  2, 1,          "        EAX     2: Synthetic Timer"))
            gef_print(c(eax,  3, 1,          "        EAX     3: Reserved"))
            gef_print(c(eax,  4, 1,          "        EAX     4: Interrupt control registers"))
            gef_print(c(eax,  5, 1,          "        EAX     5: Hypercall MSRs"))
            gef_print(c(eax,  6, 1,          "        EAX     6: VP index MSR"))
            gef_print(c(eax,  7, 0x1f,       "        EAX 11- 7: Reserved"))
            gef_print(c(eax, 12, 1,          "        EAX    12: Reenlightenment controls"))
            gef_print(c(eax, 13, 0x7ffff,    "        EAX 31-13: Reserved"))
            gef_print(c(edx,  0, 0xf,        "        EDX  3- 0: Reserved"))
            gef_print(c(eax,  4, 1,          "        EDX     4: Hypercall input params via XMM registers"))
            gef_print(c(edx,  5, 0x3ff,      "        EDX 14- 5: Reserved"))
            gef_print(c(edx, 15, 1,          "        EDX    15: Hypercall output via XMM registers"))
            gef_print(c(edx, 16, 1,          "        EDX    16: Reserved"))
            gef_print(c(edx, 17, 1,          "        EDX    17: Soft interrupt polling mode available"))
            gef_print(c(edx, 18, 0x3fff,     "        EDX 31-18: Reserved"))
        elif id == 0x4000000a:
            gef_print("    Nested hypervisor feature indentification")
            gef_print(c(eax,  0, 0x1ffff,    "        EAX 16- 0: Reserved"))
            gef_print(c(eax, 17, 1,          "        EAX    17: Direct virtual flush hypercalls"))
            gef_print(c(eax, 18, 1,          "        EAX    18: Flush GPA space and list hypercalls"))
            gef_print(c(eax, 19, 1,          "        EAX    19: Enlightened MSR bitmaps"))
            gef_print(c(eax, 20, 1,          "        EAX    20: Combining virtualization exceptions in page fault exception class"))
            gef_print(c(eax, 21, 0x7ff,      "        EAX 31-21: Reserved"))
        elif id == 0x40000010:
            gef_print("    Hypervisor timing information")
            gef_print("    eax: (Virtual) TSC frequency in kHz")
            gef_print("    ebx: (Virtual) Bus (local apic timer) frequency in kHz")
            gef_print("    ecx,edx: Reserved")
        elif id == 0x80000000:
            gef_print("    eax: Maximum Input Value for Extended Function CPUID Information")
            gef_print("    ebx,ecx,edx: Reserved")
        elif id == 0x80000001:
            gef_print("    eax,ebx: Extended Processor Signature")
            gef_print("    edx,ecx: Extended Processor Feature")
            gef_print(c(edx,  0, 1,          "        EDX     0: FPU (Floating Point Unit on-chip)"))
            gef_print(c(edx,  1, 1,          "        EDX     1: VME (Virtual 8086 Mode Enhancements)"))
            gef_print(c(edx,  2, 1,          "        EDX     2: DE (Debugging Extensions)"))
            gef_print(c(edx,  3, 1,          "        EDX     3: PSE (Page Size Extension)"))
            gef_print(c(edx,  4, 1,          "        EDX     4: TSC (Time Stamp Counter)"))
            gef_print(c(edx,  5, 1,          "        EDX     5: MSR (Model Specific Registers RDMSR and WRMSR instructions)"))
            gef_print(c(edx,  6, 1,          "        EDX     6: PAE (Physical Address Extension)"))
            gef_print(c(edx,  7, 1,          "        EDX     7: MCE (Machine Check Exception)"))
            gef_print(c(edx,  8, 1,          "        EDX     8: CX8 (CMPXCHG8B instruction)"))
            gef_print(c(edx,  9, 1,          "        EDX     9: APIC (APIC on-chip)"))
            gef_print(c(edx, 10, 1,          "        EDX    10: Reserved"))
            gef_print(c(edx, 11, 1,          "        EDX    11: (Intel) SEP (SYSENTER and SYSEXIT instructions)"))
            gef_print(c(edx, 11, 1,          "        EDX    11: (AMD) SYSCALL (SYSCALL and SYSRET instructions)"))
            gef_print(c(edx, 12, 1,          "        EDX    12: MTRR (Memory Type Range Registers)"))
            gef_print(c(edx, 13, 1,          "        EDX    13: PGE (Page Global Bit)"))
            gef_print(c(edx, 14, 1,          "        EDX    14: MCA (Machine Check Architecture)"))
            gef_print(c(edx, 15, 1,          "        EDX    15: CMOV (Conditional MOVe instructions)"))
            gef_print(c(edx, 16, 1,          "        EDX    16: PAT (Page Attribute Table)"))
            gef_print(c(edx, 17, 1,          "        EDX    17: PSE-36 (36-Bit Page Size Extension)"))
            gef_print(c(edx, 18, 1,          "        EDX    18: Reserved"))
            gef_print(c(edx, 19, 1,          "        EDX    19: MP (MultiProcessing capable)"))
            gef_print(c(edx, 20, 1,          "        EDX    20: (Intel) XD (No-execute page protection)"))
            gef_print(c(edx, 20, 1,          "        EDX    20: (AMD) NX (No-execute page protection)"))
            gef_print(c(edx, 21, 1,          "        EDX    21: Reserved"))
            gef_print(c(edx, 22, 1,          "        EDX    22: MMX+ (MMX instruction extensions)"))
            gef_print(c(edx, 23, 1,          "        EDX    23: MMX (Intel MMX technology)"))
            gef_print(c(edx, 24, 1,          "        EDX    24: FXSR (FXSAVE and FXRSTOR instructions)"))
            gef_print(c(edx, 25, 1,          "        EDX    25: FFXSR (Fast FXSAVE/FXRSTOR)"))
            gef_print(c(edx, 26, 1,          "        EDX    26: P1GB (1GB Page support)"))
            gef_print(c(edx, 27, 1,          "        EDX    27: RDTSCP (RDTSCP instruction)"))
            gef_print(c(edx, 28, 1,          "        EDX    28: Reserved"))
            gef_print(c(edx, 29, 1,          "        EDX    29: LM (Long Mode (EM64T))"))
            gef_print(c(edx, 30, 1,          "        EDX    30: 3DNow!+ (3DNow! extended)"))
            gef_print(c(edx, 31, 1,          "        EDX    31: 3DNow! (3DNow! instructions)"))
            gef_print(c(ecx,  0, 1,          "        ECX     0: LAHF (LAHF/SAHF supported in 64-bit mode)"))
            gef_print(c(ecx,  1, 1,          "        ECX     1: CMPL (Core Multi-Processing Legacy mode)"))
            gef_print(c(ecx,  2, 1,          "        ECX     2: SVM (Secure Virtual Machine)"))
            gef_print(c(ecx,  3, 1,          "        ECX     3: EAS (Extended APIC Space)"))
            gef_print(c(ecx,  4, 1,          "        ECX     4: AMC8 (AltMovCr8; LOCK MOV CR0 means MOV CR8)"))
            gef_print(c(ecx,  5, 1,          "        ECX     5: ABM (Advanced Bit Manipulation; LZCNT instruction)"))
            gef_print(c(ecx,  6, 1,          "        ECX     6: SSE4A (SSE4A instructions)"))
            gef_print(c(ecx,  7, 1,          "        ECX     7: MASSE (Mis-Aligned SSE Support)"))
            gef_print(c(ecx,  8, 1,          "        ECX     8: PREFETCH (3DNow! PREFETCH/PREFETCHHW instructions)"))
            gef_print(c(ecx,  9, 1,          "        ECX     9: OSVW (OS-Visible Workaround)"))
            gef_print(c(ecx, 10, 1,          "        ECX    10: IBS (Instruction-Based Sampling)"))
            gef_print(c(ecx, 11, 1,          "        ECX    11: XOP (eXtended OPeration)"))
            gef_print(c(ecx, 12, 1,          "        ECX    12: SKINIT (SKINIT/STGI instructions)"))
            gef_print(c(ecx, 13, 1,          "        ECX    13: WDT (WatchDog Timer)"))
            gef_print(c(ecx, 14, 1,          "        ECX    14: Reserved"))
            gef_print(c(ecx, 15, 1,          "        ECX    15: LWP (Light Weight Profiling)"))
            gef_print(c(ecx, 16, 1,          "        ECX    16: FMA4 (4-operands FMA instructions)"))
            gef_print(c(ecx, 17, 1,          "        ECX    17: TCE (Translation Cache Extension)"))
            gef_print(c(ecx, 18, 1,          "        ECX    18: Reserved"))
            gef_print(c(ecx, 19, 1,          "        ECX    19: MSR (Node ID MSR"))
            gef_print(c(ecx, 20, 1,          "        ECX    20: Reserved"))
            gef_print(c(ecx, 21, 1,          "        ECX    21: TBM (Trailing Bit Manipulation instructions)"))
            gef_print(c(ecx, 22, 1,          "        ECX    22: TOPOEXT (TOPology EXTensions)"))
            gef_print(c(ecx, 23, 1,          "        ECX    23: PERFCTR_CORE (CORE PERFormance CounTeR extensions)"))
            gef_print(c(ecx, 24, 1,          "        ECX    24: PERFCTR_NB (NB PERFormance CounTeR extensions"))
            gef_print(c(ecx, 25, 1,          "        ECX    25: Streaming performance monitor architecture"))
            gef_print(c(ecx, 26, 1,          "        ECX    26: DBX (Data breakpoint eXtensions)"))
            gef_print(c(ecx, 27, 1,          "        ECX    27: PERFTSC (PERFormance Time Stamp Counter)"))
            gef_print(c(ecx, 28, 1,          "        ECX    28: PERFCTR_L2 (L2 PERFormance CounTeR extensions)"))
            gef_print(c(ecx, 29, 1,          "        ECX    29: MONITORX/MWAITX instructions"))
            gef_print(c(ecx, 30, 1,          "        ECX    30: Address mask extension for instruction breakpoint"))
            gef_print(c(ecx, 31, 1,          "        ECX    31: Reserved"))
        elif id in [0x80000002, 0x80000003, 0x80000004]:
            vid = (p32(eax) + p32(ebx) + p32(ecx) + p32(edx)).decode("utf-8")
            gef_print("    eax+ebx+ecx+edx: Processor Brand String (={:s})".format(repr(vid)))
        elif id == 0x80000005:
            gef_print("    L1 Cache Information")
            gef_print("    eax: 4/2 MB L1 TLB configuration descriptor")
            gef_print("    ebx: 4 KB L1 TLB configuration descriptor")
            gef_print("    ecx: data L1 cache configuration descriptor")
            gef_print("    edx: code L1 cache configuration descriptor")
        elif id == 0x80000006:
            gef_print("    L2/L3 Cache Information")
            gef_print("    eax: 4/2 MB L2 TLB configuration descriptor")
            gef_print("    ebx: 4 KB L2 TLB configuration descriptor")
            gef_print("    ecx: unified L2 cache configuration descriptor")
            gef_print("    edx: unified L3 cache configuration descriptor")
        elif id == 0x80000007:
            gef_print("    ebx: RAS Capabilities")
            gef_print(c(ebx,  0, 1,          "        EBX     0: MCA overflow recovery"))
            gef_print(c(ebx,  1, 1,          "        EBX     1: Software uncorrectable error containment and recovery"))
            gef_print(c(ebx,  2, 1,          "        EBX     2: HWA (HardWare Assert)"))
            gef_print(c(ebx,  3, 1,          "        EBX     3: Scalable MCA"))
            gef_print(c(ebx,  4, 1,          "        EBX     4: PFEH (Platform First Error Handling)"))
            gef_print(c(ebx,  5, 0x7ffffff,  "        EBX 31- 5: Reserved"))
            gef_print("    edx: Advanced Power Management information")
            gef_print(c(edx,  0, 1,          "        EDX     0: TS (Temperature Sensor)"))
            gef_print(c(edx,  1, 1,          "        EDX     1: FID (Frequency ID control)"))
            gef_print(c(edx,  2, 1,          "        EDX     2: VID (Voltage ID control)"))
            gef_print(c(edx,  3, 1,          "        EDX     3: TTP (Thermal Trip)"))
            gef_print(c(edx,  4, 1,          "        EDX     4: TM (Thermal Monitoring)"))
            gef_print(c(edx,  5, 1,          "        EDX     5: STC (Software Thermal Control)"))
            gef_print(c(edx,  6, 1,          "        EDX     6: MUL (100MHz Multiplier steps)"))
            gef_print(c(edx,  7, 1,          "        EDX     7: HWPS (HardWare P-State control)"))
            gef_print(c(edx,  8, 1,          "        EDX     8: ITSC (Invariant TSC)"))
            gef_print(c(edx,  9, 1,          "        EDX     9: Core performance boost"))
            gef_print(c(edx, 10, 1,          "        EDX    10: Read-only effective frequency interface"))
            gef_print(c(edx, 11, 1,          "        EDX    11: Processor feedback interface"))
            gef_print(c(edx, 12, 1,          "        EDX    12: Core power reporting"))
            gef_print(c(edx, 13, 1,          "        EDX    13: Connected standby"))
            gef_print(c(edx, 14, 1,          "        EDX    14: RAPL (Running Average Power Limit)"))
            gef_print(c(edx, 15, 0x1ffff,    "        EAX 31-15: Reserved"))
        elif id == 0x80000008:
            gef_print("    eax: Extended Address Length Information")
            gef_print(c(eax,  0, 0xff,       "        EAX  7- 0: Physical address length"))
            gef_print(c(eax,  8, 0xff,       "        EAX 15- 8: Linear address length"))
            gef_print(c(eax, 16, 0xff,       "        EAX 23-16: Guest physical address length"))
            gef_print(c(eax, 24, 0xff,       "        EAX 31-24: Reserved"))
            gef_print("    ebx: Extended Feature Extensions ID")
            gef_print(c(ebx,  0, 1,          "        EBX     0: CLZERO (CLZERO instruction)"))
            gef_print(c(ebx,  1, 1,          "        EBX     1: IRPerf (Instructions Retired count support)"))
            gef_print(c(ebx,  2, 1,          "        EBX     2: XSAVE always saves/restores error pointers"))
            gef_print(c(ebx,  3, 1,          "        EBX     3: INVLPGB and TLBSYNC instruction"))
            gef_print(c(ebx,  4, 1,          "        EBX     4: RDPRU (RDPRU instruction)"))
            gef_print(c(ebx,  5, 1,          "        EBX     5: Reserved"))
            gef_print(c(ebx,  6, 1,          "        EBX     6: MBE (Memory Bandwidth Enforcement)"))
            gef_print(c(ebx,  7, 1,          "        EBX     7: Reserved"))
            gef_print(c(ebx,  8, 1,          "        EBX     8: MCOMMIT (MCOMMIT instruction)"))
            gef_print(c(ebx,  9, 1,          "        EBX     9: WBNOINVD (Write Back and do NOt INValiDate cache)"))
            gef_print(c(ebx, 10, 1,          "        EBX    10: LBR extensions"))
            gef_print(c(ebx, 11, 1,          "        EBX    11: Reserved"))
            gef_print(c(ebx, 12, 1,          "        EBX    12: IBPB (Indirect Branch Prediction Barrier)"))
            gef_print(c(ebx, 13, 1,          "        EBX    13: WBINVD (Write Back and INValiDate cache)"))
            gef_print(c(ebx, 14, 1,          "        EBX    14: IBRS (Indirect Branch Restricted Speculation)"))
            gef_print(c(ebx, 15, 1,          "        EBX    15: STIBP (Single Thread Indirect Branch Predictor)"))
            gef_print(c(ebx, 16, 1,          "        EBX    16: Reserved"))
            gef_print(c(ebx, 17, 1,          "        EBX    17: STIBP always on"))
            gef_print(c(ebx, 18, 1,          "        EBX    18: IBRS preferred over software solution"))
            gef_print(c(ebx, 19, 1,          "        EBX    19: IBRS provides Same Mode Protection"))
            gef_print(c(ebx, 20, 1,          "        EBX    20: EFER.LMLSE is unsupported"))
            gef_print(c(ebx, 21, 1,          "        EBX    21: INVLPGB for guest nested translations"))
            gef_print(c(ebx, 22, 1,          "        EBX    22: Reserved"))
            gef_print(c(ebx, 23, 1,          "        EBX    23: PPIN (Protected Processor Inventory Number)"))
            gef_print(c(ebx, 24, 1,          "        EBX    24: SSBD (Speculative Store Bypass Disable)"))
            gef_print(c(ebx, 25, 1,          "        EBX    25: VIRT_SPEC_CTL"))
            gef_print(c(ebx, 26, 1,          "        EBX    26: SSBD no longer needed"))
            gef_print(c(ebx, 27, 1,          "        EBX    27: CPPC (Collaborative Processor Performance Control)"))
            gef_print(c(ebx, 28, 1,          "        EBX    28: PSFD (Predictive Store Forward Disable)"))
            gef_print(c(ebx, 29, 1,          "        EBX    29: Reserved"))
            gef_print(c(ebx, 30, 1,          "        EBX    30: Reserved"))
            gef_print(c(ebx, 31, 1,          "        EBX    31: Reserved"))
            gef_print("    ecx: Extended Core Information")
            gef_print(c(ecx,  0, 0xff,       "        ECX  7- 0: Number of cores per (number of dies-1)"))
            gef_print(c(ecx,  8, 0xf,        "        ECX 11- 8: Reserved"))
            gef_print(c(ecx, 12, 0xf,        "        ECX 15-12: Number of LSBs in APIC ID that indicate core ID"))
            gef_print(c(ecx, 16, 0xffff,     "        ECX 31-16: Reserved"))
        elif id == 0x8000000a:
            gef_print("    SVM Revision and Feature Identification")
            gef_print(c(edx,  0, 1,          "        EDX     0: Nested paging"))
            gef_print(c(edx,  1, 1,          "        EDX     1: LBR virtualization"))
            gef_print(c(edx,  2, 1,          "        EDX     2: SVM lock"))
            gef_print(c(edx,  3, 1,          "        EDX     3: NRIP save"))
            gef_print(c(edx,  4, 1,          "        EDX     4: MSR-based TSC rate control"))
            gef_print(c(edx,  5, 1,          "        EDX     5: VMCB clean bits"))
            gef_print(c(edx,  6, 1,          "        EDX     6: Flush by ASID"))
            gef_print(c(edx,  7, 1,          "        EDX     7: Decode assists"))
            gef_print(c(edx,  8, 1,          "        EDX     8: Reserved"))
            gef_print(c(edx,  9, 1,          "        EDX     9: Reserved"))
            gef_print(c(edx, 10, 1,          "        EDX    10: Pause intercept filter"))
            gef_print(c(edx, 11, 1,          "        EDX    11: Encrypted micro-code patch"))
            gef_print(c(edx, 12, 1,          "        EDX    12: PAUSE filter threshold"))
            gef_print(c(edx, 13, 1,          "        EDX    13: AMD virtual interrupt controller"))
            gef_print(c(edx, 14, 1,          "        EDX    14: Reserved"))
            gef_print(c(edx, 15, 1,          "        EDX    15: Virtualized VMLOAD/VMSAVE"))
            gef_print(c(edx, 16, 1,          "        EDX    16: Virtualized GIF"))
            gef_print(c(edx, 17, 1,          "        EDX    17: GMET (Guest Mode Execution Trap"))
            gef_print(c(edx, 18, 1,          "        EDX    18: Reserved"))
            gef_print(c(edx, 19, 1,          "        EDX    19: SVM supervisor shadow stack restrictions"))
            gef_print(c(edx, 20, 1,          "        EDX    20: SPEC_CTRL virtualization"))
            gef_print(c(edx, 21, 1,          "        EDX    21: Reserved"))
            gef_print(c(edx, 22, 1,          "        EDX    22: Reserved"))
            gef_print(c(edx, 23, 1,          "        EDX    23: Host MCE override"))
            gef_print(c(edx, 24, 1,          "        EDX    24: INVLPGB/TLBSYNC hypervisor enable"))
            gef_print(c(edx, 25, 0x7f,       "        EDX 31-25: Reserved"))
        elif id == 0x80000019:
            gef_print("    TLB Configuration Descriptors")
        elif id == 0x8000001a:
            gef_print("    Performance Optimization Identifiers")
            gef_print(c(eax,  0, 1,          "        EAX     0: FP128 (128-bit SSE full-width pipelines)"))
            gef_print(c(eax,  1, 1,          "        EAX     1: MOVU (Efficient MOVU SSE instructions)"))
            gef_print(c(eax,  2, 1,          "        EAX     2: FP256 (256-bit AVX full-width pipelines)"))
            gef_print(c(eax,  3, 0x1fffffff, "        EAX 31- 3: Reserved"))
        elif id == 0x8000001b:
            gef_print("    Instruction Based Sampling Identifiers")
            gef_print(c(eax,  0, 1,          "        EAX     0: IBSFFV (IBS Feature Flags Valid)"))
            gef_print(c(eax,  1, 1,          "        EAX     1: FetchSam (IBS Fetch Sampling)"))
            gef_print(c(eax,  2, 1,          "        EAX     2: OpSam (IBS Execution Sampling)"))
            gef_print(c(eax,  3, 1,          "        EAX     3: RdWrOpCnt (Read/write of Op Counter)"))
            gef_print(c(eax,  4, 1,          "        EAX     4: OpCnt (Op Counting mode)"))
            gef_print(c(eax,  5, 1,          "        EAX     5: BrnTrgt (Branch Target address reporting)"))
            gef_print(c(eax,  6, 1,          "        EAX     6: OpCntExt (IBS op cur/max count extended by 7 bits)"))
            gef_print(c(eax,  7, 1,          "        EAX     7: RipInvalidChk (IBS RIP invalid indication)"))
            gef_print(c(eax,  8, 1,          "        EAX     8: OpBrnFuse (IBS fused Branch micro-op indication)"))
            gef_print(c(eax,  9, 1,          "        EAX     9: IbsFetchCtlExtd (IBS Fetch Control Extended MSR)"))
            gef_print(c(eax, 10, 1,          "        EAX    10: IbsOpData4 (IBS Op Data 4 MSR)"))
            gef_print(c(eax, 11, 0x1fffff,   "        EAX 31-11: Reserved"))
        elif id == 0x8fffffff:
            vid = (p32(eax) + p32(ebx) + p32(ecx) + p32(edx)).decode("utf-8")
            gef_print("    eax+ebx+ecx+edx: Easter egg (={:s})".format(repr(vid)))
        elif id == 0xc0000000:
            gef_print("    eax: Maximum Input Value for Extended Function CPUID Information")
            gef_print("    ebx,ecx,edx: Reserved")
        elif id == 0xc0000001:
            gef_print("    Centaur features")
            gef_print(c(edx,  0, 1,          "        EDX     0: AIS (Alternate Instruction Set available)"))
            gef_print(c(edx,  1, 1,          "        EDX     1: AIS_EN (Alternate Instruction Set ENabled)"))
            gef_print(c(edx,  2, 1,          "        EDX     2: RNG (Random Number Generator available)"))
            gef_print(c(edx,  3, 1,          "        EDX     3: RNG_EN (Random Number Generator ENabled)"))
            gef_print(c(edx,  4, 1,          "        EDX     4: LH (LongHaul MSR 0000_110Ah)"))
            gef_print(c(edx,  5, 1,          "        EDX     5: FEMMS"))
            gef_print(c(edx,  6, 1,          "        EDX     6: ACE (Advanced Cryptography Engine available)"))
            gef_print(c(edx,  7, 1,          "        EDX     7: ACE_EN (Advanced Cryptography Engine Enabled)"))
            gef_print(c(edx,  8, 1,          "        EDX     8: ACE2 (Montgomery Multiplier and Hash Engine available)"))
            gef_print(c(edx,  9, 1,          "        EDX     9: ACE2_EN (Montgomery Multiplier and Hash Engine Enabled)"))
            gef_print(c(edx, 10, 1,          "        EDX    10: PHE (Padlock Hash Engine available)"))
            gef_print(c(edx, 11, 1,          "        EDX    11: PHE_EN (Padlock Hash Engine ENabled)"))
            gef_print(c(edx, 12, 1,          "        EDX    12: PMM (Padlock Montgomery Multiplier available)"))
            gef_print(c(edx, 13, 1,          "        EDX    13: PMM_EN (Padlock Montgomery Multiplier ENabled)"))
            gef_print(c(edx, 14, 0x3ffff,    "        EAX 31-14: Reserved"))
        return

    @only_if_gdb_running
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            argv.remove("-h")
            self.usage()
            return

        # Basic Information
        eax, _, _, _ = self.execute_cpuid(0)
        valid_max_cpuid = min(eax, 0x20)

        for id in range(valid_max_cpuid + 1):
            if id == 4:
                for subid in range(3):
                    eax, ebx, ecx, edx = self.execute_cpuid(id, subid)
                    self.show_result(id, subid, eax, ebx, ecx, edx)
            elif id == 7:
                eax, _, _, _ = self.execute_cpuid(id, 0)
                for subid in range(eax + 1):
                    eax, ebx, ecx, edx = self.execute_cpuid(id, subid)
                    self.show_result(id, subid, eax, ebx, ecx, edx)
            elif id == 13:
                for subid in range(63):
                    eax, ebx, ecx, edx = self.execute_cpuid(id, subid)
                    self.show_result(id, subid, eax, ebx, ecx, edx)
            elif id in [16, 18, 19, 20, 23, 24, 26, 31]:
                eax, ebx, ecx, edx = self.execute_cpuid(id, 0)
                self.show_result(id, 0, eax, ebx, ecx, edx)
            else:
                eax, ebx, ecx, edx = self.execute_cpuid(id)
                self.show_result(id, None, eax, ebx, ecx, edx)

        # Hypervisor Information
        valid_max_cpuid, _, _, _ = self.execute_cpuid(0x40000000)
        for id in range(0x40000000, valid_max_cpuid + 1):
            eax, ebx, ecx, edx = self.execute_cpuid(id)
            self.show_result(id, None, eax, ebx, ecx, edx)

        # Extended Information
        valid_max_cpuid, _, _, _ = self.execute_cpuid(0x80000000)
        for id in range(0x80000000, valid_max_cpuid + 1):
            eax, ebx, ecx, edx = self.execute_cpuid(id)
            self.show_result(id, None, eax, ebx, ecx, edx)
        for id in [0x8fffffff]:
            eax, ebx, ecx, edx = self.execute_cpuid(id)
            self.show_result(id, None, eax, ebx, ecx, edx)

        # Transmeta Specific Information
        valid_max_cpuid, _, _, _ = self.execute_cpuid(0x80860000)
        for id in range(0x80860000, valid_max_cpuid + 1):
            eax, ebx, ecx, edx = self.execute_cpuid(id)
            self.show_result(id, None, eax, ebx, ecx, edx)

        # Centaur(VIA) Specific Information
        valid_max_cpuid, _, _, _ = self.execute_cpuid(0xc0000000)
        for id in range(0xc0000000, valid_max_cpuid + 1):
            eax, ebx, ecx, edx = self.execute_cpuid(id)
            self.show_result(id, None, eax, ebx, ecx, edx)
        return


@register_command
class MsrCommand(GenericCommand):
    """Get MSR via kernel."""
    _cmdline_ = "msr"
    _syntax_ = "{:s} [-h] [-l] MSR_VALUE|MSR_NAME".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} 0xc0000080 # rcx value\n".format(_cmdline_)
    _example_ += "{:s} MSR_EFER # another valid format\n".format(_cmdline_)
    _example_ += "{:s} -l # list known MSR const values\n".format(_cmdline_)
    _example_ += "{:s} -l MSR_EFER MSR_GS_BASE MSR_FS_BASE # show specified MSR const value\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "DISABLE `-enbale-kvm` option for qemu-system; This command will be aborted if the option is set"
    _category_ = "Show/Modify Register"

    msr_table = [
        ["MSR_EFER",                         0xc0000080, "Extended feature register"],
        ["MSR_STAR",                         0xc0000081, "Legacy mode SYSCALL target"],
        ["MSR_LSTAR",                        0xc0000082, "Long mode SYSCALL target"],
        ["MSR_CSTAR",                        0xc0000083, "Compat mode SYSCALL target"],
        ["MSR_SYSCALL_MASK",                 0xc0000084, "EFLAGS mask for syscall"],
        ["MSR_FS_BASE",                      0xc0000100, "64bit FS base"],
        ["MSR_GS_BASE",                      0xc0000101, "64bit GS base"],
        ["MSR_KERNEL_GS_BASE",               0xc0000102, "SwapGS GS shadow"],
        ["MSR_TSC_AUX",                      0xc0000103, "Auxiliary TSC"],
        ["MSR_TEST_CTRL",                    0x00000033, ""],
        ["MSR_IA32_SPEC_CTRL",               0x00000048, "Speculation Control"],
        ["MSR_IA32_PRED_CMD",                0x00000049, "Prediction Command"],
        ["MSR_PPIN_CTL",                     0x0000004e, ""],
        ["MSR_PPIN",                         0x0000004f, ""],
        ["MSR_IA32_PERFCTR",                 0x000000c1, ""],
        ["MSR_IA32_PERFCTR",                 0x000000c2, ""],
        ["MSR_FSB_FREQ",                     0x000000cd, ""],
        ["MSR_PLATFORM_INFO",                0x000000ce, ""],
        ["MSR_IA32_CORE_CAPS",               0x000000cf, ""],
        ["MSR_IA32_UMWAIT_CONTROL",          0x000000e1, ""],
        ["MSR_PKG_CST_CONFIG_CONTROL",       0x000000e2, ""],
        ["MSR_MTRRcap",                      0x000000fe, ""],
        ["MSR_IA32_ARCH_CAPABILITIES",       0x0000010a, ""],
        ["MSR_IA32_FLUSH_CMD",               0x0000010b, ""],
        ["MSR_IA32_BBL_CR_CTL",              0x00000119, ""],
        ["MSR_IA32_BBL_CR_CTL3",             0x0000011e, ""],
        ["MSR_IA32_TSX_CTRL",                0x00000122, ""],
        ["MSR_IA32_MCU_OPT_CTRL",            0x00000123, ""],
        ["MSR_IA32_SYSENTER_CS",             0x00000174, ""],
        ["MSR_IA32_SYSENTER_ESP",            0x00000175, ""],
        ["MSR_IA32_SYSENTER_EIP",            0x00000176, ""],
        ["MSR_IA32_MCG_CAP",                 0x00000179, ""],
        ["MSR_IA32_MCG_STATUS",              0x0000017a, ""],
        ["MSR_IA32_MCG_CTL",                 0x0000017b, ""],
        ["MSR_IA32_MCG_EXT_CTL",             0x000004d0, ""],
        ["MSR_OFFCORE_RSP_0",                0x000001a6, ""],
        ["MSR_OFFCORE_RSP_1",                0x000001a7, ""],
        ["MSR_TURBO_RATIO_LIMIT",            0x000001ad, ""],
        ["MSR_TURBO_RATIO_LIMIT1",           0x000001ae, ""],
        ["MSR_TURBO_RATIO_LIMIT2",           0x000001af, ""],
        ["MSR_LBR_SELECT",                   0x000001c8, ""],
        ["MSR_LBR_TOS",                      0x000001c9, ""],
        ["MSR_IA32_POWER_CTL",               0x000001fc, ""],
        ["MSR_LBR_NHM_FROM",                 0x00000680, ""],
        ["MSR_LBR_NHM_TO",                   0x000006c0, ""],
        ["MSR_LBR_CORE_FROM",                0x00000040, ""],
        ["MSR_LBR_CORE_TO",                  0x00000060, ""],
        ["MSR_LBR_INFO_0",                   0x00000dc0, ""],
        ["MSR_LBR_INFO_1",                   0x00000dc1, ""],
        ["MSR_LBR_INFO_2",                   0x00000dc2, ""],
        ["MSR_LBR_INFO_3",                   0x00000dc3, ""],
        ["MSR_LBR_INFO_4",                   0x00000dc4, ""],
        ["MSR_LBR_INFO_5",                   0x00000dc5, ""],
        ["MSR_LBR_INFO_6",                   0x00000dc6, ""],
        ["MSR_LBR_INFO_7",                   0x00000dc7, ""],
        ["MSR_LBR_INFO_8",                   0x00000dc8, ""],
        ["MSR_LBR_INFO_9",                   0x00000dc9, ""],
        ["MSR_LBR_INFO_10",                  0x00000dca, ""],
        ["MSR_LBR_INFO_11",                  0x00000dcb, ""],
        ["MSR_LBR_INFO_12",                  0x00000dcc, ""],
        ["MSR_LBR_INFO_13",                  0x00000dcd, ""],
        ["MSR_LBR_INFO_14",                  0x00000dce, ""],
        ["MSR_LBR_INFO_15",                  0x00000dcf, ""],
        ["MSR_LBR_INFO_16",                  0x00000dd0, ""],
        ["MSR_LBR_INFO_17",                  0x00000dd1, ""],
        ["MSR_LBR_INFO_18",                  0x00000dd2, ""],
        ["MSR_LBR_INFO_19",                  0x00000dd3, ""],
        ["MSR_LBR_INFO_20",                  0x00000dd4, ""],
        ["MSR_LBR_INFO_21",                  0x00000dd5, ""],
        ["MSR_LBR_INFO_22",                  0x00000dd6, ""],
        ["MSR_LBR_INFO_23",                  0x00000dd7, ""],
        ["MSR_LBR_INFO_24",                  0x00000dd8, ""],
        ["MSR_LBR_INFO_25",                  0x00000dd9, ""],
        ["MSR_LBR_INFO_26",                  0x00000dda, ""],
        ["MSR_LBR_INFO_27",                  0x00000ddb, ""],
        ["MSR_LBR_INFO_28",                  0x00000ddc, ""],
        ["MSR_LBR_INFO_29",                  0x00000ddd, ""],
        ["MSR_LBR_INFO_30",                  0x00000dde, ""],
        ["MSR_LBR_INFO_31",                  0x00000ddf, ""],
        ["MSR_ARCH_LBR_CTL",                 0x000014ce, ""],
        ["MSR_ARCH_LBR_DEPTH",               0x000014cf, ""],
        ["MSR_ARCH_LBR_FROM_0",              0x00001500, ""],
        ["MSR_ARCH_LBR_TO_0",                0x00001600, ""],
        ["MSR_ARCH_LBR_INFO_0",              0x00001200, ""],
        ["MSR_IA32_PEBS_ENABLE",             0x000003f1, ""],
        ["MSR_PEBS_DATA_CFG",                0x000003f2, ""],
        ["MSR_IA32_DS_AREA",                 0x00000600, ""],
        ["MSR_IA32_PERF_CAPABILITIES",       0x00000345, ""],
        ["MSR_PEBS_LD_LAT_THRESHOLD",        0x000003f6, ""],
        ["MSR_IA32_RTIT_CTL",                0x00000570, ""],
        ["MSR_IA32_RTIT_STATUS",             0x00000571, ""],
        ["MSR_IA32_RTIT_ADDR0_A",            0x00000580, ""],
        ["MSR_IA32_RTIT_ADDR0_B",            0x00000581, ""],
        ["MSR_IA32_RTIT_ADDR1_A",            0x00000582, ""],
        ["MSR_IA32_RTIT_ADDR1_B",            0x00000583, ""],
        ["MSR_IA32_RTIT_ADDR2_A",            0x00000584, ""],
        ["MSR_IA32_RTIT_ADDR2_B",            0x00000585, ""],
        ["MSR_IA32_RTIT_ADDR3_A",            0x00000586, ""],
        ["MSR_IA32_RTIT_ADDR3_B",            0x00000587, ""],
        ["MSR_IA32_RTIT_CR3_MATCH",          0x00000572, ""],
        ["MSR_IA32_RTIT_OUTPUT_BASE",        0x00000560, ""],
        ["MSR_IA32_RTIT_OUTPUT_MASK",        0x00000561, ""],
        ["MSR_MTRRfix64K_00000",             0x00000250, ""],
        ["MSR_MTRRfix16K_80000",             0x00000258, ""],
        ["MSR_MTRRfix16K_A0000",             0x00000259, ""],
        ["MSR_MTRRfix4K_C0000",              0x00000268, ""],
        ["MSR_MTRRfix4K_C8000",              0x00000269, ""],
        ["MSR_MTRRfix4K_D0000",              0x0000026a, ""],
        ["MSR_MTRRfix4K_D8000",              0x0000026b, ""],
        ["MSR_MTRRfix4K_E0000",              0x0000026c, ""],
        ["MSR_MTRRfix4K_E8000",              0x0000026d, ""],
        ["MSR_MTRRfix4K_F0000",              0x0000026e, ""],
        ["MSR_MTRRfix4K_F8000",              0x0000026f, ""],
        ["MSR_MTRRdefType",                  0x000002ff, ""],
        ["MSR_IA32_CR_PAT",                  0x00000277, ""],
        ["MSR_IA32_DEBUGCTLMSR",             0x000001d9, ""],
        ["MSR_IA32_LASTBRANCHFROMIP",        0x000001db, ""],
        ["MSR_IA32_LASTBRANCHTOIP",          0x000001dc, ""],
        ["MSR_IA32_LASTINTFROMIP",           0x000001dd, ""],
        ["MSR_IA32_LASTINTTOIP",             0x000001de, ""],
        ["MSR_PEBS_FRONTEND",                0x000003f7, ""],
        ["MSR_IA32_MC0_CTL",                 0x00000400, ""],
        ["MSR_IA32_MC0_STATUS",              0x00000401, ""],
        ["MSR_IA32_MC0_ADDR",                0x00000402, ""],
        ["MSR_IA32_MC0_MISC",                0x00000403, ""],
        ["MSR_PKG_C3_RESIDENCY",             0x000003f8, ""],
        ["MSR_PKG_C6_RESIDENCY",             0x000003f9, ""],
        ["MSR_ATOM_PKG_C6_RESIDENCY",        0x000003fa, ""],
        ["MSR_PKG_C7_RESIDENCY",             0x000003fa, ""],
        ["MSR_CORE_C3_RESIDENCY",            0x000003fc, ""],
        ["MSR_CORE_C6_RESIDENCY",            0x000003fd, ""],
        ["MSR_CORE_C7_RESIDENCY",            0x000003fe, ""],
        ["MSR_KNL_CORE_C6_RESIDENCY",        0x000003ff, ""],
        ["MSR_PKG_C2_RESIDENCY",             0x0000060d, ""],
        ["MSR_PKG_C8_RESIDENCY",             0x00000630, ""],
        ["MSR_PKG_C9_RESIDENCY",             0x00000631, ""],
        ["MSR_PKG_C10_RESIDENCY",            0x00000632, ""],
        ["MSR_PKGC3_IRTL",                   0x0000060a, ""],
        ["MSR_PKGC6_IRTL",                   0x0000060b, ""],
        ["MSR_PKGC7_IRTL",                   0x0000060c, ""],
        ["MSR_PKGC8_IRTL",                   0x00000633, ""],
        ["MSR_PKGC9_IRTL",                   0x00000634, ""],
        ["MSR_PKGC10_IRTL",                  0x00000635, ""],
        ["MSR_RAPL_POWER_UNIT",              0x00000606, ""],
        ["MSR_PKG_POWER_LIMIT",              0x00000610, ""],
        ["MSR_PKG_ENERGY_STATUS",            0x00000611, ""],
        ["MSR_PKG_PERF_STATUS",              0x00000613, ""],
        ["MSR_PKG_POWER_INFO",               0x00000614, ""],
        ["MSR_DRAM_POWER_LIMIT",             0x00000618, ""],
        ["MSR_DRAM_ENERGY_STATUS",           0x00000619, ""],
        ["MSR_DRAM_PERF_STATUS",             0x0000061b, ""],
        ["MSR_DRAM_POWER_INFO",              0x0000061c, ""],
        ["MSR_PP0_POWER_LIMIT",              0x00000638, ""],
        ["MSR_PP0_ENERGY_STATUS",            0x00000639, ""],
        ["MSR_PP0_POLICY",                   0x0000063a, ""],
        ["MSR_PP0_PERF_STATUS",              0x0000063b, ""],
        ["MSR_PP1_POWER_LIMIT",              0x00000640, ""],
        ["MSR_PP1_ENERGY_STATUS",            0x00000641, ""],
        ["MSR_PP1_POLICY",                   0x00000642, ""],
        ["MSR_AMD_PKG_ENERGY_STATUS",        0xc001029b, ""],
        ["MSR_AMD_RAPL_POWER_UNIT",          0xc0010299, ""],
        ["MSR_CONFIG_TDP_NOMINAL",           0x00000648, ""],
        ["MSR_CONFIG_TDP_LEVEL_1",           0x00000649, ""],
        ["MSR_CONFIG_TDP_LEVEL_2",           0x0000064a, ""],
        ["MSR_CONFIG_TDP_CONTROL",           0x0000064b, ""],
        ["MSR_TURBO_ACTIVATION_RATIO",       0x0000064c, ""],
        ["MSR_PLATFORM_ENERGY_STATUS",       0x0000064d, ""],
        ["MSR_PKG_WEIGHTED_CORE_C0_RES",     0x00000658, ""],
        ["MSR_PKG_ANY_CORE_C0_RES",          0x00000659, ""],
        ["MSR_PKG_ANY_GFXE_C0_RES",          0x0000065a, ""],
        ["MSR_PKG_BOTH_CORE_GFXE_C0_RES",    0x0000065b, ""],
        ["MSR_CORE_C1_RES",                  0x00000660, ""],
        ["MSR_MODULE_C6_RES_MS",             0x00000664, ""],
        ["MSR_CC6_DEMOTION_POLICY_CONFIG",   0x00000668, ""],
        ["MSR_MC6_DEMOTION_POLICY_CONFIG",   0x00000669, ""],
        ["MSR_ATOM_CORE_RATIOS",             0x0000066a, ""],
        ["MSR_ATOM_CORE_VIDS",               0x0000066b, ""],
        ["MSR_ATOM_CORE_TURBO_RATIOS",       0x0000066c, ""],
        ["MSR_ATOM_CORE_TURBO_VIDS",         0x0000066d, ""],
        ["MSR_CORE_PERF_LIMIT_REASONS",      0x00000690, ""],
        ["MSR_GFX_PERF_LIMIT_REASONS",       0x000006b0, ""],
        ["MSR_RING_PERF_LIMIT_REASONS",      0x000006b1, ""],
        ["MSR_PPERF",                        0x0000064e, ""],
        ["MSR_PERF_LIMIT_REASONS",           0x0000064f, ""],
        ["MSR_PM_ENABLE",                    0x00000770, ""],
        ["MSR_HWP_CAPABILITIES",             0x00000771, ""],
        ["MSR_HWP_REQUEST_PKG",              0x00000772, ""],
        ["MSR_HWP_INTERRUPT",                0x00000773, ""],
        ["MSR_HWP_REQUEST",                  0x00000774, ""],
        ["MSR_HWP_STATUS",                   0x00000777, ""],
        ["MSR_AMD64_MC0_MASK",               0xc0010044, ""],
        ["MSR_IA32_MC0_CTL2",                0x00000280, ""],
        ["MSR_P6_PERFCTR0",                  0x000000c1, ""],
        ["MSR_P6_PERFCTR1",                  0x000000c2, ""],
        ["MSR_P6_EVNTSEL0",                  0x00000186, ""],
        ["MSR_P6_EVNTSEL1",                  0x00000187, ""],
        ["MSR_KNC_PERFCTR0",                 0x00000020, ""],
        ["MSR_KNC_PERFCTR1",                 0x00000021, ""],
        ["MSR_KNC_EVNTSEL0",                 0x00000028, ""],
        ["MSR_KNC_EVNTSEL1",                 0x00000029, ""],
        ["MSR_IA32_PMC0",                    0x000004c1, ""],
        ["MSR_RELOAD_PMC0",                  0x000014c1, ""],
        ["MSR_RELOAD_FIXED_CTR0",            0x00001309, ""],
        ["MSR_AMD64_PATCH_LEVEL",            0x0000008b, ""],
        ["MSR_AMD64_TSC_RATIO",              0xc0000104, ""],
        ["MSR_AMD64_NB_CFG",                 0xc001001f, ""],
        ["MSR_AMD64_PATCH_LOADER",           0xc0010020, ""],
        ["MSR_AMD_PERF_CTL",                 0xc0010062, ""],
        ["MSR_AMD_PERF_STATUS",              0xc0010063, ""],
        ["MSR_AMD_PSTATE_DEF_BASE",          0xc0010064, ""],
        ["MSR_AMD64_OSVW_ID_LENGTH",         0xc0010140, ""],
        ["MSR_AMD64_OSVW_STATUS",            0xc0010141, ""],
        ["MSR_AMD_PPIN_CTL",                 0xc00102f0, ""],
        ["MSR_AMD_PPIN",                     0xc00102f1, ""],
        ["MSR_AMD64_CPUID_FN_1",             0xc0011004, ""],
        ["MSR_AMD64_LS_CFG",                 0xc0011020, ""],
        ["MSR_AMD64_DC_CFG",                 0xc0011022, ""],
        ["MSR_AMD64_BU_CFG2",                0xc001102a, ""],
        ["MSR_AMD64_IBSFETCHCTL",            0xc0011030, ""],
        ["MSR_AMD64_IBSFETCHLINAD",          0xc0011031, ""],
        ["MSR_AMD64_IBSFETCHPHYSAD",         0xc0011032, ""],
        ["MSR_AMD64_IBSOPCTL",               0xc0011033, ""],
        ["MSR_AMD64_IBSOPRIP",               0xc0011034, ""],
        ["MSR_AMD64_IBSOPDATA",              0xc0011035, ""],
        ["MSR_AMD64_IBSOPDATA2",             0xc0011036, ""],
        ["MSR_AMD64_IBSOPDATA3",             0xc0011037, ""],
        ["MSR_AMD64_IBSDCLINAD",             0xc0011038, ""],
        ["MSR_AMD64_IBSDCPHYSAD",            0xc0011039, ""],
        ["MSR_AMD64_IBSCTL",                 0xc001103a, ""],
        ["MSR_AMD64_IBSBRTARGET",            0xc001103b, ""],
        ["MSR_AMD64_IBSOPDATA4",             0xc001103d, ""],
        ["MSR_AMD64_SEV",                    0xc0010131, ""],
        ["MSR_AMD64_VIRT_SPEC_CTRL",         0xc001011f, ""],
        ["MSR_F17H_IRPERF",                  0xc00000e9, ""],
        ["MSR_F16H_L2I_PERF_CTL",            0xc0010230, ""],
        ["MSR_F16H_L2I_PERF_CTR",            0xc0010231, ""],
        ["MSR_F16H_DR1_ADDR_MASK",           0xc0011019, ""],
        ["MSR_F16H_DR2_ADDR_MASK",           0xc001101a, ""],
        ["MSR_F16H_DR3_ADDR_MASK",           0xc001101b, ""],
        ["MSR_F16H_DR0_ADDR_MASK",           0xc0011027, ""],
        ["MSR_F15H_CU_PWR_ACCUMULATOR",      0xc001007a, ""],
        ["MSR_F15H_CU_MAX_PWR_ACCUMULATOR",  0xc001007b, ""],
        ["MSR_F15H_PERF_CTL0",               0xc0010200, ""],
        ["MSR_F15H_PERF_CTL1",               0xc0010202, ""],
        ["MSR_F15H_PERF_CTL2",               0xc0010204, ""],
        ["MSR_F15H_PERF_CTL3",               0xc0010206, ""],
        ["MSR_F15H_PERF_CTL4",               0xc0010208, ""],
        ["MSR_F15H_PERF_CTL5",               0xc001020a, ""],
        ["MSR_F15H_PERF_CTR0",               0xc0010201, ""],
        ["MSR_F15H_PERF_CTR1",               0xc0010203, ""],
        ["MSR_F15H_PERF_CTR2",               0xc0010205, ""],
        ["MSR_F15H_PERF_CTR3",               0xc0010207, ""],
        ["MSR_F15H_PERF_CTR4",               0xc0010209, ""],
        ["MSR_F15H_PERF_CTR5",               0xc001020b, ""],
        ["MSR_F15H_NB_PERF_CTL",             0xc0010240, ""],
        ["MSR_F15H_NB_PERF_CTR",             0xc0010241, ""],
        ["MSR_F15H_PTSC",                    0xc0010280, ""],
        ["MSR_F15H_IC_CFG",                  0xc0011021, ""],
        ["MSR_F15H_EX_CFG",                  0xc001102c, ""],
        ["MSR_FAM10H_MMIO_CONF_BASE",        0xc0010058, ""],
        ["MSR_FAM10H_NODE_ID",               0xc001100c, ""],
        ["MSR_F10H_DECFG",                   0xc0011029, ""],
        ["MSR_K8_TOP_MEM1",                  0xc001001a, ""],
        ["MSR_K8_TOP_MEM2",                  0xc001001d, ""],
        ["MSR_K8_SYSCFG",                    0xc0010010, ""],
        ["MSR_K8_INT_PENDING_MSG",           0xc0010055, ""],
        ["MSR_K8_TSEG_ADDR",                 0xc0010112, ""],
        ["MSR_K8_TSEG_MASK",                 0xc0010113, ""],
        ["MSR_K7_EVNTSEL0",                  0xc0010000, ""],
        ["MSR_K7_PERFCTR0",                  0xc0010004, ""],
        ["MSR_K7_EVNTSEL1",                  0xc0010001, ""],
        ["MSR_K7_PERFCTR1",                  0xc0010005, ""],
        ["MSR_K7_EVNTSEL2",                  0xc0010002, ""],
        ["MSR_K7_PERFCTR2",                  0xc0010006, ""],
        ["MSR_K7_EVNTSEL3",                  0xc0010003, ""],
        ["MSR_K7_PERFCTR3",                  0xc0010007, ""],
        ["MSR_K7_CLK_CTL",                   0xc001001b, ""],
        ["MSR_K7_HWCR",                      0xc0010015, ""],
        ["MSR_K7_FID_VID_CTL",               0xc0010041, ""],
        ["MSR_K7_FID_VID_STATUS",            0xc0010042, ""],
        ["MSR_K6_WHCR",                      0xc0000082, ""],
        ["MSR_K6_UWCCR",                     0xc0000085, ""],
        ["MSR_K6_EPMR",                      0xc0000086, ""],
        ["MSR_K6_PSOR",                      0xc0000087, ""],
        ["MSR_K6_PFIR",                      0xc0000088, ""],
        ["MSR_IDT_FCR1",                     0x00000107, ""],
        ["MSR_IDT_FCR2",                     0x00000108, ""],
        ["MSR_IDT_FCR3",                     0x00000109, ""],
        ["MSR_IDT_FCR4",                     0x0000010a, ""],
        ["MSR_IDT_MCR0",                     0x00000110, ""],
        ["MSR_IDT_MCR1",                     0x00000111, ""],
        ["MSR_IDT_MCR2",                     0x00000112, ""],
        ["MSR_IDT_MCR3",                     0x00000113, ""],
        ["MSR_IDT_MCR4",                     0x00000114, ""],
        ["MSR_IDT_MCR5",                     0x00000115, ""],
        ["MSR_IDT_MCR6",                     0x00000116, ""],
        ["MSR_IDT_MCR7",                     0x00000117, ""],
        ["MSR_IDT_MCR_CTRL",                 0x00000120, ""],
        ["MSR_VIA_FCR",                      0x00001107, ""],
        ["MSR_VIA_LONGHAUL",                 0x0000110a, ""],
        ["MSR_VIA_RNG",                      0x0000110b, ""],
        ["MSR_VIA_BCR2",                     0x00001147, ""],
        ["MSR_TMTA_LONGRUN_CTRL",            0x80868010, ""],
        ["MSR_TMTA_LONGRUN_FLAGS",           0x80868011, ""],
        ["MSR_TMTA_LRTI_READOUT",            0x80868018, ""],
        ["MSR_TMTA_LRTI_VOLT_MHZ",           0x8086801a, ""],
        ["MSR_IA32_P5_MC_ADDR",              0x00000000, ""],
        ["MSR_IA32_P5_MC_TYPE",              0x00000001, ""],
        ["MSR_IA32_TSC",                     0x00000010, ""],
        ["MSR_IA32_PLATFORM_ID",             0x00000017, ""],
        ["MSR_IA32_EBL_CR_POWERON",          0x0000002a, ""],
        ["MSR_EBC_FREQUENCY_ID",             0x0000002c, ""],
        ["MSR_SMI_COUNT",                    0x00000034, ""],
        ["MSR_IA32_FEAT_CTL",                0x0000003a, ""],
        ["MSR_IA32_TSC_ADJUST",              0x0000003b, ""],
        ["MSR_IA32_BNDCFGS",                 0x00000d90, ""],
        ["MSR_IA32_BNDCFGS_RSVD",            0x00000ffc, ""],
        ["MSR_IA32_XSS",                     0x00000da0, ""],
        ["MSR_IA32_APICBASE",                0x0000001b, ""],
        ["MSR_IA32_TSCDEADLINE",             0x000006e0, ""],
        ["MSR_IA32_UCODE_WRITE",             0x00000079, ""],
        ["MSR_IA32_UCODE_REV",               0x0000008b, ""],
        ["MSR_IA32_SMM_MONITOR_CTL",         0x0000009b, ""],
        ["MSR_IA32_SMBASE",                  0x0000009e, ""],
        ["MSR_IA32_PERF_STATUS",             0x00000198, ""],
        ["MSR_IA32_PERF_CTL",                0x00000199, ""],
        ["MSR_IA32_MPERF",                   0x000000e7, ""],
        ["MSR_IA32_APERF",                   0x000000e8, ""],
        ["MSR_IA32_THERM_CONTROL",           0x0000019a, ""],
        ["MSR_IA32_THERM_INTERRUPT",         0x0000019b, ""],
        ["MSR_IA32_THERM_STATUS",            0x0000019c, ""],
        ["MSR_THERM2_CTL",                   0x0000019d, ""],
        ["MSR_IA32_MISC_ENABLE",             0x000001a0, ""],
        ["MSR_IA32_TEMPERATURE_TARGET",      0x000001a2, ""],
        ["MSR_MISC_FEATURE_CONTROL",         0x000001a4, ""],
        ["MSR_MISC_PWR_MGMT",                0x000001aa, ""],
        ["MSR_IA32_ENERGY_PERF_BIAS",        0x000001b0, ""],
        ["MSR_IA32_PACKAGE_THERM_STATUS",    0x000001b1, ""],
        ["MSR_IA32_PACKAGE_THERM_INTERRUPT", 0x000001b2, ""],
        ["MSR_MISC_FEATURES_ENABLES",        0x00000140, ""],
        ["MSR_IA32_TSC_DEADLINE",            0x000006e0, ""],
        ["MSR_TSX_FORCE_ABORT",              0x0000010f, ""],
        ["MSR_IA32_MCG_EAX",                 0x00000180, ""],
        ["MSR_IA32_MCG_EBX",                 0x00000181, ""],
        ["MSR_IA32_MCG_ECX",                 0x00000182, ""],
        ["MSR_IA32_MCG_EDX",                 0x00000183, ""],
        ["MSR_IA32_MCG_ESI",                 0x00000184, ""],
        ["MSR_IA32_MCG_EDI",                 0x00000185, ""],
        ["MSR_IA32_MCG_EBP",                 0x00000186, ""],
        ["MSR_IA32_MCG_ESP",                 0x00000187, ""],
        ["MSR_IA32_MCG_EFLAGS",              0x00000188, ""],
        ["MSR_IA32_MCG_EIP",                 0x00000189, ""],
        ["MSR_IA32_MCG_RESERVED",            0x0000018a, ""],
        ["MSR_P4_BPU_PERFCTR0",              0x00000300, ""],
        ["MSR_P4_BPU_PERFCTR1",              0x00000301, ""],
        ["MSR_P4_BPU_PERFCTR2",              0x00000302, ""],
        ["MSR_P4_BPU_PERFCTR3",              0x00000303, ""],
        ["MSR_P4_MS_PERFCTR0",               0x00000304, ""],
        ["MSR_P4_MS_PERFCTR1",               0x00000305, ""],
        ["MSR_P4_MS_PERFCTR2",               0x00000306, ""],
        ["MSR_P4_MS_PERFCTR3",               0x00000307, ""],
        ["MSR_P4_FLAME_PERFCTR0",            0x00000308, ""],
        ["MSR_P4_FLAME_PERFCTR1",            0x00000309, ""],
        ["MSR_P4_FLAME_PERFCTR2",            0x0000030a, ""],
        ["MSR_P4_FLAME_PERFCTR3",            0x0000030b, ""],
        ["MSR_P4_IQ_PERFCTR0",               0x0000030c, ""],
        ["MSR_P4_IQ_PERFCTR1",               0x0000030d, ""],
        ["MSR_P4_IQ_PERFCTR2",               0x0000030e, ""],
        ["MSR_P4_IQ_PERFCTR3",               0x0000030f, ""],
        ["MSR_P4_IQ_PERFCTR4",               0x00000310, ""],
        ["MSR_P4_IQ_PERFCTR5",               0x00000311, ""],
        ["MSR_P4_BPU_CCCR0",                 0x00000360, ""],
        ["MSR_P4_BPU_CCCR1",                 0x00000361, ""],
        ["MSR_P4_BPU_CCCR2",                 0x00000362, ""],
        ["MSR_P4_BPU_CCCR3",                 0x00000363, ""],
        ["MSR_P4_MS_CCCR0",                  0x00000364, ""],
        ["MSR_P4_MS_CCCR1",                  0x00000365, ""],
        ["MSR_P4_MS_CCCR2",                  0x00000366, ""],
        ["MSR_P4_MS_CCCR3",                  0x00000367, ""],
        ["MSR_P4_FLAME_CCCR0",               0x00000368, ""],
        ["MSR_P4_FLAME_CCCR1",               0x00000369, ""],
        ["MSR_P4_FLAME_CCCR2",               0x0000036a, ""],
        ["MSR_P4_FLAME_CCCR3",               0x0000036b, ""],
        ["MSR_P4_IQ_CCCR0",                  0x0000036c, ""],
        ["MSR_P4_IQ_CCCR1",                  0x0000036d, ""],
        ["MSR_P4_IQ_CCCR2",                  0x0000036e, ""],
        ["MSR_P4_IQ_CCCR3",                  0x0000036f, ""],
        ["MSR_P4_IQ_CCCR4",                  0x00000370, ""],
        ["MSR_P4_IQ_CCCR5",                  0x00000371, ""],
        ["MSR_P4_ALF_ESCR0",                 0x000003ca, ""],
        ["MSR_P4_ALF_ESCR1",                 0x000003cb, ""],
        ["MSR_P4_BPU_ESCR0",                 0x000003b2, ""],
        ["MSR_P4_BPU_ESCR1",                 0x000003b3, ""],
        ["MSR_P4_BSU_ESCR0",                 0x000003a0, ""],
        ["MSR_P4_BSU_ESCR1",                 0x000003a1, ""],
        ["MSR_P4_CRU_ESCR0",                 0x000003b8, ""],
        ["MSR_P4_CRU_ESCR1",                 0x000003b9, ""],
        ["MSR_P4_CRU_ESCR2",                 0x000003cc, ""],
        ["MSR_P4_CRU_ESCR3",                 0x000003cd, ""],
        ["MSR_P4_CRU_ESCR4",                 0x000003e0, ""],
        ["MSR_P4_CRU_ESCR5",                 0x000003e1, ""],
        ["MSR_P4_DAC_ESCR0",                 0x000003a8, ""],
        ["MSR_P4_DAC_ESCR1",                 0x000003a9, ""],
        ["MSR_P4_FIRM_ESCR0",                0x000003a4, ""],
        ["MSR_P4_FIRM_ESCR1",                0x000003a5, ""],
        ["MSR_P4_FLAME_ESCR0",               0x000003a6, ""],
        ["MSR_P4_FLAME_ESCR1",               0x000003a7, ""],
        ["MSR_P4_FSB_ESCR0",                 0x000003a2, ""],
        ["MSR_P4_FSB_ESCR1",                 0x000003a3, ""],
        ["MSR_P4_IQ_ESCR0",                  0x000003ba, ""],
        ["MSR_P4_IQ_ESCR1",                  0x000003bb, ""],
        ["MSR_P4_IS_ESCR0",                  0x000003b4, ""],
        ["MSR_P4_IS_ESCR1",                  0x000003b5, ""],
        ["MSR_P4_ITLB_ESCR0",                0x000003b6, ""],
        ["MSR_P4_ITLB_ESCR1",                0x000003b7, ""],
        ["MSR_P4_IX_ESCR0",                  0x000003c8, ""],
        ["MSR_P4_IX_ESCR1",                  0x000003c9, ""],
        ["MSR_P4_MOB_ESCR0",                 0x000003aa, ""],
        ["MSR_P4_MOB_ESCR1",                 0x000003ab, ""],
        ["MSR_P4_MS_ESCR0",                  0x000003c0, ""],
        ["MSR_P4_MS_ESCR1",                  0x000003c1, ""],
        ["MSR_P4_PMH_ESCR0",                 0x000003ac, ""],
        ["MSR_P4_PMH_ESCR1",                 0x000003ad, ""],
        ["MSR_P4_RAT_ESCR0",                 0x000003bc, ""],
        ["MSR_P4_RAT_ESCR1",                 0x000003bd, ""],
        ["MSR_P4_SAAT_ESCR0",                0x000003ae, ""],
        ["MSR_P4_SAAT_ESCR1",                0x000003af, ""],
        ["MSR_P4_SSU_ESCR0",                 0x000003be, ""],
        ["MSR_P4_SSU_ESCR1",                 0x000003bf, ""],
        ["MSR_P4_TBPU_ESCR0",                0x000003c2, ""],
        ["MSR_P4_TBPU_ESCR1",                0x000003c3, ""],
        ["MSR_P4_TC_ESCR0",                  0x000003c4, ""],
        ["MSR_P4_TC_ESCR1",                  0x000003c5, ""],
        ["MSR_P4_U2L_ESCR0",                 0x000003b0, ""],
        ["MSR_P4_U2L_ESCR1",                 0x000003b1, ""],
        ["MSR_P4_PEBS_MATRIX_VERT",          0x000003f2, ""],
        ["MSR_CORE_PERF_FIXED_CTR0",         0x00000309, ""],
        ["MSR_CORE_PERF_FIXED_CTR1",         0x0000030a, ""],
        ["MSR_CORE_PERF_FIXED_CTR2",         0x0000030b, ""],
        ["MSR_CORE_PERF_FIXED_CTR_CTRL",     0x0000038d, ""],
        ["MSR_CORE_PERF_GLOBAL_STATUS",      0x0000038e, ""],
        ["MSR_CORE_PERF_GLOBAL_CTRL",        0x0000038f, ""],
        ["MSR_CORE_PERF_GLOBAL_OVF_CTRL",    0x00000390, ""],
        ["MSR_GEODE_BUSCONT_CONF0",          0x00001900, ""],
        ["MSR_IA32_VMX_BASIC",               0x00000480, ""],
        ["MSR_IA32_VMX_PINBASED_CTLS",       0x00000481, ""],
        ["MSR_IA32_VMX_PROCBASED_CTLS",      0x00000482, ""],
        ["MSR_IA32_VMX_EXIT_CTLS",           0x00000483, ""],
        ["MSR_IA32_VMX_ENTRY_CTLS",          0x00000484, ""],
        ["MSR_IA32_VMX_MISC",                0x00000485, ""],
        ["MSR_IA32_VMX_CR0_FIXED0",          0x00000486, ""],
        ["MSR_IA32_VMX_CR0_FIXED1",          0x00000487, ""],
        ["MSR_IA32_VMX_CR4_FIXED0",          0x00000488, ""],
        ["MSR_IA32_VMX_CR4_FIXED1",          0x00000489, ""],
        ["MSR_IA32_VMX_VMCS_ENUM",           0x0000048a, ""],
        ["MSR_IA32_VMX_PROCBASED_CTLS2",     0x0000048b, ""],
        ["MSR_IA32_VMX_EPT_VPID_CAP",        0x0000048c, ""],
        ["MSR_IA32_VMX_TRUE_PINBASED_CTLS",  0x0000048d, ""],
        ["MSR_IA32_VMX_TRUE_PROCBASED_CTLS", 0x0000048e, ""],
        ["MSR_IA32_VMX_TRUE_EXIT_CTLS",      0x0000048f, ""],
        ["MSR_IA32_VMX_TRUE_ENTRY_CTLS",     0x00000490, ""],
        ["MSR_IA32_VMX_VMFUNC",              0x00000491, ""],
        ["MSR_VM_CR",                        0xc0010114, ""],
        ["MSR_VM_IGNNE",                     0xc0010115, ""],
        ["MSR_VM_HSAVE_PA",                  0xc0010117, ""],
    ]

    def lookup_name2val(self, target_name):
        for name, val, desc in self.msr_table:
            if name == target_name:
                return val
        return None

    def lookup_val2name(self, target_val):
        for name, val, desc in self.msr_table:
            if val == target_val:
                return name
        return "Unknown"

    def print_const_table(self, filt):
        gef_print(titlify("MSR const table"))
        fmt = "{:34s}: {:10s} : {:s}"
        legend = ["Name", "Value", "Description"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        for name, val, desc in self.msr_table:
            if filt == []:
                gef_print("{:34s}: {:#010x} : {:s}".format(name, val, desc))
                continue
            for f in filt:
                if f in name:
                    gef_print("{:34s}: {:#010x} : {:s}".format(name, val, desc))
        return

    def bits_split(self, x, bits=64):
        # 0xaaaabbbb -> 0xaaaa_bbbb
        out = ""
        for i in range(bits):
            if x & (1 << i):
                out = "1" + out
            else:
                out = "0" + out
            if i % 4 == 3:
                out = "_" + out
        while out.startswith("_0000"):
            out = out[5:]
        return "0b" + out[1:]

    def get_state(self, code_len):
        d = {}
        d["pc"] = get_register("$pc")
        d["code"] = read_memory(d["pc"], code_len)
        if is_x86_64():
            d["rax"] = get_register("$rax")
            d["rdx"] = get_register("$rdx")
            d["rcx"] = get_register("$rcx")
        else:
            d["eax"] = get_register("$eax")
            d["edx"] = get_register("$edx")
            d["ecx"] = get_register("$ecx")
        return d

    def revert_state(self, d):
        write_memory(d["pc"], d["code"], len(d["code"]))
        gdb.execute("set $pc = {:#x}".format(d["pc"]), to_string=True)
        if is_x86_64():
            gdb.execute("set $rax = {:#x}".format(d["rax"]), to_string=True)
            gdb.execute("set $rdx = {:#x}".format(d["rdx"]), to_string=True)
            gdb.execute("set $rcx = {:#x}".format(d["rcx"]), to_string=True)
        else:
            gdb.execute("set $eax = {:#x}".format(d["eax"]), to_string=True)
            gdb.execute("set $edx = {:#x}".format(d["edx"]), to_string=True)
            gdb.execute("set $ecx = {:#x}".format(d["ecx"]), to_string=True)
        return

    def close_stdout(self):
        self.stdout = 1
        self.stdout_bak = os.dup(self.stdout)
        f = open("/dev/null")
        os.dup2(f.fileno(), self.stdout)
        f.close()
        return

    def revert_stdout(self):
        os.dup2(self.stdout_bak, self.stdout)
        os.close(self.stdout_bak)
        return

    def read_msr_core(self, num):
        code = b"\xeb\xfe\x0f\x32" # inf-loop (to stop another thread); rdmsr
        gef_on_stop_unhook(hook_stop_handler)
        d = self.get_state(len(code))
        write_memory(d["pc"], code, len(code))
        if is_x86_64():
            gdb.execute("set $rcx = {:#x}".format(num), to_string=True)
        else:
            gdb.execute("set $ecx = {:#x}".format(num), to_string=True)
        gdb.execute("set $pc = {:#x}".format(d["pc"] + 2), to_string=True) # skip "\xeb\xfe"
        self.close_stdout()
        gdb.execute("stepi", to_string=True)
        self.revert_stdout()
        eax = get_register("$eax")
        edx = get_register("$edx")
        self.revert_state(d)
        gef_on_stop_hook(hook_stop_handler)
        return ((edx << 32) | eax) & 0xffffffffffffffff

    def read_msr(self, num):
        val = self.read_msr_core(num)
        name = self.lookup_val2name(num)
        gef_print("{:s} ({:#x}): {:#x} (={:s})".format(name, num, val, self.bits_split(val)))
        return

    @only_if_gdb_running
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv or not argv:
            self.usage()
            return

        if "-l" in argv:
            argv.remove("-l")
            self.print_const_table(argv)
            return

        ring = get_register("$cs") & 0b11
        if ring != 0:
            err("Ring 0 is needed")
            return

        # search const table
        num = self.lookup_name2val(argv[0])
        if num is None:
            try:
                num = int(argv[0], 16)
            except Exception:
                self.usage()
                return
        self.read_msr(num)
        return


class PrintBitInfo:
    """Printing various bit informations of the register"""

    def __init__(self, name, register_bit, description, bit_info):
        self.name = name
        self.register_bit = register_bit
        self.description = description
        self.bit_info = bit_info
        return

    def bits_split(self, x):
        # split by 4bits. ex: 0bXXYYYY -> 0b00XX_YYYY
        out = ""
        for i in range(self.register_bit):
            if x & (1 << i):
                out = "1" + out
            else:
                out = "0" + out
            if i % 4 == 3:
                out = "_" + out
        return "0b" + out[1:]

    def print_value(self, regval, split=True):
        regname = Color.colorify(self.name, "red bold")
        if split:
            value_str = Color.colorify("{:#x} (={:s})".format(regval, self.bits_split(regval)), "yellow bold")
            gef_print("{:s} = {:s}".format(regname, value_str))
        else:
            value_str = Color.colorify("{:#x}".format(regval), "yellow bold")
            gef_print("{:s} = {:s}".format(regname, value_str))
        return

    def print_description(self):
        if self.description:
            gef_print(self.description)
        return

    def print_bitinfo(self, regval):
        # search max width for bit range string
        bit_range_strs = []
        for info in self.bit_info:
            bits, sym, sdesc, ldesc = info
            if isinstance(bits, int):
                bit_range_strs.append("") # length = 0
            elif isinstance(bits, list):
                bit_range_str = []
                tmp = []
                for b in sorted(bits, reverse=True):
                    if tmp == [] or tmp[-1] - 1 == b:
                        tmp.append(b) # bits are contiguous
                        continue
                    else:
                        # bits are not contiguous (scattered), create format string
                        if len(tmp) == 1:
                            bit_range_str.append("{:d}".format(tmp[0]))
                        else:
                            bit_range_str.append("{:d}-{:d}".format(tmp[0], tmp[-1]))
                        # then restart
                        tmp = [b]
                # add remain
                if tmp:
                    if len(tmp) == 1:
                        bit_range_str.append("{:d}".format(tmp[0]))
                    else:
                        bit_range_str.append("{:d}-{:d}".format(tmp[0], tmp[-1]))
                # join
                bit_range_strs.append(','.join(bit_range_str))
            else:
                raise
        max_width_bits = max(list(map(len, bit_range_strs)) + [2]) # 2 is default

        # search max width for sym
        max_width_sym = 0
        for info in self.bit_info:
            bits, sym, sdesc, ldesc = info
            if sym:
                max_width_sym = max(max_width_sym, len(sym))

        # search max width for val
        max_width_val = 0
        for info in self.bit_info:
            bits, sym, sdesc, ldesc = info
            if isinstance(bits, int):
                val = (regval & (1 << bits)) >> bits
            elif isinstance(bits, list):
                val = 0
                for j, x in enumerate(bits):
                    val |= (regval & (1 << x)) >> (x - j)
            else:
                raise
            max_width_val = max(max_width_val, len("{:#x}".format(val)))

        # search max width for sdesc
        max_width_sdesc = 0
        for info in self.bit_info:
            bits, sym, sdesc, ldesc = info
            if sdesc:
                max_width_sdesc = max(max_width_sdesc, len(sdesc))

        # print using each width
        for i, info in enumerate(self.bit_info):
            bits, sym, sdesc, ldesc = info
            if isinstance(bits, int):
                b = "{:d}".format(bits)
                val = (regval & (1 << bits)) >> bits
            elif isinstance(bits, list):
                b = bit_range_strs[i]
                val = 0
                for j, x in enumerate(bits):
                    val |= (regval & (1 << x)) >> (x - j)
            else:
                raise

            if val:
                colored_val = Color.colorify(f"{val:>#{max_width_val}x}", "bold")
            else:
                colored_val = f"{val:>#{max_width_val}x}"
            if sym is not None and sdesc is not None:
                gef_print(f"bit{b:>{max_width_bits}s}: {colored_val:s} [{sym:{max_width_sym}s}: {sdesc:{max_width_sdesc}s}]: {ldesc}")
            else:
                gef_print(f"bit{b:>{max_width_bits}s}: {colored_val:s}: {ldesc}")
        return

    def print(self, regval, split=True):
        self.print_value(regval, split)
        self.print_description()
        self.print_bitinfo(regval)
        return


@register_command
class QemuRegistersCommand(GenericCommand):
    """Get regisers via qemu-monitor."""
    _cmdline_ = "qreg"
    _syntax_ = "{:s} [-h] [-v]".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    def qregisters_x86_x64(self):
        res = gdb.execute("monitor info registers", to_string=True)
        red = lambda x: Color.colorify(x, "red bold")
        yellow = lambda x: Color.colorify(x, "yellow bold")

        # CR0
        gef_print(titlify("CR0 (Control Register 0)"))
        desc = "It contains system control flags that control operating mode and states of the processor"
        bit_info = [
            [31, "PG", "Paging", "If 1, enable paging and use CR3 register, else disable paging"],
            [30, "CD", "Cache disable", "If 1, disable the memory cache globally"],
            [29, "NW", "Not-write through", "If 1, disable write-through caching globally"],
            [18, "AM", "Alignment mask", "If 1, alignment check enabled when EFLAGS.AC==1 and Ring-3"],
            [16, "WP", "Write protect", "If 1, the CPU can't write to read-only pages when Ring-0"],
            [5, "NE", "Numeric error", "If 1, enable internal x87 FPU error reporting, else enables PC style x87 error detection"],
            [4, "ET", "Extension type", "x64: always 1. i386: if 1, x87 DX math coprosessor instructions is supported"],
            [3, "TS", "Task switched", "If 1, allow the saving x87 task context upon a task switch only after x87 instruction used"],
            [2, "EM", "Emulation", "If 1, no x87 FPU present, else x87 FPU present"],
            [1, "MP", "Monitor co-processor", "If 1, WAIT/FWAIT instructions generate #NM exception when CR0.TS"],
            [0, "PE", "Protected mode enable", "If 1, system is in protected mode, else system is in real mode"],
        ]
        cr0 = int(re.search(r"CR0=(\S+)", res).group(1), 16)
        PrintBitInfo("CR0", 32, desc, bit_info).print(cr0)

        # CR1
        gef_print(titlify("CR1 (Control Register 1)"))
        gef_print("Reserved")

        # CR2
        gef_print(titlify("CR2 (Control Register 2)"))
        desc = "When page fault, the address attempted to access is stored (PFLA: Page Fault Linear Address)"
        cr2 = int(re.search(r"CR2=(\S+)", res).group(1), 16)
        PrintBitInfo("CR2", 64 if is_x86_64() else 32, desc, bit_info=[]).print(cr2, split=False)

        # CR3
        gef_print(titlify("CR3 (Control Register 3)"))
        desc = "It contains the physical address of the base of the paging-structure hierarchy and two flags"
        bit_info = [
            [list(range(12, 32)), None, None, "Base of page directory base, typically it points to PML4T if 4-level paging"],
            [list(range(0, 12)), None, None, "Process context identifier when CR4.PCIDE=1"],
            [4, "PCD", "Page-level Cache Disable", "If 1, disable Page-Directory itself caching when CR4.PCIDE=0"],
            [3, "PWT", "Page-level Write-Through", "If 1, enable write through Page-Directory itself caching when CR4.PCIDE=0"],
        ]
        cr3 = int(re.search(r"CR3=(\S+)", res).group(1), 16)
        PrintBitInfo("CR3", 64 if is_x86_64() else 32, desc, bit_info).print(cr3)

        # CR4
        gef_print(titlify("CR4 (Control Register 4)"))
        desc = "It contains flags that enable some architectural extensions, and indicate OS or executive support for specific processor capabilities"
        bit_info = [
            [24, "PKS", "Enable protection keys for supervisor-mode pages", "If 1, enables PKS"],
            [23, "CET", "Control-flow Enforcement Technology", "If 1, enables CET"],
            [22, "PKE", "Protection Key Enable", "If 1, enables PKE"],
            [21, "SMAP", "Supervisor Mode Access Protection Enable", "If 1, access of data in a higher ring generates a fault"],
            [20, "SMEP", "Supervisor Mode Execution Protection Enable", "If 1, execution of code in a higher ring generates a fault"],
            [18, "OSXSAVE", "Enable XSAVE and Processor Extended States", "If 1, enable XSAVE/XSAVEC/XSAVEOPT/XSAVES/XRSTOR/XRSTORS/XSETBV/XGETBV"],
            [17, "PCIDE", "PCID Enable", "If 1, enables process-context identifiers (PCIDs)"],
            [15, "FSGSBASE", "FSGSBASE Enable", "If 1, enable RDFSBASE/RDGSBASE/WRFSBASE/WRGSBASE"],
            [14, "SMXE", "Safer Mode Extensions Enable", "If 1, enable Trusted Execution Technology (TXT)"],
            [13, "VMXE", "Virtual Machine Extensions Enable", "If 1, enable Intel VT-x x86 virtualization"],
            [12, "LA57", "57bit linear addresses", "If 1, enables 5-Level Paging"],
            [11, "UMIP", "User-Mode Instruction Prevention", "If 1, SGDT/SIDT/SLDT/SMSW/STR instructions can only be executed in ring0"],
            [10, "OSXMMEXCPT", "OS support for Unmasked SIMD FP Exceptions", "If 1, enables unmasked SSE exceptions"],
            [9, "OSFXSR", "OS support for FXSAVE/FXRSTOR", "If 1, enables SSE instructions and fast FPU save & restore"],
            [8, "PCE", "Performance-Monitoring Counter enable", "If 1, RDPMC instruction can be executed at any privilege level"],
            [7, "PGE", "Page Global Enabled", "If 1, address translations (PDE or PTE records) may be shared between address spaces"],
            [6, "MCE", "Machine Check Exception", "If 1, enables machine check interrupts to occur"],
            [5, "PAE", "Physical Address Extension", "If 1, changes page table layout to translate 32bit virtaddr into 36bit physaddr"],
            [4, "PSE", "Page Size Extension", "If 1, page size is 4MB, else 4KB, this bit is ignored when PAE or x86-64 long mode"],
            [3, "DE", "Debugging Extensions", "If 1, enables debug register based breaks on I/O space access"],
            [2, "TSD", "Time Stamp Disable", "If 1, RDTSC instruction can only be executed in ring0"],
            [1, "PVI", "Protected-mode Virtual Interrupts", "If 1, enables support for the virtual interrupt flag (VIF) in protected mode"],
            [0, "VME", "Virtual 8086 Mode Extensions", "If 1, enables support for the virtual interrupt flag (VIF) in virtual-8086 mode"],
        ]
        cr4 = int(re.search(r"CR4=(\S+)", res).group(1), 16)
        PrintBitInfo("CR4", 64 if is_x86_64() else 32, desc, bit_info).print(cr4)

        # DR0-DR3
        gef_print(titlify("DR0-DR3 (Debug Address Register 0-3)"))
        desc = "Contain linear addresses of up to 4 hardware breakpoints. If paging is enabled, they are translated to physical addresses"
        dr0 = int(re.search(r"DR0=(\S+)", res).group(1), 16)
        dr1 = int(re.search(r"DR1=(\S+)", res).group(1), 16)
        dr2 = int(re.search(r"DR2=(\S+)", res).group(1), 16)
        dr3 = int(re.search(r"DR3=(\S+)", res).group(1), 16)
        PrintBitInfo("DR0", 64 if is_x86_64() else 32, None, bit_info=[]).print(dr0, split=False)
        PrintBitInfo("DR1", 64 if is_x86_64() else 32, None, bit_info=[]).print(dr1, split=False)
        PrintBitInfo("DR2", 64 if is_x86_64() else 32, None, bit_info=[]).print(dr2, split=False)
        PrintBitInfo("DR3", 64 if is_x86_64() else 32, desc, bit_info=[]).print(dr3, split=False)

        # DR4-DR5
        gef_print(titlify("DR4-DR5 (Debug Register 4-5)"))
        gef_print("Reserved")

        # DR6
        gef_print(titlify("DR6 (Debug Status Register 6)"))
        desc = "It permits the debugger to determine which debug conditions have occurred"
        bit_info = [
            [16, "RTM", "restricted transactional memory", "If 0, the debug exception or breakpoint exception occured inside an RTM region"],
            [15, "BT", "task switch", "If 1, the debug instruction resulted from a task switch where TSS.T of target task was set"],
            [14, "BS", "single step", "If 1, the debug exception was triggered by the single-step execution mode (enabled with EFLAGS.TF)"],
            [13, "BD", "debug register access detected", "If 1, the next instruction accesses one of the debug registers"],
            [3, "B3", "breakpoint condition detected", "If 1, breakpoint condition was met when a debug exception for DR3"],
            [2, "B2", "breakpoint condition detected", "If 1, breakpoint condition was met when a debug exception for DR2"],
            [1, "B1", "breakpoint condition detected", "If 1, breakpoint condition was met when a debug exception for DR1"],
            [0, "B0", "breakpoint condition detected", "If 1, breakpoint condition was met when a debug exception for DR0"],
        ]
        dr6 = int(re.search(r"DR6=(\S+)", res).group(1), 16)
        PrintBitInfo("DR6", 32, desc, bit_info).print(dr6)

        # DR7
        gef_print(titlify("DR7 (Debug Control Register 7)"))
        desc = "A local breakpoint bit deactivates on hardware task switches, while a global does not"
        bit_info = [
            [[30, 31], "LEN3", "Size of DR3 breakpoint", ""],
            [[28, 29], "R/W3", "Breakpoint conditions for DR3", ""],
            [[26, 27], "LEN2", "Size of DR2 breakpoint", ""],
            [[24, 25], "R/W2", "Breakpoint conditions for DR2", ""],
            [[22, 23], "LEN1", "Size of DR1 breakpoint", ""],
            [[20, 21], "R/W1", "Breakpoint conditions for DR1", ""],
            [[18, 19], "LEN0", "Size of DR0 breakpoint", ""],
            [[16, 17], "R/W0", "Breakpoint conditions for DR0", ""],
            [13, "GD", "General Detect enable", ""],
            [11, "RTM", "Restricted Transactional Memory", ""],
            [9, "GE", "Global Exact breakpoint", ""],
            [8, "LE", "Local Exact breakpoint", ""],
            [7, "G3", "Global DR3 breakpoint", ""],
            [6, "L3", "Local DR3 breakpoint", ""],
            [5, "G2", "Global DR2 breakpoint", ""],
            [4, "L2", "Local DR2 breakpoint", ""],
            [3, "G1", "Global DR1 breakpoint", ""],
            [2, "L1", "Local DR1 breakpoint", ""],
            [1, "G0", "Global DR0 breakpoint", ""],
            [0, "L0", "Local DR0 breakpoint", ""],
        ]
        dr7 = int(re.search(r"DR7=(\S+)", res).group(1), 16)
        PrintBitInfo("DR7", 64 if is_x86_64() else 32, desc, bit_info).print(dr7)

        # EFER
        gef_print(titlify("EFER (Extended Feature Enable Register; MSR_EFER:0xc0000080)"))
        efer = int(re.search(r"EFER=(\S+)", res).group(1), 16)
        bit_info = [
            [15, "TCE", "Translation Cache Extension", ""],
            [14, "FFXSR", "Fast FXSAVE/FXRSTOR", ""],
            [13, "LMSLE", "Long Mode Segment Limit Enable", ""],
            [12, "SVME", "Secure Virtual Machine Enable", ""],
            [11, "NXE", "No-Execute Enable", ""],
            [10, "LMA", "Long Mode Active", ""],
            [8, "LME", "Long Mode Enable", ""],
            [4, "L2D", "L2 Cache Disable", "AMD K6 only"],
            [3, "GEWBED", "Global EWBE# Disable", "AMD K6 only"],
            [2, "SEWBED", "Speculative EWBE# Disable", "AMD K6 only"],
            [1, "DPE", "Data Prefetch Enable", "AMD K6 only"],
            [0, "SCE", "System Call Extensions", ""],
        ]
        PrintBitInfo("EFER", 64 if is_x86_64() else 32, None, bit_info).print(efer)

        # TR
        gef_print(titlify("TR (Task Register)"))
        tr = re.search(r"TR\s*=\s*(\S+) (\S+) (\S+) (\S+)", res)
        trseg, base, limit, attr = [int(tr.group(i), 16) for i in range(1, 5)]
        gef_print("{:s} = {:s}".format(red("TR"), yellow("{:#x}".format(trseg))))
        regv = Color.boldify("{:#x} (rpl:{:d},ti:{:d},index:{:d})".format(trseg, trseg & 0b11, (trseg >> 2) & 1, trseg >> 3))
        gef_print("seg: {:s}: segment selector for TSS (Task State Segment)".format(regv))
        gef_print("  base : {:s}: starting address of TSS".format(Color.boldify("{:#x}".format(base))))
        limit_c = Color.boldify("{:#x}".format(limit))
        gef_print("  limit: {:s}: segment limit or fixed value(=__KERNEL_TSS_LIMIT x64:0x206f/x86:0x206b)".format(limit_c))
        gef_print("  attr : {:s}: attribute".format(Color.boldify("{:#x}".format(attr))))

        # GDTR
        gef_print(titlify("GDTR (Global Descriptor Table Register)"))
        gdtr = re.search(r"GDT\s*=\s*(\S+) (\S+)", res)
        base, limit = [int(gdtr.group(i), 16) for i in range(1, 3)]
        gef_print("{:s} = {:s}:{:s}".format(red("GDTR"), yellow("{:#x}".format(base)), yellow("{:#x}".format(limit))))
        gef_print("base : {:s}: starting address of GDT (Global Descriptor Table)".format(Color.boldify("{:#x}".format(base))))
        gef_print("limit: {:s}: (size of GDT) - 1".format(Color.boldify("{:#x}".format(limit))))
        info("GDT entry")
        regs = GdtInfoCommand.get_segreg_list()
        legend = GdtInfoCommand.segval2str_legend()
        gef_print(Color.colorify(legend, get_gef_setting("theme.table_heading")))
        gdtinfo = read_memory(base, limit + 1)
        # https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/segment.h
        if is_x86_64():
            segname_info = [
                "NULL",
                "KERNEL_32_CS",
                "KERNEL_CS",
                "KERNEL_DS",
                "DEFAULT_USER32_CS",
                "DEFAULT_USER_DS",
                "DEFAULT_USER_CS",
                "",
                "TSS-part1",
                "TSS-part2",
                "LDT-part1",
                "LDT-part2",
                "TLS_#1",
                "TLS_#2",
                "TLS_#3",
                "CPUNODE",
            ]
        else:
            segname_info = [
                "NULL",
                "RESERVED",
                "RESERVED",
                "RESERVED",
                "UNUSED",
                "UNUSED",
                "TLS_#1",
                "TLS_#2",
                "TLS_#3",
                "RESERVED",
                "RESERVED",
                "RESERVED",
                "KERNEL_CS",
                "KERNEL_DS",
                "DEFAULT_USER_CS",
                "DEFAULT_USER_DS",
                "TSS",
                "LDT",
                "PNPBIOS_CS32",
                "PNPBIOS_CS16",
                "PNPBIOS_DS",
                "PNPBIOS_TS1",
                "PNPBIOS_TS2",
                "APMBIOS_BASE",
                "APMBIOS",
                "APMBIOS",
                "ESPFIX_SS",
                "PERCPU",
                "STACK_CANARY",
                "UNUSED",
                "UNUSED",
                "DOUBLEFAULT_TSS",
            ]
        sliced = list(map(u64, [gdtinfo[i:i + 8] for i in range(0, len(gdtinfo), 8)]))
        registers_color = get_gef_setting("theme.dereference_register_value")
        for i, b in enumerate(sliced):
            reglist = ', '.join(regs.get(i, []))
            if reglist:
                reglist = LEFT_ARROW + reglist
            if is_x86_64() and i == (trseg >> 3): # for TSS
                s = GdtInfoCommand.segval2str(b, value_only=True)
                prev = b
                reglist = reglist + ", tr" if reglist else LEFT_ARROW + "TR"
            elif is_x86_64() and i == (trseg >> 3) + 1: # for TSS
                s = GdtInfoCommand.segval2str([prev, b])
            elif is_x86_32() and i == (trseg >> 3): # for TSS
                s = GdtInfoCommand.segval2str(b)
                reglist = reglist + ", tr" if reglist else LEFT_ARROW + "TR"
            else:
                s = GdtInfoCommand.segval2str(b)
            gef_print("[{:02d}] {:20s}: {:s} {:s}".format(i, segname_info[i], s, Color.colorify(reglist, registers_color)))
        info("more info, use `gdtinfo -v` command, it prints legend of GDT entry")

        # IDTR
        gef_print(titlify("IDTR (Interrupt Descriptor Table Register)"))
        idtr = re.search(r"IDT\s*=\s*(\S+) (\S+)", res)
        base, limit = [int(idtr.group(i), 16) for i in range(1, 3)]
        gef_print("{:s} = {:s}:{:s}".format(red("IDTR"), yellow("{:#x}".format(base)), yellow("{:#x}".format(limit))))
        gef_print("base : {:s}: starting address of IDT (Interrupt Descriptor Table)".format(Color.boldify("{:#x}".format(base))))
        gef_print("limit: {:s}: (size of IDT) - 1".format(Color.boldify("{:#x}".format(limit))))

        # LDTR
        gef_print(titlify("LDTR (Local Descriptor Table Register)"))
        ldtr = re.search(r"LDT\s*=\s*(\S+) (\S+) (\S+) (\S+)", res)
        seg, base, limit, attr = [int(ldtr.group(i), 16) for i in range(1, 5)]
        gef_print("{:s} = {:s}".format(red("LDTR"), yellow("{:#x}".format(seg))))
        regv = Color.boldify("{:#x} (rpl:{:d},ti:{:d},index:{:d})".format(seg, seg & 0b11, (seg >> 2) & 1, seg >> 3))
        gef_print("seg: {:s}: segment selector for LDT (Local Descriptor Table)".format(regv))
        gef_print("  base : {:s}: starting address of LDT".format(Color.boldify("{:#x}".format(base))))
        gef_print("  limit: {:s}: segment limit".format(Color.boldify("{:#x}".format(limit))))
        gef_print("  attr : {:s}: attribute".format(Color.boldify("{:#x}".format(attr))))
        return

    def qregisters(self):
        res = gdb.execute("monitor info registers", to_string=True)
        gef_print(titlify("info register"))
        for line in res.splitlines():
            gef_print(line)

        if is_x86():
            if not self.add_info:
                info("use `-v` for print Additional info")
            else:
                info("Additional info")
                self.qregisters_x86_x64()
        return

    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        self.add_info = False
        if "-v" in argv:
            self.add_info = True
            argv.remove("-v")

        self.qregisters()
        return


@functools.lru_cache()
def get_maps_arm64_optee_secure_memory(verbose=False):
    # heuristic search of qemu-system memory
    sm_base, sm_size = XSecureMemAddrCommand.get_secure_memory_base_and_size(verbose)
    if sm_base is None or sm_size is None:
        err("Not found memory tree of secure memory (see monitor info mtree -f)")
        return None
    sm = XSecureMemAddrCommand.get_secure_memory_qemu_map(sm_base, sm_size, verbose)
    if sm is None:
        err("Not found secure memory maps")
        return None
    data = XSecureMemAddrCommand.read_secure_memory(sm, 0x0, sm.size, verbose)
    data_list = slice_unpack(data, 8)

    """
    enum teecore_memtypes {
        MEM_AREA_END = 0,
        MEM_AREA_TEE_RAM,
        MEM_AREA_TEE_RAM_RX,
        MEM_AREA_TEE_RAM_RO,
        MEM_AREA_TEE_RAM_RW,
        MEM_AREA_INIT_RAM_RO,
        MEM_AREA_INIT_RAM_RX,
        MEM_AREA_NEX_RAM_RO,
        MEM_AREA_NEX_RAM_RW,
        MEM_AREA_TEE_COHERENT,
        MEM_AREA_TEE_ASAN,
        MEM_AREA_IDENTITY_MAP_RX,
        MEM_AREA_TA_RAM,
        MEM_AREA_NSEC_SHM,
        MEM_AREA_RAM_NSEC,
        MEM_AREA_RAM_SEC,
        MEM_AREA_IO_NSEC,
        MEM_AREA_IO_SEC,
        MEM_AREA_EXT_DT,
        MEM_AREA_RES_VASPACE,
        MEM_AREA_SHM_VASPACE,
        MEM_AREA_TS_VASPACE,
        MEM_AREA_PAGER_VASPACE,
        MEM_AREA_SDP_MEM,
        MEM_AREA_DDR_OVERALL,
        MEM_AREA_SEC_RAM_OVERALL,
        MEM_AREA_MAXTYPE
    };
    struct tee_mmap_region {
        unsigned int type; /* enum teecore_memtypes */
        unsigned int region_size;
        paddr_t pa;
        vaddr_t va;
        size_t size;
        uint32_t attr; /* TEE_MATTR_* above */
    };
    """
    maps = []
    old_i = -1
    for i in range(len(data_list) - 4):
        type = data_list[i] & 0xffffffff
        if 26 < type: # enum teecore_memtypes
            continue
        region_size = (data_list[i] >> 32) & 0xffffffff
        if region_size & 0xfff or region_size < 0x1000 or 0xfffff000 < region_size:
            continue
        pa, va, size, attr = data_list[i + 1:i + 5]
        if pa & 0xfff or 0xfffff000 < pa:
            continue
        if va & 0xfff or 0xfffff000 < va:
            continue
        if size & 0xfff or size < 0x1000 or 0xfffff000 < size:
            continue
        if len(maps) > 0 and old_i + 5 != i: # Judging continuity
            continue
        maps.append([va, va + size, pa, pa + size])
        old_i = i
    if verbose:
        fmt = "{:33s}  {:33s}  {:12s}"
        legend = ["Virtual address start-end", "Physical address start-end", "Total size"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))
        for va_start, va_end, pa_start, pa_end in maps:
            fmt = "{:016x}-{:016x}  {:016x}-{:016x}  {:<#12x}"
            gef_print(fmt.format(va_start, va_end, pa_start, pa_end, va_end - va_start))
    return maps


@functools.lru_cache()
def get_maps_by_pagewalk(command):
    # for lru cache
    return gdb.execute(command, to_string=True)


@register_command
class V2PCommand(GenericCommand):
    """Transfer from virtual address to physical address."""
    _cmdline_ = "v2p"
    _syntax_ = "{:s} [-h] [-s|-S] ADDRESS".format(_cmdline_)
    _example_ = ""
    _example_ += "{:s} 0xa31dd000\n".format(_cmdline_)
    _example_ += "{:s} 0xa31dd000 -S # use TTBRn_ELm_S for parsing start register (ARMv7)\n".format(_cmdline_)
    _example_ += "                  # heuristic search the memory of qemu-system (ARMv8)\n"
    _example_ += "{:s} 0xa31dd000 -s # use TTBRn_ELm for parsing start register (ARMv7/v8)".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    @staticmethod
    def get_maps(FORCE_PREFIX_S, verbose=False):
        if is_arm64():
            if FORCE_PREFIX_S is True:
                return get_maps_arm64_optee_secure_memory(verbose) # already parsed
            else:
                res = get_maps_by_pagewalk("pagewalk 1 -q --no-merge")
        else:
            if FORCE_PREFIX_S is None:
                res = get_maps_by_pagewalk("pagewalk -q --no-merge")
            elif FORCE_PREFIX_S is True:
                res = get_maps_by_pagewalk("pagewalk -q --no-merge -S")
            elif FORCE_PREFIX_S is False:
                res = get_maps_by_pagewalk("pagewalk -q --no-merge -s")
        res = sorted(set(res.splitlines()))
        res = list(filter(lambda line: line.endswith("]"), res))
        res = list(filter(lambda line: "[+]" not in line, res))
        maps = []
        for line in res:
            vrange, prange, *_ = line.split()
            vstart, vend = [int(x, 16) for x in vrange.split("-")]
            pstart, pend = [int(x, 16) for x in prange.split("-")]
            maps.append((vstart, vend, pstart, pend))
        if maps == []:
            if is_x86():
                warn("Make sure you are in ring0 (=kernel mode)")
            elif is_arm32():
                warn("Make sure you are in supervisor mode (=kernel mode)")
                warn("Make sure qemu 3.x or higher")
            elif is_arm64():
                warn("Make sure you are in EL1 (=kernel mode)")
                warn("Make sure qemu 3.x or higher")
            return None
        return maps

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64", "ARM32", "ARM64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        if not argv:
            self.usage()
            return

        FORCE_PREFIX_S = None
        if is_arm32() or is_arm64():
            if "-s" in argv:
                FORCE_PREFIX_S = False
                argv.remove("-s")
            elif "-S" in argv:
                FORCE_PREFIX_S = True
                argv.remove("-S")

        try:
            addr = int(gdb.parse_and_eval(' '.join(argv)))
        except Exception:
            self.usage()
            return

        maps = self.get_maps(FORCE_PREFIX_S)
        if maps is None:
            return
        for vstart, vend, pstart, pend in maps:
            if vstart <= addr < vend:
                offset = addr - vstart
                paddr = pstart + offset
                gef_print("Virt: {:#x} -> Phys: {:#x}".format(addr, paddr))
        return


@register_command
class P2VCommand(GenericCommand):
    """Transfer from physical address to virtual address."""
    _cmdline_ = "p2v"
    _syntax_ = "{:s} [-h] [-s|-S] ADDRESS".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64", "ARM32", "ARM64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        if not argv:
            self.usage()
            return

        FORCE_PREFIX_S = None
        if is_arm32() or is_arm64():
            if "-s" in argv:
                FORCE_PREFIX_S = False
                argv.remove("-s")
            elif "-S" in argv:
                FORCE_PREFIX_S = True
                argv.remove("-S")

        try:
            addr = int(gdb.parse_and_eval(' '.join(argv)))
        except Exception:
            self.usage()
            return

        maps = V2PCommand.get_maps(FORCE_PREFIX_S)
        if maps is None:
            return
        count = 0
        for vstart, vend, pstart, pend in maps:
            if pstart <= addr < pend:
                offset = addr - pstart
                vaddr = vstart + offset
                if count < 10:
                    gef_print("Phys: {:#x} -> Virt: {:#x}".format(addr, vaddr))
                count += 1
        if count:
            gef_print("Total {:d} results are found".format(count))
        else:
            gef_print("Not mapped as virt")
        return


@register_command
class PagewalkCommand(GenericCommand):
    """Get physical memory info via qemu-monitor. Currently, x64, x86, arm and arm64 are supported."""
    _cmdline_ = "pagewalk"
    _syntax_ = "{:s}".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    def __init__(self, *args, **kwargs):
        prefix = kwargs.get("prefix", True)
        super().__init__(prefix=prefix)
        return

    def read_physmem_cache(self, paddr, size):
        key = "{:#x}_{:d}".format(paddr, size)
        if key in self.cache:
            return self.cache[key]
        out = read_physmem(paddr, size)
        self.cache[key] = out
        return out

    # merge pages that points same phys page
    # for example, there are 16 pages,
    #    virt: 0xffffffff11107000  -> phys:0xabcd000
    #    virt: 0xffffffff11117000  -> phys;0xabcd000
    #    virt: 0xffffffff11127000  -> phys;0xabcd000
    #    ...
    #    virt: 0xffffffff111d7000  -> phys;0xabcd000
    #    virt: 0xffffffff111e7000  -> phys;0xabcd000
    #    virt: 0xffffffff111f7000  -> phys;0xabcd000
    # they will be merged by "*". type is changed from int to string.
    #    virt:"0xffffffff111*7000" -> phys:0xabcd000
    def merge1(self):
        # group entries that refer to the same phys page
        tmp = {}
        for entry in self.mappings: # [virt_addr, phys_addr, page_size, page_count, flags]
            va, other = entry[0], tuple(entry[1:])
            if other not in tmp:
                tmp[other] = []
            tmp[other].append("{:016x}".format(va))

        # merge if possible
        merged_mappings = []
        for other, va_array in tmp.items():
            queue = va_array
            # extract
            dic = {}
            for q in queue:
                for i in range(16):
                    dst = dic
                    src = dic
                    for j in range(i + 1):
                        src = src.get(q[j], {})
                        if j > 0:
                            dst = dst.get(q[j - 1], {})
                    dst[q[i]] = src

            # merge
            def recursive_merge(d):
                if d == {}:
                    return [""]
                out = []
                if len(d) == 16:
                    tmp = list(d.values())
                    if tmp.count(tmp[0]) == 16:
                        for vv in recursive_merge(tmp[0]):
                            out.append("*" + vv)
                        return out
                for k, v in d.items():
                    for vv in recursive_merge(v):
                        out.append(k + vv)
                return out

            for d in recursive_merge(dic):
                merged_mappings.append([d] + list(other))

        # done
        self.mappings = sorted(merged_mappings)
        return

    # merge consecutive pages
    def merge2(self):
        merged_mappings = []
        prev = None
        for now in self.mappings: # [virt_addr_string, phys_addr, page_size, page_count, flags]

            # specific case
            if "*" in now[0]:
                if prev:
                    merged_mappings += [prev]
                merged_mappings += [now]
                prev = None
                continue

            # first loop case
            if prev is None:
                prev = now
                continue

            now_va = int(now[0], 16) if isinstance(now[0], str) else now[0]
            prev_va = int(prev[0], 16) if isinstance(prev[0], str) else prev[0]
            now_pa = int(now[1], 16) if isinstance(now[1], str) else now[1]
            prev_pa = int(prev[1], 16) if isinstance(prev[1], str) else prev[1]
            now_size = now[2]
            prev_size = prev[2]
            #now_cnt = now[3] # unused
            prev_cnt = prev[3]
            now_flags = now[4]
            prev_flags = prev[4]

            # check consecutiveness
            if self.simple:
                if prev_va + prev_size == now_va: # va consecutiveness
                    if prev_flags == now_flags: # flags equivalence
                        # ok, they are consecutive (at least virt_addr)
                        prev[2] += now[2]
                        # For simple mode, page_size is ignored.
                        # so we use entry[2] as total_size instead of page_size.
                        continue
            else:
                if prev_va + prev_size * prev_cnt == now_va: # va consecutiveness
                    if prev_pa + prev_size * prev_cnt == now_pa: # pa consecutiveness
                        if prev_size == now_size: # page_size equivalence
                            if prev_flags == now_flags: # flags equivalence
                                # ok, they are consecutive
                                prev[3] += 1 # prev_page_cnt update
                                continue

            merged_mappings += [prev]
            prev = now

        if prev:
            merged_mappings += [prev]

        self.mappings = merged_mappings
        return

    def vrange_filter(self):
        filterd_mappings = []
        for addr in self.vrange:
            for mapping in self.mappings:
                va, _, size, cnt = mapping[:4]
                if isinstance(va, str) and "*" in va:
                    start = int(va.replace("*", "0"), 16)
                    end = int(va.replace("*", "f"), 16)
                    if start <= addr and addr < end + size * cnt:
                        filterd_mappings.append(mapping)
                else:
                    if isinstance(va, str):
                        va = int(va, 16)
                    if va <= addr and addr < va + size * cnt:
                        filterd_mappings.append(mapping)
        self.mappings = sorted(filterd_mappings)
        return

    def prange_filter(self):
        filterd_mappings = []
        for addr in self.prange:
            for mapping in self.mappings:
                _, pa, size, cnt = mapping[:4]
                if isinstance(pa, str):
                    pa = int(pa, 16)
                if pa <= addr and addr < pa + size * cnt:
                    filterd_mappings.append(mapping)
        self.mappings = sorted(filterd_mappings)
        return

    def format_legend(self):
        fmt = "{:33s}  {:33s}  {:12s} {:11s} {:6s} {:s}"
        legend = ["Virtual address start-end", "Physical address start-end", "Total size", "Page size", "Count", "Flags"]
        return fmt.format(*legend)

    def format_entry(self, entry):
        va, pa, size, cnt, flags = entry
        if isinstance(va, str) and "*" in va:
            vend = "{:016x}".format(int(va.replace("*", "0"), 16) + size * cnt)
            for pos in [x.span() for x in re.finditer(r'\*', va)]:
                vend = vend[:pos[0]] + "*" + vend[pos[1]:]
            pend = pa + size * cnt
            if self.simple:
                fmt = "{:16s}-{:16s}  {:33s}  {:<#12x} {:<11s} {:<6s} [{:s}]"
                text = fmt.format(va, vend, "-", size, "-", "-", flags)
            else:
                fmt = "{:16s}-{:16s}  {:016x}-{:016x}  {:<#12x} {:<#11x} {:<6d} [{:s}]"
                text = fmt.format(va, vend, pa, pend, size * cnt, size, cnt, flags)
        else:
            if isinstance(va, str):
                va = int(va, 16)
            vend = va + size * cnt
            pend = pa + size * cnt
            if self.simple:
                fmt = "{:016x}-{:016x}  {:33s}  {:<#12x} {:<11s} {:<6s} [{:s}]"
                text = fmt.format(va, vend, "-", size, "-", "-", flags)
            else:
                fmt = "{:016x}-{:016x}  {:016x}-{:016x}  {:<#12x} {:<#11x} {:<6d} [{:s}]"
                text = fmt.format(va, vend, pa, pend, size * cnt, size, cnt, flags)
        return text

    def print_page(self):
        if len(self.mappings) == 0:
            warn("No virtual mappings found")
            return

        self.mappings = sorted(self.mappings)

        # merging
        if self.no_merge:
            pass
        else:
            self.merge1()
            if not self.quiet:
                info("PT Entry (merged similar pages that refer the same physpage): {:d}".format(len(self.mappings)))
            self.merge2()
            if not self.quiet:
                info("PT Entry (merged consecutive pages): {:d}".format(len(self.mappings)))

        # filter by virtual address range
        if self.vrange != []:
            self.vrange_filter()
            if not self.quiet:
                info("PT Entry (filterd by virtual address range): {:d}".format(len(self.mappings)))

        # filter by physical address range
        if self.prange != []:
            self.prange_filter()
            if not self.quiet:
                info("PT Entry (filterd by physical address range): {:d}".format(len(self.mappings)))

        # create output
        lines = []
        for entry_info in self.mappings:
            line = self.format_entry(entry_info)
            lines.append(line)

        # filter by keyword
        if self.filter != []:
            filtered_lines = []
            for line in lines:
                for filt in self.filter:
                    if re.search(filt, line):
                        filtered_lines.append(line)
            lines = filtered_lines
            if not self.quiet:
                info("PT Entry (filterd by keyword): {:d}".format(len(lines)))

        # sort by phys
        if self.sort_by_phys:
            lines = sorted(lines, key=lambda x: x.split()[1])

        # check how many result
        if lines == []:
            warn("Nothing to display")
            return

        # print
        gef_print(titlify("Memory map"))
        gef_print(Color.colorify(self.format_legend(), get_gef_setting("theme.table_heading")))
        for line in lines:
            gef_print(line)
        return

    def is_not_trace_target(self, va_start, va_end):
        if self.trace == []:
            return False
        for tr in self.trace:
            if va_start <= tr and tr < va_end:
                return False
        return True

    def is_not_filter_target(self, line):
        if self.filter == []:
            return False
        for filt in self.filter:
            if re.search(filt, line):
                return False
        return True

    def parse_common_args(self, argv):
        self.quiet = False
        if "-q" in argv:
            self.quiet = True
            argv.remove("-q")

        self.print_each_level = False
        if "--print-each-level" in argv:
            self.print_each_level = True
            argv.remove("--print-each-level")

        self.no_merge = False
        if "--no-merge" in argv:
            self.no_merge = True
            argv.remove("--no-merge")

        self.sort_by_phys = False
        if "--sort-by-phys" in argv:
            self.sort_by_phys = True
            argv.remove("--sort-by-phys")

        self.simple = False
        if "--simple" in argv:
            self.simple = True
            argv.remove("--simple")

        self.filter = []
        while "--filter" in argv:
            idx = argv.index("--filter")
            pattern = argv[idx + 1]
            self.filter.append(pattern)
            argv = argv[:idx] + argv[idx + 2:]

        self.vrange = []
        while "--vrange" in argv:
            idx = argv.index("--vrange")
            vrange_addr = int(argv[idx + 1], 16)
            self.vrange.append(vrange_addr)
            argv = argv[:idx] + argv[idx + 2:]

        self.prange = []
        while "--prange" in argv:
            idx = argv.index("--prange")
            prange_addr = int(argv[idx + 1], 16)
            self.prange.append(prange_addr)
            argv = argv[:idx] + argv[idx + 2:]

        self.trace = []
        while "--trace" in argv:
            idx = argv.index("--trace")
            trace_addr = int(argv[idx + 1], 16)
            self.trace.append(trace_addr)
            self.vrange.append(trace_addr) # also set --vrange
            argv = argv[:idx] + argv[idx + 2:]
            self.print_each_level = True # overwrite

        self.cache = {}
        return argv

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64", "ARM32", "ARM64"])
    def do_invoke(self, argv):
        self.dont_repeat()
        if is_x86_32():
            gdb.execute("pagewalk x86 {}".format(' '.join(argv)))
        elif is_x86_64():
            gdb.execute("pagewalk x64 {}".format(' '.join(argv)))
        elif is_arm32():
            gdb.execute("pagewalk arm {}".format(' '.join(argv)))
        elif is_arm64():
            gdb.execute("pagewalk arm64 {}".format(' '.join(argv)))
        return


@register_command
class PagewalkX64Command(PagewalkCommand):
    """Dump pagetable for x64/x86 using qemu-monitor."""
    _cmdline_ = "pagewalk x64"
    _syntax_ = "{:s} [-h] [-q] [--print-each-level] [--no-merge] [--filter REGEX] ".format(_cmdline_)
    _syntax_ += "[--vrange ADDR] [--prange ADDR] [--sort-by-phys] [--simple] [--trace ADDR]"
    _example_ = "\n"
    _example_ += "{:s} --print-each-level # show all level pagetables\n".format(_cmdline_)
    _example_ += "{:s} --no-merge         # do not merge similar/consecutive address\n".format(_cmdline_)
    _example_ += "{:s} --filter 0xabc     # grep by REGEX pattern\n".format(_cmdline_)
    _example_ += "{:s} --vrange 0x7fff00  # filter by map included specified virtual address\n".format(_cmdline_)
    _example_ += "{:s} --prange 0x7fff00  # filter by map included specified physical address\n".format(_cmdline_)
    _example_ += "{:s} --sort-by-phys     # sort by physical address\n".format(_cmdline_)
    _example_ += "{:s} --simple           # merge with ignoring physical address consecutivness\n".format(_cmdline_)
    _example_ += "{:s} --trace 0x7fff00   # show all level pagetables only associated specified address\n".format(_cmdline_)
    _example_ += "{:s} -q                 # show result only (quiet)".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"
    _aliases_ = ["pagewalk x86"]

    def __init__(self):
        super().__init__(prefix=False)
        return

    def format_flags(self, flag_info):
        flags = []
        if "NO_RW" in flag_info and "XD" in flag_info:
            flags += ["R--"]
        elif "NO_RW" in flag_info and "XD" not in flag_info:
            flags += ["R-X"]
        elif "NO_RW" not in flag_info and "XD" in flag_info:
            flags += ["RW-"]
        elif "NO_RW" not in flag_info and "XD" not in flag_info:
            flags += ["RWX"]
        if "NO_US" in flag_info:
            flags += ["KERN"]
        else:
            flags += ["USER"]
        if "A" in flag_info:
            flags += ["ACCESSED"]
        if "D" in flag_info:
            flags += ["DIRTY"]
        if "G" in flag_info:
            flags += ["GLOBAL"]
        return ' '.join(flags)

    def pagewalk_PML5T(self):
        if not self.quiet:
            gef_print(titlify("PML5E: Page Map Level 5 Entry"))
        PML5E = []
        COUNT = 0
        for va_base, table_base, parent_flags in self.TABLES:
            entries = self.read_physmem_cache(table_base, 2 ** self.bits["PML5T_BITS"] * self.bits["ENTRY_SIZE"])
            entries = slice_unpack(entries, self.bits["ENTRY_SIZE"])
            COUNT += len(entries)
            for i, entry in enumerate(entries):
                # present flag
                if (entry & 1) == 0:
                    continue

                # calc virtual address
                b = self.bits["PML4T_BITS"] + self.bits["PDPT_BITS"] + self.bits["PDT_BITS"] + self.bits["PT_BITS"] + self.bits["OFFSET"]
                sign_ext = 0xfe00000000000000 if ((i >> (self.bits["PML5T_BITS"] - 1)) & 1) else 0
                new_va = va_base + (sign_ext | (i << b))
                new_va_end = new_va + (1 << b)

                # calc flags
                flags = parent_flags.copy()
                if ((entry >> 1) & 1) == 0:
                    flags.append("NO_RW")
                if ((entry >> 2) & 1) == 0:
                    flags.append("NO_US")
                if ((entry >> 5) & 1) == 1:
                    flags.append("A")
                if ((entry >> 63) & 1) == 1:
                    flags.append("XD")

                # calc next table (drop the flag bits)
                next_level_table = entry & 0x000ffffffffff000

                # make entry
                PML5E.append([new_va, next_level_table, flags])
                entry_type = "TABLE"

                # dump
                if self.print_each_level:
                    if self.is_not_trace_target(new_va, new_va_end):
                        continue
                    addr = table_base + i * self.bits["ENTRY_SIZE"]
                    fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                    line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                    if self.is_not_filter_target(line):
                        continue
                    gef_print(line)

        if not self.quiet:
            info("Number of entries: {:d}".format(COUNT))
            info("PML5 Entry: {:d}".format(len(PML5E)))
            info("Invalid entries: {:d}".format(COUNT - len(PML5E)))
        self.TABLES = PML5E
        return

    def pagewalk_PML4T(self):
        if not self.quiet:
            gef_print(titlify("PML4E: Page Map Level 4 Entry"))
        PML4E = []
        COUNT = 0
        for va_base, table_base, parent_flags in self.TABLES:
            entries = self.read_physmem_cache(table_base, 2 ** self.bits["PML4T_BITS"] * self.bits["ENTRY_SIZE"])
            entries = slice_unpack(entries, self.bits["ENTRY_SIZE"])
            COUNT += len(entries)
            for i, entry in enumerate(entries):
                # present flag
                if (entry & 1) == 0:
                    continue

                # calc virtual address
                b = self.bits["PDPT_BITS"] + self.bits["PDT_BITS"] + self.bits["PT_BITS"] + self.bits["OFFSET"]
                if "PML5T_BITS" in self.bits:
                    new_va = va_base + (i << b)
                    new_va_end = new_va + (1 << b)
                else:
                    sign_ext = 0xffff000000000000 if ((i >> (self.bits["PML4T_BITS"] - 1)) & 1) else 0
                    new_va = va_base + (sign_ext | (i << b))
                    new_va_end = new_va + (1 << b)

                # calc flags
                flags = parent_flags.copy()
                if ((entry >> 1) & 1) == 0:
                    flags.append("NO_RW")
                if ((entry >> 2) & 1) == 0:
                    flags.append("NO_US")
                if ((entry >> 5) & 1) == 1:
                    flags.append("A")
                if ((entry >> 63) & 1) == 1:
                    flags.append("XD")

                # calc next table (drop the flag bits)
                next_level_table = entry & 0x000ffffffffff000

                # make entry
                PML4E.append([new_va, next_level_table, flags])
                entry_type = "TABLE"

                # dump
                if self.print_each_level:
                    if self.is_not_trace_target(new_va, new_va_end):
                        continue
                    addr = table_base + i * self.bits["ENTRY_SIZE"]
                    fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                    line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                    if self.is_not_filter_target(line):
                        continue
                    gef_print(line)

        if not self.quiet:
            info("Number of entries: {:d}".format(COUNT))
            info("PML4 Entry: {:d}".format(len(PML4E)))
            info("Invalid entries: {:d}".format(COUNT - len(PML4E)))
        self.TABLES = PML4E
        return

    def pagewalk_PDPT(self):
        if not self.quiet:
            gef_print(titlify("PDPE: Page Directory Pointer Entry"))

        def is_set_PS(entry):
            return ((entry >> 7) & 1) == 1

        PDPTE = []
        PTE = []
        COUNT = 0
        for va_base, table_base, parent_flags in self.TABLES:
            entries = self.read_physmem_cache(table_base, 2 ** self.bits["PDPT_BITS"] * self.bits["ENTRY_SIZE"])
            entries = slice_unpack(entries, self.bits["ENTRY_SIZE"])
            COUNT += len(entries)
            for i, entry in enumerate(entries):
                # present flag
                if (entry & 1) == 0:
                    continue

                # calc virtual address
                new_va = va_base + (i << (self.bits["PDT_BITS"] + self.bits["PT_BITS"] + self.bits["OFFSET"]))
                new_va_end = new_va + (1 << (self.bits["PDT_BITS"] + self.bits["PT_BITS"] + self.bits["OFFSET"]))

                # calc flags
                flags = parent_flags.copy()
                if is_x86_64():
                    if ((entry >> 1) & 1) == 0:
                        flags.append("NO_RW")
                    if ((entry >> 2) & 1) == 0:
                        flags.append("NO_US")
                    if ((entry >> 5) & 1) == 1:
                        flags.append("A")
                    if is_set_PS(entry) and ((entry >> 6) & 1) == 1:
                        flags.append("D")
                    if is_set_PS(entry) and ((entry >> 8) & 1) == 1:
                        flags.append("G")
                    if ((entry >> 63) & 1) == 1:
                        flags.append("XD")
                else: # x86_32 and PAE
                    pass

                # calc next table (drop the flag bits)
                if is_x86_64() and is_set_PS(entry):
                    next_level_table = entry & 0x000fffffffffe000
                else:
                    next_level_table = entry & 0x000ffffffffff000

                # make entry
                if is_set_PS(entry):
                    virt_addr = new_va
                    phys_addr = next_level_table
                    page_size = 1 * 1024 * 1024 * 1024
                    page_count = 1
                    PTE.append([virt_addr, phys_addr, page_size, page_count, self.format_flags(flags)])
                    entry_type = "1GB-PAGE"
                else:
                    PDPTE.append([new_va, next_level_table, flags])
                    entry_type = "TABLE"

                # dump
                if self.print_each_level:
                    if self.is_not_trace_target(new_va, new_va_end):
                        continue
                    addr = table_base + i * self.bits["ENTRY_SIZE"]
                    fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                    line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                    if self.is_not_filter_target(line):
                        continue
                    gef_print(line)

        if not self.quiet:
            info("Number of entries: {:d}".format(COUNT))
            info("PDPT Entry: {:d}".format(len(PDPTE)))
            info("PT Entry (1GB): {:d}".format(len(PTE)))
            info("Invalid entries: {:d}".format(COUNT - len(PDPTE) - len(PTE)))
        self.TABLES = PDPTE
        self.PTE += PTE
        return

    def pagewalk_PDT(self):
        if not self.quiet:
            gef_print(titlify("PDE: Page Directory Entry"))

        def is_set_PS(entry):
            return ((entry >> 7) & 1) == 1

        PDE = []
        PTE = []
        COUNT = 0
        for va_base, table_base, parent_flags in self.TABLES:
            entries = self.read_physmem_cache(table_base, 2 ** self.bits["PDT_BITS"] * self.bits["ENTRY_SIZE"])
            entries = slice_unpack(entries, self.bits["ENTRY_SIZE"])
            COUNT += len(entries)
            for i, entry in enumerate(entries):
                # present flag
                if (entry & 1) == 0:
                    continue

                # calc virtual address
                new_va = va_base + (i << (self.bits["PT_BITS"] + self.bits["OFFSET"]))
                new_va_end = new_va + (1 << (self.bits["PT_BITS"] + self.bits["OFFSET"]))

                # calc flags
                flags = parent_flags.copy()
                if ((entry >> 1) & 1) == 0:
                    flags.append("NO_RW")
                if ((entry >> 2) & 1) == 0:
                    flags.append("NO_US")
                if ((entry >> 5) & 1) == 1:
                    flags.append("A")
                if is_set_PS(entry) and ((entry >> 6) & 1) == 1:
                    flags.append("D")
                if is_set_PS(entry) and ((entry >> 8) & 1) == 1:
                    flags.append("G")
                if self.PAE and ((entry >> 63) & 1) == 1:
                    flags.append("XD")

                # calc next table (drop the flag bits)
                if is_x86_64() and is_set_PS(entry):
                    next_level_table = entry & 0x000fffffffffe000
                elif is_x86_32() and is_set_PS(entry):
                    high = (entry >> 13) & 0xf
                    low = (entry >> 22) & 0x3ff
                    next_level_table = (high << 10) | low
                else:
                    next_level_table = entry & 0x000ffffffffff000

                # make entry
                if is_set_PS(entry):
                    virt_addr = new_va
                    phys_addr = next_level_table
                    if self.PAE:
                        page_size = 2 * 1024 * 1024
                        entry_type = "2MB-PAGE"
                    else:
                        page_size = 4 * 1024 * 1024
                        entry_type = "4MB-PAGE"
                    page_count = 1
                    PTE.append([virt_addr, phys_addr, page_size, page_count, self.format_flags(flags)])
                else:
                    PDE.append([new_va, next_level_table, flags])
                    entry_type = "TABLE"

                # dump
                if self.print_each_level:
                    if self.is_not_trace_target(new_va, new_va_end):
                        continue
                    addr = table_base + i * self.bits["ENTRY_SIZE"]
                    fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                    line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                    if self.is_not_filter_target(line):
                        continue
                    gef_print(line)

        if not self.quiet:
            info("Number of entries: {:d}".format(COUNT))
            info("PD Entry: {:d}".format(len(PDE)))
            info("PT Entry ({:d}MB): {:d}".format(2 if self.PAE else 4, len(PTE)))
            info("Invalid entries: {:d}".format(COUNT - len(PDE) - len(PTE)))
        self.TABLES = PDE
        self.PTE += PTE
        return

    def pagewalk_PT(self):
        if not self.quiet:
            gef_print(titlify("PTE: Page Table Entry"))
        PTE = []
        COUNT = 0
        for va_base, table_base, parent_flags in self.TABLES:
            entries = self.read_physmem_cache(table_base, 2 ** self.bits["PT_BITS"] * self.bits["ENTRY_SIZE"])
            entries = slice_unpack(entries, self.bits["ENTRY_SIZE"])
            COUNT += len(entries)
            for i, entry in enumerate(entries):
                # present flag
                if (entry & 1) == 0:
                    continue

                # calc virtual address
                virt_addr = va_base + (i << self.bits["OFFSET"])
                virt_addr_end = virt_addr + (1 << self.bits["OFFSET"])

                # calc flags
                flags = parent_flags.copy()
                if ((entry >> 1) & 1) == 0:
                    flags.append("NO_RW")
                if ((entry >> 2) & 1) == 0:
                    flags.append("NO_US")
                if ((entry >> 5) & 1) == 1:
                    flags.append("A")
                if ((entry >> 6) & 1) == 1:
                    flags.append("D")
                if ((entry >> 8) & 1) == 1:
                    flags.append("G")
                if self.PAE and ((entry >> 63) & 1) == 1:
                    flags.append("XD")

                # calc physical addr (drop the flag bits)
                phys_addr = entry & 0x000ffffffffff000

                # make entry
                page_size = 4 * 1024
                page_count = 1
                PTE.append([virt_addr, phys_addr, page_size, page_count, self.format_flags(flags)])
                entry_type = "4KB-PAGE"

                # dump
                if self.print_each_level:
                    if self.is_not_trace_target(virt_addr, virt_addr_end):
                        continue
                    addr = table_base + i * self.bits["ENTRY_SIZE"]
                    fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                    line = fmt.format(addr, entry, virt_addr, virt_addr_end, entry_type, ' '.join(flags))
                    if self.is_not_filter_target(line):
                        continue
                    gef_print(line)

        if not self.quiet:
            info("Number of entries: {:d}".format(COUNT))
            info("PT Entry (4KB): {:d}".format(len(PTE)))
            info("Invalid entries: {:d}".format(COUNT - len(PTE)))
        self.PTE += PTE
        return

    def pagewalk(self):
        # `info tlb` on qemu-monitor returns pagetable without intermediate pagetable information.
        # for printing it, we will pagewalk manually.
        res = gdb.execute("monitor info registers", to_string=True)
        cr3 = int(re.search(r"CR3=(\S+)", res).group(1), 16)
        cr4 = int(re.search(r"CR4=(\S+)", res).group(1), 16)
        if not self.quiet:
            info("cr3: {:#018x}".format(cr3))
            info("cr4: {:#018x}".format(cr4))

        # virtual address base
        va_base = 0

        # pagewalk base is from CR3 register
        if is_x86_64(): # 64bit
            pagewalk_base = (cr3 >> 12) << 12
        elif ((cr4 >> 5) & 1) == 1: # 32bit PAE
            pagewalk_base = (cr3 >> 5) << 5
        else: # 32bit non-PAE
            pagewalk_base = (cr3 >> 12) << 12

        # we ignore PWT and PCD flags.
        flags = []

        # do pagewalk
        self.PTE = []
        self.TABLES = [(va_base, pagewalk_base, flags)]
        if is_x86_64():
            if (cr4 >> 12) & 1: # PML5T check
                # 64bit 5-level(4KB): 9,9,9,9,9,12
                # 64bit 5-level(2MB): 9,9,9,9,0,21
                # 64bit 5-level(1GB): 9,9,9,0,0,30
                if not self.quiet:
                    info("64-bit 5 level page table")
                self.bits = {
                    "ENTRY_SIZE": 8,
                    "PML5T_BITS": 9, "PML4T_BITS": 9, "PDPT_BITS": 9, "PDT_BITS": 9, "PT_BITS": 9, "OFFSET": 12,
                }
                self.PAE = True
                self.pagewalk_PML5T()
                self.pagewalk_PML4T()
                self.pagewalk_PDPT()
                self.pagewalk_PDT()
                self.pagewalk_PT()
            else:
                # 64bit 4-level(4KB): 9,9,9,9,12
                # 64bit 4-level(2MB): 9,9,9,0,21
                # 64bit 4-level(1GB): 9,9,0,0,30
                if not self.quiet:
                    info("64-bit 4 level page table")
                self.bits = {
                    "ENTRY_SIZE": 8,
                    "PML4T_BITS": 9, "PDPT_BITS": 9, "PDT_BITS": 9, "PT_BITS": 9, "OFFSET": 12,
                }
                self.PAE = True
                self.pagewalk_PML4T()
                self.pagewalk_PDPT()
                self.pagewalk_PDT()
                self.pagewalk_PT()
        elif is_x86_32():
            if (cr4 >> 5) & 1: # PAE check
                # 32bit PAE(4KB): 2,9,9,12 (PTE Size: 64bit)
                # 32bit PAE(2MB): 2,9,0,21 (PTE Size: 64bit)
                if not self.quiet:
                    info("32-bit {:s} page table".format(Color.boldify("PAE")))
                self.bits = {
                    "ENTRY_SIZE": 8,
                    "PDPT_BITS": 2, "PDT_BITS": 9, "PT_BITS": 9, "OFFSET": 12,
                }
                self.PAE = True
                self.pagewalk_PDPT()
                self.pagewalk_PDT()
                self.pagewalk_PT()
            else:
                # 32bit(4KB): 10,10,12
                # 32bit(4MB): 10,0,22
                if not self.quiet:
                    info("32-bit Non-PAE page table")
                self.bits = {
                    "ENTRY_SIZE": 4,
                    "PDT_BITS": 10, "PT_BITS": 10, "OFFSET": 12,
                }
                self.PAE = False
                self.pagewalk_PDT()
                self.pagewalk_PT()
        else:
            err("Unsupported")
            return

        if not self.quiet:
            gef_print(titlify("Total"))
            info("PT Entry (Total): {:d}".format(len(self.PTE)))
        self.mappings = self.PTE
        self.print_page()
        return

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        try:
            argv = self.parse_common_args(argv)
            if argv:
                raise
        except Exception:
            self.usage()
            return
        self.mappings = None
        self.pagewalk()
        self.cache = {}
        return


@register_command
class PagewalkArmCommand(PagewalkCommand):
    """Dump pagetable for ARM (Cortex-A only) using qemu-monitor."""
    _cmdline_ = "pagewalk arm"
    _syntax_ = "{:s} [-h] [-q] [-S|-s] [--print-each-level] [--no-merge] [--filter REGEX] ".format(_cmdline_)
    _syntax_ += "[--vrange ADDR] [--prange ADDR] [--sort-by-phys] [--simple] [--trace ADDR]"
    _example_ = "\n"
    _example_ += "{:s} --print-each-level # show all level pagetables\n".format(_cmdline_)
    _example_ += "{:s} --no-merge         # do not merge similar/consecutive address\n".format(_cmdline_)
    _example_ += "{:s} --filter 0xabc     # grep by REGEX pattern\n".format(_cmdline_)
    _example_ += "{:s} --vrange 0x7fff00  # filter by map included specified virtual address\n".format(_cmdline_)
    _example_ += "{:s} --prange 0x7fff00  # filter by map included specified physical address\n".format(_cmdline_)
    _example_ += "{:s} --sort-by-phys     # sort by physical address\n".format(_cmdline_)
    _example_ += "{:s} --simple           # merge with ignoring physical address consecutivness\n".format(_cmdline_)
    _example_ += "{:s} --trace 0x7fff00   # show all level pagetables only associated specified address\n".format(_cmdline_)
    _example_ += "{:s} -q                 # show result only (quiet)\n".format(_cmdline_)
    _example_ += "{:s} -S                 # use TTBRn_ELm_S for parsing start register\n".format(_cmdline_)
    _example_ += "{:s} -s                 # use TTBRn_ELm for parsing start register\n".format(_cmdline_)
    _example_ += "PL2 pagewalk is unsupported"
    _category_ = "Qemu-system Cooperation"

    def __init__(self):
        super().__init__(prefix=False)
        return

    def format_flags_short(self, flag_info):
        flags = []

        XN = "XN" in flag_info
        PXN = "PXN" in flag_info
        PXN &= self.PXN

        # AP[2:0] access permissions model
        if "AP=000" in flag_info:
            if XN is False and PXN is False:
                flags += ['PL0/---', "PL1/---"] #
            elif XN is False and PXN is True:
                flags += ['PL0/---', "PL1/---"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/---', "PL1/---"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/---', "PL1/---"] # XN, PXN
        elif "AP=001" in flag_info:
            if XN is False and PXN is False:
                flags += ['PL0/---', "PL1/RWX"] #
            elif XN is False and PXN is True:
                flags += ['PL0/---', "PL1/RW-"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/---', "PL1/RW-"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/---', "PL1/RW-"] # XN, PXN
        elif "AP=010" in flag_info:
            if XN is False and PXN is False:
                flags += ['PL0/R-X', "PL1/RWX"] #
            elif XN is False and PXN is True:
                flags += ['PL0/R-X', "PL1/RW-"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/R--', "PL1/RW-"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/R--', "PL1/RW-"] # XN, PXN
        elif "AP=011" in flag_info:
            if XN is False and PXN is False:
                flags += ['PL0/RWX', "PL1/RWX"] #
            elif XN is False and PXN is True:
                flags += ['PL0/RWX', "PL1/RW-"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/RW-', "PL1/RW-"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/RW-', "PL1/RW-"] # XN, PXN
        elif "AP=100" in flag_info:
            flags += ['PL0/???', "PL1/???"] # undefined (reserved)
        elif "AP=101" in flag_info:
            if XN is False and PXN is False:
                flags += ['PL0/---', "PL1/R-X"] #
            elif XN is False and PXN is True:
                flags += ['PL0/---', "PL1/R--"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/---', "PL1/R--"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/---', "PL1/R--"] # XN, PXN
        elif "AP=110" in flag_info: # deprecated
            if XN is False and PXN is False:
                flags += ['PL0/R-X', "PL1/R-X"] #
            elif XN is False and PXN is True:
                flags += ['PL0/R-X', "PL1/R--"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/R--', "PL1/R--"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/R--', "PL1/R--"] # XN, PXN
        elif "AP=111" in flag_info:
            if XN is False and PXN is False:
                flags += ['PL0/R-X', "PL1/R-X"] #
            elif XN is False and PXN is True:
                flags += ['PL0/R-X', "PL1/R--"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/R--', "PL1/R--"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/R--', "PL1/R--"] # XN, PXN
        # AP[2:1] access permissions model
        elif "AP=00" in flag_info:
            if XN is False and PXN is False:
                flags += ['PL0/---', "PL1/RWX"] #
            elif XN is False and PXN is True:
                flags += ['PL0/---', "PL1/RW-"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/---', "PL1/RW-"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/---', "PL1/RW-"] # XN, PXN
        elif "AP=01" in flag_info:
            if XN is False and PXN is False:
                flags += ['PL0/RWX', "PL1/RWX"] #
            elif XN is False and PXN is True:
                flags += ['PL0/RWX', "PL1/RW-"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/RW-', "PL1/RW-"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/RW-', "PL1/RW-"] # XN, PXN
        elif "AP=10" in flag_info:
            if XN is False and PXN is False:
                flags += ['PL0/---', "PL1/R-X"] #
            elif XN is False and PXN is True:
                flags += ['PL0/---', "PL1/R--"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/---', "PL1/R--"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/---', "PL1/R--"] # XN, PXN
        elif "AP=11" in flag_info:
            if XN is False and PXN is False:
                flags += ['PL0/R-X', "PL1/R-X"] #
            elif XN is False and PXN is True:
                flags += ['PL0/R-X', "PL1/R--"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/R--', "PL1/R--"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/R--', "PL1/R--"] # XN, PXN

        if "NS" in flag_info:
            flags += ['NS']
        # short description has no `AF` bit
        if "nG" not in flag_info:
            flags += ["GLOBAL"]
        return ' '.join(flags)

    def format_flags_long(self, flag_info):
        flags = []

        # AP/APTable parsing
        if "AP=00" in flag_info:
            disable_write_access = 0
            enable_unpriv_access = 0
        elif "AP=01" in flag_info:
            disable_write_access = 0
            enable_unpriv_access = 1
        elif "AP=10" in flag_info:
            disable_write_access = 1
            enable_unpriv_access = 0
        elif "AP=11" in flag_info:
            disable_write_access = 1
            enable_unpriv_access = 1
        if "APTable2=00" in flag_info:
            pass
        elif "APTable2=01" in flag_info:
            enable_unpriv_access &= 0
        elif "APTable2=10" in flag_info:
            disable_write_access |= 1
        elif "APTable2=11" in flag_info:
            disable_write_access |= 1
            enable_unpriv_access &= 0
        if "APTable1=00" in flag_info:
            pass
        elif "APTable1=01" in flag_info:
            enable_unpriv_access &= 0
        elif "APTable1=10" in flag_info:
            disable_write_access |= 1
        elif "APTable1=11" in flag_info:
            disable_write_access |= 1
            enable_unpriv_access &= 0
        AP = (disable_write_access << 1) | enable_unpriv_access

        # XN/XNTable, PXN/PXNTable, NS/NSTable parsing
        XN = "XN" in flag_info
        XN |= "XNTable2" in flag_info
        XN |= "XNTable1" in flag_info
        PXN = "PXN" in flag_info
        PXN |= "PXNTable2" in flag_info
        PXN |= "PXNTable1" in flag_info
        PXN &= self.PXN
        NS = "NS" in flag_info
        NS |= "NSTable2" in flag_info
        NS |= "NSTable1" in flag_info

        # AP[2:1] access permissions model
        if AP == 0b00:
            if XN is False and PXN is False:
                flags += ['PL0/---', "PL1/RWX"] #
            elif XN is False and PXN is True:
                flags += ['PL0/---', "PL1/RW-"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/---', "PL1/RW-"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/---', "PL1/RW-"] # XN, PXN
        elif AP == 0b01:
            if XN is False and PXN is False:
                flags += ['PL0/RWX', "PL1/RWX"] #
            elif XN is False and PXN is True:
                flags += ['PL0/RWX', "PL1/RW-"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/RW-', "PL1/RW-"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/RW-', "PL1/RW-"] # XN, PXN
        elif AP == 0b10:
            if XN is False and PXN is False:
                flags += ['PL0/---', "PL1/R-X"] #
            elif XN is False and PXN is True:
                flags += ['PL0/---', "PL1/R--"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/---', "PL1/R--"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/---', "PL1/R--"] # XN, PXN
        elif AP == 0b11:
            if XN is False and PXN is False:
                flags += ['PL0/R-X', "PL1/R-X"] #
            elif XN is False and PXN is True:
                flags += ['PL0/R-X', "PL1/R--"] # PXN
            elif XN is True and PXN is False:
                flags += ['PL0/R--', "PL1/R--"] # XN
            elif XN is True and PXN is True:
                flags += ['PL0/R--', "PL1/R--"] # XN, PXN

        if NS:
            flags += ['NS']
        if "AF" in flag_info:
            flags += ['ACCESSED']
        if "nG" not in flag_info:
            flags += ["GLOBAL"]
        return ' '.join(flags)

    def do_pagewalk_short(self, table_base, va_base=0):
        self.mappings = []

        def has_next_level(entry):
            return (entry & 0b11) == 0b01

        def is_section(entry):
            return (entry & 0b11) in [0b10, 0b11] and ((entry >> 18) & 1) == 0

        def is_super_section(entry):
            return (entry & 0b11) in [0b10, 0b11] and ((entry >> 18) & 1) == 1

        def is_large_page(entry):
            return (entry & 0b11) == 0b01

        def is_small_page(entry):
            return (entry & 0b11) in [0b10, 0b11]

        # 1st level parse
        if not self.quiet:
            gef_print(titlify("LEVEL 1"))
        LEVEL1 = []
        SECTION = []
        SUPER_SECTION = []
        COUNT = 0
        entries = self.read_physmem_cache(table_base, 4 * (2 ** (12 - self.N)))
        entries = slice_unpack(entries, 4)
        COUNT += len(entries)
        for i, entry in enumerate(entries):
            # present flag
            if (entry & 0b11) == 0b00:
                continue

            # calc virtual address
            new_va = va_base + (i << 20)
            new_va_end = new_va + (1 << 20)

            # calc flags
            flags = []
            if has_next_level(entry):
                if ((entry >> 2) & 1) == 1:
                    flags.append("PXN")
                if ((entry >> 3) & 1) == 1:
                    flags.append("NS")
                flags.append("domain={:#x}".format((entry >> 5) & 0b1111))
            elif is_section(entry):
                if ((entry >> 0) & 1) == 1:
                    flags.append("PXN")
                if ((entry >> 2) & 1) == 1:
                    flags.append("B")
                if ((entry >> 3) & 1) == 1:
                    flags.append("C")
                if ((entry >> 4) & 1) == 1:
                    flags.append("XN")
                flags.append("domain={:#x}".format((entry >> 5) & 0b1111))
                ap = (((entry >> 15) & 1) << 2) + ((entry >> 10) & 0b11)
                if self.AFE: # AP[2:1] access permissions model
                    flags.append("AP={:02b}".format(ap >> 1))
                else: # AP[2:0] access permissions model
                    flags.append("AP={:03b}".format(ap))
                flags.append("TEX={:#x}".format((entry >> 12) & 0b111))
                if ((entry >> 16) & 1) == 1:
                    flags.append("S")
                if ((entry >> 17) & 1) == 1:
                    flags.append("nG")
                if ((entry >> 19) & 1) == 1:
                    flags.append("NS")
            elif is_super_section(entry):
                if ((entry >> 0) & 1) == 1:
                    flags.append("PXN")
                if ((entry >> 2) & 1) == 1:
                    flags.append("B")
                if ((entry >> 3) & 1) == 1:
                    flags.append("C")
                if ((entry >> 4) & 1) == 1:
                    flags.append("XN")
                ap = (((entry >> 15) & 1) << 2) + ((entry >> 10) & 0b11)
                if self.AFE: # AP[2:1] access permissions model
                    flags.append("AP={:02b}".format(ap >> 1))
                else: # AP[2:0] access permissions model
                    flags.append("AP={:03b}".format(ap))
                flags.append("TEX={:#x}".format((entry >> 12) & 0b111))
                if ((entry >> 16) & 1) == 1:
                    flags.append("S")
                if ((entry >> 17) & 1) == 1:
                    flags.append("nG")
                if ((entry >> 19) & 1) == 1:
                    flags.append("NS")

            # calc next table (drop the flag bits)
            if has_next_level(entry):
                next_level_table = entry & 0xfffffc00
            elif is_section(entry):
                next_level_table = entry & 0xfff00000
            elif is_super_section(entry):
                next_level_table = entry & 0xff000000         # PA[31:24]
                next_level_table += (entry & 0x00f0000) << 12 # PA[35:32]
                next_level_table += (entry & 0x00001e0) << 31 # PA[39:36]

            # make entry
            if has_next_level(entry):
                LEVEL1.append([new_va, next_level_table, flags])
                entry_type = "TABLE"
            elif is_section(entry):
                virt_addr = new_va
                phys_addr = next_level_table
                page_size = 1 * 1024 * 1024
                page_count = 1
                SECTION.append([virt_addr, phys_addr, page_size, page_count, self.format_flags_short(flags)])
                entry_type = "SECTION"
            elif is_super_section(entry):
                virt_addr = new_va
                phys_addr = next_level_table
                page_size = 16 * 1024 * 1024
                page_count = 1
                SUPER_SECTION.append([virt_addr, phys_addr, page_size, page_count, self.format_flags_short(flags)])
                entry_type = "SUPER_SECTION"

            # dump
            if self.print_each_level:
                if self.is_not_trace_target(new_va, new_va_end):
                    continue
                addr = table_base + i * 4
                fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                if self.is_not_filter_target(line):
                    continue
                gef_print(line)

        if not self.quiet:
            info("Number of entries: {:d}".format(COUNT))
            info("Level 1 Entry: {:d}".format(len(LEVEL1)))
            info("PT Entry (supersection; 16MB): {:d}".format(len(SUPER_SECTION)))
            info("PT Entry (section; 1MB): {:d}".format(len(SECTION)))
            info("Invalid entries: {:d}".format(COUNT - len(LEVEL1) - len(SUPER_SECTION) - len(SECTION)))
        self.mappings += SECTION + SUPER_SECTION

        # 2nd level parse
        if not self.quiet:
            gef_print(titlify("LEVEL 2"))
        LARGE = []
        SMALL = []
        COUNT = 0
        for va_base, table_base, parent_flags in LEVEL1:
            entries = self.read_physmem_cache(table_base, 4 * (2 ** 8))
            entries = slice_unpack(entries, 4)
            COUNT += len(entries)
            for i, entry in enumerate(entries):
                # present flag
                if (entry & 0b11) == 0b00:
                    continue

                # calc virtual address
                virt_addr = va_base + (i << 12)
                virt_addr_end = virt_addr + (1 << 12)

                # calc flags
                flags = parent_flags.copy()
                if is_large_page(entry):
                    if ((entry >> 2) & 1) == 1:
                        flags.append("B")
                    if ((entry >> 3) & 1) == 1:
                        flags.append("C")
                    ap = (((entry >> 9) & 1) << 2) + ((entry >> 4) & 0b11)
                    if self.AFE: # AP[2:1] access permissions model
                        flags.append("AP={:02b}".format(ap >> 1))
                    else: # AP[2:0] access permissions model
                        flags.append("AP={:03b}".format(ap))
                    if ((entry >> 10) & 1) == 1:
                        flags.append("S")
                    if ((entry >> 11) & 1) == 1:
                        flags.append("nG")
                    flags.append("TEX={:#x}".format((entry >> 12) & 0b111))
                    if ((entry >> 15) & 1) == 1:
                        flags.append("XN")
                elif is_small_page(entry):
                    if ((entry >> 0) & 1) == 1:
                        flags.append("XN")
                    if ((entry >> 2) & 1) == 1:
                        flags.append("B")
                    if ((entry >> 3) & 1) == 1:
                        flags.append("C")
                    ap = (((entry >> 9) & 1) << 2) + ((entry >> 4) & 0b11)
                    if self.AFE: # AP[2:1] access permissions model
                        flags.append("AP={:02b}".format(ap >> 1))
                    else: # AP[2:0] access permissions model
                        flags.append("AP={:03b}".format(ap))
                    flags.append("TEX={:#x}".format((entry >> 6) & 0b111))
                    if ((entry >> 10) & 1) == 1:
                        flags.append("S")
                    if ((entry >> 11) & 1) == 1:
                        flags.append("nG")

                # calc physical addr (drop the flag bits)
                if is_large_page(entry):
                    phys_addr = entry & 0xffff0000
                elif is_small_page(entry):
                    phys_addr = entry & 0xfffff000

                # make entry
                if is_large_page(entry):
                    page_size = 64 * 1024
                    page_count = 1
                    LARGE.append([virt_addr, phys_addr, page_size, page_count, self.format_flags_short(flags)])
                    entry_type = "LARGE"
                elif is_small_page(entry):
                    page_size = 4 * 1024
                    page_count = 1
                    SMALL.append([virt_addr, phys_addr, page_size, page_count, self.format_flags_short(flags)])
                    entry_type = "SMALL"

                # dump
                if self.print_each_level:
                    if self.is_not_trace_target(virt_addr, virt_addr_end):
                        continue
                    addr = table_base + i * 4
                    fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                    line = fmt.format(addr, entry, virt_addr, virt_addr_end, entry_type, ' '.join(flags))
                    if self.is_not_filter_target(line):
                        continue
                    gef_print(line)

        if not self.quiet:
            info("Number of entries: {:d}".format(COUNT))
            info("PT Entry (large; 64KB): {:d}".format(len(LARGE)))
            info("PT Entry (small; 4KB): {:d}".format(len(SMALL)))
            info("Invalid entries: {:d}".format(COUNT - len(LARGE) - len(SMALL)))
        self.mappings += LARGE + SMALL

        if not self.quiet:
            gef_print(titlify("Total"))
            info("PT Entry (Total): {:d}".format(len(self.mappings)))
        self.mappings = sorted(self.mappings)
        return

    def do_pagewalk_long(self, table_base, va_base=0):
        self.mappings = []

        def has_next_level(entry):
            return (entry & 0b11) == 0b11

        def is_1GB_page(entry):
            return (entry & 0b11) == 0b01

        def is_2MB_page(entry):
            return (entry & 0b11) == 0b01

        if not self.quiet:
            gef_print(titlify("LEVEL 1"))
        if self.N < 2:
            # 1st level parse
            LEVEL1 = []
            GB = []
            COUNT = 0
            entries = self.read_physmem_cache(table_base, 8 * (2 ** 2))
            entries = slice_unpack(entries, 8)
            COUNT += len(entries)
            for i, entry in enumerate(entries):
                # present flag
                if (entry & 1) == 0:
                    continue

                # calc virtual address
                new_va = va_base | (i << 30)
                new_va_end = new_va + (1 << 30)

                # calc flags
                flags = []
                if has_next_level(entry):
                    if ((entry >> 59) & 1) == 1:
                        flags.append("PXNTable1")
                    if ((entry >> 60) & 1) == 1:
                        flags.append("XNTable1")
                    flags.append("APTable1={:02b}".format((entry >> 61) & 0b11))
                    if ((entry >> 63) & 1) == 1:
                        flags.append("NSTable1")
                elif is_1GB_page(entry):
                    flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                    if ((entry >> 5) & 1) == 1:
                        flags.append("NS")
                    flags.append("AP={:02b}".format((entry >> 6) & 0b11))
                    flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                    if ((entry >> 10) & 1) == 1:
                        flags.append("AF")
                    if ((entry >> 11) & 1) == 1:
                        flags.append("nG")
                    if ((entry >> 52) & 1) == 1:
                        flags.append("Contiguous")
                    if ((entry >> 53) & 1) == 1:
                        flags.append("PXN")
                    if ((entry >> 54) & 1) == 1:
                        flags.append("XN")

                # calc next table (drop the flag bits)
                if has_next_level(entry):
                    next_level_table = entry & 0x000000fffffff000
                elif is_1GB_page(entry):
                    next_level_table = entry & 0x000000ffc0000000

                # make entry
                if has_next_level(entry):
                    LEVEL1.append([new_va, next_level_table, flags])
                    entry_type = "TABLE"
                elif is_1GB_page(entry):
                    virt_addr = new_va
                    phys_addr = next_level_table
                    page_size = 1 * 1024 * 1024 * 1024
                    page_count = 1
                    GB.append([virt_addr, phys_addr, page_size, page_count, self.format_flags_long(flags)])
                    entry_type = "1GB-PAGE"

                # dump
                if self.print_each_level:
                    if self.is_not_trace_target(new_va, new_va_end):
                        continue
                    addr = table_base + i * 8
                    fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                    line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                    if self.is_not_filter_target(line):
                        continue
                    gef_print(line)

            if not self.quiet:
                info("Number of entries: {:d}".format(COUNT))
                info("Level 1 Entry: {:d}".format(len(LEVEL1)))
                info("PT Entry (1GB): {:d}".format(len(GB)))
                info("Invalid entries: {:d}".format(COUNT - len(LEVEL1) - len(GB)))
            self.mappings += GB
        else:
            if not self.quiet:
                info("LEVEL 1 is skipped")
            flags = []
            LEVEL1 = [[va_base, table_base, flags]]

        # 2nd level parse
        if not self.quiet:
            gef_print(titlify("LEVEL 2"))
        LEVEL2 = []
        MB = []
        COUNT = 0
        for va_base, table_base, parent_flags in LEVEL1:
            entries = self.read_physmem_cache(table_base, 8 * (2 ** 9))
            entries = slice_unpack(entries, 8)
            COUNT += len(entries)
            for i, entry in enumerate(entries):
                # present flag
                if (entry & 1) == 0:
                    continue

                # calc virtual address
                new_va = va_base | (i << 21)
                new_va_end = new_va + (1 << 21)

                # calc flags
                flags = parent_flags.copy()
                if has_next_level(entry):
                    if ((entry >> 59) & 1) == 1:
                        flags.append("PXNTable2")
                    if ((entry >> 60) & 1) == 1:
                        flags.append("XNTable2")
                    flags.append("APTable2={:02b}".format((entry >> 61) & 0b11))
                    if ((entry >> 63) & 1) == 1:
                        flags.append("NSTable2")
                elif is_2MB_page(entry):
                    flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                    if ((entry >> 5) & 1) == 1:
                        flags.append("NS")
                    flags.append("AP={:02b}".format((entry >> 6) & 0b11))
                    flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                    if ((entry >> 10) & 1) == 1:
                        flags.append("AF")
                    if ((entry >> 11) & 1) == 1:
                        flags.append("nG")
                    if ((entry >> 52) & 1) == 1:
                        flags.append("Contiguous")
                    if ((entry >> 53) & 1) == 1:
                        flags.append("PXN")
                    if ((entry >> 54) & 1) == 1:
                        flags.append("XN")

                # calc next table (drop the flag bits)
                if has_next_level(entry):
                    next_level_table = entry & 0x000000fffffff000
                elif is_2MB_page(entry):
                    next_level_table = entry & 0x000000ffffe00000

                # make entry
                if has_next_level(entry):
                    LEVEL2.append([new_va, next_level_table, flags])
                    entry_type = "TABLE"
                elif is_2MB_page(entry):
                    virt_addr = new_va
                    phys_addr = next_level_table
                    page_size = 2 * 1024 * 1024
                    page_count = 1
                    MB.append([virt_addr, phys_addr, page_size, page_count, self.format_flags_long(flags)])
                    entry_type = "2MB-PAGE"

                # dump
                if self.print_each_level:
                    if self.is_not_trace_target(new_va, new_va_end):
                        continue
                    addr = table_base + i * 8
                    fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                    line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                    if self.is_not_filter_target(line):
                        continue
                    gef_print(line)

        if not self.quiet:
            info("Number of entries: {:d}".format(COUNT))
            info("Level 2 Entry: {:d}".format(len(LEVEL2)))
            info("PT Entry (2MB): {:d}".format(len(MB)))
            info("Invalid entries: {:d}".format(COUNT - len(LEVEL2) - len(MB)))
        self.mappings += MB

        # 3rd level parse
        if not self.quiet:
            gef_print(titlify("LEVEL 3"))
        KB = []
        COUNT = 0
        for va_base, table_base, parent_flags in LEVEL2:
            entries = self.read_physmem_cache(table_base, 8 * (2 ** 9))
            entries = slice_unpack(entries, 8)
            COUNT += len(entries)
            for i, entry in enumerate(entries):
                # present flag
                if (entry & 0b11) != 0b11:
                    continue

                # calc virtual address
                virt_addr = va_base | (i << 12)
                virt_addr_end = virt_addr + (1 << 12)

                # calc flags
                flags = parent_flags.copy()
                flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                if ((entry >> 5) & 1) == 1:
                    flags.append("NS")
                flags.append("AP={:02b}".format((entry >> 6) & 0b11))
                flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                if ((entry >> 10) & 1) == 1:
                    flags.append("AF")
                if ((entry >> 11) & 1) == 1:
                    flags.append("nG")
                if ((entry >> 52) & 1) == 1:
                    flags.append("Contiguous")
                if ((entry >> 53) & 1) == 1:
                    flags.append("PXN")
                if ((entry >> 54) & 1) == 1:
                    flags.append("XN")

                # calc physical addr (drop the flag bits)
                phys_addr = entry & 0x000000fffffff000

                # make entry
                page_size = 4 * 1024
                page_count = 1
                KB.append([virt_addr, phys_addr, page_size, page_count, self.format_flags_long(flags)])
                entry_type = "1KB-PAGE"

                # dump
                if self.print_each_level:
                    if self.is_not_trace_target(virt_addr, virt_addr_end):
                        continue
                    addr = table_base + i * 8
                    fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                    line = fmt.format(addr, entry, virt_addr, virt_addr_end, entry_type, ' '.join(flags))
                    if self.is_not_filter_target(line):
                        continue
                    gef_print(line)

        if not self.quiet:
            info("Number of entries: {:d}".format(COUNT))
            info("PT Entry (4KB): {:d}".format(len(KB)))
            info("Invalid entries: {:d}".format(COUNT - len(KB)))
        self.mappings += KB

        if not self.quiet:
            gef_print(titlify("Total"))
            info("PT Entry (Total): {:d}".format(len(self.mappings)))
        self.mappings = sorted(self.mappings)
        return

    def pagewalk_short(self):
        gef_print(titlify("$TTBR0_EL1{}".format(self.suffix)))

        TTBR0_EL1 = get_register('$TTBR0_EL1{}'.format(self.suffix))
        if TTBR0_EL1 is None:
            err('$TTBR0_EL1{} is not found'.format(self.suffix))
            return

        TTBR1_EL1 = get_register('$TTBR1_EL1{}'.format(self.suffix))
        if TTBR1_EL1 is None:
            err('$TTBR1_EL1{} is not found'.format(self.suffix))
            return

        TTBCR = get_register('$TTBCR{}'.format(self.suffix))
        if TTBCR is None:
            err('$TTBCR{} is not found'.format(self.suffix))
            return

        # pagewalk TTBR0_EL1
        self.N = TTBCR & 0b111
        ml = 14 - self.N
        pl0_base = ((TTBR0_EL1 & ((1 << 32) - 1)) >> ml) << ml
        if not self.quiet:
            info("$TTBR0_EL1{}: {:#x}".format(self.suffix, TTBR0_EL1))
            info("$TTBCR{}: {:#x}".format(self.suffix, TTBCR))
            info("PL0 base: {:#x}".format(pl0_base))
        self.do_pagewalk_short(pl0_base)
        self.print_page()

        # pagewalk TTBR1_EL1
        gef_print(titlify("$TTBR1_EL1{}".format(self.suffix)))
        if self.suffix:
            pl1_vabase = 0 # I don't know why, but vabase of PL1 seems to be 0x0 when using TTBR1_EL1_S.
        else:
            pl1_vabase = {
                0: None, 1: 0x80000000, 2: 0x40000000, 3: 0x20000000,
                4: 0x10000000, 5: 0x08000000, 6: 0x04000000, 7: 0x02000000
            }[self.N]
        pl1_base = ((TTBR1_EL1 & ((1 << 32) - 1)) >> ml) << ml
        self.N = 0 # Whenever TTBCR.N is nonzero, the size of the translation table addressed by TTBR1 is 16KB (N=0).
        if pl1_vabase is not None:
            if not self.quiet:
                info("$TTBR1_EL1{}: {:#x}".format(self.suffix, TTBR1_EL1))
                info("$TTBCR{}: {:#x}".format(self.suffix, TTBCR))
                info("PL1 base: {:#x}".format(pl1_base))
                info("PL1 va_base: {:#x}".format(pl1_vabase))
            self.do_pagewalk_short(pl1_base, pl1_vabase)
            self.print_page()
        else:
            if not self.quiet:
                info("$TTBR1_EL1{} is unused".format(self.suffix))
        return

    def pagewalk_long(self):
        gef_print(titlify("$TTBR0_EL1{}".format(self.suffix)))

        TTBR0_EL1 = get_register('$TTBR0_EL1{}'.format(self.suffix))
        if TTBR0_EL1 is None:
            err('$TTBR0_EL1{} is not found'.format(self.suffix))
            return

        TTBR1_EL1 = get_register('$TTBR1_EL1{}'.format(self.suffix))
        if TTBR1_EL1 is None:
            err('$TTBR1_EL1{} is not found'.format(self.suffix))
            return

        TTBCR = get_register('$TTBCR{}'.format(self.suffix))
        if TTBCR is None:
            err('$TTBCR{} is not found'.format(self.suffix))
            return

        # pagewalk TTBR0_EL1
        T0SZ = TTBCR & 0b111
        T1SZ = (TTBCR >> 16) & 0b111
        self.N = T0SZ
        pl0_base = TTBR0_EL1 & ((1 << 40) - 1)
        if not self.quiet:
            info("$TTBR0_EL1{}: {:#x}".format(self.suffix, TTBR0_EL1))
            info("$TTBCR{}: {:#x}".format(self.suffix, TTBCR))
            info("PL0 base: {:#x}".format(pl0_base))
        self.do_pagewalk_long(pl0_base)
        self.print_page()

        # pagewalk TTBR1_EL1
        gef_print(titlify("$TTBR1_EL1{}".format(self.suffix)))
        if T0SZ != 0 or T1SZ != 0:
            self.N = T1SZ
            pl1_base = TTBR1_EL1 & ((1 << 40) - 1)
            if T1SZ == 0:
                pl1_vabase = 2 ** (32 - T0SZ)
            else:
                pl1_vabase = (2 ** 32) - (2 ** (32 - T1SZ))
            if not self.quiet:
                info("$TTBR1_EL1{}: {:#x}".format(self.suffix, TTBR1_EL1))
                info("PL1 base: {:#x}".format(pl1_base))
                info("PL1 va_base: {:#x}".format(pl1_vabase))
            self.do_pagewalk_long(pl1_base, pl1_vabase)
            self.print_page()
        else:
            if not self.quiet:
                info("$TTBR1_EL1{} is unused".format(self.suffix))
        return

    def pagewalk(self):
        res = gdb.execute("info registers", to_string=True)
        if "TTBR" not in res:
            err("Not found system registers. Check qemu version (at least: 3.x~, recommend: 5.x~).")
            return

        # check Secure mode
        if self.FORCE_PREFIX_S is None:
            # auto detect
            SCR = get_register('$SCR_S')
            if SCR is None:
                SCR = get_register('$SCR')
            if SCR is not None:
                self.SECURE = (SCR & 0x1) == 0 # NS bit
            else:
                self.SECURE = False
            self.suffix = "_S" if self.SECURE else ""
        elif self.FORCE_PREFIX_S is True:
            # use "_S"
            SCR = get_register('$SCR_S')
            if SCR is not None:
                self.SECURE = (SCR & 0x1) == 0 # NS bit
            else:
                self.SECURE = False
            self.suffix = "_S"
        elif self.FORCE_PREFIX_S is False:
            # do not use "_S"
            SCR = get_register('$SCR')
            if SCR is not None:
                self.SECURE = (SCR & 0x1) == 0 # NS bit
            else:
                self.SECURE = False
            self.suffix = ""
        if not self.quiet:
            info("Secure world: {}".format(self.SECURE))

        # check AFE
        SCTLR = get_register('$SCTLR{}'.format(self.suffix))
        if SCTLR is not None:
            self.AFE = ((SCTLR >> 29) & 0x1) == 1
        else:
            self.AFE = False

        # check enabled LPAE
        TTBCR = get_register('$TTBCR{}'.format(self.suffix))
        if TTBCR is not None:
            self.LPAE = ((TTBCR >> 31) & 0x1) == 1
            self.PTE_SIZE = 8 if self.LPAE else 4
        else:
            self.LPAE = False

        # check PXN supported
        ID_MMFR0 = get_register('$ID_MMFR0{}'.format(self.suffix))
        if ID_MMFR0 is not None:
            self.PXN = ((ID_MMFR0 >> 2) & 0x1) == 1
        else:
            self.PXN = False

        if not self.quiet:
            if self.PXN:
                info("{:s} is supported".format(Color.boldify("PXN")))
            else:
                info("PXN is unsupported")
            info("PAN is unimplemented on all ARMv7")

        # pagewalk
        if self.LPAE:
            if not self.quiet:
                info("{:s} is enabled (using long description)".format(Color.boldify("LPAE")))
            self.pagewalk_long()
        else:
            if not self.quiet:
                info("LPAE is disabled (using short description)")
            self.pagewalk_short()
        return

    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        if not is_arm32():
            err("Unsupported")
            return

        self.FORCE_PREFIX_S = None
        if "-S" in argv and "-s" in argv:
            self.usage()
            return
        elif "-S" in argv:
            self.FORCE_PREFIX_S = True
            argv.remove("-S")
        elif "-s" in argv:
            self.FORCE_PREFIX_S = False
            argv.remove("-s")

        try:
            argv = self.parse_common_args(argv)
            if argv:
                raise
        except Exception:
            self.usage()
            return
        self.mappings = None
        self.pagewalk()
        self.cache = {}
        return


@register_command
class PagewalkArm64Command(PagewalkCommand):
    """Dump pagetable for ARM64 using qemu-monitor (for ARMv8.3)."""
    _cmdline_ = "pagewalk arm64"
    _syntax_ = "{:s} [-h] [-q] [TARGET_EL] [--print-each-level] [--no-merge] [--filter REGEX] ".format(_cmdline_)
    _syntax_ += "[--vrange ADDR] [--prange ADDR] [--sort-by-phys] [--simple] [--trace ADDR]"
    _example_ = "\n"
    _example_ += "{:s} --print-each-level # for current EL, show all level pagetables\n".format(_cmdline_)
    _example_ += "{:s} 1 --no-merge       # for EL1+0, do not merge similar/consecutive address\n".format(_cmdline_)
    _example_ += "{:s} 2 --filter 0xabc   # for EL2, grep by REGEX pattern\n".format(_cmdline_)
    _example_ += "{:s} --vrange 0x7fff00  # filter by map included specified virtual address\n".format(_cmdline_)
    _example_ += "{:s} --prange 0x7fff00  # filter by map included specified physical address\n".format(_cmdline_)
    _example_ += "{:s} --sort-by-phys     # for current EL, sort by physical address\n".format(_cmdline_)
    _example_ += "{:s} --simple           # for current EL, merge with ignoring physical address consecutivness\n".format(_cmdline_)
    _example_ += "{:s} --trace 0x7fff00   # for current EL, show all level pagetables only associated specified address\n".format(_cmdline_)
    _example_ += "{:s} -q                 # show result only (quiet)".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    # If you want to dump the secure world memory map, you need to break in the secure world.
    # This is because unlike ARMv7, TTBR0_EL1_S and TTBR1_EL1_S do not exist.
    # It is difficult to know the correct value of the secure world's system registers while in the normal world,
    # as the secure monitor saves all system registers to memory when the world changes.

    def __init__(self):
        super().__init__(prefix=False)
        return

    def read_mem_wrapper(self, addr, size=8):
        """
        When pagewalking EL0/EL1 of the guest OS, gdb pagewalks the physical memory according to $TTBR0_ELx.
        However, even if you try to read the physical memory, access to the address will fail
        because it is actually an intermediate physical memory.
        Therefore, in order to perform a pagewalk of EL0/EL1, EL2 mapping information is required.
        This function is for reading from physical memory with that in mind.
        """

        if self.EL3_M and self.TargetEL == 3:
            return read_memory(addr, size)

        # translate via EL2 mappings
        if self.EL2_VM and self.TargetEL == 1 and self.el2_mappings:
            def search_pa(addr):
                for entry_info in self.el2_mappings:
                    va, entry, sz, cnt, flags = entry_info
                    if isinstance(va, str):
                        va = int(va, 16)
                    pa = entry & 0x0000fffffffff000
                    if va <= addr < va + sz:
                        offset = addr - va
                        return pa + offset, sz - offset
                else: # not found
                    raise
            out = b""
            while size > 0:
                paddr, available_sz = search_pa(addr)
                out += self.read_physmem_cache(paddr, min([size, available_sz]))
                size -= min(size, available_sz)
            return out

        # direct physmem read
        else:
            return self.read_physmem_cache(addr, size)

    def format_flags_stage2(self, flag_info):
        flags = []

        XN1 = "XN1" in flag_info
        XN0 = "XN0" in flag_info
        if "S2AP=00" in flag_info:
            if XN1 is False and XN0 is False:
                flags += ['EL0/---', 'EL1/---']
            elif XN1 is False and XN0 is True:
                flags += ['EL0/---', 'EL1/---']
            elif XN1 is True and XN0 is False:
                flags += ['EL0/---', 'EL1/---']
            elif XN1 is True and XN0 is True:
                flags += ['EL0/---', 'EL1/---']
        elif "S2AP=01" in flag_info:
            if XN1 is False and XN0 is False:
                flags += ['EL0/R-X', 'EL1/R-X']
            elif XN1 is False and XN0 is True:
                flags += ['EL0/R-X', 'EL1/R--']
            elif XN1 is True and XN0 is False:
                flags += ['EL0/R--', 'EL1/R--']
            elif XN1 is True and XN0 is True:
                flags += ['EL0/R--', 'EL1/R-X']
        elif "S2AP=10" in flag_info:
            if XN1 is False and XN0 is False:
                flags += ['EL0/-W-', 'EL1/-W-']
            elif XN1 is False and XN0 is True:
                flags += ['EL0/-W-', 'EL1/-W-']
            elif XN1 is True and XN0 is False:
                flags += ['EL0/-W-', 'EL1/-W-']
            elif XN1 is True and XN0 is True:
                flags += ['EL0/-W-', 'EL1/-W-']
        elif "S2AP=11" in flag_info:
            if XN1 is False and XN0 is False:
                flags += ['EL0/RWX', 'EL1/RWX']
            elif XN1 is False and XN0 is True:
                flags += ['EL0/RWX', 'EL1/RW-']
            elif XN1 is True and XN0 is False:
                flags += ['EL0/RW-', 'EL1/RW-']
            elif XN1 is True and XN0 is True:
                flags += ['EL0/RW-', 'EL1/RWX']
        if "AF" in flag_info:
            flags += ['ACCESSED']
        if "DBM" in flag_info:
            flags += ['DIRTY']
        # stage2 has no `nG` bit
        return ' '.join(flags)

    def format_flags(self, flag_info):
        flags = []

        # AP/APTable parsing
        if "AP=00" in flag_info:
            disable_write_access = 0
            enable_unpriv_access = 0
        elif "AP=01" in flag_info:
            disable_write_access = 0
            enable_unpriv_access = 1
        elif "AP=10" in flag_info:
            disable_write_access = 1
            enable_unpriv_access = 0
        elif "AP=11" in flag_info:
            disable_write_access = 1
            enable_unpriv_access = 1
        if "APTable2=00" in flag_info:
            pass
        elif "APTable2=01" in flag_info:
            enable_unpriv_access &= 0
        elif "APTable2=10" in flag_info:
            disable_write_access |= 1
        elif "APTable2=11" in flag_info:
            disable_write_access |= 1
            enable_unpriv_access &= 0
        if "APTable1=00" in flag_info:
            pass
        elif "APTable1=01" in flag_info:
            enable_unpriv_access &= 0
        elif "APTable1=10" in flag_info:
            disable_write_access |= 1
        elif "APTable1=11" in flag_info:
            disable_write_access |= 1
            enable_unpriv_access &= 0
        if "APTable0=00" in flag_info:
            pass
        elif "APTable0=01" in flag_info:
            enable_unpriv_access &= 0
        elif "APTable0=10" in flag_info:
            disable_write_access |= 1
        elif "APTable0=11" in flag_info:
            disable_write_access |= 1
            enable_unpriv_access &= 0
        if "APTable-1=00" in flag_info:
            pass
        elif "APTable-1=01" in flag_info:
            enable_unpriv_access &= 0
        elif "APTable-1=10" in flag_info:
            disable_write_access |= 1
        elif "APTable-1=11" in flag_info:
            disable_write_access |= 1
            enable_unpriv_access &= 0

        # UXN/UXNTable, XN/XNTable, PXN/PXNTable, NS/NSTable parsing
        UXN = "UXN" in flag_info
        UXN |= "UXNTable2" in flag_info
        UXN |= "UXNTable1" in flag_info
        UXN |= "UXNTable0" in flag_info
        UXN |= "UXNTable-1" in flag_info
        XN = "XN" in flag_info
        XN |= "XNTable2" in flag_info
        XN |= "XNTable1" in flag_info
        XN |= "XNTable0" in flag_info
        XN |= "XNTable-1" in flag_info
        PXN = "PXN" in flag_info
        PXN |= "PXNTable2" in flag_info
        PXN |= "PXNTable1" in flag_info
        PXN |= "PXNTable0" in flag_info
        PXN |= "PXNTable-1" in flag_info
        NS = "NS" in flag_info
        NS |= "NSTable2" in flag_info
        NS |= "NSTable1" in flag_info
        NS |= "NSTable0" in flag_info
        NS |= "NSTable-1" in flag_info

        if self.TargetEL == 1:
            # always support 2VA ranges
            if UXN is False and PXN is False:
                if disable_write_access == 0 and enable_unpriv_access == 0:
                    if not self.EL1_WXN:
                        flags += ['EL0/--X', 'EL1/RWX']
                    else:
                        flags += ['EL0/--X', 'EL1/RW-']
                elif disable_write_access == 0 and enable_unpriv_access == 1:
                    if not self.EL1_WXN:
                        flags += ['EL0/RWX', 'EL1/RW-']
                    else:
                        flags += ['EL0/RW-', 'EL1/RW-']
                elif disable_write_access == 1 and enable_unpriv_access == 0:
                    flags += ['EL0/--X', 'EL1/R-X']
                elif disable_write_access == 1 and enable_unpriv_access == 1:
                    flags += ['EL0/R-X', 'EL1/R-X']
            elif UXN is False and PXN is True:
                if disable_write_access == 0 and enable_unpriv_access == 0:
                    flags += ['EL0/--X', 'EL1/RW-']
                elif disable_write_access == 0 and enable_unpriv_access == 1:
                    if not self.EL1_WXN:
                        flags += ['EL0/RWX', 'EL1/RW-']
                    else:
                        flags += ['EL0/RW-', 'EL1/RW-']
                elif disable_write_access == 1 and enable_unpriv_access == 0:
                    flags += ['EL0/--X', 'EL1/R--']
                elif disable_write_access == 1 and enable_unpriv_access == 1:
                    flags += ['EL0/R-X', 'EL1/R--']
            elif UXN is True and PXN is False:
                if disable_write_access == 0 and enable_unpriv_access == 0:
                    if not self.EL1_WXN:
                        flags += ['EL0/---', 'EL1/RWX']
                    else:
                        flags += ['EL0/---', 'EL1/RW-']
                elif disable_write_access == 0 and enable_unpriv_access == 1:
                    flags += ['EL0/RW-', 'EL1/RW-']
                elif disable_write_access == 1 and enable_unpriv_access == 0:
                    flags += ['EL0/---', 'EL1/R-X']
                elif disable_write_access == 1 and enable_unpriv_access == 1:
                    flags += ['EL0/R--', 'EL1/R-X']
            elif UXN is True and PXN is True:
                if disable_write_access == 0 and enable_unpriv_access == 0:
                    flags += ['EL0/---', 'EL1/RW-']
                elif disable_write_access == 0 and enable_unpriv_access == 1:
                    flags += ['EL0/RW-', 'EL1/RW-']
                elif disable_write_access == 1 and enable_unpriv_access == 0:
                    flags += ['EL0/---', 'EL1/R--']
                elif disable_write_access == 1 and enable_unpriv_access == 1:
                    flags += ['EL0/R--', 'EL1/R--']
        elif self.TargetEL == 2:
            if self.EL2_M20:
                # support 2VA ranges if HCR_EL2.{TGE,E2H} == {1,1}
                if UXN is False and PXN is False:
                    if disable_write_access == 0 and enable_unpriv_access == 0:
                        if not self.EL2_WXN:
                            flags += ['EL0/--X', 'EL2/RWX']
                        else:
                            flags += ['EL0/--X', 'EL2/RW-']
                    elif disable_write_access == 0 and enable_unpriv_access == 1:
                        if not self.EL2_WXN:
                            flags += ['EL0/RWX', 'EL2/RW-']
                        else:
                            flags += ['EL0/RW-', 'EL2/RW-']
                    elif disable_write_access == 1 and enable_unpriv_access == 0:
                        flags += ['EL0/--X', 'EL2/R-X']
                    elif disable_write_access == 1 and enable_unpriv_access == 1:
                        flags += ['EL0/R-X', 'EL2/R-X']
                elif UXN is False and PXN is True:
                    if disable_write_access == 0 and enable_unpriv_access == 0:
                        flags += ['EL0/--X', 'EL2/RW-']
                    elif disable_write_access == 0 and enable_unpriv_access == 1:
                        if not self.EL2_WXN:
                            flags += ['EL0/RWX', 'EL2/RW-']
                        else:
                            flags += ['EL0/RW-', 'EL2/RW-']
                    elif disable_write_access == 1 and enable_unpriv_access == 0:
                        flags += ['EL0/--X', 'EL2/R--']
                    elif disable_write_access == 1 and enable_unpriv_access == 1:
                        flags += ['EL0/R-X', 'EL2/R--']
                elif UXN is True and PXN is False:
                    if disable_write_access == 0 and enable_unpriv_access == 0:
                        if not self.EL2_WXN:
                            flags += ['EL0/---', 'EL2/RWX']
                        else:
                            flags += ['EL0/---', 'EL2/RW-']
                    elif disable_write_access == 0 and enable_unpriv_access == 1:
                        flags += ['EL0/RW-', 'EL2/RW-']
                    elif disable_write_access == 1 and enable_unpriv_access == 0:
                        flags += ['EL0/---', 'EL2/R-X']
                    elif disable_write_access == 1 and enable_unpriv_access == 1:
                        flags += ['EL0/R--', 'EL2/R-X']
                elif UXN is True and PXN is True:
                    if disable_write_access == 0 and enable_unpriv_access == 0:
                        flags += ['EL0/---', 'EL2/RW-']
                    elif disable_write_access == 0 and enable_unpriv_access == 1:
                        flags += ['EL0/RW-', 'EL2/RW-']
                    elif disable_write_access == 1 and enable_unpriv_access == 0:
                        flags += ['EL0/---', 'EL2/R--']
                    elif disable_write_access == 1 and enable_unpriv_access == 1:
                        flags += ['EL0/R--', 'EL2/R--']
            else:
                # not support 2VA ranges if HCR_EL2.{TGE,E2H} != {1,1}
                if XN is False:
                    if disable_write_access == 0:
                        if not self.EL2_WXN:
                            flags += ['EL2/RWX']
                        else:
                            flags += ['EL2/RW-']
                    elif disable_write_access == 1:
                        flags += ['EL2/R-X']
                elif XN is True:
                    if disable_write_access == 0:
                        flags += ['EL2/RW-']
                    elif disable_write_access == 1:
                        flags += ['EL2/R--']
        elif self.TargetEL == 3:
            if XN is False:
                if disable_write_access == 0:
                    if not self.EL3_WXN:
                        flags += ['EL3/RWX']
                    else:
                        flags += ['EL3/RW-']
                elif disable_write_access == 1:
                    flags += ['EL3/R-X']
            elif XN is True:
                if disable_write_access == 0:
                    flags += ['EL3/RW-']
                elif disable_write_access == 1:
                    flags += ['EL3/R--']
        if NS:
            flags += ['NS']
        if "AF" in flag_info:
            flags += ['ACCESSED']
        if "DBM" in flag_info:
            flags += ['DIRTY']
        if "nG" not in flag_info:
            flags += ["GLOBAL"]
        return ' '.join(flags)

    """
     Stage1                   |     Stage2
    -------------------------------------------------------
    +----------------------+  |   +----------------------+
    | Guest OS table       | -|-> | Virtualization table |
    +----------------------+  |   +----------------------+
      TTBR0_EL1, TTBR1_EL1    |     VTTBR0_EL2
                              |
    +----------------------+  |
    | Hypervisor table     |  |
    +----------------------+  |
      TTBR0_EL2, TTBR1_EL2    |
                              |
    +----------------------+  |
    | Secure monitor table |  |
    +----------------------+  |
      TTBR0_EL3               |
                              |


      TargetEL=1              |    TargetEL=2              |    TargetEL=3
    ---------------------------------------------------------------------------------
    +----------------------+  |  +----------------------+  |  +----------------------+
    | Guest OS table       |  |  | Virtualization table |  |  | Secure monitor table |
    +----------------------+  |  +----------------------+  |  +----------------------+
      TTBR0_EL1, TTBR1_EL1    |    VTTBR0_EL2              |    TTBR0_EL3
                              |                            |
                              |  +----------------------+  |
                              |  | Hypervisor table     |  |
                              |  +----------------------+  |
                              |    TTBR0_EL2, TTBR1_EL2    |
                              |                            |
    """
    def parse_bit_range(self, granule_bits, region_bits):
        IA_LVA_MAX = 52 if self.FEAT_LVA else 48
        if granule_bits == 12: # 4KB granule
            self.LEVELM1_BIT_RANGE = [48, min(IA_LVA_MAX, region_bits)] if region_bits > 48 else None # no block descriptor
            self.LEVEL0_BIT_RANGE = [39, min(48, region_bits)] if region_bits > 39 else None          # 512GB
            self.LEVEL1_BIT_RANGE = [30, min(39, region_bits)] if region_bits > 30 else None          # 1GB
            self.LEVEL2_BIT_RANGE = [21, min(30, region_bits)] if region_bits > 21 else None          # 2MB
            self.LEVEL3_BIT_RANGE = [12, min(21, region_bits)] if region_bits > 12 else None          # 4KB
            self.OFFSET_BIT_RANGE = [0, 12]
        elif granule_bits == 14: # 16KB granule
            self.LEVELM1_BIT_RANGE = None
            self.LEVEL0_BIT_RANGE = [47, min(IA_LVA_MAX, region_bits)] if region_bits > 47 else None  # no block descriptor
            self.LEVEL1_BIT_RANGE = [36, min(47, region_bits)] if region_bits > 36 else None          # 64GB
            self.LEVEL2_BIT_RANGE = [25, min(36, region_bits)] if region_bits > 25 else None          # 32MB
            self.LEVEL3_BIT_RANGE = [14, min(25, region_bits)] if region_bits > 14 else None          # 16KB
            self.OFFSET_BIT_RANGE = [0, 14]
        elif granule_bits == 16: # 64KB granule
            self.LEVELM1_BIT_RANGE = None
            self.LEVEL0_BIT_RANGE = None
            self.LEVEL1_BIT_RANGE = [42, min(IA_LVA_MAX, region_bits)] if region_bits > 42 else None  # 4TB
            self.LEVEL2_BIT_RANGE = [29, min(42, region_bits)] if region_bits > 29 else None          # 512MB
            self.LEVEL3_BIT_RANGE = [16, min(29, region_bits)] if region_bits > 16 else None          # 64KB
            self.OFFSET_BIT_RANGE = [0, 16]
        else:
            if not self.silent:
                err("Unsupported granule_bits")
            return

        if not self.silent and not self.quiet:
            info("granule_bits: {:d}".format(granule_bits))
            info("LEVELM1_BIT_RANGE: " + str(self.LEVELM1_BIT_RANGE))
            info("LEVEL0_BIT_RANGE: " + str(self.LEVEL0_BIT_RANGE))
            info("LEVEL1_BIT_RANGE: " + str(self.LEVEL1_BIT_RANGE))
            info("LEVEL2_BIT_RANGE: " + str(self.LEVEL2_BIT_RANGE))
            info("LEVEL3_BIT_RANGE: " + str(self.LEVEL3_BIT_RANGE))
            info("OFFSET_BIT_RANGE: " + str(self.OFFSET_BIT_RANGE))
        return

    def do_pagewalk(self, table_base, granule_bits, region_start, start_level=0, is_stage2=False, is_2VAranges=False):
        # table_base: The start address of pagewalk
        # granule_bits: One of [12, 14, 16]; It specifies how to separate the bits used for address translation.
        # region_start: The base address of translated address
        # start_level: Only used at stage2. In stage2, the starting level will fluctuate
        # is_stage2: Affects how the bitfield of each entry is interpreted
        self.mappings = []

        is_4k_granule = granule_bits == 12
        is_16k_granule = granule_bits == 14
        is_64k_granule = granule_bits == 16

        def get_entries_per_table(BIT_RANGE):
            entries_per_table = 2 ** (BIT_RANGE[1] - BIT_RANGE[0])
            if not self.silent and not self.quiet:
                info("Entries per table: {:d}".format(entries_per_table))
            return entries_per_table

        def has_next_level(entry): # for Level0, 1, 2 but not Level3
            return (entry & 0b11) == 0b11

        flags = []
        TABLE_BASE = [[region_start, table_base, flags]]

        # level -1 parse for 4KB granule
        if not self.silent and not self.quiet:
            gef_print(titlify("LEVEL -1"))
        if self.LEVELM1_BIT_RANGE is not None and start_level == -1:
            entries_per_table = get_entries_per_table(self.LEVELM1_BIT_RANGE)
            LEVELM1 = []
            COUNT = 0
            for va_base, table_base, parent_flags in TABLE_BASE:
                entries = self.read_mem_wrapper(table_base, 8 * entries_per_table)
                entries = slice_unpack(entries, 8)
                COUNT += len(entries)
                for i, entry in enumerate(entries):
                    # present flag
                    if entry & 1 == 0:
                        continue

                    # calc virtual address
                    new_va = va_base + (i << self.LEVELM1_BIT_RANGE[0])
                    new_va_end = new_va + (1 << self.LEVELM1_BIT_RANGE[0])

                    # calc flags
                    flags = parent_flags.copy()
                    if has_next_level(entry):
                        if is_stage2:
                            pass
                        elif is_2VAranges:
                            if ((entry >> 59) & 1) == 1:
                                flags.append("PXNTable-1")
                            if ((entry >> 60) & 1) == 1:
                                flags.append("UXNTable-1")
                            flags.append("APTable-1={:02b}".format((entry >> 61) & 0b11))
                            if ((entry >> 63) & 1) == 1:
                                flags.append("NSTable-1")
                        else:
                            if ((entry >> 60) & 1) == 1:
                                flags.append("XNTable-1") # Use XNTable, not UXNTable # PXNTable is undefined
                            flags.append("APTable-1={:02b}".format((entry >> 61) & 0b11 & 0b10)) # APTable[0] must be 0
                            if ((entry >> 63) & 1) == 1:
                                flags.append("NSTable-1")
                    else:
                        # In ARMv8.7, level -1 has no block descriptors
                        raise

                    # calc next table / output phys addr (drop the flag bits)
                    if has_next_level(entry):
                        next_level_table = (entry & 0x0003fffffffff000) | (((entry >> 8) & 0b11) << 50)
                    else:
                        # In ARMv8.7, level -1 has no block descriptors
                        raise

                    # make entry
                    if has_next_level(entry):
                        LEVELM1.append([new_va, next_level_table, flags])
                        entry_type = "TABLE"
                    else:
                        # In ARMv8.7, level -1 has no block descriptors
                        raise

                    # dump
                    if self.print_each_level:
                        if self.is_not_trace_target(new_va, new_va_end):
                            continue
                        addr = table_base + i * 8
                        fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                        line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                        if self.is_not_filter_target(line):
                            continue
                        gef_print(line)

            if not self.silent and not self.quiet:
                info("Number of entries: {:d}".format(COUNT))
                info("Level -1 Entry: {:d}".format(len(LEVELM1)))
                info("Invalid entries: {:d}".format(COUNT - len(LEVELM1)))
            self.mappings += []
        else:
            if not self.silent and not self.quiet:
                info("LEVEL -1 is skipped")
            LEVELM1 = TABLE_BASE

        # level 0 parse for 4KB/16KB granule
        if not self.silent and not self.quiet:
            gef_print(titlify("LEVEL 0"))
        if self.LEVEL0_BIT_RANGE is not None and start_level <= 0:
            entries_per_table = get_entries_per_table(self.LEVEL0_BIT_RANGE)
            LEVEL0 = []
            GB512 = []
            COUNT = 0
            for va_base, table_base, parent_flags in LEVELM1:
                entries = self.read_mem_wrapper(table_base, 8 * entries_per_table)
                entries = slice_unpack(entries, 8)
                COUNT += len(entries)
                for i, entry in enumerate(entries):
                    # present flag
                    if entry & 1 == 0:
                        continue

                    # calc virtual address
                    new_va = va_base + (i << self.LEVEL0_BIT_RANGE[0])
                    new_va_end = new_va + (1 << self.LEVEL0_BIT_RANGE[0])

                    # calc flags
                    flags = parent_flags.copy()
                    if has_next_level(entry):
                        if is_stage2:
                            pass
                        elif is_2VAranges:
                            if ((entry >> 59) & 1) == 1:
                                flags.append("PXNTable0")
                            if ((entry >> 60) & 1) == 1:
                                flags.append("UXNTable0")
                            flags.append("APTable0={:02b}".format((entry >> 61) & 0b11))
                            if ((entry >> 63) & 1) == 1:
                                flags.append("NSTable0")
                        else:
                            if ((entry >> 60) & 1) == 1:
                                flags.append("XNTable0") # Use XNTable, not UXNTable # PXNTable is undefined
                            flags.append("APTable0={:02b}".format((entry >> 61) & 0b11 & 0b10)) # APTable[0] must be 0
                            if ((entry >> 63) & 1) == 1:
                                flags.append("NSTable0")
                    else:
                        if is_stage2:
                            flags.append("MemAttr={:#x}".format((entry >> 2) & 0b1111))
                            flags.append("S2AP={:02b}".format((entry >> 6) & 0b11))
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1:
                                flags.append("AF")
                            if ((entry >> 51) & 1) == 1:
                                flags.append("DBM")
                            if ((entry >> 52) & 1) == 1:
                                flags.append("Contiguous")
                            flags.append("XN={:02b}".format((entry >> 53) & 0b11)) # Use XN, not UXN
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))
                        elif is_2VAranges:
                            flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                            if ((entry >> 5) & 1) == 1:
                                flags.append("NS")
                            flags.append("AP={:02b}".format((entry >> 6) & 0b11))
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1:
                                flags.append("AF")
                            if ((entry >> 11) & 1) == 1:
                                flags.append("nG")
                            if ((entry >> 16) & 1) == 1:
                                flags.append("nT")
                            if ((entry >> 50) & 1) == 1:
                                flags.append("GP")
                            if ((entry >> 51) & 1) == 1:
                                flags.append("DBM")
                            if ((entry >> 52) & 1) == 1:
                                flags.append("Contiguous")
                            if ((entry >> 53) & 1) == 1:
                                flags.append("PXN")
                            if ((entry >> 54) & 1) == 1:
                                flags.append("UXN")
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))
                        else:
                            flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                            if ((entry >> 5) & 1) == 1:
                                flags.append("NS")
                            flags.append("AP={:02b}".format((entry >> 6) & 0b11 & 0b10)) # AP[0] must be 0
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1:
                                flags.append("AF")
                            if ((entry >> 11) & 1) == 1:
                                flags.append("nG")
                            if ((entry >> 16) & 1) == 1:
                                flags.append("nT")
                            if ((entry >> 50) & 1) == 1:
                                flags.append("GP")
                            if ((entry >> 51) & 1) == 1:
                                flags.append("DBM")
                            if ((entry >> 52) & 1) == 1:
                                flags.append("Contiguous")
                            if ((entry >> 54) & 1) == 1:
                                flags.append("XN") # Use XN, not UXN # PXN is undefined
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))

                    # calc next table / output phys addr (drop the flag bits)
                    if has_next_level(entry):
                        if self.FEAT_LPA:
                            next_level_table = (entry & 0x0003fffffffff000) | (((entry >> 8) & 0b11) << 50)
                        else:
                            next_level_table = entry & 0x0000fffffffff000
                    else:
                        if self.FEAT_LPA:
                            phys_addr = (entry & 0x0003fffffffe0000) | (((entry >> 8) & 0b11) << 50)
                        else:
                            # In ARMv8.7, level 0 + no-FEAT_LPA has no block descriptors
                            raise

                    # make entry
                    if has_next_level(entry):
                        LEVEL0.append([new_va, next_level_table, flags])
                        entry_type = "TABLE"
                    else:
                        virt_addr = new_va
                        page_count = 1
                        flag_string = self.format_flags_stage2(flags) if is_stage2 else self.format_flags(flags)
                        if is_4k_granule:
                            page_size = 512 * 1024 * 1024 * 1024
                            GB512.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                            entry_type = "512GB-PAGE"
                        else:
                            raise

                    # dump
                    if self.print_each_level:
                        if self.is_not_trace_target(new_va, new_va_end):
                            continue
                        addr = table_base + i * 8
                        fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                        line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                        if self.is_not_filter_target(line):
                            continue
                        gef_print(line)

            if not self.silent and not self.quiet:
                info("Number of entries: {:d}".format(COUNT))
                info("Level 0 Entry: {:d}".format(len(LEVEL0)))
                info("PT Entry (512GB): {:d}".format(len(GB512)))
                info("Invalid entries: {:d}".format(COUNT - len(LEVEL0) - len(GB512)))
            self.mappings += GB512
        else:
            if not self.silent and not self.quiet:
                info("LEVEL 0 is skipped")
            LEVEL0 = TABLE_BASE

        # level 1 parse for 4KB/16KB/64KB granule
        if not self.silent and not self.quiet:
            gef_print(titlify("LEVEL 1"))
        if self.LEVEL1_BIT_RANGE is not None and start_level <= 1:
            entries_per_table = get_entries_per_table(self.LEVEL1_BIT_RANGE)
            LEVEL1 = []
            GB1 = []
            TB4 = []
            GB64 = []
            COUNT = 0
            for va_base, table_base, parent_flags in LEVEL0:
                entries = self.read_mem_wrapper(table_base, 8 * entries_per_table)
                entries = slice_unpack(entries, 8)
                COUNT += len(entries)
                for i, entry in enumerate(entries):
                    # present flag
                    if entry & 1 == 0:
                        continue

                    # calc virtual address
                    new_va = va_base + (i << self.LEVEL1_BIT_RANGE[0])
                    new_va_end = new_va + (1 << self.LEVEL1_BIT_RANGE[0])

                    # calc flags
                    flags = parent_flags.copy()
                    if has_next_level(entry):
                        if is_stage2:
                            pass
                        elif is_2VAranges:
                            if ((entry >> 59) & 1) == 1:
                                flags.append("PXNTable1")
                            if ((entry >> 60) & 1) == 1:
                                flags.append("UXNTable1")
                            flags.append("APTable1={:02b}".format((entry >> 61) & 0b11))
                            if ((entry >> 63) & 1) == 1:
                                flags.append("NSTable1")
                        else:
                            if ((entry >> 60) & 1) == 1:
                                flags.append("XNTable1") # Use XNTable, not UXNTable # PXNTable is undefined
                            flags.append("APTable1={:02b}".format((entry >> 61) & 0b11 & 0b10)) # APTable[0] must be 0
                            if ((entry >> 63) & 1) == 1:
                                flags.append("NSTable1")
                    else:
                        if is_stage2:
                            flags.append("MemAttr={:#x}".format((entry >> 2) & 0b1111))
                            flags.append("S2AP={:02b}".format((entry >> 6) & 0b11))
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1:
                                flags.append("AF")
                            if ((entry >> 51) & 1) == 1:
                                flags.append("DBM")
                            if ((entry >> 52) & 1) == 1:
                                flags.append("Contiguous")
                            flags.append("XN={:02b}".format((entry >> 53) & 0b11)) # Use XN, not UXN
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))
                        elif is_2VAranges:
                            flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                            if ((entry >> 5) & 1) == 1:
                                flags.append("NS")
                            flags.append("AP={:02b}".format((entry >> 6) & 0b11))
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1:
                                flags.append("AF")
                            if ((entry >> 11) & 1) == 1:
                                flags.append("nG")
                            if ((entry >> 16) & 1) == 1:
                                flags.append("nT")
                            if ((entry >> 50) & 1) == 1:
                                flags.append("GP")
                            if ((entry >> 51) & 1) == 1:
                                flags.append("DBM")
                            if ((entry >> 52) & 1) == 1:
                                flags.append("Contiguous")
                            if ((entry >> 53) & 1) == 1:
                                flags.append("PXN")
                            if ((entry >> 54) & 1) == 1:
                                flags.append("UXN")
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))
                        else:
                            flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                            if ((entry >> 5) & 1) == 1:
                                flags.append("NS")
                            flags.append("AP={:02b}".format((entry >> 6) & 0b11 & 0b10)) # AP[0] must be 0
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1:
                                flags.append("AF")
                            if ((entry >> 11) & 1) == 1:
                                flags.append("nG")
                            if ((entry >> 16) & 1) == 1:
                                flags.append("nT")
                            if ((entry >> 50) & 1) == 1:
                                flags.append("GP")
                            if ((entry >> 51) & 1) == 1:
                                flags.append("DBM")
                            if ((entry >> 52) & 1) == 1:
                                flags.append("Contiguous")
                            if ((entry >> 54) & 1) == 1:
                                flags.append("XN") # Use XN, not UXN # PXN is undefined
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))

                    # calc next table / output phys addr (drop the flag bits)
                    if has_next_level(entry):
                        if self.FEAT_LPA:
                            if is_64k_granule:
                                next_level_table = (entry & 0x0000ffffffff0000) | (((entry >> 12) & 0b1111) << 48)
                            else:
                                next_level_table = (entry & 0x0003fffffffff000) | (((entry >> 8) & 0b11) << 50)
                        else:
                            next_level_table = entry & 0x0000fffffffff000
                    else:
                        if self.FEAT_LPA:
                            if is_64k_granule:
                                phys_addr = (entry & 0x0000fffffffe0000) | (((entry >> 12) & 0b1111) << 48)
                            else:
                                phys_addr = (entry & 0x0003fffffffe0000) | (((entry >> 8) & 0b11) << 50)
                        else:
                            phys_addr = entry & 0x0000fffffffe0000

                    # make entry
                    if has_next_level(entry):
                        LEVEL1.append([new_va, next_level_table, flags])
                        entry_type = "TABLE"
                    else:
                        virt_addr = new_va
                        page_count = 1
                        flag_string = self.format_flags_stage2(flags) if is_stage2 else self.format_flags(flags)
                        if is_64k_granule:
                            page_size = 4 * 1024 * 1024 * 1024 * 1024
                            TB4.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                            entry_type = "4TB-PAGE"
                        elif is_4k_granule:
                            page_size = 1 * 1024 * 1024 * 1024
                            GB1.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                            entry_type = "1GB-PAGE"
                        elif is_16k_granule:
                            page_size = 64 * 1024 * 1024 * 1024
                            GB64.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                            entry_type = "64GB-PAGE"

                    # dump
                    if self.print_each_level:
                        if self.is_not_trace_target(new_va, new_va_end):
                            continue
                        addr = table_base + i * 8
                        fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                        line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                        if self.is_not_filter_target(line):
                            continue
                        gef_print(line)

            if not self.silent and not self.quiet:
                info("Number of entries: {:d}".format(COUNT))
                info("Level 1 Entry: {:d}".format(len(LEVEL1)))
                info("PT Entry (1GB): {:d}".format(len(GB1)))
                info("PT Entry (64GB): {:d}".format(len(GB64)))
                info("PT Entry (4TB): {:d}".format(len(TB4)))
                info("Invalid entries: {:d}".format(COUNT - len(LEVEL1) - len(GB1) - len(GB64) - len(TB4)))
            self.mappings += GB1 + GB64 + TB4
        else:
            if not self.silent and not self.quiet:
                info("LEVEL 1 is skipped")
            LEVEL1 = LEVEL0

        # level 2 parse for 4KB/16KB/64KB granule
        if not self.silent and not self.quiet:
            gef_print(titlify("LEVEL 2"))
        if self.LEVEL2_BIT_RANGE is not None and start_level <= 2:
            entries_per_table = get_entries_per_table(self.LEVEL2_BIT_RANGE)
            LEVEL2 = []
            MB2 = []
            MB32 = []
            MB512 = []
            COUNT = 0
            for va_base, table_base, parent_flags in LEVEL1:
                entries = self.read_mem_wrapper(table_base, 8 * entries_per_table)
                entries = slice_unpack(entries, 8)
                COUNT += len(entries)
                for i, entry in enumerate(entries):
                    # present flag
                    if entry & 1 == 0:
                        continue

                    # calc virtual address
                    new_va = va_base + (i << self.LEVEL2_BIT_RANGE[0])
                    new_va_end = new_va + (1 << self.LEVEL2_BIT_RANGE[0])

                    # calc flags
                    flags = parent_flags.copy()
                    if has_next_level(entry):
                        if is_stage2:
                            pass
                        elif is_2VAranges:
                            if ((entry >> 59) & 1) == 1:
                                flags.append("PXNTable2")
                            if ((entry >> 60) & 1) == 1:
                                flags.append("UXNTable2")
                            flags.append("APTable2={:02b}".format((entry >> 61) & 0b11))
                            if ((entry >> 63) & 1) == 1:
                                flags.append("NSTable2")
                        else:
                            if ((entry >> 60) & 1) == 1:
                                flags.append("XNTable2") # Use XNTable, not UXNTable # PXNTable is undefined
                            flags.append("APTable2={:02b}".format((entry >> 61) & 0b11 & 0b10)) # APTable[0] must be 0
                            if ((entry >> 63) & 1) == 1:
                                flags.append("NSTable2")
                    else:
                        if is_stage2:
                            flags.append("MemAttr={:#x}".format((entry >> 2) & 0b1111))
                            flags.append("S2AP={:02b}".format((entry >> 6) & 0b11))
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1:
                                flags.append("AF")
                            if ((entry >> 51) & 1) == 1:
                                flags.append("DBM")
                            if ((entry >> 52) & 1) == 1:
                                flags.append("Contiguous")
                            flags.append("XN={:02b}".format((entry >> 53) & 0b11)) # Use XN, not UXN
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))
                        elif is_2VAranges:
                            flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                            if ((entry >> 5) & 1) == 1:
                                flags.append("NS")
                            flags.append("AP={:02b}".format((entry >> 6) & 0b11))
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1:
                                flags.append("AF")
                            if ((entry >> 11) & 1) == 1:
                                flags.append("nG")
                            if ((entry >> 16) & 1) == 1:
                                flags.append("nT")
                            if ((entry >> 50) & 1) == 1:
                                flags.append("GP")
                            if ((entry >> 51) & 1) == 1:
                                flags.append("DBM")
                            if ((entry >> 52) & 1) == 1:
                                flags.append("Contiguous")
                            if ((entry >> 53) & 1) == 1:
                                flags.append("PXN")
                            if ((entry >> 54) & 1) == 1:
                                flags.append("UXN")
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))
                        else:
                            flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                            if ((entry >> 5) & 1) == 1:
                                flags.append("NS")
                            flags.append("AP={:02b}".format((entry >> 6) & 0b11 & 0b10)) # AP[0] must be 0
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1:
                                flags.append("AF")
                            if ((entry >> 11) & 1) == 1:
                                flags.append("nG")
                            if ((entry >> 16) & 1) == 1:
                                flags.append("nT")
                            if ((entry >> 50) & 1) == 1:
                                flags.append("GP")
                            if ((entry >> 51) & 1) == 1:
                                flags.append("DBM")
                            if ((entry >> 52) & 1) == 1:
                                flags.append("Contiguous")
                            if ((entry >> 54) & 1) == 1:
                                flags.append("XN") # Use XN, not UXN # PXN is undefined
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))

                    # calc next table / output phys addr (drop the flag bits)
                    if has_next_level(entry):
                        if self.FEAT_LPA:
                            if is_64k_granule:
                                next_level_table = (entry & 0x0000ffffffff0000) | (((entry >> 12) & 0b1111) << 48)
                            else:
                                next_level_table = (entry & 0x0003fffffffff000) | (((entry >> 8) & 0b11) << 50)
                        else:
                            next_level_table = entry & 0x0000fffffffff000
                    else:
                        if self.FEAT_LPA:
                            if is_64k_granule:
                                phys_addr = (entry & 0x0000fffffffe0000) | (((entry >> 12) & 0b1111) << 48)
                            else:
                                phys_addr = (entry & 0x0003fffffffe0000) | (((entry >> 8) & 0b11) << 50)
                        else:
                            phys_addr = entry & 0x0000fffffffe0000

                    # make entry
                    if has_next_level(entry):
                        LEVEL2.append([new_va, next_level_table, flags])
                        entry_type = "TABLE"
                    else:
                        virt_addr = new_va
                        page_count = 1
                        flag_string = self.format_flags_stage2(flags) if is_stage2 else self.format_flags(flags)
                        if is_64k_granule:
                            page_size = 512 * 1024 * 1024
                            MB512.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                            entry_type = "512MB-PAGE"
                        elif is_16k_granule:
                            page_size = 32 * 1024 * 1024
                            MB32.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                            entry_type = "32MB-PAGE"
                        elif is_4k_granule:
                            page_size = 2 * 1024 * 1024
                            MB2.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                            entry_type = "2MB-PAGE"

                    # dump
                    if self.print_each_level:
                        if self.is_not_trace_target(new_va, new_va_end):
                            continue
                        addr = table_base + i * 8
                        fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                        line = fmt.format(addr, entry, new_va, new_va_end, entry_type, ' '.join(flags))
                        if self.is_not_filter_target(line):
                            continue
                        gef_print(line)

            if not self.silent and not self.quiet:
                info("Number of entries: {:d}".format(COUNT))
                info("Level 2 Entry: {:d}".format(len(LEVEL2)))
                info("PT Entry (2MB): {:d}".format(len(MB2)))
                info("PT Entry (32MB): {:d}".format(len(MB32)))
                info("PT Entry (512MB): {:d}".format(len(MB512)))
                info("Invalid entries: {:d}".format(COUNT - len(LEVEL2) - len(MB2) - len(MB32) - len(MB512)))
            self.mappings += MB2 + MB32 + MB512
        else:
            if not self.silent and not self.quiet:
                info("LEVEL 2 is skipped")
            LEVEL2 = LEVEL1

        # level 3 parse for 4KB/16KB/64KB granule
        if not self.silent and not self.quiet:
            gef_print(titlify("LEVEL 3"))
        if self.LEVEL3_BIT_RANGE is not None and start_level <= 3:
            entries_per_table = get_entries_per_table(self.LEVEL3_BIT_RANGE)
            KB4 = []
            KB16 = []
            KB64 = []
            COUNT = 0
            for va_base, table_base, parent_flags in LEVEL2:
                entries = self.read_mem_wrapper(table_base, 8 * entries_per_table)
                entries = slice_unpack(entries, 8)
                COUNT += len(entries)
                for i, entry in enumerate(entries):
                    # present flag
                    if entry & 1 == 0:
                        continue

                    # calc virtual address
                    virt_addr = va_base + (i << self.LEVEL3_BIT_RANGE[0])
                    virt_addr_end = virt_addr + (1 << self.LEVEL3_BIT_RANGE[0])

                    # calc flags
                    flags = parent_flags.copy()
                    if (entry & 0b11) == 0b11:
                        if is_stage2:
                            flags.append("MemAttr={:#x}".format((entry >> 2) & 0b1111))
                            flags.append("S2AP={:02b}".format((entry >> 6) & 0b11))
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1:
                                flags.append("AF")
                            if ((entry >> 51) & 1) == 1:
                                flags.append("DBM")
                            if ((entry >> 52) & 1) == 1:
                                flags.append("Contiguous")
                            flags.append("XN={:02b}".format((entry >> 53) & 0b11)) # Use XN, not UXN
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))
                        elif is_2VAranges:
                            flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                            if ((entry >> 5) & 1) == 1:
                                flags.append("NS")
                            flags.append("AP={:02b}".format((entry >> 6) & 0b11))
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1:
                                flags.append("AF")
                            if ((entry >> 11) & 1) == 1:
                                flags.append("nG")
                            if ((entry >> 16) & 1) == 1:
                                flags.append("nT")
                            if ((entry >> 50) & 1) == 1:
                                flags.append("GP")
                            if ((entry >> 51) & 1) == 1:
                                flags.append("DBM")
                            if ((entry >> 52) & 1) == 1:
                                flags.append("Contiguous")
                            if ((entry >> 53) & 1) == 1:
                                flags.append("PXN")
                            if ((entry >> 54) & 1) == 1:
                                flags.append("UXN")
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))
                        else:
                            flags.append("AttrIndx={:03b}".format((entry >> 2) & 0b111))
                            if ((entry >> 5) & 1) == 1:
                                flags.append("NS")
                            flags.append("AP={:02b}".format((entry >> 6) & 0b11 & 0b10)) # AP[0] must be 0
                            flags.append("SH={:02b}".format((entry >> 8) & 0b11))
                            if ((entry >> 10) & 1) == 1:
                                flags.append("AF")
                            if ((entry >> 11) & 1) == 1:
                                flags.append("nG")
                            if ((entry >> 16) & 1) == 1:
                                flags.append("nT")
                            if ((entry >> 50) & 1) == 1:
                                flags.append("GP")
                            if ((entry >> 51) & 1) == 1:
                                flags.append("DBM")
                            if ((entry >> 52) & 1) == 1:
                                flags.append("Contiguous")
                            if ((entry >> 54) & 1) == 1:
                                flags.append("XN") # Use XN, not UXN # PXN is undefined
                            flags.append("PBHA={:#x}".format((entry >> 59) & 0b1111))
                    else:
                        # In ARMv8.7, level 3 has no table descriptors
                        raise

                    # calc next table / output phys addr (drop the flag bits)
                    if is_4k_granule:
                        if self.FEAT_LPA:
                            phys_addr = (entry & 0x0003fffffffff000) | (((entry >> 8) & 0b11) << 50)
                        else:
                            phys_addr = entry & 0x0000fffffffff000
                    elif is_16k_granule:
                        if self.FEAT_LPA:
                            phys_addr = (entry & 0x0003ffffffffc000) | (((entry >> 8) & 0b11) << 50)
                        else:
                            phys_addr = entry & 0x0000ffffffffc000
                    elif is_64k_granule:
                        if self.FEAT_LPA:
                            phys_addr = (entry & 0x0000ffffffff0000) | (((entry >> 12) & 0b1111) << 48)
                        else:
                            phys_addr = entry & 0x0000ffffffff0000

                    # make entry
                    page_count = 1
                    flag_string = self.format_flags_stage2(flags) if is_stage2 else self.format_flags(flags)
                    if is_64k_granule:
                        page_size = 64 * 1024
                        KB64.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                        entry_type = "64KB-PAGE"
                    elif is_16k_granule:
                        page_size = 16 * 1024
                        KB16.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                        entry_type = "16KB-PAGE"
                    elif is_4k_granule:
                        page_size = 4 * 1024
                        KB4.append([virt_addr, phys_addr, page_size, page_count, flag_string])
                        entry_type = "4KB-PAGE"

                    # dump
                    if self.print_each_level:
                        if self.is_not_trace_target(virt_addr, virt_addr_end):
                            continue
                        addr = table_base + i * 8
                        fmt = "{:#018x}: {:#018x} (virt:{:#018x}-{:#018x},type:{:s}) {:s}"
                        line = fmt.format(addr, entry, virt_addr, virt_addr_end, entry_type, ' '.join(flags))
                        if self.is_not_filter_target(line):
                            continue
                        gef_print(line)

            if not self.silent and not self.quiet:
                info("Number of entries: {:d}".format(COUNT))
                info("PT Entry (4KB): {:d}".format(len(KB4)))
                info("PT Entry (16KB): {:d}".format(len(KB16)))
                info("PT Entry (64KB): {:d}".format(len(KB64)))
                info("Invalid entries: {:d}".format(COUNT - len(KB4) - len(KB16) - len(KB64)))
            self.mappings += KB4 + KB16 + KB64
        else:
            if not self.silent and not self.quiet:
                info("LEVEL 3 is skipped")

        # Finalize
        if not self.silent and not self.quiet:
            gef_print(titlify("Total"))
            info("PT Entry (Total): {:d}".format(len(self.mappings)))
        self.mappings = sorted(self.mappings)
        return

    def switch_el(self):
        self.SAVED_CPSR = 0
        CPSR = get_register('$cpsr') & 0xffffffff
        CurrentEL = int((CPSR >> 2) & 0b11)
        # change EL
        try:
            if self.TargetEL < 1 or self.TargetEL > 3:
                err("Invalid argument (ELx>=1 && ELx<=3)")
                return
            if self.TargetEL != CurrentEL:
                self.SAVED_CPSR = CPSR
                CPSR = CPSR & ~(0b11 << 2) # clear EL
                CPSR |= self.TargetEL << 2 # set desired EL
                gdb.parse_and_eval('$cpsr = 0x%08x' % CPSR)
                if not self.quiet:
                    info('Moving to EL%d' % (self.TargetEL))
        except ValueError:
            err("Invalid argument (ELx integer required)")
            return
        except gdb.error:
            err("Maybe unsupported to change to EL%d" % (self.TargetEL))
            return
        # reload CPSR
        CPSR = get_register('$cpsr') & 0xffffffff
        CurrentEL = int((CPSR >> 2) & 0b11)
        if not self.quiet:
            info('CPSR: EL%d' % (CurrentEL))
        return True

    def revert_el(self):
        if self.SAVED_CPSR:
            gdb.parse_and_eval('$cpsr = 0x%08x' % self.SAVED_CPSR)
            SavedEL = (self.SAVED_CPSR >> 2) & 0b11
            if not self.quiet:
                info('Moving back to EL%d' % (SavedEL))
        return

    def pagewalk_TTBR0_EL1(self):
        gef_print(titlify("$TTBR0_EL1"))

        TTBR0_EL1 = get_register('$TTBR0_EL1')
        TCR_EL1 = get_register('$TCR_EL1')
        if TTBR0_EL1 == 0:
            warn("Maybe unused TTBR0_EL1")
            return

        IPS = (TCR_EL1 >> 32) & 0b111
        TG0 = (TCR_EL1 >> 14) & 0b11
        T0SZ = TCR_EL1 & 0b111111
        try:
            granule_bits = {0b00: 12, 0b01: 16, 0b10: 14}[TG0]
        except Exception:
            err("Unsupported $TCR_EL1.TG0")
            return
        region_start = 0
        region_end = region_start + (2 ** (64 - T0SZ))
        region_bits = int(math.log2(region_end - region_start))
        page_size = 2 ** (granule_bits - 10)
        intermediate_pa_size = 32 + (IPS * 4)

        if IPS == 0b110:
            if self.FEAT_LPA:
                translation_base_addr = (TTBR0_EL1 & 0xffffffffffc0) | (((TTBR0_EL1 >> 2) & 0b1111) << 48)
            else:
                err("Unsupported FEAT_LPA and IPS pair")
                return
        else:
            translation_base_addr = TTBR0_EL1 & 0xfffffffffffe

        if not self.quiet:
            info('$TTBR0_EL1: {:#x}'.format(TTBR0_EL1))
            info('$TCR_EL1: {:#x}'.format(TCR_EL1))
            info('Intermediate Physical Address Size: {:d} bits'.format(intermediate_pa_size))
            info('EL1 User Region: {:#018x} - {:#018x} ({:d} bits)'.format(region_start, region_end - 1, region_bits))
            info('EL1 User Page Size: {:d}KB (per page)'.format(page_size))

        self.parse_bit_range(granule_bits, region_bits)
        self.do_pagewalk(translation_base_addr, granule_bits, region_start, is_2VAranges=True)
        self.print_page()
        return

    def pagewalk_TTBR1_EL1(self):
        gef_print(titlify("$TTBR1_EL1"))

        TTBR1_EL1 = get_register('$TTBR1_EL1')
        TCR_EL1 = get_register('$TCR_EL1')
        if TTBR1_EL1 == 0:
            warn("Maybe unused TTBR1_EL1")
            return

        IPS = (TCR_EL1 >> 32) & 0b111
        TG1 = (TCR_EL1 >> 30) & 0b11
        T1SZ = (TCR_EL1 >> 16) & 0b111111
        try:
            granule_bits = {0b01: 14, 0b10: 12, 0b11: 16}[TG1]
        except Exception:
            err("Unsupported $TCR_EL1.TG1")
            return
        region_end = 2 ** 64
        region_start = region_end - (2 ** (64 - T1SZ))
        region_bits = int(math.log2(region_end - region_start))
        page_size = 2 ** (granule_bits - 10)
        intermediate_pa_size = 32 + (IPS * 4)

        if IPS == 0b110:
            if self.FEAT_LPA:
                translation_base_addr = (TTBR1_EL1 & 0xffffffffffc0) | (((TTBR1_EL1 >> 2) & 0b1111) << 48)
            else:
                err("Unsupported FEAT_LPA and IPS pair")
                return
        else:
            translation_base_addr = TTBR1_EL1 & 0xfffffffffffe

        if not self.quiet:
            info('$TTBR1_EL1: {:#x}'.format(TTBR1_EL1))
            info('$TCR_EL1: {:#x}'.format(TCR_EL1))
            info('Intermediate Physical Address Size: {:d} bits'.format(intermediate_pa_size))
            info('EL1 Kernel Region: {:#018x} - {:#018x} ({:d} bits)'.format(region_start, region_end - 1, region_bits))
            info('EL1 Kernel Page Size: {:d}KB (per page)'.format(page_size))

        self.parse_bit_range(granule_bits, region_bits)
        self.do_pagewalk(translation_base_addr, granule_bits, region_start, is_2VAranges=True)
        self.print_page()
        return

    def pagewalk_VTTBR_EL2(self):
        if not self.silent:
            gef_print(titlify("$VTTBR_EL2"))

        VTTBR_EL2 = get_register('$VTTBR_EL2')
        VTCR_EL2 = get_register('$VTCR_EL2')
        if VTTBR_EL2 == 0:
            if not self.silent:
                warn("Maybe unused VTTBR_EL2")
            return

        SL2 = (VTCR_EL2 >> 33) & 0b1
        PS = (VTCR_EL2 >> 16) & 0b11
        TG0 = (VTCR_EL2 >> 14) & 0b11
        SL0 = (VTCR_EL2 >> 6) & 0b11
        T0SZ = VTCR_EL2 & 0b111111
        try:
            granule_bits = {0b00: 12, 0b01: 16, 0b10: 14}[TG0]
        except Exception:
            if not self.silent:
                err("Unsupported $VTCR_EL2.TG0")
            return
        region_start = 0
        region_end = region_start + (2 ** (64 - T0SZ))
        region_bits = int(math.log2(region_end - region_start))
        page_size = 2 ** (granule_bits - 10)
        pa_size = 32 + (PS * 4)

        if self.FEAT_TTST:
            if SL0 == 0b00:
                if TG0 == 0b00:
                    if self.FEAT_LPA2 and SL2 == 1:
                        stage2_start_level = -1
                    else:
                        stage2_start_level = 2
                else:
                    stage2_start_level = 3
            elif SL0 == 0b01:
                if TG0 == 0b00:
                    if self.FEAT_LPA2 and SL2 == 1:
                        if not self.silent:
                            err("Unsupported stage2 start level")
                        return
                    else:
                        stage2_start_level = 1
                else:
                    stage2_start_level = 2
            elif SL0 == 0b10:
                if TG0 == 0b00:
                    if self.FEAT_LPA2 and SL2 == 1:
                        if not self.silent:
                            err("Unsupported stage2 start level")
                        return
                    else:
                        stage2_start_level = 0
                else:
                    stage2_start_level = 1
            elif SL0 == 0b11:
                if TG0 == 0b00:
                    if self.FEAT_LPA2 and SL2 == 1:
                        if not self.silent:
                            err("Unsupported stage2 start level")
                        return
                    else:
                        stage2_start_level = 3
                else:
                    stage2_start_level = 0
        else:
            if SL0 == 0b00:
                if TG0 == 0b00:
                    stage2_start_level = 2
                else:
                    stage2_start_level = 3
            elif SL0 == 0b01:
                if TG0 == 0b00:
                    stage2_start_level = 1
                else:
                    stage2_start_level = 2
            elif SL0 == 0b10:
                if TG0 == 0b00:
                    stage2_start_level = 0
                else:
                    stage2_start_level = 1
            else:
                if not self.silent:
                    err("Unsupported stage2 start level")
                return

        if PS == 0b110:
            if self.FEAT_LPA:
                translation_base_addr = (VTTBR_EL2 & 0xffffffffffc0) | (((VTTBR_EL2 >> 2) & 0b1111) << 48)
            else:
                if not self.silent:
                    err("Unsupported FEAT_LPA and PS pair")
                return
        else:
            translation_base_addr = VTTBR_EL2 & 0xfffffffffffe

        if not self.silent and not self.quiet:
            info('$VTTBR_EL2: {:#x}'.format(VTTBR_EL2))
            info('$VTCR_EL2: {:#x}'.format(VTCR_EL2))
            info('Physical Address Size: {:d} bits'.format(pa_size))
            info('EL2 Starting Level: {:d}'.format(SL0))
            info('EL2 Region: {:#018x} - {:#018x} ({:d} bits)'.format(region_start, region_end - 1, region_bits))
            info('EL2 Page Size: {:d}KB (per page)'.format(page_size))

        self.parse_bit_range(granule_bits, region_bits)
        self.do_pagewalk(translation_base_addr, granule_bits, region_start, start_level=stage2_start_level, is_stage2=True)
        if not self.silent:
            self.print_page()
        return

    def pagewalk_TTBR0_EL2(self):
        gef_print(titlify("$TTBR0_EL2"))

        TTBR0_EL2 = get_register('$TTBR0_EL2')
        TCR_EL2 = get_register('$TCR_EL2')
        if TTBR0_EL2 == 0:
            warn("Maybe unused TTBR0_EL2")
            return

        if self.EL2_E2H:
            IPS = (TCR_EL2 >> 32) & 0b111
        else:
            PS = (TCR_EL2 >> 16) & 0b111
        TG0 = (TCR_EL2 >> 14) & 0b11
        T0SZ = TCR_EL2 & 0b111111
        try:
            granule_bits = {0b00: 12, 0b01: 16, 0b10: 14}[TG0]
        except Exception:
            err("Unsupported $TCR_EL2.TG0")
            return
        region_start = 0
        region_end = region_start + (2 ** (64 - T0SZ))
        region_bits = int(math.log2(region_end - region_start))
        page_size = 2 ** (granule_bits - 10)
        if self.EL2_E2H:
            intermediate_pa_size = 32 + (IPS * 4)
        else:
            pa_size = 32 + (PS * 4)

        if not self.EL2_E2H and PS == 0b110:
            if self.FEAT_LPA:
                translation_base_addr = (TTBR0_EL2 & 0xffffffffffc0) | (((TTBR0_EL2 >> 2) & 0b1111) << 48)
            else:
                err("Unsupported FEAT_LPA and PS pair")
                return
        elif self.EL2_E2H and IPS == 0b110:
            if self.FEAT_LPA:
                translation_base_addr = (TTBR0_EL2 & 0xffffffffffc0) | (((TTBR0_EL2 >> 2) & 0b1111) << 48)
            else:
                err("Unsupported FEAT_LPA and IPS pair")
                return
        else:
            translation_base_addr = TTBR0_EL2 & 0xfffffffffffe

        if not self.quiet:
            info('$TTBR0_EL2: {:#x}'.format(TTBR0_EL2))
            info('$TCR_EL2: {:#x}'.format(TCR_EL2))
            if self.EL2_E2H:
                info('Intermediate Physical Address Size: {:d} bits'.format(intermediate_pa_size))
            else:
                info('Physical Address Size: {:d} bits'.format(pa_size))
            if self.EL2_M20:
                info('EL2 User Region: {:#018x} - {:#018x} ({:d} bits)'.format(region_start, region_end - 1, region_bits))
                info('EL2 USer Page Size: {:d}KB (per page)'.format(page_size))
            else:
                info('EL2 Region: {:#018x} - {:#018x} ({:d} bits)'.format(region_start, region_end - 1, region_bits))
                info('EL2 Page Size: {:d}KB (per page)'.format(page_size))

        self.parse_bit_range(granule_bits, region_bits)
        self.do_pagewalk(translation_base_addr, granule_bits, region_start, is_2VAranges=self.EL2_M20)
        self.print_page()
        return

    def pagewalk_TTBR1_EL2(self):
        gef_print(titlify("$TTBR1_EL2"))

        TTBR1_EL2 = get_register('$TTBR1_EL2')
        TCR_EL2 = get_register('$TCR_EL2')
        if TTBR1_EL2 == 0:
            warn("Maybe unused TTBR1_EL2")
            return

        IPS = (TCR_EL2 >> 32) & 0b111
        TG1 = (TCR_EL2 >> 30) & 0b11
        T1SZ = (TCR_EL2 >> 16) & 0b111111
        try:
            granule_bits = {0b01: 14, 0b10: 12, 0b11: 16}[TG1]
        except Exception:
            err("Unsupported $TCR_EL2.TG1")
            return
        region_end = 2 ** 64
        region_start = region_end - (2 ** (64 - T1SZ))
        region_bits = int(math.log2(region_end - region_start))
        page_size = 2 ** (granule_bits - 10)
        intermediate_pa_size = 32 + (IPS * 4)

        if IPS == 0b110:
            if self.FEAT_LPA:
                translation_base_addr = (TTBR1_EL2 & 0xffffffffffc0) | (((TTBR1_EL2 >> 2) & 0b1111) << 48)
            else:
                err("Unsupported FEAT_LPA and IPS pair")
                return
        else:
            translation_base_addr = TTBR1_EL2 & 0xfffffffffffe

        if not self.quiet:
            info('$TTBR1_EL2: {:#x}'.format(TTBR1_EL2))
            info('$TCR_EL2: {:#x}'.format(TCR_EL2))
            info('Intermediate Physical Address Size: {:d} bits'.format(intermediate_pa_size))
            info('EL2 Kernel Region: {:#018x} - {:#018x} ({:d} bits)'.format(region_start, region_end - 1, region_bits))
            info('EL2 Kernel Page Size: {:d}KB (per page)'.format(page_size))

        self.parse_bit_range(granule_bits, region_bits)
        self.do_pagewalk(translation_base_addr, granule_bits, region_start, is_2VAranges=self.EL2_M20)
        self.print_page()
        return

    def pagewalk_TTBR0_EL3(self):
        gef_print(titlify("$TTBR0_EL3"))

        TTBR0_EL3 = get_register('$TTBR0_EL3')
        TCR_EL3 = get_register('$TCR_EL3')
        if TTBR0_EL3 == 0:
            warn("Maybe unused TTBR0_EL3")
            return

        PS = (TCR_EL3 >> 16) & 0b111
        TG0 = (TCR_EL3 >> 14) & 0b11
        T0SZ = TCR_EL3 & 0b111111
        try:
            granule_bits = {0b00: 12, 0b01: 16, 0b10: 14}[TG0]
        except Exception:
            err("Unsupported $TCR_EL3.TG0")
            return
        region_start = 0
        region_end = region_start + (2 ** (64 - T0SZ))
        region_bits = int(math.log2(region_end - region_start))
        page_size = 2 ** (granule_bits - 10)
        pa_size = 32 + (PS * 4)

        if PS == 0b110:
            if self.FEAT_LPA:
                translation_base_addr = (TTBR0_EL3 & 0xffffffffffc0) | (((TTBR0_EL3 >> 2) & 0b1111) << 48)
            else:
                err("Unsupported FEAT_LPA and PS pair")
                return
        else:
            translation_base_addr = TTBR0_EL3 & 0xfffffffffffe

        if not self.quiet:
            info('$TTBR0_EL3: {:#x}'.format(TTBR0_EL3))
            info('$TCR_EL3: {:#x}'.format(TCR_EL3))
            info('Physical Address Size: {:d} bits'.format(pa_size))
            info('EL3 Region: {:#018x} - {:#018x} ({:d} bits)'.format(region_start, region_end - 1, region_bits))
            info('EL3 Page Size: {:d}KB (per page)'.format(page_size))

        self.parse_bit_range(granule_bits, region_bits)
        self.do_pagewalk(translation_base_addr, granule_bits, region_start)
        self.print_page()
        return

    def pagewalk_init(self):
        res = gdb.execute("info registers", to_string=True)
        if "TTBR" not in res:
            err("Not found system registers. Check qemu version (at least: 3.x~, recommend: 5.x~).")
            return

        SCTLR_EL1 = get_register('$SCTLR_EL1')
        if SCTLR_EL1 is None:
            SCTLR_EL1 = get_register('$SCTLR')
        if SCTLR_EL1 is not None:
            self.EL1_M = (SCTLR_EL1 & 1) == 1
            self.EL1_WXN = ((SCTLR_EL1 >> 19) & 1) == 1
        else:
            self.EL1_M = False
            self.EL1_WXN = False

        HCR_EL2 = get_register('$HCR_EL2')
        if HCR_EL2 is not None:
            self.EL2_TGE = ((HCR_EL2 >> 27) & 1) == 1
            self.EL2_E2H = ((HCR_EL2 >> 34) & 1) == 1
            self.EL2_M20 = self.EL2_TGE and self.EL2_E2H
            self.EL2_VM = (HCR_EL2 & 1) == 1
        else:
            self.EL2_TGE = False
            self.EL2_E2H = False
            self.EL2_M20 = False
            self.EL2_VM = False

        SCTLR_EL2 = get_register('$SCTLR_EL2')
        if SCTLR_EL2 is not None:
            self.EL2_M = (SCTLR_EL2 & 1) == 1
            self.EL2_WXN = ((SCTLR_EL2 >> 19) & 1) == 1
        else:
            self.EL2_M = False
            self.EL2_WXN = False

        SCTLR_EL3 = get_register('$SCTLR_EL3')
        if SCTLR_EL3 is not None:
            self.EL3_M = (SCTLR_EL3 & 1) == 1
            self.EL3_WXN = ((SCTLR_EL3 >> 19) & 1) == 1
        else:
            self.EL3_M = False
            self.EL3_WXN = False

        ID_AA64MMFR0_EL1 = get_register('$ID_AA64MMFR0_EL1')
        if ID_AA64MMFR0_EL1 is not None:
            TGran4_2 = (ID_AA64MMFR0_EL1 >> 40) & 0b1111
            TGran16_2 = (ID_AA64MMFR0_EL1 >> 32) & 0b1111
            TGran4 = (ID_AA64MMFR0_EL1 >> 28) & 0b1111
            TGran16 = (ID_AA64MMFR0_EL1 >> 20) & 0b1111
            self.FEAT_LPA2 = (TGran4_2 == 0b0011) or (TGran16_2 == 0b0011) or (TGran4 == 0b0001) or (TGran16 == 0b0010)
            self.FEAT_LPA = (ID_AA64MMFR0_EL1 & 0b1111) == 0b0110
        else:
            self.FEAT_LPA2 = False
            self.FEAT_LPA = False

        ID_AA64MMFR1_EL1 = get_register('$ID_AA64MMFR1_EL1')
        if ID_AA64MMFR1_EL1 is not None:
            self.FEAT_PAN = ((ID_AA64MMFR1_EL1 >> 20) & 0b1111) != 0b0000
        else:
            self.FEAT_PAN = False
        if not self.quiet:
            info("{:s} is supported on all ARMv8".format(Color.boldify("PXN")))
            if self.FEAT_PAN:
                info("{:s} is supported".format(Color.boldify("PAN")))
            else:
                info("PAN is unsupported")

        ID_AA64MMFR2_EL1 = get_register('$ID_AA64MMFR2_EL1')
        if ID_AA64MMFR2_EL1 is not None:
            self.FEAT_TTST = ((ID_AA64MMFR2_EL1 >> 28) & 0b1111) == 0b0001
            self.FEAT_LVA = ((ID_AA64MMFR2_EL1 >> 16) & 0b1111) == 0b0001
        else:
            self.FEAT_TTST = False
            self.FEAT_LVA = False

        return

    def pagewalk(self):
        # parse system registers
        self.pagewalk_init()

        # TODO implementation for VSTTBR_EL2, VSTCR_EL2 pattern

        # do pagewalk
        if self.TargetEL < 1 or 3 < self.TargetEL:
            warn('No paging in EL{:d}'.format(self.TargetEL))
            return
        if self.TargetEL == 1 and self.EL1_M:
            if self.EL2_VM:
                # el2_mapping is needed because read_mem() uses PA, but not IPA
                self.silent = True
                self.pagewalk_VTTBR_EL2()
                if self.mappings:
                    self.el2_mappings = self.mappings
                self.silent = False
            self.pagewalk_TTBR0_EL1()
            self.pagewalk_TTBR1_EL1()
        if self.TargetEL == 1 and not self.EL1_M:
            if not self.quiet:
                info("EL1/0 translation is unused")
        if self.TargetEL == 2 and self.EL2_VM:
            self.pagewalk_VTTBR_EL2()
        if self.TargetEL == 2 and not self.EL2_VM:
            if not self.quiet:
                info("EL2(as stage2) translation is unused")
        if self.TargetEL == 2 and self.EL2_M:
            self.pagewalk_TTBR0_EL2()
            if self.EL2_M20:
                self.pagewalk_TTBR1_EL2()
        if self.TargetEL == 2 and self.EL2_VM:
            if not self.quiet:
                info("EL2(as stage1) translation is unused")
        if self.TargetEL == 3 and self.EL3_M:
            if not self.switch_el():
                return
            self.pagewalk_TTBR0_EL3()
            self.revert_el()
        if self.TargetEL == 3 and not self.EL3_M:
            if not self.quiet:
                info("EL3 translation is unused")
        return

    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        if not is_arm64():
            err("Unsupported")
            return

        try:
            argv = self.parse_common_args(argv)
            if argv:
                self.TargetEL = int(argv[-1])
                argv = argv[:-1]
                if argv:
                    raise
            else:
                CPSR = int(gdb.parse_and_eval('$cpsr'))
                self.TargetEL = (CPSR >> 2) & 0b11
        except Exception:
            self.usage()
            return

        self.silent = False
        self.mappings = None
        self.el2_mappings = None
        self.pagewalk()
        self.cache = {}
        return


@register_command
class SwitchELCommand(GenericCommand):
    """Switch EL (Exception Level) on ARM64 architecture."""
    _cmdline_ = "switch-el"
    _syntax_ = "{:s} [-h] [TARGET_EL]".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    def switch_el(self):
        # current EL
        CPSR = int(gdb.parse_and_eval('$cpsr')) & 0xffffffff
        CurrentEL = (CPSR >> 2) & 0b11

        # check argv
        if self.target_el is None:
            info('$cpsr = 0x%x (EL%d)' % (CPSR, CurrentEL))
            return

        # check target EL
        try:
            if self.target_el < 0 or self.target_el > 3:
                err("Invalid argument (ELx>=0 && ELx<=3)")
                return
        except ValueError:
            err("Invalid argument (ELx integer required)")
            return

        # change CPSR
        if self.target_el != CurrentEL:
            CPSR = CPSR & ~(0b11 << 2) # clear EL
            CPSR |= self.target_el << 2 # set desired EL
            gdb.parse_and_eval('$cpsr = 0x%08x' % CPSR)
            info('Moving to EL%d' % (self.target_el))
        else:
            info('Already at EL%d' % (self.target_el))

        # reprint CPSR
        CPSR = int(gdb.parse_and_eval('$cpsr')) & 0xffffffff
        CurrentEL = (CPSR >> 2) & 0b11
        info('$cpsr = 0x%x (EL%d)' % (CPSR, CurrentEL))
        return

    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return
        if not is_arm64():
            err("Unsupported")
            return
        if argv:
            self.target_el = int(argv[0])
        else:
            self.target_el = None
        self.switch_el()
        return


@register_command
class MemoryHashCommand(GenericCommand):
    """Caluculate memory hash."""
    _cmdline_ = "hash-memory"
    _syntax_ = "{:s} [-h] md5|sha1|sha224|sha256|sha384|sha512|crc16|crc32|crc64 ADDRESS SIZE".format(_cmdline_)
    _category_ = "Misc"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    def calc_hash(self, type, h, start_address, end_address):
        step = 0x400 * gef_getpagesize()
        if is_qemu_system():
            step = gef_getpagesize()

        for chunk_addr in range(start_address, end_address, step):
            if chunk_addr + step > end_address:
                chunk_size = end_address - chunk_addr
            else:
                chunk_size = step

            try:
                mem = read_memory(chunk_addr, chunk_size)
            except gdb.MemoryError:
                err("Memory read error")
                return None

            if type == 1:
                h.update(mem)
            elif type == 2:
                h.process(mem)

            del mem
        if type == 1:
            return h.hexdigest()
        elif type == 2:
            return h.finalhex()
        return None

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if "-h" in argv:
            self.usage()
            return

        if len(argv) != 3:
            self.usage()
            return

        if not argv[0] in ["md5", "sha1", "sha224", "sha256", "sha384", "sha512", "crc16", "crc32", "crc64"]:
            self.usage()
            return

        try:
            address = int(argv[1], 0)
            size = int(argv[2], 0)
        except Exception:
            self.usage()
            return

        gef_print("Address: {:#x}".format(address))
        gef_print("Size: {:#x}".format(size))

        if argv[0] == "md5":
            h = self.calc_hash(1, hashlib.md5(), address, address + size)
        elif argv[0] == "sha1":
            h = self.calc_hash(1, hashlib.sha1(), address, address + size)
        elif argv[0] == "sha224":
            h = self.calc_hash(1, hashlib.sha224(), address, address + size)
        elif argv[0] == "sha256":
            h = self.calc_hash(1, hashlib.sha256(), address, address + size)
        elif argv[0] == "sha384":
            h = self.calc_hash(1, hashlib.sha384(), address, address + size)
        elif argv[0] == "sha512":
            h = self.calc_hash(1, hashlib.sha512(), address, address + size)
        else:
            try:
                crccheck = __import__("crccheck")
            except ImportError:
                msg = "Missing `crccheck` package for Python, install with: `pip install crccheck`."
                raise ImportWarning(msg)
            if argv[0] == "crc16":
                h = self.calc_hash(2, crccheck.crc.Crc16(), address, address + size)
            elif argv[0] == "crc32":
                h = self.calc_hash(2, crccheck.crc.Crc32(), address, address + size)
            elif argv[0] == "crc64":
                h = self.calc_hash(2, crccheck.crc.Crc64(), address, address + size)

        if h is None:
            return

        gef_print("{:s} ({:d}-bit)".format(h, len(h) * 4))
        return


@register_command
class ExecNextCommand(GenericCommand):
    """Execute until next address. This command is used for rep prefix."""
    _cmdline_ = "exec-next"
    _syntax_ = "{:s}".format(_cmdline_)
    _category_ = "Debugging Support"

    @only_if_gdb_running
    def do_invoke(self, argv):
        if is_arm32() or is_arm64():
            next_addr = gdb_get_nth_next_instruction_address(current_arch.pc, 1)
        else:
            next_addr = gdb_get_nth_next_instruction_address(current_arch.pc, 2)
        # `until` command has a bug(?) because sometimes fail. we use `tbreak` and `continue` instead of `until`.
        gdb.execute("tbreak *{:#x}".format(next_addr))
        gdb.execute("continue")
        return


@register_command
class ExecUntilCommand(GenericCommand):
    """Execute until next call/jmp/syscall/ret/mem-access/specified-keyword instruction."""
    _cmdline_ = "exec-until"
    _syntax_ = "{:s} [-h] call|jmp|syscall|ret|memaccess|keyword|cond [ARGS] [--print-insn] [--skip-lib]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} call # execute until call instruction\n".format(_cmdline_)
    _example_ += "{:s} jmp # execute until jmp instruction\n".format(_cmdline_)
    _example_ += "{:s} syscall # execute until syscall instruction\n".format(_cmdline_)
    _example_ += "{:s} ret # execute until ret instruction\n".format(_cmdline_)
    _example_ += "{:s} memaccess # execute until '[' is included by the instruction\n".format(_cmdline_)
    _example_ += "{:s} keyword \"call +r[ab]x\" # execute until specified keyword (regex)\n".format(_cmdline_)
    _example_ += "{:s} cond \"$rax==0xdeadbeef && $rbx==0xcafebabe\" # execute until specified condition is filled\n".format(_cmdline_)
    _example_ += "THIS FEATURE IS TOO SLOW.\n"
    _example_ += "Consider using the `--skip-lib` option. (it uses `nexti` instead of `stepi` if instruction is `call xxx@plt`)"
    _category_ = "Debugging Support"

    def __init__(self, *args, **kwargs):
        prefix = kwargs.get("prefix", True)
        super().__init__(prefix=prefix)
        self.mode = None
        return

    def close_stdout_stderr(self):
        self.stdout = 1
        self.stdout_bak = os.dup(self.stdout)
        f = open("/dev/null")
        os.dup2(f.fileno(), self.stdout)
        f.close()

        self.stderr = 2
        self.stderr_bak = os.dup(self.stderr)
        f = open("/dev/null")
        os.dup2(f.fileno(), self.stderr)
        f.close()
        return

    def revert_stdout_stderr(self):
        os.dup2(self.stdout_bak, self.stdout)
        os.close(self.stdout_bak)
        os.dup2(self.stderr_bak, self.stderr)
        os.close(self.stderr_bak)
        return

    def force_write_stdout(self, msg):
        open("/proc/self/fd/0", "wb").write(msg)
        return

    def is_target_insn(self, insn):
        if self.mode == "call":
            return current_arch.is_call(insn)
        elif self.mode == "jmp":
            return current_arch.is_jump(insn)
        elif self.mode == "indirect-branch":
            if current_arch.is_call(insn) or current_arch.is_jump(insn):
                if "[" in str(insn):
                    return True
                for reg in current_arch.gpr_registers:
                    if reg.replace("$", "") in str(insn):
                        return True
            return False
        elif self.mode == "syscall":
            return current_arch.is_syscall(insn)
        elif self.mode == "ret":
            return current_arch.is_ret(insn)
        elif self.mode == "memaccess":
            return "[" in str(insn)
        elif self.mode == "keyword":
            for k in self.keyword:
                if re.search(k, str(insn)):
                    return True
            return False
        elif self.mode == "cond":
            try:
                v = gdb.parse_and_eval(self.condition)
            except gdb.error:
                return False
            if v not in [0x0, 0x1]:
                self.err = "condition result should be True or False"
                return True
            if v:
                return True
        return False

    def get_breakpoint_list(self):
        lines = gdb.execute("info breakpoints", to_string=True).splitlines()
        if lines[0] == 'No breakpoints or watchpoints.':
            return []

        enable_idx = lines[0].index("Enb")
        addr_idx = lines[0].index("Address")

        bp_list = []
        for line in lines[1:]:
            try:
                if line[0] == "\t":
                    continue
                enable = line[enable_idx]
                addr = int(line[addr_idx:].split()[0], 16)
                if enable == 'y':
                    bp_list.append(addr)
            except Exception:
                pass
        # breakpoint with condition is unsupported
        return bp_list

    def exec_next(self):
        bp_list = self.get_breakpoint_list()
        gef_on_stop_unhook(hook_stop_handler)
        self.close_stdout_stderr()
        self.err = None

        prev_addr = -1
        try:
            count = 0
            while True:
                # progress
                if not self.print_insn and count % 100 == 0:
                    self.force_write_stdout([b"\r|", b"\r/", b"\r-", b"\r\\"][count // 100 % 4])

                # backup
                prev_prev_addr = prev_addr
                prev_addr = current_arch.pc

                # execute 1 instruction
                insn = gef_current_instruction(current_arch.pc)
                if self.skip_lib and "@plt>" in str(insn):
                    gdb.execute("nexti")
                else:
                    gdb.execute("stepi")

                # check breakpoint
                insn = gef_current_instruction(current_arch.pc)
                if current_arch.pc in bp_list:
                    break

                # $pc is not changed
                if prev_prev_addr == prev_addr == current_arch.pc: # for faster, repeat insn is skip
                    # infinity self loop
                    if current_arch.is_call(insn) or current_arch.is_jump(insn) or current_arch.is_ret(insn):
                        self.err = "Detected infinity loop prev_addr"
                        break
                    # maybe rep prefix
                    gdb.execute("exec-next")
                    # recheck
                    if prev_prev_addr == prev_addr == current_arch.pc:
                        self.err = "Detected infinity loop prev_addr"
                        break
                    insn = gef_current_instruction(current_arch.pc)

                if self.print_insn:
                    self.force_write_stdout((str(insn) + "\n").encode())

                # found and break
                if current_arch.pc not in self.filter:
                    if self.is_target_insn(insn):
                        if not self.print_insn:
                            self.force_write_stdout(b"\r \r")
                        break

                count += 1

        except KeyboardInterrupt:
            pass

        except Exception:
            if is_alive():
                exc_type, exc_value, exc_traceback = sys.exc_info()
                self.err = exc_value
            else:
                pass

        finally:
            self.revert_stdout_stderr() # anytime needed
            gef_on_stop_hook(hook_stop_handler) # anytime needed
            if self.err:
                err(self.err)
            else:
                gdb.execute("context")
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        if "-h" in argv:
            self.usage()
            return

        if self.mode is None:
            self.usage()
            return

        self.print_insn = False
        if "--print-insn" in argv:
            argv.remove("--print-insn")
            self.print_insn = True

        self.skip_lib = False
        if "--skip-lib" in argv:
            argv.remove("--skip-lib")
            self.skip_lib = True

        self.filter = []
        while "-v" in argv:
            idx = argv.index("-v")
            filter_address = int(argv[idx + 1], 16)
            self.filter.append(filter_address)
            argv = argv[:idx] + argv[idx + 2:]

        if argv:
            self.usage()
            return

        self.exec_next()
        return


@register_command
class ExecUntilCallCommand(ExecUntilCommand):
    """Execute until next call instruction (alias: next-call)."""
    _cmdline_ = "exec-until call"
    _syntax_ = "{:s} [-h] [--print-insn] [--skip-lib]".format(_cmdline_)
    _example_ = "{:s} # execute until call instruction\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "THIS FEATURE IS TOO SLOW.\n"
    _example_ += "Consider using the `--skip-lib` option. (it uses `nexti` instead of `stepi` if instruction is `call xxx@plt`)"
    _category_ = "Debugging Support"
    _aliases_ = ["next-call"]
    _repeat_ = True

    def __init__(self):
        super().__init__(prefix=False)
        self.mode = "call"
        return


@register_command
class ExecUntilJumpCommand(ExecUntilCommand):
    """Execute until next jmp instruction (alias: next-jmp)."""
    _cmdline_ = "exec-until jmp"
    _syntax_ = "{:s} [-h] [--print-insn] [--skip-lib]".format(_cmdline_)
    _example_ = "{:s} # execute until jmp instruction\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "THIS FEATURE IS TOO SLOW.\n"
    _example_ += "Consider using the `--skip-lib` option. (it uses `nexti` instead of `stepi` if instruction is `call xxx@plt`)"
    _category_ = "Debugging Support"
    _aliases_ = ["next-jmp"]
    _repeat_ = True

    def __init__(self):
        super().__init__(prefix=False)
        self.mode = "jmp"
        return


@register_command
class ExecUntilIndirectBranchCommand(ExecUntilCommand):
    """Execute until next indirect call/jmp instruction (x86/x64 only) (alias: next-indirect-branch)."""
    _cmdline_ = "exec-until indirect-branch"
    _syntax_ = "{:s} [-h] [--print-insn] [--skip-lib]".format(_cmdline_)
    _example_ = "{:s} # execute until indirect branch instruction\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "THIS FEATURE IS TOO SLOW.\n"
    _example_ += "Consider using the `--skip-lib` option. (it uses `nexti` instead of `stepi` if instruction is `call xxx@plt`)"
    _category_ = "Debugging Support"
    _aliases_ = ["next-indirect-branch"]
    _repeat_ = True

    def __init__(self):
        super().__init__(prefix=False)
        self.mode = "indirect-branch"
        return

    @only_if_gdb_running
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, argv):
        if "-h" in argv:
            self.usage()
            return

        self.print_insn = False
        if "--print-insn" in argv:
            argv.remove("--print-insn")
            self.print_insn = True

        self.skip_lib = False
        if "--skip-lib" in argv:
            argv.remove("--skip-lib")
            self.skip_lib = True

        self.filter = []
        while "-v" in argv:
            idx = argv.index("-v")
            filter_address = int(argv[idx + 1], 16)
            self.filter.append(filter_address)
            argv = argv[:idx] + argv[idx + 2:]

        if argv:
            self.usage()
            return

        self.exec_next()
        return


@register_command
class ExecUntilSyscallCommand(ExecUntilCommand):
    """Execute until next syscall instruction (alias: next-syscall)."""
    _cmdline_ = "exec-until syscall"
    _syntax_ = "{:s} [-h] [--print-insn] [--skip-lib]".format(_cmdline_)
    _example_ = "{:s} # execute until syscall instruction\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "THIS FEATURE IS TOO SLOW.\n"
    _example_ += "Consider using the `--skip-lib` option. (it uses `nexti` instead of `stepi` if instruction is `call xxx@plt`)"
    _category_ = "Debugging Support"
    _aliases_ = ["next-syscall"]
    _repeat_ = True

    def __init__(self):
        super().__init__(prefix=False)
        self.mode = "syscall"
        return


@register_command
class ExecUntilRetCommand(ExecUntilCommand):
    """Execute until next ret instruction (alias: next-ret)."""
    _cmdline_ = "exec-until ret"
    _syntax_ = "{:s} [-h] [--print-insn] [--skip-lib]".format(_cmdline_)
    _example_ = "{:s} # execute until ret instruction\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "THIS FEATURE IS TOO SLOW.\n"
    _example_ += "Consider using the `--skip-lib` option. (it uses `nexti` instead of `stepi` if instruction is `call xxx@plt`)"
    _category_ = "Debugging Support"
    _aliases_ = ["next-ret"]
    _repeat_ = True

    def __init__(self):
        super().__init__(prefix=False)
        self.mode = "ret"
        return


@register_command
class ExecUntilMemaccessCommand(ExecUntilCommand):
    """Execute until next mem-access instruction (alias: next-mem)."""
    _cmdline_ = "exec-until memaccess"
    _syntax_ = "{:s} [-h] [--print-insn] [--skip-lib]".format(_cmdline_)
    _example_ = "{:s} # execute until '[' is included by the instruction\n".format(_cmdline_)
    _example_ += "\n"
    _example_ += "THIS FEATURE IS TOO SLOW.\n"
    _example_ += "Consider using the `--skip-lib` option. (it uses `nexti` instead of `stepi` if instruction is `call xxx@plt`)"
    _category_ = "Debugging Support"
    _aliases_ = ["next-mem"]
    _repeat_ = True

    def __init__(self):
        super().__init__(prefix=False)
        self.mode = "memaccess"
        return


@register_command
class ExecUntilKeywordReCommand(ExecUntilCommand):
    """Execute until specified keyword instruction (alias: next-keyword)."""
    _cmdline_ = "exec-until keyword"
    _syntax_ = "{:s} [-h] KEYWORD [KEYWORD ...] [--print-insn] [--skip-lib]".format(_cmdline_)
    _example_ = "\n"
    _example_ += '{:s} "call +r[ab]x" # execute until specified keyword (regex)\n'.format(_cmdline_)
    _example_ += '{:s} "(push|pop) +(r[a-d]x|r[ds]i|r[sb]p|r[89]|r1[0-5])" # another exsample\n'.format(_cmdline_)
    _example_ += '{:s} "mov +rax, QWORD PTR \\\\[" # another exsample (need double escape if use)\n'.format(_cmdline_)
    _example_ += "\n"
    _example_ += "THIS FEATURE IS TOO SLOW.\n"
    _example_ += "Consider using the `--skip-lib` option. (it uses `nexti` instead of `stepi` if instruction is `call xxx@plt`)"
    _category_ = "Debugging Support"
    _aliases_ = ["next-keyword"]
    _repeat_ = True

    def __init__(self):
        super().__init__(prefix=False)
        self.mode = "keyword"
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        if "-h" in argv:
            self.usage()
            return

        self.print_insn = False
        if "--print-insn" in argv:
            argv.remove("--print-insn")
            self.print_insn = True

        self.skip_lib = False
        if "--skip-lib" in argv:
            argv.remove("--skip-lib")
            self.skip_lib = True

        self.filter = []
        while "-v" in argv:
            idx = argv.index("-v")
            filter_address = int(argv[idx + 1], 16)
            self.filter.append(filter_address)
            argv = argv[:idx] + argv[idx + 2:]

        if len(argv) == 0:
            self.usage()
            return

        self.keyword = argv
        self.exec_next()
        return


@register_command
class ExecUntilCondCommand(ExecUntilCommand):
    """Execute until specified condition is filled (alias: next-cond)."""
    _cmdline_ = "exec-until cond"
    _syntax_ = "{:s} [-h] CONDITION [--print-insn] [--skip-lib]".format(_cmdline_)
    _example_ = "\n"
    _example_ += '{:s} "$rax==0xdeadbeef && $rbx==0xcafebabe" # execute until specified condition is filled\n'.format(_cmdline_)
    _example_ += '{:s} "$rax==0x123 && *(long*)$rbx==0x4" # multiple condition and memory access is supported\n'.format(_cmdline_)
    _example_ += '{:s} "$ALL_REG==0x1234" # means compare with all registers. ex: `($rax==0x1234||$rbx==0x1234||...)`\n'.format(_cmdline_)
    _example_ += "\n"
    _example_ += "THIS FEATURE IS TOO SLOW.\n"
    _example_ += "Consider using the `--skip-lib` option. (it uses `nexti` instead of `stepi` if instruction is `call xxx@plt`)"
    _category_ = "Debugging Support"
    _aliases_ = ["next-cond"]
    _repeat_ = True

    def __init__(self):
        super().__init__(prefix=False)
        self.mode = "cond"
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        if "-h" in argv:
            self.usage()
            return

        self.print_insn = False
        if "--print-insn" in argv:
            argv.remove("--print-insn")
            self.print_insn = True

        self.skip_lib = False
        if "--skip-lib" in argv:
            argv.remove("--skip-lib")
            self.skip_lib = True

        self.filter = []
        while "-v" in argv:
            idx = argv.index("-v")
            filter_address = int(argv[idx + 1], 16)
            self.filter.append(filter_address)
            argv = argv[:idx] + argv[idx + 2:]

        if len(argv) == 0:
            self.usage()
            return

        condition = argv[0]
        if re.search(r"[^><!=]=[^=]", condition):
            err("Should not use `=` since it will be replace register/memory value. Use `==`.")
            return

        match = re.search(r"\$ALL_REG==(\w+)", condition)
        if match:
            value = match.groups()[0]
            replace_cond = []
            if hasattr(current_arch, "gpr_registers"):
                regs = current_arch.gpr_registers
            else:
                regs = current_arch.all_registers
                if hasattr(current_arch, "flag_register"):
                    if current_arch.flag_register in regs:
                        regs.remove(current_arch.flag_register)
            for regname in regs:
                replace_cond.append("{:s}=={:s}".format(regname, value))
            replace_string = "(" + "||".join(replace_cond) + ")"
            condition = re.sub(r"\$ALL_REG==(\w+)", replace_string, condition)

        info("Condition: {:s}".format(condition))
        self.condition = condition
        self.exec_next()
        return


class CallUsermodehelperSetupBreakpoint(gdb.Breakpoint):
    """Create a breakpoint to print argv information at call_usermodehelper_setup"""
    def __init__(self, loc):
        super().__init__("*{:#x}".format(loc), gdb.BP_BREAKPOINT, internal=False)
        return

    def stop(self):
        ptr1, addr1 = current_arch.get_ith_parameter(0)
        ptr2, addr2 = current_arch.get_ith_parameter(1)
        path = read_cstring_from_memory(addr1)
        argv = []
        while True:
            string_addr = read_int_from_memory(addr2)
            if string_addr == 0:
                break
            string = read_cstring_from_memory(string_addr)
            argv.append("'{:s}'".format(string))
            addr2 += current_arch.ptrsize
        gef_print("{:s}: {:#x} -> '{:s}'".format(ptr1, addr1, path))
        gef_print("{:s}: {:#x} -> [{:s}]".format(ptr2, addr2, ','.join(argv)))
        return False # continue


@register_command
class UsermodehelperHunterCommand(GenericCommand):
    """Collects and displays information that is executed by call_usermodehelper_setup"""
    _cmdline_ = "usermodehelper-hunter"
    _syntax_ = "{:s} [-h]".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        info("Resolving the function addresses")
        addr = get_ksymaddr("call_usermodehelper_setup")
        if addr is None:
            err("Not found call_usermodehelper_setup")
            return
        CallUsermodehelperSetupBreakpoint(addr)
        info("Do `continue`. If failed, try `vmlinux-to-elf-apply`")
        return


class ThunkBreakpoint(gdb.Breakpoint):
    """Create a breakpoint to print caller address for thunk function"""
    def __init__(self, loc, sym, reg, maps):
        super().__init__("*{:#x}".format(loc), gdb.BP_BREAKPOINT, internal=False)
        self.loc = loc
        self.sym = sym
        self.reg = reg
        self.maps = maps
        self.seen = []
        return

    def search_perm(self, target):
        for m in self.maps:
            addr, size, perm = m
            if addr <= target < addr + size:
                return perm.lower()
        return "?"

    def stop(self):
        try:
            return_address = gdb.selected_frame().older().pc()
            caller_address = gdb_get_nth_previous_instruction_address(return_address, 1)
            target_address = get_register(self.reg)
        except Exception:
            return False # continue

        # duplicate, check
        if (caller_address, target_address) in self.seen:
            return False # continue
        else:
            self.seen.append((caller_address, target_address))

        # get caller address, symbol
        caller_symbol = get_symbol_string(caller_address, nosymbol_string=" <NO_SYMBOL>")

        # get callee address, symbol
        target_symbol = get_symbol_string(target_address, nosymbol_string=" <NO_SYMBOL>")

        # print information
        if caller_address is None:
            fmt = "{:s}{:s} -> {:#x} <{:s}> -> {:#x}{:s}"
            msg = fmt.format("???(unknown)", caller_symbol, self.loc, self.sym, target_address, target_symbol)
        else:
            fmt = "{:#x}{:s} -> {:#x} <{:s}> -> {:#x}{:s}"
            msg = fmt.format(caller_address, caller_symbol, self.loc, self.sym, target_address, target_symbol)
        info(msg)

        # print preferred register condition
        pattern = [0] + [(x + 1) * y for x, y in itertools.product(range(0x100), [1, -1])] # [0, 1, -1, 2, -2, ...]
        for reg in current_arch.gpr_registers:
            reg_value = get_register(reg)
            for i in pattern:
                slide = current_arch.ptrsize * i
                reg_value_slided = reg_value + slide
                try:
                    mem_value = read_int_from_memory(reg_value_slided)
                except Exception:
                    continue
                if mem_value == target_address:
                    perm = self.search_perm(reg_value_slided)
                    reg_value_slided_symbol = get_symbol_string(reg_value_slided, nosymbol_string=" <NO_SYMBOL>")
                    mem_value_symbol = get_symbol_string(mem_value, nosymbol_string=" <NO_SYMBOL>")
                    fmt = "    {:s}{:+#x}: {:#x}{:s} [{:s}]  ->  {:#x}{:s}"
                    info(fmt.format(reg, slide, reg_value_slided, reg_value_slided_symbol, perm, mem_value, mem_value_symbol))
                    break
        return False # continue


@register_command
class ThunkHunterCommand(GenericCommand):
    """Collects and displays the thunk addresses that are called automatically.
    If this address comes from RW area, this is useful for getting RIP.(x64/x86 only)"""
    _cmdline_ = "thunk-hunter"
    _syntax_ = "{:s} [-h]".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, argv):
        self.dont_repeat()

        info("Wait for memory scan")
        maps = KernelbaseCommand.get_maps() # [vaddr, size, perm]
        info("Resolving thunk function addresses")
        for reg in current_arch.gpr_registers:
            if reg in ["$esp", "$rsp", "$eip", "$rip"]:
                continue
            sym = "__x86_indirect_thunk_{}".format(reg.replace("$", ""))
            addr = get_ksymaddr(sym)
            if addr is None:
                continue
            gef_print(sym + ": ", end="")
            ThunkBreakpoint(addr, sym, reg, maps)
        info("Do `continue`. If NO_SYMBOL is in the result, try `vmlinux-to-elf-apply`")
        return


@register_command
class UefiOvmfInfoCommand(GenericCommand):
    """Print UEFI OVMF info.
    https://github.com/tianocore/tianocore.github.io/wiki/OVMF-Boot-Overview
    https://github.com/tianocore/edk2/blob/master/OvmfPkg/Sec/SecMain.c
    https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Core/Pei/PeiMain/PeiMain.c
    https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Core/Dxe/DxeMain/DxeMain.c
    https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Universal/BdsDxe/BdsEntry.c
    https://uefi.org/sites/default/files/resources/UEFI_Spec_2_8_final.pdf"""
    _cmdline_ = "uefi-ovmf-info"
    _syntax_ = "{:s}".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    def check_crc32(self, addr):
        try:
            crccheck = __import__("crccheck")
        except ImportError:
            msg = "Missing `crccheck` package for Python, install with: `pip install crccheck`."
            raise ImportWarning(msg)

        size = u32(read_memory(addr + 0xc, 0x4))
        if size <= 0 or size > 0x1000:
            return False
        crc = u64(read_memory(addr + 0x10, 0x8))
        if crc == 0:
            return False
        data = read_memory(addr, 0x10)
        data += p64(0x0) # crc is zero when calculate
        data += read_memory(addr + 0x18, size - 0x18)
        calculated_crc = crccheck.crc.Crc32().calc(data)
        return calculated_crc == crc

    def read_structure(self, addr, structure):
        d = {}
        d["__addr"] = addr
        for size, name in structure:
            unpack = u32 if size == 4 else u64
            d[name] = unpack(read_memory(addr, size))
            addr += size
        return d

    @functools.lru_cache()
    def get_gPs(self):
        result = gdb.execute("search-pattern 'PEI SERV' --disable-utf16", to_string=True) # EFI_TABLE_HEADER.Signature
        result = filter(lambda x: "->" in x, result.splitlines())
        result = [int(x.split()[0], 16) for x in result]
        for addr in result[::-1]: # Higher address seems more likely
            return addr
        return None

    def read_gPs(self):
        addr = self.get_gPs()
        if addr is None:
            return None
        structure = [
            [8, "Hdr.Signature"],
            [4, "Hdr.Revision"],
            [4, "Hdr.HeaderSize"],
            [4, "Hdr.CRC32"],
            [4, "Hdr.Reserved"],
            [8, "InstallPpi"],
            [8, "ReInstallPpi"],
            [8, "LocatePpi"],
            [8, "NotifyPpi"],
            [8, "GetBootMode"],
            [8, "SetBootMode"],
            [8, "GetHobList"],
            [8, "CreateHob"],
            [8, "FfsFindNextVolume"],
            [8, "FfsFindNextFile"],
            [8, "FfsFindSectionData"],
            [8, "InstallPeiMemory"],
            [8, "AllocatePages"],
            [8, "AllocatePool"],
            [8, "CopyMem"],
            [8, "SetMem"],
            [8, "ReportStatusCode"],
            [8, "ResetSystem"],
            [8, "CpuIo"],
            [8, "PciCfg"],
            [8, "FfsFindFileByName"],
            [8, "FfsGetFileInfo"],
            [8, "FfsGetVolumeInfo"],
            [8, "RegisterForShadow"],
            [8, "FindSectionData3"],
            [8, "FfsGetFileInfo2"],
            [8, "ResetSystem2"],
            [8, "FreePages"],
        ]
        return self.read_structure(addr, structure)

    def dump_gPs(self):
        self.gPs = self.read_gPs()
        if self.gPs is None:
            err("gPs is not found")
            return
        info("gPs: {:#x}".format(self.gPs["__addr"]))
        for k, v in self.gPs.items():
            if k.startswith("__"):
                continue
            gef_print("  {:40s}{:#x}".format(k + ":", v))
        return

    @functools.lru_cache()
    def get_mBootServices(self):
        result = gdb.execute("search-pattern BOOTSERV --disable-utf16", to_string=True) # EFI_TABLE_HEADER.Signature
        result = filter(lambda x: "->" in x, result.splitlines())
        result = [int(x.split()[0], 16) for x in result]
        for addr in result[::-1]: # Higher address seems more likely
            if self.check_crc32(addr):
                return addr
        return None

    def read_mBootServices(self):
        addr = self.get_mBootServices()
        if addr is None:
            return None
        structure = [
            [8, "Hdr.Signature"],
            [4, "Hdr.Revision"],
            [4, "Hdr.HeaderSize"],
            [4, "Hdr.CRC32"],
            [4, "Hdr.Reserved"],
            [8, "RaiseTPL"],
            [8, "RestoreTPL"],
            [8, "AllocatePages"],
            [8, "FreePages"],
            [8, "GetMemoryMap"],
            [8, "AllocatePool"],
            [8, "FreePool"],
            [8, "CreateEvent"],
            [8, "SetTimer"],
            [8, "WaitForEvent"],
            [8, "SignalEvent"],
            [8, "CloseEvent"],
            [8, "CheckEvent"],
            [8, "InstallProtocolInterface"],
            [8, "ReinstallProtocolInterface"],
            [8, "UninstallProtocolInterface"],
            [8, "HandleProtocol"],
            [8, "Reserved"],
            [8, "RegisterProtocolNotify"],
            [8, "LocateHandle"],
            [8, "LocateDevicePath"],
            [8, "InstallConfigurationTable"],
            [8, "LoadImage"],
            [8, "StartImage"],
            [8, "Exit"],
            [8, "UnloadImage"],
            [8, "ExitBootServices"],
            [8, "GetNextMonotonicCount"],
            [8, "Stall"],
            [8, "SetWatchdogTimer"],
            [8, "ConnectController"],
            [8, "DisconnectController"],
            [8, "OpenProtocol"],
            [8, "CloseProtocol"],
            [8, "OpenProtocolInformation"],
            [8, "ProtocolsPerHandle"],
            [8, "LocateHandleBuffer"],
            [8, "LocateProtocol"],
            [8, "InstallMultipleProtocolInterfaces"],
            [8, "UninstallMultipleProtocolInterfaces"],
            [8, "CalculateCrc32"],
            [8, "CopyMem"],
            [8, "SetMem"],
            [8, "CreateEventEx"],
        ]
        return self.read_structure(addr, structure)

    def dump_mBootServices(self):
        self.mBootServices = self.read_mBootServices()
        if self.mBootServices is None:
            err("mBootServices is not found")
            return
        info("mBootServices: {:#x}".format(self.mBootServices["__addr"]))
        for k, v in self.mBootServices.items():
            if k.startswith("__"):
                continue
            gef_print("  {:40s}{:#x}".format(k + ":", v))
        return

    @functools.lru_cache()
    def get_mDxeServices(self):
        # fastpath maybe mDxeServices is next to mBootServices
        if self.mBootServices:
            addr = self.mBootServices["__addr"] + self.mBootServices["Hdr.HeaderSize"]
            while addr % 0x10:
                addr += 1
            if read_memory(addr, 8) == b"DXE_SERV" and self.check_crc32(addr):
                return addr

        # slowpath
        result = gdb.execute("search-pattern DXE_SERV --disable-utf16", to_string=True) # EFI_TABLE_HEADER.Signature
        result = filter(lambda x: "->" in x, result.splitlines())
        result = [int(x.split()[0], 16) for x in result]
        for addr in result[::-1]: # Higher address seems more likely
            if self.check_crc32(addr):
                return addr
        return None

    def read_mDxeServices(self):
        addr = self.get_mDxeServices()
        if addr is None:
            return None
        structure = [
            [8, "Hdr.Signature"],
            [4, "Hdr.Revision"],
            [4, "Hdr.HeaderSize"],
            [4, "Hdr.CRC32"],
            [4, "Hdr.Reserved"],
            [8, "AddMemorySpace"],
            [8, "AllocateMemorySpace"],
            [8, "FreeMemorySpace"],
            [8, "RemoveMemorySpace"],
            [8, "GetMemorySpaceDescriptor"],
            [8, "SetMemorySpaceAttributes"],
            [8, "GetMemorySpaceMap"],
            [8, "AddIoSpace"],
            [8, "AllocateIoSpace"],
            [8, "FreeIoSpace"],
            [8, "RemoveIoSpace"],
            [8, "GetIoSpaceDescriptor"],
            [8, "GetIoSpaceMap"],
            [8, "Dispatch"],
            [8, "Schedule"],
            [8, "Trust"],
            [8, "ProcessFirmwareVolume"],
            [8, "SetMemorySpaceCapabilities"],
        ]
        return self.read_structure(addr, structure)

    def dump_mDxeServices(self):
        self.mDxeServices = self.read_mDxeServices()
        if self.mDxeServices is None:
            err("mDxeServices is not found")
            return
        info("mDxeServices: {:#x}".format(self.mDxeServices["__addr"]))
        for k, v in self.mDxeServices.items():
            if k.startswith("__"):
                continue
            gef_print("  {:40s}{:#x}".format(k + ":", v))
        return

    @functools.lru_cache()
    def get_mEfiSystemTable(self):
        result = gdb.execute("search-pattern 'IBI SYST' --disable-utf16", to_string=True) # EFI_TABLE_HEADER.Signature
        result = filter(lambda x: "->" in x, result.splitlines())
        result = [int(x.split()[0], 16) for x in result]
        for addr in result[::-1]: # Higher address seems more likely
            if self.check_crc32(addr):
                return addr
        return None

    def read_mEfiSystemTable(self):
        addr = self.get_mEfiSystemTable()
        if addr is None:
            return None
        structure = [
            [8, "Hdr.Signature"],
            [4, "Hdr.Revision"],
            [4, "Hdr.HeaderSize"],
            [4, "Hdr.CRC32"],
            [4, "Hdr.Reserved"],
            [8, "FirmwareVendor"],
            [8, "FirmwareRevision"],
            [8, "ConsoleInHandle"],
            [8, "ConIn"],
            [8, "ConsoleOutHandle"],
            [8, "ConOut"],
            [8, "StandardErrorHandle"],
            [8, "StdErr"],
            [8, "RuntimeServices"],
            [8, "BootServices"],
            [8, "NumberOfConfigurationTableEntries"],
            [8, "ConfigurationTable"],
        ]
        return self.read_structure(addr, structure)

    def dump_mEfiSystemTable(self):
        self.mEfiSystemTable = self.read_mEfiSystemTable()
        if self.mEfiSystemTable is None:
            err("*gDxeCoreST(=mEfiSystemTable) is not found")
            return
        info("*gDxeCoreST(=mEfiSystemTable): {:#x}".format(self.mEfiSystemTable["__addr"]))
        for k, v in self.mEfiSystemTable.items():
            if k.startswith("__"):
                continue
            gef_print("  {:40s}{:#x}".format(k + ":", v))
        return

    @functools.lru_cache()
    def get_mEfiRuntimeServicesTable(self):
        result = gdb.execute("search-pattern RUNTSERV --disable-utf16", to_string=True) # EFI_TABLE_HEADER.Signature
        result = filter(lambda x: "->" in x, result.splitlines())
        result = [int(x.split()[0], 16) for x in result]
        for addr in result[::-1]: # Higher address seems more likely
            if self.check_crc32(addr):
                return addr
        return None

    def read_mEfiRuntimeServicesTable(self):
        addr = self.get_mEfiRuntimeServicesTable()
        if addr is None:
            return None
        structure = [
            [8, "Hdr.Signature"],
            [4, "Hdr.Revision"],
            [4, "Hdr.HeaderSize"],
            [4, "Hdr.CRC32"],
            [4, "Hdr.Reserved"],
            [8, "GetTime"],
            [8, "SetTime"],
            [8, "GetWakeupTime"],
            [8, "SetWakeupTime"],
            [8, "SetVirtualAddressMap"],
            [8, "ConvertPointer"],
            [8, "GetVariable"],
            [8, "GetNextVariableName"],
            [8, "SetVariable"],
            [8, "GetNextHighMonotonicCount"],
            [8, "ResetSystem"],
            [8, "UpdateCapsule"],
            [8, "QueryCapsuleCapabilities"],
            [8, "QueryVariableInfo"],
        ]
        return self.read_structure(addr, structure)

    def dump_mEfiRuntimeServicesTable(self):
        self.mEfiRuntimeServicesTable = self.read_mEfiRuntimeServicesTable()
        if self.mEfiRuntimeServicesTable is None:
            err("*gDxeCoreRT(=mEfiRuntimeServicesTable) is not found")
            return
        info("*gDxeCoreRT(=mEfiRuntimeServicesTable): {:#x}".format(self.mEfiRuntimeServicesTable["__addr"]))
        for k, v in self.mEfiRuntimeServicesTable.items():
            if k.startswith("__"):
                continue
            gef_print("  {:40s}{:#x}".format(k + ":", v))
        return

    @functools.lru_cache()
    def get_gMemoryMap(self):
        # gMemoryMap is just above mDxeServices
        if not self.mDxeServices:
            return None
        addr = self.mDxeServices["__addr"]
        while addr % 0x10:
            addr -= 1
        while self.mDxeServices["__addr"] - 0x1000 < addr:
            try:
                a = u64(read_memory(addr, 8))
                b = u64(read_memory(a + 8, 8))
                asig = u64(read_memory(a - 8, 8))
                c = u64(read_memory(addr + 8, 8))
                d = u64(read_memory(c, 8))
                csig = u64(read_memory(c - 8, 8))
                if addr == b == d and asig == csig == u32(b"mmap"):
                    return addr
            except Exception:
                pass
            addr -= 0x10
        return None

    def read_gMemoryMap(self):
        addr = self.get_gMemoryMap()
        if addr is None:
            return None
        structure = [
            [8, "ForwardLink"],
            [8, "BackLink"],
        ]
        return self.read_structure(addr, structure)

    def read_Entry(self, addr):
        structure = [
            [8, "Signature"],
            [8, "Link.ForwardLink"],
            [8, "Link.BackLink"],
            [4, "FromPages"], # with pad
            [4, "Type"],
            [8, "Start"],
            [8, "End"],
            [8, "VirtualStart"],
            [8, "Attribute"],
        ]
        offset_of_link = 8
        return self.read_structure(addr - offset_of_link, structure)

    def dump_memory_map(self):
        self.gMemoryMap = self.read_gMemoryMap()
        if self.gMemoryMap is None:
            err("gMemoryMap is not found")
            return
        info("gMemoryMap: {:#x}".format(self.gMemoryMap["__addr"]))

        type_names = [
            "EfiReservedMemoryType",
            "EfiLoaderCode",
            "EfiLoaderData",
            "EfiBootServicesCode",
            "EfiBootServicesData",
            "EfiRuntimeServicesCode",
            "EfiRuntimeServicesData",
            "EfiConventionalMemory",
            "EfiUnusableMemory",
            "EfiACPIReclaimMemory",
            "EfiACPIMemoryNVS",
            "EfiMemoryMappedIO",
            "EfiMemoryMappedIOPortSpace",
            "EfiPalCode",
            "EfiPersistentMemory",
            "EfiMaxMemoryType",
        ]

        att_list = {
            0x1: "UC",
            0x2: "WC",
            0x4: "WT",
            0x8: "WB",
            0x10: "UCE",
            0x1000: "WP",
            0x2000: "RP",
            0x4000: "XP",
            0x8000: "NV",
            0x10000: "MORE_RELIABLE",
            0x20000: "RO",
            0x40000: "SPM",
            0x80000: "CPU_CRYPTO",
            0x8000000000000000: "RUNTIME"
        }

        def att2str(att):
            string = []
            for k, v in att_list.items():
                if k & att:
                    string.append(v)
            return ",".join(string)

        fmt = "{:21s} {:10s} {:10s} {:30s} {:s}"
        legend = ["Paddr Start-End", "Vaddr", "Size", "Type:TypeName", "Attribute"]
        gef_print(Color.colorify(fmt.format(*legend), get_gef_setting("theme.table_heading")))

        current = self.gMemoryMap["ForwardLink"]
        while current != self.gMemoryMap["__addr"]:
            entry = self.read_Entry(current)

            paddr_s = entry["Start"]
            paddr_e = entry["End"] + 1
            vaddr = entry["VirtualStart"]
            size = paddr_e - paddr_s
            typ = entry["Type"]
            memtype = type_names[entry["Type"]]
            att = entry["Attribute"]
            att_s = att2str(att)
            fmt = "{:#010x}-{:#010x} {:#010x} {:#010x} {:#x}:{:26s} {:#x}:[{:s}]"
            gef_print(fmt.format(paddr_s, paddr_e, vaddr, size, typ, memtype, att, att_s))

            if entry["Signature"] != u32(b"mmap"):
                gef_print("Signature does not match. Corrupted?")
                break
            current = entry["Link.ForwardLink"]

        gef_print("Legend for attribute")
        gef_print("UC: It supports being configured as Un-Cacheable")
        gef_print("WC: It supports being configured as Write-Combining")
        gef_print("WT: It supports being configured as Write-Through")
        gef_print("WB: It supports being configured as Write-Back")
        gef_print("UCE: It supports being configured as Un-Cacheable and Exportable")
        gef_print("WP: It supports being configured as Write-Protected")
        gef_print("RP: It supports being configured as Read-Protected")
        gef_print("XP: It supports being configured as eXecute-Protected")
        gef_print("NV: It refers to persistent memory(Non-Volatile-Memory)")
        gef_print("MORE_RELIABLE: it has higher reliability than other")
        gef_print("RO: It supports being configured as Read-Only")
        gef_print("SP: Specific-Purpose memory")
        gef_print("CPU_CRYPTO: Encrypted and protected by CPU function")
        gef_print("RUNTIME: It will be mapped by OS when SetVirtualAddressMap() is called")
        return

    @only_if_gdb_running
    @only_if_qemu_system
    @only_if_specific_arch(arch=["x86_32", "x86_64"])
    def do_invoke(self, argv):
        self.dont_repeat()
        info("This command is very slow. Wait a few tens of seconds")
        gef_print(titlify("SEC (Security) phase variables"))
        gef_print("Unimplemented")
        gef_print(titlify("PEI (Pre EFI Initialization) phase variables"))
        self.dump_gPs()
        gef_print(titlify("DXE (Driver Exectuion Environment) phase variables"))
        self.dump_mBootServices()
        self.dump_mDxeServices()
        self.dump_mEfiSystemTable()
        self.dump_mEfiRuntimeServicesTable()
        gef_print(titlify("Memory map for UEFI"))
        self.dump_memory_map()
        gef_print(titlify("BDS (Boot Device Selection) phase variables"))
        gef_print("gBS: See `mBootServices` in the DXE phase")
        gef_print("gST: See `mEfiSystemTable` in the DXE phase")
        gef_print("gRT: See `mEfiRuntimeServicesTable` in the DXE phase")
        return


@register_command
class AddSymbolTemporaryCommand(GenericCommand):
    """Add symbol from command temporarily"""
    _cmdline_ = "add-symbol-temporary"
    _syntax_ = "{:s} FUNCTION_NAME ADDRESS".format(_cmdline_)
    _category_ = "Misc"

    @staticmethod
    def add_symbol_temp(function_info):
        try:
            gcc = which("gcc")
            objcopy = which("objcopy")
        except FileNotFoundError as e:
            err("{}".format(e))
            return

        cache = {}

        def create_blank_elf(text_base):
            if cache:
                open(cache["fname"], "wb").write(cache["data"])
                return cache["fname"]
            # create light ELF
            fd, fname = tempfile.mkstemp(dir="/tmp", suffix=".c")
            os.fdopen(fd, "w").write("int main() {}")
            os.system(f"{gcc} '{fname}' -no-pie -o '{fname}.debug'")
            os.unlink(f"{fname}")
            # delete unneeded section for faster
            os.system(f"{objcopy} --only-keep-debug '{fname}.debug'")
            os.system(f"{objcopy} --strip-all '{fname}.debug'")
            elf = get_elf_headers(f"{fname}.debug")
            for s in elf.shdrs:
                section_name = s.sh_name
                if section_name == "": # null, skip
                    continue
                if section_name == ".text": # .text is needed, don't remove
                    continue
                if section_name == ".interp": # broken if removed
                    continue
                if section_name == ".rela.dyn": # cannot removed
                    continue
                if section_name == ".dynamic": # cannot removed
                    continue
                if section_name == ".bss": # broken if removed
                    continue
                os.system(f"{objcopy} --remove-section='{section_name}' '{fname}.debug' 2>/dev/null")
            cache["fname"] = fname + ".debug"
            cache["data"] = open(cache["fname"], "rb").read()
            return cache["fname"]

        def apply_symbol(fname, cmd_string_arr, text_base):
            cmd_string = ' '.join(cmd_string_arr)
            os.system(f"{objcopy} {cmd_string} '{fname}'")
            gdb.execute(f"add-symbol-file {fname} {text_base:#x}", to_string=True)
            os.unlink(fname)
            return

        info("{:d} entries will be added".format(len(function_info)))

        if is_64bit():
            text_base = 0xffff000000000000
        else:
            text_base = 0x80000000

        cmd_string_arr = []
        fname = create_blank_elf(text_base)
        for i, (fn, fa, typ) in enumerate(function_info):
            # debug print
            if i > 1 and i % 10000 == 0:
                info("{:d} entries were processed".format(i))

            if typ in ["T", "t", "W", None]:
                type_flag = "function"
            else:
                type_flag = "object"
            if typ and typ in "abcdefghijklmnopqrstuvwxyz":
                global_flag = "local"
            else:
                global_flag = "global"

            if fa < text_base:
                # lower address needs not relative, use absolute
                cmd_string_arr.append(f"--add-symbol '{fn}'={fa:#x},{global_flag},{type_flag}")
            else:
                # higher address needs relative
                relative_addr = fa - text_base
                cmd_string_arr.append(f"--add-symbol '{fn}'=.text:{relative_addr:#x},{global_flag},{type_flag}")

            if i > 1 and i % 1000 == 0:
                # too long, so let's commit
                apply_symbol(fname, cmd_string_arr, text_base)
                # re-init
                fname = create_blank_elf(text_base)
                cmd_string_arr = []

        # commit remain
        if cmd_string_arr:
            apply_symbol(fname, cmd_string_arr, text_base)

        info("{:d} entries were processed".format(i + 1))
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        if len(argv) != 2:
            self.usage()
            return

        try:
            function_name = argv[0]
            function_addr = int(gdb.parse_and_eval(argv[1]))
        except Exception:
            self.usage()
            return

        if is_32bit() and function_addr > 0xffffffff:
            err("function address must be 0xffffffff or less")
            return
        if is_64bit() and function_addr > 0xffffffffffffffff:
            err("function address must be 0xffffffffffffffff or less")
            return

        function_info = []
        function_info.append((function_name, function_addr, None))
        self.add_symbol_temp(function_info)
        return


@register_command
class KsymaddrRemoteApplyCommand(GenericCommand):
    """Apply symbol from kallsyms in memory"""
    _cmdline_ = "ksymaddr-remote-apply"
    _syntax_ = "{:s}".format(_cmdline_)
    _category_ = "Qemu-system Cooperation"

    @only_if_gdb_running
    @only_if_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        info("Wait for memory scan")
        res = gdb.execute("ksymaddr-remote --print-all", to_string=True)
        function_info = []
        for entry in res.splitlines():
            r = re.findall(r"(0x\w+) (\w) (\w+)", entry)
            if not r:
                continue
            addr = int(r[0][0], 16)
            typ = r[0][1]
            func_name = r[0][2]
            if addr == 0:
                continue
            function_info.append((func_name, addr, typ))
        if len(function_info) > 0:
            AddSymbolTemporaryCommand.add_symbol_temp(function_info)
            info("Done. Try `p FUNCTION_NAME`")
        return


@register_command
class LinklistWalkCommand(GenericCommand):
    """Link list walk."""
    _cmdline_ = "linklist-walk"
    _syntax_ = "{:s} [-o OFFSET] ADDRESS".format(_cmdline_)
    _example_ = "{:s} 0xffff9c60800597e0 # walk list_head.next\n".format(_cmdline_)
    _example_ += "{:s} -o 8 0xffff9c60800597e0 # walk list_head.prev".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    def walk_link_list(self, head, offset):
        current = head
        seen = [current]
        idx = 1
        while True:
            try:
                flink = read_int_from_memory(current + offset)
            except Exception:
                err("memory corrupted")
                return
            gef_print("[{:d}]   -> {:#x}".format(idx, flink))
            if flink == 0:
                break
            if flink == head:
                break
            if flink in seen[1:]:
                err("loop detected")
                break
            seen.append(current)
            current = flink
            idx += 1
        return

    def do_invoke(self, argv):
        self.dont_repeat()

        try:
            offset = 0
            if "-o" in argv:
                idx = argv.index("-o")
                offset = int(argv[idx + 1], 0)
                argv = argv[:idx] + argv[idx + 2:]
            head = parse_address(''.join(argv))
        except Exception:
            self.usage()
            return

        info("head address: {:#x}".format(head))
        info("list offset: {:#x}".format(offset))
        self.walk_link_list(head, offset)
        return


@register_command
class PeekPointersCommand(GenericCommand):
    """Command to help find pointers belonging to other memory regions helpful in case
    of OOB Read when looking for specific pointers"""
    _cmdline_ = "peek-pointers"
    _syntax_ = "{:s} starting_address <object_name> <all>".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} 0x00007ffffffde000          # begin address of stack region\n".format(_cmdline_)
    _example_ += "{:s} 0x00007ffffffde000 vdso     # grep by `vdso`\n".format(_cmdline_)
    _example_ += "{:s} 0x00007ffffffde000 vdso all # show all found address".format(_cmdline_)
    _category_ = "Show/Modify Memory"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_LOCATION)
        return

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        argc = len(argv)
        if argc not in (1, 2, 3):
            self.usage()
            return

        try:
            addr = lookup_address(int(argv[0], 16))
        except Exception:
            self.usage()
            return
        if (addr.value % gef_getpagesize()):
            err("<starting_address> must be aligned to a page")
            return
        if addr.section is None:
            err("{:#x} does not exist".format(addr.value))
            return

        unique = True if "all" not in argv else False
        vmmap = get_process_maps()

        if argc >= 2 :
            section_name = argv[1].lower()
            if section_name == "stack":
                sections = [(s.path, s.page_start, s.page_end) for s in vmmap if s.path == "[stack]"]
            elif section_name == "heap":
                sections = [(s.path, s.page_start, s.page_end) for s in vmmap if s.path == "[heap]"]
            elif section_name != "all":
                sections = [(s.path, s.page_start, s.page_end) for s in vmmap if section_name in s.path]
            else:
                sections = [(s.path, s.page_start, s.page_end) for s in vmmap]
        else:
            sections = [(s.path, s.page_start, s.page_end) for s in vmmap]

        data = read_memory(addr.section.page_start, addr.section.size)
        data = slice_unpack(data, current_arch.ptrsize)

        for off, addr_value in enumerate(data):
            addr_v = lookup_address(addr_value)
            if not addr_v:
                continue

            for i, section in enumerate(sections):
                name, start_addr, end_addr = section
                if not (start_addr <= addr_value < end_addr):
                    continue
                sym = gdb_get_location_from_symbol(addr_value)
                sym = "<{:s}+{:04x}>".format(*sym) if sym else ''
                if name.startswith("/"):
                    name = os.path.basename(name)
                elif len(name) == 0:
                    name = get_filename()
                addr_pos = addr.value + off * current_arch.ptrsize
                perm = str(addr_v.section.permission)
                ok("Found at {:#x} to {:#x} {:s} ('{:s}', perm: {:s})".format(addr_pos, addr_value, sym, name, perm))
                if unique:
                    del sections[i]
                break
        return


@register_command
class CurrentFrameStackCommand(GenericCommand):
    """Show the entire stack of the current frame."""
    _cmdline_ = "current-stack-frame"
    _syntax_ = "{:s}".format(_cmdline_)
    _example_ = "{:s}".format(_cmdline_)
    _category_ = "Show/Modify Memory"
    _aliases_ = ["stack", "full-stack"]

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        ptrsize = current_arch.ptrsize
        try:
            frame = gdb.selected_frame()
        except Exception:
            # For unknown reasons, gdb.selected_frame() may cause an error (often occurs during kernel startup).
            err("Faild to get frame information")
            return

        if not frame.older():
            reason_str = gdb.frame_stop_reason_string(frame.unwind_stop_reason())
            warn("Cannot determine frame boundary, reason: {:s}".format(reason_str))
            return

        saved_ip = frame.older().pc()
        stack_hi = int(frame.older().read_register("sp"))
        stack_lo = int(frame.read_register("sp"))
        should_stack_grow_down = get_gef_setting("context.grow_stack_down") is True
        results = []

        for offset, address in enumerate(range(stack_lo, stack_hi, ptrsize)):
            pprint_str = DereferenceCommand.pprint_dereferenced(stack_lo, offset)
            if dereference(address) == saved_ip:
                pprint_str += " " + Color.colorify("($savedip)", attrs="gray underline")
            results.append(pprint_str)

        if should_stack_grow_down:
            results.reverse()
            gef_print(titlify("Stack top (higher address)"))
        else:
            gef_print(titlify("Stack top (lower address)"))

        for res in results:
            gef_print(res)

        if should_stack_grow_down:
            gef_print(titlify("Stack bottom (lower address)"))
        else:
            gef_print(titlify("Stack bottom (higher address)"))
        return


@register_command
class XRefTelescopeCommand(SearchPatternCommand):
    """Recursively search for cross-references to a pattern in memory"""
    _cmdline_ = "xref-telescope"
    _syntax_ = "{:s} PATTERN [depth]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} AAAAAAAA\n".format(_cmdline_)
    _example_ += "{:s} 0x555555554000 15".format(_cmdline_)
    _category_ = "Show/Modify Memory"
    _aliases_ = []

    def xref_telescope_(self, pattern, depth, tree_heading):
        """Recursively search a pattern within the whole userland memory."""
        if depth <= 0:
            return

        if is_hex(pattern):
            if get_endian() == Elf.BIG_ENDIAN:
                pattern = "".join(["\\x" + pattern[i:i + 2] for i in range(2, len(pattern), 2)])
            else:
                pattern = "".join(["\\x" + pattern[i:i + 2] for i in range(len(pattern) - 2, 0, -2)])

        locs = []
        for section in get_process_maps():
            if not section.permission & Permission.READ:
                continue
            if section.path == "[vvar]":
                continue

            start = section.page_start
            end = section.page_end

            locs += self.search_pattern_by_address(pattern, start, end)
        if tree_heading == "":
            gef_print(" .")
        for i, loc in enumerate(locs):
            addr_loc_start = lookup_address(loc[0])
            path = addr_loc_start.section.path
            perm = addr_loc_start.section.permission
            if i == len(locs) - 1:
                tree_suffix_pre = " +--"
                tree_suffix_post = "    "
            else:
                tree_suffix_pre = " +--"
                tree_suffix_post = " |  "

            gef_print('{} {:#x} {} {} "{}"'.format(tree_heading + tree_suffix_pre, loc[0], Color.blueify(path), perm, Color.pinkify(loc[2])))
            self.xref_telescope_(hex(loc[0]), depth - 1, tree_heading + tree_suffix_post)

    def xref_telescope(self, pattern, depth):
        self.xref_telescope_(pattern, depth, "")

    @only_if_gdb_running
    @only_if_not_qemu_system
    def do_invoke(self, argv):
        self.dont_repeat()

        argc = len(argv)
        if argc < 1:
            self.usage()
            return

        pattern = argv[0]
        try:
            depth = int(argv[1])
        except (IndexError, ValueError):
            depth = 3

        info("Recursively searching '{:s}' in memory".format(Color.yellowify(pattern)))
        self.xref_telescope(pattern, depth)
        return


@register_command
class BytearrayCommand(GenericCommand):
    """BytearrayCommand: Generate a bytearray to be compared with possible badchars.
    Function ported from mona.py"""
    _cmdline_ = "bytearray"
    _syntax_ = "{:s} [-b badchars] [-d]".format(_cmdline_)
    _example_ = "\n"
    _example_ += "{:s} -b 414243 # exclude 41,42,43\n".format(_cmdline_)
    _example_ += "{:s} -b 41..49 # exclude 41,42,43,...,49\n".format(_cmdline_)
    _example_ += "{:s} -d # dump to ./bytearray.txt, ./bytearray.bin".format(_cmdline_)
    _category_ = "Misc"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_FILENAME)
        return

    def do_invoke(self, argv):
        self.dont_repeat()

        badchars = ""
        bytesperline = 32
        startval = 0
        endval = 255
        dump = False

        try:
            opts, args = getopt.getopt(argv, "b:cdh")
            for o, a in opts:
                if o == "-b":
                    badchars = a
                elif o == "-h":
                    self.usage()
                    return
                elif o == "-d":
                    dump = True
        except Exception:
            self.usage()
            return

        badchars = self.cleanHex(badchars)

        try:
            # see if we need to expand ..
            bpos = 0
            newbadchars = ""
            while bpos < len(badchars):
                curchar = badchars[bpos] + badchars[bpos + 1]
                if curchar == "..":
                    pos = bpos
                    if pos > 1 and pos <= len(badchars) - 4:
                        # get byte before and after ..
                        bytebefore = badchars[pos - 2] + badchars[pos - 1]
                        byteafter = badchars[pos + 2] + badchars[pos + 3]
                        bbefore = int(bytebefore, 16)
                        bafter = int(byteafter, 16)
                        if bbefore > bafter:
                            bbefore, bafter = bafter, bbefore
                        insertbytes = ""
                        bbefore += 1
                        while bbefore < bafter:
                            insertbytes += "%02x" % bbefore
                            bbefore += 1
                        newbadchars += insertbytes
                else:
                    newbadchars += curchar
                bpos += 2
            badchars = newbadchars

            cnt = 0
            excluded = []
            while cnt < len(badchars):
                excluded.append(self.hex2bin(badchars[cnt] + badchars[cnt + 1]))
                cnt = cnt + 2
        except Exception:
            self.usage()
            return

        info("Generating table, excluding {:d} bad chars...".format(len(excluded)))
        arraytable = []
        binarray = bytearray()

        # handle range() last value
        if endval > startval:
            increment = 1
            endval += 1
        else:
            endval += -1
            increment = -1

        # create bytearray
        for thisval in range(startval, endval, increment):
            hexbyte = "{:02x}".format(thisval)
            binbyte = self.hex2bin(hexbyte)
            intbyte = self.hex2int(hexbyte)
            if binbyte not in excluded:
                arraytable.append(hexbyte)
                binarray.append(intbyte)

        info("Dumping table to file")
        output = ""
        cnt = 0
        outputline = '"'
        totalbytes = len(arraytable)
        tablecnt = 0
        while tablecnt < totalbytes:
            if (cnt < bytesperline):
                outputline += "\\x" + arraytable[tablecnt]
            else:
                outputline += '"\n'
                cnt = 0
                output += outputline
                outputline = '"\\x' + arraytable[tablecnt]
            tablecnt += 1
            cnt += 1
        if (cnt - 1) < bytesperline:
            outputline += '"'
        output += outputline
        gef_print(output)

        if dump:
            binfilename = "bytearray.bin"
            arrayfile = "bytearray.txt"
            binfile = open(binfilename, "wb")
            binfile.write(binarray)
            binfile.close()

            txtfile = open(arrayfile, "w+")
            txtfile.write(output)
            txtfile.close()

            info("Done, wrote {:d} bytes to file {:s}".format(len(arraytable), arrayfile))
            info("Binary output saved in {:s}".format(binfilename))
        return

    def hex2bin(self, pattern):
        """Converts a hex string (\\x??\\x??\\x??\\x??) to real hex bytes
        Arguments: pattern - A string representing the bytes to convert
        Return: the bytes"""
        pattern = pattern.replace("\\x", "")
        pattern = pattern.replace("\"", "")
        pattern = pattern.replace("\'", "")
        return binascii.unhexlify(pattern)

    def cleanHex(self, hex):
        return "".join(filter(self.permitted_char, hex))

    def hex2int(self, hex):
        return int(hex, 16)

    def permitted_char(self, s):
        if bool(re.match("^[A-Fa-f0-9.]", s)):
            return True
        else:
            return False


@register_command
class BincompareCommand(GenericCommand):
    """BincompareCommand: compare an binary file with the memory position looking for badchars."""
    _cmdline_ = "bincompare"
    _syntax_ = "{:s} [-h] -f FILE -a MEMORY_ADDRESS\n".format(_cmdline_)
    _syntax_ += "  -f FILE            specifies the binary file to be compared.\n"
    _syntax_ += "  -a MEMORY_ADDRESS  sepecifies the memory address."
    _category_ = "Misc"

    def __init__(self):
        super().__init__(complete=gdb.COMPLETE_FILENAME)
        return

    @only_if_gdb_running
    def do_invoke(self, argv):
        self.dont_repeat()

        filename = None
        start_addr = None
        size = 0
        file_data = None
        memory_data = None

        try:
            opts, args = getopt.getopt(argv, "f:a:ch")
            for o, a in opts:
                if o == "-f":
                    filename = a
                elif o == "-a":
                    start_addr = int(gdb.parse_and_eval(a))
                elif o == "-h":
                    self.usage()
                    return
        except Exception:
            self.usage()
            return

        if not filename or not start_addr:
            err("No file and/or address specified")
            return

        if not os.path.isfile(filename):
            err("Especified file '{:s}' not exists".format(filename))
            return

        f = open(filename, "rb")
        file_data = f.read()
        f.close()

        size = len(file_data)

        if size < 8:
            err("Error - file does not contain enough bytes (min 8 bytes needed)")
            return

        try:
            memory_data = read_memory(start_addr, size)
        except gdb.MemoryError:
            err("Cannot reach memory {:#x}".format(start_addr))
            return

        result_table = []
        badchars = ""
        cnt = 0
        corrupted = -1
        for eachByte in file_data:
            hexchar = "{:02x}".format(eachByte)
            if cnt > len(memory_data):
                result_table.append((hexchar, "--"))
                corrupted = -1
            elif eachByte == memory_data[cnt]:
                result_table.append((hexchar, "  "))
                corrupted = -1
            else:
                result_table.append((hexchar, "{:02x}".format(memory_data[cnt])))
                if len(badchars) == 0:
                    badchars = hexchar
                else:
                    badchars += ", " + hexchar
                if corrupted == -1:
                    corrupted = cnt
            cnt += 1

        line = 0

        info("Comparison result:")
        gef_print("    +-----------------------------------------------+")
        for line in range(0, len(result_table), 16):
            pdata1 = []
            pdata2 = []
            for i in range(line, line + 16):
                if i < len(result_table):
                    pdata1.append(result_table[i][0])
                    pdata2.append(result_table[i][1])

            self.print_line("{:02x}".format(line), pdata1, "file")
            self.print_line("  ", pdata2, "memory")

        gef_print("    +-----------------------------------------------+")
        gef_print("")

        if corrupted > -1:
            info("Corruption after {:d} bytes".format(corrupted))

        if badchars == "":
            info("No badchars found!")
        else:
            info("Badchars found: {:s}".format(badchars))
        return

    def print_line(self, prefix, data, label):
        line = []
        for d in data:
            line.append(d)
        r = 16 - len(line)
        for i in range(0, r):
            line.append("--")

        fmt = " {:s} |{:s} {:s} {:s} {:s} {:s} {:s} {:s} {:s} {:s} {:s} {:s} {:s} {:s} {:s} {:s} {:s}| {:s}"
        gef_print(fmt.format(prefix, *line, label))
        return


class FtraceEnterBreakpoint(gdb.Breakpoint):
    def __init__(self, location, nb_args, *args, **kwargs):
        super().__init__(location, gdb.BP_BREAKPOINT, internal=True)
        self.silent = True
        self.nb_args = nb_args
        self.retbp = None
        return

    def stop(self):
        regs = collections.OrderedDict()
        for r in current_arch.function_parameters[:self.nb_args]:
            regs[r] = get_register(r)
        self.retbp = FtraceExitBreakpoint(location=self.location, regs=regs)
        return False


class FtraceExitBreakpoint(gdb.FinishBreakpoint):
    def __init__(self, *args, **kwargs):
        super().__init__(gdb.newest_frame(), internal=True)
        self.silent = True
        self.args = kwargs
        return

    def stop(self):
        if self.return_value:
            retval = "{:#x}".format(int(self.return_value))
        else:
            retval = get_register(current_arch.return_register)

        output = get_gef_setting("ftrace.output")
        mode = "a"
        use_color = False

        if output is None:
            output = "/dev/stderr"
            mode = "w"
            use_color = True

        with open(output, mode) as fd:
            if use_color:
                fd.write("{:s}() = {} {{\n".format(Color.yellowify(self.args["location"]), retval))
            else:
                fd.write("{:s}() = {} {{\n".format(self.args["location"], retval))
            for reg in self.args["regs"].keys():
                regval = self.args["regs"][reg]
                fd.write("\t{} {} {}\n".format(reg, RIGHT_ARROW, RIGHT_ARROW.join(dereference_from(regval))))
            fd.write("}\n")
            fd.flush()
        return False


@register_command
class FtraceCommand(GenericCommand):
    """Tracks a function given in parameter for arguments and return code."""
    _cmdline_ = "ftrace"
    _syntax_ = "{:s} <function_name1>,<nb_args1> [<function_name2>,<nb_args2> ...]".format(_cmdline_)
    _category_ = "Debugging Support"

    def do_invoke(self, args):
        self.dont_repeat()

        if len(args) < 1:
            self.usage()
            return

        self.bkps = []

        for item in args:
            funcname, nb_args = item.split(",")
            self.bkps.append(FtraceEnterBreakpoint(funcname, int(nb_args)))
            ok("added '{}()' (with {} args) to tracking list".format(funcname, nb_args))

        gdb.events.exited.connect(self.cleanup)
        return

    def cleanup(self, events):
        for bp in self.bkps:
            if bp.retbp:
                bp.retbp.delete()
            bp.delete()
        gdb.events.exited.disconnect(self.cleanup)
        return


class GenericFunction(gdb.Function):
    """This is an abstract class for invoking convenience functions, should not be instantiated."""
    __metaclass__ = abc.ABCMeta

    @abc.abstractproperty
    def _function_(self):
        return

    @property
    def _syntax_(self):
        return "${}([offset])".format(self._function_)

    def __init__(self):
        super().__init__(self._function_)
        return

    def invoke(self, *args):
        if not is_alive():
            raise gdb.GdbError("No debugging session active")
        return int(self.do_invoke(args))

    def arg_to_long(self, args, index, default=0):
        try:
            addr = args[index]
            return int(addr) if addr.address is None else int(addr.address)
        except IndexError:
            return default

    @abc.abstractmethod
    def do_invoke(self, args):
        return


@register_function
class StackOffsetFunction(GenericFunction):
    """Return the current stack base address plus an optional offset."""
    _function_ = "_stack"

    def do_invoke(self, args):
        return self.arg_to_long(args, 0) + get_section_base_address("[stack]")


@register_function
class HeapBaseFunction(GenericFunction):
    """Return the current heap base address plus an optional offset."""
    _function_ = "_heap"

    def do_invoke(self, args):
        base = HeapBaseFunction.heap_base()
        if not base:
            raise gdb.GdbError("Heap not found")

        return self.arg_to_long(args, 0) + base

    @staticmethod
    def heap_base():
        try:
            base = parse_address("mp_->sbrk_base")
            if base != 0:
                return base
        except gdb.error:
            pass
        return get_section_base_address("[heap]")


@register_function
class SectionBaseFunction(GenericFunction):
    """Return the matching section's base address plus an optional offset."""
    _function_ = "_base"

    def do_invoke(self, args):
        try:
            name = args[0].string()
        except IndexError:
            name = get_filename()
        except gdb.error:
            err("Invalid arg: {}".format(args[0]))
            return 0

        try:
            addr = int(get_section_base_address(name))
        except TypeError:
            err("Cannot find section {}".format(name))
            return 0
        return addr


@register_function
class BssBaseFunction(GenericFunction):
    """Return the current bss base address plus the given offset."""
    _function_ = "_bss"

    def do_invoke(self, args):
        return self.arg_to_long(args, 0) + get_zone_base_address(".bss")


@register_function
class GotBaseFunction(GenericFunction):
    """Return the current bss base address plus the given offset."""
    _function_ = "_got"

    def do_invoke(self, args):
        return self.arg_to_long(args, 0) + get_zone_base_address(".got")


@register_command
class GefFunctionsCommand(GenericCommand):
    """List the convenience functions provided by GEF."""
    _cmdline_ = "functions"
    _syntax_ = _cmdline_
    _category_ = "Misc"

    def __init__(self):
        super().__init__()
        self.docs = []
        self.setup()
        return

    def setup(self):
        global __gef__
        for function in __gef__.loaded_functions:
            self.add_function_to_doc(function)
        self.__doc__ = "\n".join(sorted(self.docs))
        return

    def add_function_to_doc(self, function):
        """Add function to documentation."""
        doc = getattr(function, "__doc__", "").lstrip()
        doc = "\n                         ".join(doc.split("\n"))
        syntax = getattr(function, "_syntax_", "").lstrip()
        msg = "{syntax:<25s} -- {help:s}".format(syntax=syntax, help=Color.greenify(doc))
        self.docs.append(msg)
        return

    def do_invoke(self, argv):
        self.dont_repeat()
        gef_print(titlify("GEF - Convenience Functions"))
        gef_print("These functions can be used as arguments to other "
                  "commands to dynamically calculate values, eg: {:s}\n"
                  .format(Color.colorify("deref $_heap(0x20)", "yellow")))
        gef_print(self.__doc__)
        return


class GefCommand(gdb.Command):
    """GEF main command: view all new commands by typing `gef`."""
    _cmdline_ = "gef"
    _syntax_ = "{:s} (missing|config|save|restore|set|run)".format(_cmdline_)
    _category_ = "GEF Maintenance Command"

    def __init__(self):
        super().__init__(self._cmdline_, gdb.COMMAND_SUPPORT, gdb.COMPLETE_NONE, True)
        set_gef_setting("gef.follow_child", True, bool, "Automatically set GDB to follow child when forking")
        set_gef_setting("gef.readline_compat", False, bool, "Workaround for readline SOH/ETX issue (SEGV)")
        set_gef_setting("gef.debug", True, bool, "Enable debug mode for gef")
        set_gef_setting("gef.autosave_breakpoints_file", "", str, "Automatically save and restore breakpoints")
        set_gef_setting("gef.extra_plugins_dir", "", str, "Autoload additional GEF commands from external directory")
        set_gef_setting("gef.disable_color", False, bool, "Disable all colors in GEF")
        set_gef_setting("gef.tempdir", GEF_TEMP_DIR, str, "Directory to use for temporary/cache content")
        self.loaded_commands = []
        self.loaded_functions = []
        self.missing_commands = {}
        return

    def setup(self):
        self.load(initial=True)
        # loading GEF sub-commands
        self.doc = GefHelpCommand(self.loaded_commands)
        self.cfg = GefConfigCommand(self.loaded_command_names)
        GefSaveCommand()
        GefRestoreCommand()
        GefMissingCommand()
        GefSetCommand()
        GefRunCommand()

        # load the saved settings
        gdb.execute("gef restore")

        # restore the autosave/autoreload breakpoints policy (if any)
        self.__reload_auto_breakpoints()

        # load plugins from `extra_plugins_dir`
        if self.__load_extra_plugins() > 0:
            # if here, at least one extra plugin was loaded, so we need to restore
            # the settings once more
            gdb.execute("gef restore quiet")
        return

    def __reload_auto_breakpoints(self):
        bkp_fname = __config__.get("gef.autosave_breakpoints_file", None)
        bkp_fname = bkp_fname[0] if bkp_fname else None
        if bkp_fname:
            # restore if existing
            if os.access(bkp_fname, os.R_OK):
                gdb.execute("source {:s}".format(bkp_fname))

            # add hook for autosave breakpoints on quit command
            source = [
                "define hook-quit",
                " save breakpoints {:s}".format(bkp_fname),
                "end",
            ]
            gef_execute_gdb_script("\n".join(source) + "\n")
        return

    def __load_extra_plugins(self):
        nb_added = -1
        try:
            nb_inital = len(self.loaded_commands)
            directories = get_gef_setting("gef.extra_plugins_dir")
            if directories:
                for directory in directories.split(";"):
                    directory = os.path.realpath(os.path.expanduser(directory))
                    if os.path.isdir(directory):
                        sys.path.append(directory)
                        for fname in os.listdir(directory):
                            if not fname.endswith(".py"):
                                continue
                            fpath = "{:s}/{:s}".format(directory, fname)
                            if os.path.isfile(fpath):
                                gdb.execute("source {:s}".format(fpath))
            nb_added = len(self.loaded_commands) - nb_inital
            if nb_added > 0:
                ok("{:s} extra commands added from '{:s}'".format(Color.colorify(nb_added, "bold green"),
                                                                  Color.colorify(directories, "bold blue")))
        except gdb.error as e:
            err("failed: {}".format(str(e)))
        return nb_added

    @property
    def loaded_command_names(self):
        return [x[0] for x in self.loaded_commands]

    def invoke(self, args, from_tty):
        self.dont_repeat()
        gdb.execute("gef help")
        return

    def load(self, initial=False):
        """Load all the commands and functions defined by GEF into GDB."""
        nb_missing = 0
        self.commands = [(x._cmdline_, x) for x in __commands__]

        # load all of the functions
        for function_class_name in __functions__:
            self.loaded_functions.append(function_class_name())

        def is_loaded(x):
            return any(filter(lambda u: x == u[0], self.loaded_commands))

        time_elapsed = []
        for cmd, class_name in self.commands:
            if is_loaded(cmd):
                continue

            try:
                start_time_real = time.perf_counter()
                start_time_proc = time.process_time()
                self.loaded_commands.append((cmd, class_name, class_name()))
                end_time_real = time.perf_counter()
                end_time_proc = time.process_time()
                time_elapsed.append((cmd, end_time_real - start_time_real, end_time_proc - start_time_proc))

                repeat = False
                if hasattr(class_name, "_repeat_"):
                    repeat = getattr(class_name, "_repeat_")

                if hasattr(class_name, "_aliases_"):
                    aliases = getattr(class_name, "_aliases_")
                    for alias in aliases:
                        GefAlias(alias, cmd, repeat=repeat)

            except Exception as reason:
                self.missing_commands[cmd] = reason
                nb_missing += 1

        if False: # debug print
            print(titlify("Top 10 commands that took the longest to load"))
            for cmd, real, cpu in sorted(time_elapsed, key=lambda x: x[1], reverse=True)[:10]:
                print("{:30s} Real:{:.10f} s, CPU:{:.10f} s".format(cmd, real, cpu))

        # sort by command name
        self.loaded_commands = sorted(self.loaded_commands, key=lambda x: x[1]._cmdline_)

        if initial:
            gef_print("{:s} for {:s} ready, type `{:s}' to start, `{:s}' to configure".format(
                Color.greenify("GEF"),
                get_os(),
                Color.colorify("gef", "underline yellow"),
                Color.colorify("gef config", "underline pink")
            ))

            ver = "{:d}.{:d}".format(sys.version_info.major, sys.version_info.minor)
            nb_cmds = len(self.loaded_commands)
            gef_print("{:s} commands loaded for GDB {:s} using Python engine {:s}".format(
                Color.colorify(nb_cmds, "bold green"),
                Color.colorify(gdb.VERSION, "bold yellow"),
                Color.colorify(ver, "bold red")
            ))

            if nb_missing:
                warn("{:s} command{} could not be loaded, run `{:s}` to know why.".format(
                    Color.colorify(nb_missing, "bold red"),
                    "s" if nb_missing > 1 else "",
                    Color.colorify("gef missing", "underline pink")
                ))
        return


class GefHelpCommand(gdb.Command):
    """GEF help sub-command."""
    _cmdline_ = "gef help"
    _syntax_ = _cmdline_
    _category_ = "GEF Maintenance Command"

    def __init__(self, commands, *args, **kwargs):
        super().__init__(self._cmdline_, gdb.COMMAND_SUPPORT, gdb.COMPLETE_NONE, False)
        self.docs = []
        self.generate_help(commands)
        self.refresh()
        return

    def invoke(self, args, from_tty):
        self.dont_repeat()
        gef_print(titlify("GEF - GDB Enhanced Features"))
        gef_print(self.__doc__)
        return

    def generate_help(self, commands):
        """Generate builtin commands documentation."""
        for command in commands:
            self.add_command_to_doc(command)
        return

    def add_command_to_doc(self, command):
        """Add command to GEF documentation."""
        cmd, class_name, _ = command
        if " " in cmd:
            # do not print subcommands in gef help
            return
        doc = getattr(class_name, "__doc__", "").lstrip()
        doc = "\n                         ".join(doc.split("\n"))
        if hasattr(class_name, "_aliases_") and class_name._aliases_ != []:
            aliases = " (alias: {:s})".format(", ".join(class_name._aliases_))
        else:
            aliases = ""
        msg = "  {cmd:<23s} -- {help:s}{aliases:s}".format(cmd=cmd, help=Color.greenify(doc), aliases=aliases)
        category = class_name._category_ if hasattr(class_name, "_category_") else "Uncategorized"
        self.docs.append([category, msg])
        return

    def refresh(self):
        """Refresh the documentation."""
        newdoc = ""
        old_category = None
        for category, msg in sorted(self.docs):
            if old_category != category:
                newdoc += "[{:s}]\n".format(Color.colorify(category, "bold yellow"))
            old_category = category
            newdoc += msg + "\n"
        self.__doc__ = newdoc.rstrip()
        return


class GefConfigCommand(gdb.Command):
    """GEF configuration sub-command
    This command will help set/view GEF settings for the current debugging session.
    It is possible to make those changes permanent by running `gef save` (refer
    to this command help), and/or restore previously saved settings by running
    `gef restore` (refer help)."""
    _cmdline_ = "gef config"
    _syntax_ = "{:s} [setting_name] [setting_value]".format(_cmdline_)
    _category_ = "GEF Maintenance Command"

    def __init__(self, loaded_commands, *args, **kwargs):
        super().__init__(self._cmdline_, gdb.COMMAND_NONE, prefix=False)
        self.loaded_commands = loaded_commands
        return

    def invoke(self, args, from_tty):
        self.dont_repeat()
        argv = gdb.string_to_argv(args)
        argc = len(argv)

        if not (0 <= argc <= 2):
            err("Invalid number of arguments")
            return

        if argc == 0:
            gef_print(titlify("GEF configuration settings"))
            self.print_settings()
            return

        if argc == 1:
            prefix = argv[0]
            names = list(filter(lambda x: x.startswith(prefix), __config__.keys()))
            if names:
                if len(names) == 1:
                    gef_print(titlify("GEF configuration setting: {:s}".format(names[0])))
                    self.print_setting(names[0], verbose=True)
                else:
                    gef_print(titlify("GEF configuration settings matching '{:s}'".format(argv[0])))
                    for name in names:
                        self.print_setting(name)
            return

        self.set_setting(argc, argv)
        return

    def print_setting(self, plugin_name, verbose=False):
        res = __config__.get(plugin_name)
        string_color = get_gef_setting("theme.dereference_string")
        misc_color = get_gef_setting("theme.dereference_base_address")

        if not res:
            return

        _value, _type, _desc = res
        _setting = Color.colorify(plugin_name, "green")
        _type = _type.__name__
        if _type == "str":
            _value = '"{:s}"'.format(Color.colorify(_value, string_color))
        else:
            _value = Color.colorify(_value, misc_color)

        gef_print("{:s} ({:s}) = {:s}".format(_setting, _type, _value))

        if verbose:
            gef_print(Color.colorify("\nDescription:", "bold underline"))
            gef_print("\t{:s}".format(_desc))
        return

    def print_settings(self):
        for x in sorted(__config__):
            self.print_setting(x)
        return

    def set_setting(self, argc, argv):
        global __gef__
        if "." not in argv[0]:
            err("Invalid command format")
            return

        loaded_commands = [x[0] for x in __gef__.loaded_commands] + ["gef"]
        plugin_name = argv[0].split(".", 1)[0]
        if plugin_name not in loaded_commands:
            err("Unknown plugin '{:s}'".format(plugin_name))
            return

        _type = __config__.get(argv[0], [None, None, None])[1]
        if _type is None:
            err("Failed to get '{:s}' config setting".format(argv[0],))
            return

        try:
            if _type == bool:
                _newval = True if argv[1].upper() in ("TRUE", "T", "1") else False
            else:
                _newval = _type(argv[1])

        except Exception:
            err("{} expects type '{}'".format(argv[0], _type.__name__))
            return

        reset_all_caches()
        __config__[argv[0]][0] = _newval
        get_gef_setting.cache_clear()
        return

    def complete(self, text, word):
        settings = sorted(__config__)

        if text == "":
            # no prefix: example: `gef config TAB`
            return [s for s in settings if word in s]

        if "." not in text:
            # if looking for possible prefix
            return [s for s in settings if s.startswith(text.strip())]

        # finally, look for possible values for given prefix
        return [s.split(".", 1)[1] for s in settings if s.startswith(text.strip())]


class GefSaveCommand(gdb.Command):
    """GEF save sub-command.
    Saves the current configuration of GEF to disk (by default in file '~/.gef.rc')."""
    _cmdline_ = "gef save"
    _syntax_ = _cmdline_

    def __init__(self, *args, **kwargs):
        super().__init__(self._cmdline_, gdb.COMMAND_SUPPORT, gdb.COMPLETE_NONE, False)
        return

    def invoke(self, args, from_tty):
        self.dont_repeat()
        cfg = configparser.RawConfigParser()
        old_sect = None

        # save the configuration
        for key in sorted(__config__):
            sect, optname = key.split(".", 1)
            value = __config__.get(key, None)
            value = value[0] if value else None

            if old_sect != sect:
                cfg.add_section(sect)
                old_sect = sect

            cfg.set(sect, optname, value)

        # save the aliases
        cfg.add_section("aliases")
        for alias in __aliases__:
            cfg.set("aliases", alias._alias, alias._command)

        with open(GEF_RC, "w") as fd:
            cfg.write(fd)

        ok("Configuration saved to '{:s}'".format(GEF_RC))
        return


class GefRestoreCommand(gdb.Command):
    """GEF restore sub-command.
    Loads settings from file '~/.gef.rc' and apply them to the configuration of GEF."""
    _cmdline_ = "gef restore"
    _syntax_ = _cmdline_

    def __init__(self, *args, **kwargs):
        super().__init__(self._cmdline_, gdb.COMMAND_SUPPORT, gdb.COMPLETE_NONE, False)
        return

    def invoke(self, args, from_tty):
        self.dont_repeat()
        if not os.access(GEF_RC, os.R_OK):
            return

        quiet = args.lower() == "quiet"
        cfg = configparser.ConfigParser()
        cfg.read(GEF_RC)

        for section in cfg.sections():
            if section == "aliases":
                # load the aliases
                for key in cfg.options(section):
                    try:
                        GefAlias(key, cfg.get(section, key))
                    except Exception:
                        pass
                continue

            # load the other options
            for optname in cfg.options(section):
                try:
                    key = "{:s}.{:s}".format(section, optname)
                    _type = __config__.get(key)[1]
                    new_value = cfg.get(section, optname)
                    if _type == bool:
                        new_value = True if new_value == "True" else False
                    else:
                        new_value = _type(new_value)
                    __config__[key][0] = new_value
                except Exception:
                    pass

        # ensure that the temporary directory always exists
        gef_makedirs(__config__["gef.tempdir"][0])

        if not quiet:
            ok("Configuration from '{:s}' restored".format(Color.colorify(GEF_RC, "bold blue")))
        return


class GefMissingCommand(gdb.Command):
    """GEF missing sub-command.
    Display the GEF commands that could not be loaded, along with the reason of why
    they could not be loaded."""
    _cmdline_ = "gef missing"
    _syntax_ = _cmdline_

    def __init__(self, *args, **kwargs):
        super().__init__(self._cmdline_, gdb.COMMAND_SUPPORT, gdb.COMPLETE_NONE, False)
        return

    def invoke(self, args, from_tty):
        self.dont_repeat()
        missing_commands = __gef__.missing_commands.keys()
        if not missing_commands:
            ok("No missing command")
            return
        for missing_command in missing_commands:
            reason = __gef__.missing_commands[missing_command]
            warn("Command `{}` is missing, reason {} {}".format(missing_command, RIGHT_ARROW, reason))
        return


class GefSetCommand(gdb.Command):
    """Override GDB set commands with the context from GEF."""
    _cmdline_ = "gef set"
    _syntax_ = "{:s} [GDB_SET_ARGUMENTS]".format(_cmdline_)

    def __init__(self, *args, **kwargs):
        super().__init__(self._cmdline_, gdb.COMMAND_SUPPORT, gdb.COMPLETE_SYMBOL, False)
        return

    def invoke(self, args, from_tty):
        self.dont_repeat()
        args = args.split()
        cmd = ["set", args[0]]
        for p in args[1:]:
            if p.startswith("$_gef"):
                c = gdb.parse_and_eval(p)
                cmd.append(c.string())
            else:
                cmd.append(p)

        gdb.execute(" ".join(cmd))
        return


class GefRunCommand(gdb.Command):
    """Override GDB run commands with the context from GEF.
    Simple wrapper for GDB run command to use arguments set from `gef set args`. """
    _cmdline_ = "gef run"
    _syntax_ = "{:s} [GDB_RUN_ARGUMENTS]".format(_cmdline_)

    def __init__(self, *args, **kwargs):
        super().__init__(self._cmdline_, gdb.COMMAND_SUPPORT, gdb.COMPLETE_FILENAME, False)
        return

    def invoke(self, args, from_tty):
        self.dont_repeat()
        if is_alive():
            gdb.execute("continue")
            return

        argv = args.split()
        gdb.execute("gef set args {:s}".format(" ".join(argv)))
        gdb.execute("run")
        return


class GefAlias(gdb.Command):
    """Simple aliasing wrapper because GDB doesn't do what it should."""
    def __init__(self, alias, command, repeat=False, completer_class=gdb.COMPLETE_NONE, command_class=gdb.COMMAND_NONE):
        p = command.split()
        if not p:
            return

        if list(filter(lambda x: x._alias == alias, __aliases__)):
            return

        self._command = command
        self._alias = alias
        self._repeat = repeat
        c = command.split()[0]
        r = self.lookup_command(c)
        self.__doc__ = "Alias for '{}'".format(Color.greenify(command))
        if r is not None:
            _instance = r[2]
            self.__doc__ += ": {}".format(_instance.__doc__)

            if hasattr(_instance, "complete"):
                self.complete = _instance.complete

        super().__init__(alias, command_class, completer_class=completer_class)
        __aliases__.append(self)
        return

    def invoke(self, args, from_tty):
        if not self._repeat:
            self.dont_repeat()
        gdb.execute("{} {}".format(self._command, args), from_tty=from_tty)
        return

    def lookup_command(self, cmd):
        global __gef__
        for _name, _class, _instance in __gef__.loaded_commands:
            if cmd == _name:
                return _name, _class, _instance
        return None


@register_command
class AliasesCommand(GenericCommand):
    """Base command to add, remove, or list aliases."""
    _cmdline_ = "aliases"
    _syntax_ = "{:s} (add|rm|ls)".format(_cmdline_)
    _category_ = "GEF Maintenance Command"

    def __init__(self, *args, **kwargs):
        prefix = kwargs.get("prefix", True)
        super().__init__(prefix=prefix)
        return

    def do_invoke(self, argv):
        self.dont_repeat()
        self.usage()
        return


@register_command
class AliasesAddCommand(AliasesCommand):
    """Command to add aliases."""
    _cmdline_ = "aliases add"
    _syntax_ = "{:s} [ALIAS] [COMMAND]".format(_cmdline_)
    _example_ = "{:s} scope telescope".format(_cmdline_)
    _category_ = "GEF Maintenance Command"

    def __init__(self):
        super().__init__(prefix=False)
        return

    def do_invoke(self, argv):
        self.dont_repeat()
        if (len(argv) < 2):
            self.usage()
            return
        GefAlias(argv[0], " ".join(argv[1:]))
        return


@register_command
class AliasesRmCommand(AliasesCommand):
    """Command to remove aliases."""
    _cmdline_ = "aliases rm"
    _syntax_ = "{:s} [ALIAS]".format(_cmdline_)
    _category_ = "GEF Maintenance Command"

    def __init__(self):
        super().__init__(prefix=False)
        return

    def do_invoke(self, argv):
        self.dont_repeat()
        global __aliases__
        if len(argv) != 1:
            self.usage()
            return
        try:
            alias_to_remove = next(filter(lambda x: x._alias == argv[0], __aliases__))
            __aliases__.remove(alias_to_remove)
        except (ValueError, StopIteration):
            err("{0} not found in aliases.".format(argv[0]))
            return
        gef_print("You must reload GEF for alias removals to apply.")
        return


@register_command
class AliasesListCommand(AliasesCommand):
    """Command to list aliases."""
    _cmdline_ = "aliases ls"
    _syntax_ = _cmdline_
    _category_ = "GEF Maintenance Command"

    def __init__(self):
        super().__init__(prefix=False)
        return

    def do_invoke(self, argv):
        self.dont_repeat()

        ok("Aliases defined:")
        for a in __aliases__:
            gef_print("{:30s} {} {}".format(a._alias, RIGHT_ARROW, a._command))
        return


class GefTmuxSetup(gdb.Command):
    """Setup a confortable tmux debugging environment."""
    def __init__(self):
        super().__init__("tmux-setup", gdb.COMMAND_NONE, gdb.COMPLETE_NONE)
        GefAlias("screen-setup", "tmux-setup")
        return

    def invoke(self, args, from_tty):
        self.dont_repeat()

        tmux = os.getenv("TMUX")
        if tmux:
            self.tmux_setup()
            return
        screen = os.getenv("TERM")
        if screen is not None and screen == "screen":
            self.screen_setup()
            return
        warn("Not in a tmux/screen session")
        return

    def tmux_setup(self):
        """Prepare the tmux environment by vertically splitting the current pane, and
        forcing the context to be redirected there."""
        try:
            tmux = which("tmux")
        except FileNotFoundError as e:
            err("{}".format(e))
            return

        ok("tmux session found, splitting window...")
        old_ptses = set(os.listdir("/dev/pts"))
        gdb.execute("! {} split-window -h 'clear ; cat'".format(tmux))
        gdb.execute("! {} select-pane -L".format(tmux))
        new_ptses = set(os.listdir("/dev/pts"))
        pty = list(new_ptses - old_ptses)[0]
        pty = "/dev/pts/{}".format(pty)
        ok("Setting `context.redirect` to '{}'...".format(pty))
        gdb.execute("gef config context.redirect {}".format(pty))
        ok("Done!")
        return

    def screen_setup(self):
        """Hackish equivalent of the tmux_setup() function for screen."""
        try:
            screen = which("screen")
        except FileNotFoundError as e:
            err("{}".format(e))
            return

        sty = os.getenv("STY")
        ok("screen session found, splitting window...")
        fd_script, script_path = tempfile.mkstemp()
        fd_tty, tty_path = tempfile.mkstemp()
        os.close(fd_tty)

        with os.fdopen(fd_script, "w") as f:
            f.write("startup_message off\n")
            f.write("split -v\n")
            f.write("focus right\n")
            f.write("screen bash -c 'tty > {}; clear; cat'\n".format(tty_path))
            f.write("focus left\n")

        gdb.execute("""! {} -r {} -m -d -X source {}""".format(screen, sty, script_path))
        # artificial delay to make sure `tty_path` is populated
        time.sleep(0.25)
        with open(tty_path, "r") as f:
            pty = f.read().strip()
        ok("Setting `context.redirect` to '{}'...".format(pty))
        gdb.execute("gef config context.redirect {}".format(pty))
        ok("Done!")
        os.unlink(script_path)
        os.unlink(tty_path)
        return


def __gef_prompt__(current_prompt):
    """GEF custom prompt function."""
    if get_gef_setting("gef.readline_compat") is True:
        return GEF_PROMPT
    if get_gef_setting("gef.disable_color") is True:
        return GEF_PROMPT
    if is_alive():
        return GEF_PROMPT_ON
    return GEF_PROMPT_OFF


def main():
    if sys.version_info[0] == 2:
        err("GEF has dropped Python2 support for GDB when it reached EOL on 2020/01/01.")
        err("If you require GEF for GDB+Python2, use https://github.com/hugsy/gef-legacy.")
        return

    if GDB_VERSION < GDB_MIN_VERSION:
        err("You're using an old version of GDB. GEF will not work correctly. "
            "Consider updating to GDB {} or higher.".format(".".join(map(str, GDB_MIN_VERSION))))
        return

    try:
        pyenv = which("pyenv")
        PYENV_ROOT = gef_pystring(subprocess.check_output([pyenv, "root"]).strip())
        PYENV_VERSION = gef_pystring(subprocess.check_output([pyenv, "version-name"]).strip())
        site_packages_dir = os.path.join(PYENV_ROOT, "versions", PYENV_VERSION, "lib",
                                         "python{}".format(PYENV_VERSION[:3]), "site-packages")
        site.addsitedir(site_packages_dir)
    except FileNotFoundError:
        pass

    # When using a Python virtual environment, GDB still loads the system-installed Python
    # so GEF doesn't load site-packages dir from environment
    # In order to fix it, from the shell with venv activated we run the python binary,
    # take and parse its path, add the path to the current python process using sys.path.extend

    try:
        pythonbin = which("python3")
        cmds = [pythonbin, '-c', 'import os, sys;print((sys.prefix))']
        PREFIX = gef_pystring(subprocess.check_output(cmds)).strip("\\n")
        if PREFIX != sys.base_prefix:
            cmds = [pythonbin, "-c", "import os, sys;print(os.linesep.join(sys.path).strip())"]
            SITE_PACKAGES_DIRS = subprocess.check_output(cmds).decode("utf-8").split()
            sys.path.extend(SITE_PACKAGES_DIRS)
    except FileNotFoundError:
        pass

    # setup prompt
    gdb.prompt_hook = __gef_prompt__

    # setup config
    gdb.execute("set confirm off")
    gdb.execute("set verbose off")
    gdb.execute("set pagination off")
    gdb.execute("set print elements 0")

    # gdb history
    gdb.execute("set history save on")
    gdb.execute("set history filename ~/.gdb_history")

    # gdb input and output bases
    gdb.execute("set output-radix 0x10")

    # pretty print
    gdb.execute("set print pretty on")

    # array print
    gdb.execute("set print array on")
    gdb.execute("set print array-indexes on")

    try:
        # this will raise a gdb.error unless we're on x86
        gdb.execute("set disassembly-flavor intel")
    except gdb.error:
        # we can safely ignore this
        pass

    # SIGALRM will simply display a message, but gdb won't forward the signal to the process
    gdb.execute("handle SIGALRM print nopass")

    # SIGSEGV/SIGTERM/SIG32(for thread creation)
    gdb.execute("handle SIGSEGV print nopass")
    gdb.execute("handle SIGTERM print nopass")
    gdb.execute("handle SIG32 nostop")

    # demangle
    gdb.execute("set print asm-demangle on")

    # frame args
    gdb.execute("set print frame-arguments all")

    # object/vtbl
    gdb.execute("set print object on")
    gdb.execute("set print vtbl on")

    # load GEF
    global __gef__
    __gef__ = GefCommand()
    __gef__.setup()

    gdb.execute("save gdb-index {}".format(get_gef_setting("gef.tempdir")))

    # gdb events configuration
    gef_on_continue_hook(continue_handler)
    gef_on_stop_hook(hook_stop_handler)
    gef_on_new_hook(new_objfile_handler)
    gef_on_exit_hook(exit_handler)
    gef_on_memchanged_hook(memchanged_handler)
    gef_on_regchanged_hook(regchanged_handler)

    if gdb.current_progspace().filename is not None:
        # if here, we are sourcing gef from a gdb session already attached
        # we must force a call to the new_objfile handler (see issue #278)
        new_objfile_handler(None)

    GefTmuxSetup()
    return


if __name__ == "__main__":
    main()
